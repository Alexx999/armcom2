# -*- coding: UTF-8 -*-
# Python 3.6.8 x64
# tcod 11.4.0 x64
##########################################################################################
#                                                                                        #
#                                Armoured Commander II                                   #
#                                                                                        #
##########################################################################################
#             Project Started February 23, 2016; Restarted July 25, 2016                 #
#          Restarted again January 11, 2018; Restarted again January 2, 2019             #
#                           First stable release March 14, 2020                          #
#          Private Beta Steam release May 9, 2020; Early Access May 14, 2020             #
#                           Full Steam release September 4, 2021                         #
##########################################################################################
#
#    Copyright (c) 2021 Gregory Adam Scott sudasana@gmail.com
#
#    This Python script (armcom2.py) is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This script is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this script, in the form of a file named "gpl.txt".
#    If not, see <https://www.gnu.org/licenses/>.
#
#    xp_loader.py is covered under a MIT License (MIT) and is Copyright (c) 2015
#    Sean Hagar; see XpLoader_LICENSE.txt for more info.
#
#    Some sound samples from the C64 sample pack by Odo:
#    <https://howtomakeelectronicmusic.com/270mb-of-free-c64-samples-made-by-odo/>
#
#    Steam integration thanks to SteamworksPy, covered under a MIT License (MIT)
#    Copyright (c) 2016 GP Garcia, CoaguCo Industries
#    https://github.com/Gramps/SteamworksPy
#
##########################################################################################


##### Import Libraries #####
import os, sys						# OS-related stuff
from shutil import copyfile
from pathlib import Path				# to find the user's home directory
from configparser import ConfigParser			# saving and loading configuration settings
from random import choice, shuffle, sample		# for the illusion of randomness
from math import floor, degrees, atan2, ceil		# math and heading calculations
import traceback					# for error reporting
from calendar import monthrange				# for date calculations
import gzip, json, time
from datetime import date, datetime, timedelta		# for timestamping logs, date calculations
from textwrap import wrap				# breaking up strings
import shelve						# saving and loading games
from astral import LocationInfo, moon
from astral.sun import sun
os.environ['PYSDL2_DLL_PATH'] = os.getcwd() + os.sep + 'lib'	# set sdl2 dll path
import sdl2.sdlmixer as mixer				# sound effects
import sdl2						# gamepad support
import libtcodpy as libtcod				# main display library
import xp_loader					# loading xp image files
from steamworks import STEAMWORKS			# main steamworks library
import ctypes


##########################################################################################
#                                        Constants                                       #
##########################################################################################

DEBUG = False							# debug flag - set to False in all distribution versions

NAME = 'Armoured Commander II'					# game name
VERSION = '1.2.41'						# game version
DISCLAIMER = 'This is a work of fiction and no endorsement of any historical ideologies or events depicted within is intended.'
DATAPATH = 'data' + os.sep					# path to data files
PORTRAITPATH = 'data/unit_portraits/'.replace('/', os.sep)	# path to unit portraits
SAVEPATH = 'saved_campaigns' + os.sep				# path to saved campaign folder
BACKUP_PATH = 'backups' + os.sep				# path to backup campaign folders
SOUNDPATH = 'sounds' + os.sep					# path to sound samples
CAMPAIGNPATH = 'campaigns' + os.sep				# path to campaign files
HOMEPATH = str(Path.home()) + os.sep + 'ArmCom2'
MODPATH = HOMEPATH + os.sep + 'mods' + os.sep
LOGPATH = HOMEPATH + os.sep + 'logs' + os.sep

PORTRAIT_VARIANTS = [
	'STD', 'DES', 'WIN', 'TRO', 'LTW', 'ELW'	# list of possible portrait variants (STD is standard)
]

if os.name == 'posix':					# linux (and OS X?) has to use SDL 1 for some reason
	RENDERER = libtcod.RENDERER_SDL
else:
	RENDERER = libtcod.RENDERER_SDL2

LIMIT_FPS = 50						# maximum screen refreshes per second
SCREEN_WIDTH, SCREEN_HEIGHT = 120, 68			# size of screen in character cells for 16:9 fullscreen mode
UW_SCREEN_WIDTH, UW_SCREEN_HEIGHT = 158, 68		# size of screen in character cells for 21:9 fullscreen mode
WINDOW_WIDTH, WINDOW_HEIGHT = 90, 60			# size of game window in character cells
WINDOW_XM, WINDOW_YM = int(WINDOW_WIDTH/2), int(WINDOW_HEIGHT/2)	# center of game window
KEYBOARDS = ['QWERTY', 'AZERTY', 'QWERTZ', 'Dvorak', 'Custom']	# list of possible keyboard layout settings
MAX_TANK_NAME_LENGTH = 20				# maximum length of tank names
MAX_CREW_NAME_LENGTH = 17				# maximum total length of crew names, including space
MAX_NICKNAME_LENGTH = 10				# " for crew nicknames
MAX_SKILL_NAME_LENGTH = 22				# " for skill names
CONTROLLER_STICK_DEADZONE = 5000			# axis level below which controller stick input will be ignored
CONTROLLER_STICK_X_THRESHOLD = 11000			# axis level used to detect x stick direction, +/- 0
CONTROLLER_STICK_Y_THRESHOLD = 7000			# axis level used to detect y stick direction, +/- 0
CONTROLLER_TRIGGER_DEADZONE = 500			# " trigger

STEAM_STATS = [						# for debug testing
	'weeks_passed', 'dec_three_or_more', 'completed_campaigns'
]

# character mapping for extended characters
CHAR_MAP = {
	'Ç' : 128,
	'ü' : 129,
	'é' : 130,
	'â' : 131,
	'ä' : 132,
	'à' : 133,
	'å' : 134,
	'ç' : 135,
	'ê' : 136,
	'ë' : 137,
	'è' : 138,
	'ï' : 139,
	'î' : 140,
	'ì' : 141,
	'Ä' : 142,
	'Å' : 143,
	'É' : 144,
	'æ' : 145,
	'Æ' : 146,
	'ô' : 147,
	'ö' : 148,
	'ò' : 149,
	'û' : 150,
	'ù' : 151,
	'ÿ' : 152,
	'Ö' : 153,
	'Ü' : 154,
	'ø' : 155,
	'£' : 156,
	'Ø' : 157,
	'×' : 158,
	'ƒ' : 159,
	'á' : 160,
	'í' : 161,
	'ó' : 162,
	'ú' : 163,
	'ñ' : 164,
	'Ñ' : 165,
	'ª' : 166,
	'º' : 167,
	'¿' : 168,
	'®' : 169,
	'¬' : 170,
	'½' : 171,
	'¼' : 172,
	'¡' : 173,
	'«' : 174,
	'»' : 175,
	'░' : 176,
	'▒' : 177,
	'▓' : 178,
	'│' : 179,
	'┤' : 180,
	'Á' : 181,
	'Â' : 182,
	'À' : 183,
	'©' : 184,
	'╣' : 185,
	'║' : 186,
	'╗' : 187,
	'╝' : 188,
	'¢' : 189,
	'¥' : 190,
	'┐' : 191,
	'└' : 192,
	'┴' : 193,
	'┬' : 194,
	'├' : 195,
	'─' : 196,
	'┼' : 197,
	'ã' : 198,
	'Ã' : 199,
	'╚' : 200,
	'╔' : 201,
	'╩' : 202,
	'╦' : 203,
	'╠' : 204,
	'═' : 205,
	'╬' : 206,
	'¤' : 207,
	'ð' : 208,
	'Ð' : 209,
	'Ê' : 210,
	'Ë' : 211,
	'È' : 212,
	'ı' : 213,
	'Í' : 214,
	'Î' : 215,
	'Ï' : 216,
	'┘' : 217,
	'┌' : 218,
	'█' : 219,
	'▄' : 220,
	'¦' : 221,
	'Ì' : 222,
	'▀' : 223,
	'Ó' : 224,
	'ß' : 225,
	'Ô' : 226,
	'Ò' : 227,
	'õ' : 228,
	'Õ' : 229,
	'µ' : 230,
	'þ' : 231,
	'Þ' : 232,
	'Ú' : 233,
	'Û' : 234,
	'Ù' : 235,
	'ý' : 236,
	'Ý' : 237,
	'¯' : 238,
	'´' : 239,
	
	'±' : 241,
	'‗' : 242,
	'¾' : 243,
	'¶' : 244,
	'§' : 245,
	'÷' : 246,
	'¸' : 247,
	'°' : 248,
	'¨' : 249,
	'·' : 250,
	'¹' : 251,
	'³' : 252,
	'²' : 253,
	'■' : 254,
	
	'Ą' : 256,
	'Ć' : 257,
	'Ę' : 258,
	'Ł' : 259,
	'Ń' : 260,
	'Ó' : 261,
	'Ś' : 262,
	'Ź' : 263,
	'Ż' : 264,
	'ą' : 265,
	'ć' : 266,
	'ę' : 267,
	'ł' : 268,
	'ń' : 269,
	'ó' : 270,
	'ś' : 271,
	'ź' : 272,
	'ż' : 273
}

# only used when DEBUG flag is set to true
DEBUG_OPTIONS  = [
	'Regenerate CD Map Roads & Rivers', 'Stress Test', 'Spawn Enemy', 'Remove Enemy',
	'Attack Selected Crewman (Scenario)', 'Set Crewman Injury', 'Set Time to End of Day',
	'End Current Scenario', 'Regenerate Weather', 'Set Steam Stat'
]

# definitions for game options
GAME_OPTIONS = [
	'Font Size', 'Fullscreen', 'Ultrawide Fullscreen', 'Sound Effects', 'Music',
	'Master Volume', 'Message Pause', 'Must Dismiss Messages', 'Animation Speed',
	'Unit Stack Display', 'New Inf/Cav Portraits', 'Ready Rack Refill', 'Keyboard', 'Active Controller',
	'Return to Main Menu'
]

# defintions for campaign options
CAMPAIGN_OPTIONS = [
	('Player Commander', 'permadeath', 'You take on the role of the vehicle commander. If you are seriously ' +
		'injured, you may miss a number of days of the campaign. If you are killed, your campaign ends.', 20),
	('Fate Points', 'fate_points', 'You are protected by fate, giving you the option of negating ' +
		'a few incoming attacks per day that might otherwise destroy your vehicle.', -25),
	('Realistic Explosions', 'explosion_kills', "If your vehicle is destroyed there's a chance that " +
		"gun ammo or fuel will ignite, igniting an explosion inside the vehicle. If this option is " +
		"active, all crewmen inside the vehicle are killed by such an explosion (no fate point use allowed), " +
		"otherwise they have a small chance of survival.", 15),
	('Random Vehicle Model', 'random_tank', 'At the start of a new campaign and whenever replacing ' +
		'a lost vehicle, you will be given a randomly selected list of 2-3 vehicle models, based ' +
		'on their historical availability ' +
		'on that date in the calendar. During a refit period, you will only be offered 2-3 random ' +
		'alternate vehicle models. Player Commanders with a higher rank will be give more options.', 30),
	('Go It Alone', 'go_it_alone', 'You will never be assigned any squadmates for the duration of the campaign.',
		50),
	('Ahistorical Availability', 'ahistorical', 'Unit rarity factors will be ignored for player and enemy units, ' +
		'meaning that tanks, guns, and other unit types may appear before or after they were ' +
		'historically available.', -25),
	('Armoured Cars', 'armoured_cars', 'Include Armoured Cars as possible player units, if included in ' +
		'the campaign.', 0),
	('Realistic Injuries', 'realistic_injuries', 'Crewmen will be injured more often from incoming small ' +
		'arms attacks and spalling.', 20),
	('Enemy Rate of Fire', 'enemy_rof', 'All enemy units can maintain Rate of Fire, potentially attacking ' +
		'multiple times in a turn. If disabled, only enemy Rocket Launcher and MG weapons can possibly ' +
		'maintain RoF.', 20),
	('Enemy AI Difficulty', 'ai_difficulty', '', 0)
]

# keys and default values for campaign options
DEFAULT_CAMPAIGN_OPTIONS = {
	'permadeath' : True,
	'fate_points' : True,
	'explosion_kills' : False,
	'random_tank' : False,
	'go_it_alone' : False,
	'ahistorical' : False,
	'armoured_cars' : False,
	'realistic_injuries' : False,
	'enemy_rof' : False,
	'ai_difficulty' : 0
}

# descriptive info for different AI difficulty levels
DIFFICULTY_DETAILS = {
	'Easy' : 'Enemy units will not be very aggressive, and may not act at all during their turn.',
	'Normal' : 'Enemy units will be somewhat aggressive and more likely to become Alert if Lax.',
	'Hard' : 'Enemy units will be quite aggressive and more likely to become Alert if Lax. Elite enemy units will be especially aggressive.',
	'Very Hard' : 'Enemy units will be very active and aggressive, and very likely to become Alert if Lax. Elite enemy units will be especially aggressive.'
}

# hotkeys for quickly selecting commonly-used crew commands
QUICK_COMMANDS = {
	'1' : 'Spot',
	'2' : 'Direct Movement',
	'3' : 'Direct Fire',
	'4' : 'Operate Gun',
	'5' : 'Operate MG',
	'6' : 'Operate AAMG',
	'7' : 'Reload',
	'8' : 'Drive',
	'9' : 'Drive Into Terrain',
	'0' : 'Pass Ammo'
}

##### Hex geometry definitions #####

# directional and positional constants
DESTHEX = [(0,-1),(1,-1),(1,0),(0,1),(-1,1),(-1,0)]	# change in hx, hy values for hexes in each direction
CD_DESTHEX = [(1,-1),(1,0),(0,1),(-1,1),(-1,0),(0,-1)]	# same for pointy-top
PLOT_DIR = [(0,-1),(1,-1),(1,1),(0,1),(-1,1),(-1,-1)]	# x/y offsets for direction indicator
CD_PLOT_DIR = [(1,-1),(1,0),(1,1),(-1,1),(-1,0),(-1,-1)]	# same for pointy-top hexes
TURRET_CHAR = [254,47,92,254,47,92]			# characters to use for turret display
VIEW_MODE_DIR_KEYS = ['w', 'e', 'c', 'x', 'z', 'q']	# keys to move the highlighted hex in scenario layer hex view mode

# relative locations of edge cells in a given direction for a map hex
HEX_EDGE_CELLS = {
	0: [(-1,-2),(0,-2),(1,-2)],
	1: [(1,-2),(2,-1),(3,0)],
	2: [(3,0),(2,1),(1,2)],
	3: [(1,2),(0,2),(-1,2)],
	4: [(-1,2),(-2,1),(-3,0)],
	5: [(-3,0),(-2,-1),(-1,-2)]
}

# same for campaign day hexes (pointy-topped)
CD_HEX_EDGE_CELLS = {
	0: [(0,-4),(1,-3),(2,-2),(3,-1)],
	1: [(3,-1),(3,0),(3,1)],
	2: [(3,1),(2,2),(1,3),(0,4)],
	3: [(0,4),(-1,3),(-2,2),(-3,1)],
	4: [(-3,1),(-3,0),(-3,-1)],
	5: [(-3,-1),(-2,-2),(-1,-3),(0,-4)]
}

# one cell smaller
CD_HEX_EDGE_CELLS2 = {
	0: [(0,-3),(1,-2),(2,-1)],
	1: [(2,-1),(2,0),(2,1)],
	2: [(2,1),(1,2),(0,3)],
	3: [(0,3),(-1,2),(-2,1)],
	4: [(-2,1),(-2,0),(-2,-1)],
	5: [(-2,-1), (-1,-2), (0,-3)]
}

# list of hexes on campaign day map
CAMPAIGN_DAY_HEXES = [
	(0,0),(1,0),(2,0),(3,0),(4,0),
	(0,1),(1,1),(2,1),(3,1),
	(-1,2),(0,2),(1,2),(2,2),(3,2),
	(-1,3),(0,3),(1,3),(2,3),
	(-2,4),(-1,4),(0,4),(1,4),(2,4),
	(-2,5),(-1,5),(0,5),(1,5),
	(-3,6),(-2,6),(-1,6),(0,6),(1,6),
	(-3,7),(-2,7),(-1,7),(0,7),
	(-4,8),(-3,8),(-2,8),(-1,8),(0,8)
]

# ordered list of scenario hex locations, not including 0,0, ordered by distance and hextant
SCENARIO_HEXES = [
	(0,-1), (0,-2), (0,-3), (1,-2), (1,-3), (1,-1), (2,-2), (2,-3), (3,-3), (2,-1), (3,-2),
	(3,-1), (1,0), (2,0), (3,0), (1,1), (2,1), (1,2), (0,1), (0,2), (0,3), (-1,1), (-1,2),
	(-1,3), (-2,3), (-1,1), (-2,2), (-3,3), (-2,1), (-3,2), (-3,1), (-1,0), (-2,0), (-3,0),
	(-1,-1), (-2,-1), (-1,-2)
]

##### Colour Definitions #####
KEY_COLOR = libtcod.Color(255, 0, 255)			# key color for transparency
ACTION_KEY_COL = libtcod.Color(51, 153, 255)		# colour for key commands
GAMEPAD_INPUT_COL = libtcod.Color(255, 150, 50)		# colour for gamepad inputs
HIGHLIGHT_MENU_COL = libtcod.Color(30, 70, 130)		# background highlight colour for selected menu option
TITLE_COL = libtcod.Color(102, 178, 255)		# menu titles
PORTRAIT_BG_COL = libtcod.Color(217, 108, 0)		# background color for unit portraits
UNKNOWN_UNIT_COL = libtcod.grey				# unknown enemy unit display colour
ENEMY_UNIT_COL = libtcod.Color(255, 20, 20)		# known "
ALLIED_UNIT_COL = libtcod.Color(120, 120, 255)		# allied unit display colour
GOLD_COL = libtcod.Color(255, 255, 100)			# golden colour for awards
DIRT_ROAD_COL = libtcod.Color(80, 50, 20)		# dirt roads on campaign day map
STONE_ROAD_COL = libtcod.Color(110, 110, 110)		# stone "
BRIDGE_COL = libtcod.Color(40, 20, 10)			# bridges/fords "
PC_COL = libtcod.lightest_blue				# player commander highlight colour

# Special characters for gamepad input display
GAMEPADCHAR_DPAD_UD = 274
GAMEPADCHAR_DPAD_LR = 275
GAMEPADCHAR_A = 276
GAMEPADCHAR_B = 277
GAMEPADCHAR_X = 278
GAMEPADCHAR_Y = 279
GAMEPADCHAR_LS = 280
GAMEPADCHAR_RS = 281
GAMEPADCHAR_LB = 282
GAMEPADCHAR_RB = 283
GAMEPADCHAR_BACK = 284
GAMEPADCHAR_START = 285
GAMEPADCHAR_LSB = 286		# left stick button
GAMEPADCHAR_RSB = 287		# right stick button

# text names for months
MONTH_NAMES = [
	'', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
	'October', 'November', 'December'
]

# order of turn phases
PHASE_COMMAND = 0
PHASE_SPOTTING = 1
PHASE_CREW_ACTION = 2
PHASE_MOVEMENT = 3
PHASE_SHOOTING = 4
PHASE_ALLIED_ACTION = 5
PHASE_ENEMY_ACTION = 6
PHASE_RANDOM_EVENT = 7

# crew commands that require specific inputs during the Crew Action phase
CREW_ACTION_INPUT_COMMANDS = ['Manage Ready Rack', 'Command Battlegroup', 'First Aid']

# text names for scenario turn phases
SCEN_PHASE_NAMES = [
	'Command', 'Spotting', 'Crew Action', 'Movement', 'Shooting', 'Allied Action', 'Enemy Action',
	'Random Event'
]

# colour associated with phases
SCEN_PHASE_COL = [
	libtcod.yellow, libtcod.purple, libtcod.light_blue, libtcod.green, libtcod.red,
	ALLIED_UNIT_COL, ENEMY_UNIT_COL, libtcod.light_purple]

# list of campaign calendar menus and their highlight colours
CC_MENU_LIST = [
	('Proceed', 1, libtcod.Color(70, 140, 0)),
	('Crew & Vehicle', 2, libtcod.Color(140, 140, 0)),
	('Journal', 3, libtcod.Color(0, 0, 150)),
	('Field Hospital', 4, libtcod.Color(200, 0, 0))
]

# list of campaign day menus and their highlight colours
CD_MENU_LIST = [
	('Supply', 1, libtcod.Color(128, 100, 64)),
	('Crew', 2, libtcod.Color(140, 140, 0)),
	('Travel', 3, libtcod.Color(70, 140, 0)),
	('Battlegroup', 4, libtcod.Color(180, 0, 45))
]

# directional arrows for directions on the campaign day map
CD_DIR_ARROW = [228,26,229,230,27,231]

# list of key commands for travel in campaign day
DIRECTION_KEYS = ['e', 'd', 'c', 'z', 'a', 'q']
CD_TRAVEL_CMDS = [('e',1,-2,228), ('d',2,0,26), ('c',1,2,229), ('z',-1,2,230), ('a',-2,0,27), ('q',-1,-2,231)]

# order to display ammo types
AMMO_TYPES = ['HE', 'AP', 'APCR', 'APDS', 'HEAT', 'C', 'SH', 'WP', 'Smoke']

# anti-armour only ammo types, no effect otherwise
AP_AMMO_TYPES = ['AP', 'APCR', 'APDS']

# ammo types that can be used to attempt to immobilize an armoured target
IMM_AMMO_TYPES = ['HE', 'AP', 'APCR', 'APDS', 'HEAT']

# descriptions for ammo load menu
AMMO_DESCRIPTIONS = {
	'HE' : ('High Explosive', 'Explodes on contact, used against guns, infantry, and unarmoured vehicles.'),
	'AP' : ('Armour-Piercing', 'A solid, capped, or explosive projectile, used against armoured targets.'),
	'APCR' : ('Armour-Piercing Composite Rigid', 'Has a dense core surrounded by a lighter material for better armour penetration, but loses velocity more quickly and is thus less effective at long ranges.'),
	'APDS' : ('Armour-Piercing Discarding Sabot', 'Uses a narrow dart of very dense material for excellent armour penetration, but is usually less accurate at long ranges.'),
	'HEAT' : ('High-Explosive Anti-Tank', 'Uses a shaped explosive charge to penetrate armour, also potentially causing damage to exposed crewmen.'),
	'C' : ('Canister', 'Canister rounds contain steel shot that spreads out over a large area. Only effective against guns and infantry.'),
	'SH' : ('Shrapnel', 'Shrapnel rounds contain steel shot that spreads out over a large area. Only effective against guns and infantry.'),
	'WP' : ('White Phosphorous', 'Burns at a high temperature, generating Smoke but also causing injury to any exposed personnel.'),
	'Smoke' : ('Smoke Round', 'Emits concealing smoke for a short period of time. Not harmful to personnel.')
}

# display colours for ammo types
AMMO_TYPE_COLOUR = {
	'HE' : libtcod.lighter_grey,
	'AP' : libtcod.light_yellow,
	'APCR' : libtcod.lighter_blue,
	'APDS' : libtcod.lighter_blue,
	'HEAT' : libtcod.light_red,
	'C' : libtcod.purple,
	'SH' : libtcod.purple,
	'WP' : libtcod.white,
	'Smoke' : libtcod.darker_grey
}

# list of MG-type weapons
MG_WEAPONS = ['MG', 'CMG', 'TMG', 'RMG', 'BMG', 'AAMG', 'LMG', 'MMG', 'HMG']

# list of rifle-type weapons
RIFLE_WEAPONS = ['Rifles']

# list of dedicated AA unit classes
AA_CLASSES = ['Anti-Aircraft Gun', 'Self-Propelled AA Gun']

# types of records to store for each combat day and for entire campaign
# also order in which they are displayed
RECORD_LIST = ['Engagements Fought', 'Zones Captured', 'Gun Hits', 'Vehicles Destroyed', 'Guns Destroyed', 'Infantry Destroyed']

# text descriptions for different types of Campaign Day missions
MISSION_DESC = {
	'Advance' : 'Enemy resistance is scattered and we are pushing forward. Advance into enemy territory and destroy any resistance.',
	'Battle' : 'Your group has been posted to the front line where there is heavy resistance. Break through the enemy defenses and destroy enemy units.',
	'Major Battle' : 'Enemy and friendly forces are flooding into this area for a major battle. Capture territory and destroy enemy units with the help of allied forces.',
	'Counterattack' : 'Enemy forces have mounted a counterattack against our lines. Hold as much territory as possible and attack the enemy wherever you can.',
	'Fighting Withdrawal' : 'The enemy is mounting a strong attack against our lines. Destroy enemy units but withdraw into friendly territory if necessary.',
	'Hold the Line' : 'Our position is under attack. Hold our ground at all costs.',
	'Spearhead' : 'You must pierce the enemy lines, driving forward as far as possible before the end of the day.',
	'Patrol' : 'Scattered enemy forces are in this area, but their strength is unknown. Scout as much as you can, and engage any enemy forces discovered.',
	'Urban Assault' : 'Today we face a tough challenge; assaulting a well-defended urban area. We must take each building and street in turn in order to secure control.',
	'Urban Defense' : 'Enemy forces are on the outskirts of the city; we must defend each building and street and not allow them to take this important location.',
	'Amphibious Assault' : 'Today we assault coastal positions of enemy-occupied territory, one of the most challenging types of operations. Your tank will be transported by landing craft to the beach.'
}

# urban day missions
RATTENKRIEG_MISSIONS = ['Urban Assault', 'Urban Defense']

# possible filter tags for unit gallery
FILTER_TAGS = ['origin_nation', 'category', 'class']

# bail-out minigame action descriptions
BAILOUT_ACTION_DESC = {
	'None' : 'No action.',
	'Return to Vehicle' : 'Move from a safe location to the vehicle exterior.',
	'Move to Safe Location' : 'Move from the vehicle exterior to a safe location, away from enemy units.',
	'Covering Fire' : 'Use small arms to fire at nearby enemy units, decreasing the chance of them firing at your vehicle and exposed crew.',
	'Aid All Crewmen Bailing Out' : 'Help any crewmen attempting to bail out from the vehicle, increasing the chance of their success.',
	'Rescue Unconscious Crewman' : 'Pull an unconscious crewman out of the vehicle, either through an open hatch or an open top.',
	'Carry Unconscious Crewman to Safety' : 'Move with an unconscious crewman to a safe location, away from enemy units. If there are 2+ unconscious crewmen on the vehicle, you will move a random one.',
	'Open Hatch' : 'Attempt to open the hatch in this position',
	'Throw Smoke Grenade' : 'Throw a smoke grenade, giving your vehicle some cover from incoming attacks.',
	'Push Out Crewman' : 'Push out an unconscious crewman in your location to the exterior of the vehicle.',
	'Swap Positions' : 'Swap positions with a dead or unconscious crewman.',
	'Move Crewman' : 'Move an unconscious crewman to another, empty position within the vehicle.',
	'Bail Out' : 'Leave the vehicle through an open top.',
	'Bail Out through Large Hatch' : 'Leave the vehicle through an open large hatch.',
	'Bail Out through Hatch' : 'Leave the vehicle through an open hatch.',
	'Bail Out through Nearby Large Hatch' : 'Leave the vehicle through an open large hatch in a nearby position.',
	'Bail Out through Nearby Hatch' : 'Leave the vehicle through an open hatch in a nearby position.',
	'Go to Position' : 'Move to another position within the vehicle.',
	'Aid Fellow Crewmen' : 'Give first aid to other crewmen in the same location, increasing their chances of recovering from being unconscious, stunned, or shaken.',
	'Stabilize Crewmen' : 'Attempt to stabilize any crewman in the same location who has one or more critical injuries.'
}


##########################################################################################
#                                Game Engine Definitions                                 #
##########################################################################################

# max level for crewman
CREWMAN_LEVEL_CAP = 75

# effective amount of FP from a WP hit - not modified by anything
WP_FP = 4

# base chances of partial effect for area fire attacks: infantry/gun and vehicle targets
INF_FP_BASE_CHANCE = 50.0
VEH_FP_BASE_CHANCE = 40.0

FP_CHANCE_STEP = 5.0		# each additional firepower beyond 1 adds this additional chance
FP_CHANCE_STEP_MOD = 0.95	# additional firepower modifier reduced by this much beyond 1
FP_FULL_EFFECT = 0.8		# multiplier for full effect
FP_CRIT_EFFECT = 0.1		# multipler for critical effect

HE_PARTIAL_EFFECT = 0.5		# multiplier for partial HE effect

RESOLVE_FP_BASE_CHANCE = 3.0	# base chance of a 1 firepower attack destroying a unit
RESOLVE_FP_CHANCE_STEP = 3.0	# each additional firepower beyond 1 adds this additional chance
RESOLVE_FP_CHANCE_MOD = 1.02	# additional firepower modifier increased by this much beyond 1

# list of anti-tank close combat weapons
AT_CC_WEAPONS = ['Bazooka', 'PIAT', 'Panzerfaust Klein', 'Panzerschreck', 'Panzerfaust']

# base fatigue level for personnel
BASE_FATIGUE = -2

# definition for panzerfaust, only added randomly to German infantry squads
PF_WEAPON = {
	"type" : "Close Combat",
	"name" : "Panzerfaust",
	"fp" : "16",
	"max_range" : "1"
}

# definition for demolition charge, added randomly to infantry squads
DC_WEAPON = {
	"type" : "Close Combat",
	"name" : "Demolition Charge",
	"fp" : "30",
	"max_range" : "1"
}

# defintion for molotov cocktails, added randomly to infantry squads
MOL_WEAPON = {
	"type" : "Close Combat",
	"name" : "Molotovs",
	"fp" : "2",
	"max_range" : "1"
}

# definition for light/medium machine guns, added randomly to infantry squads
LMG_WEAPON = {
	"type" : "LMG",
	"name" : "Light Machine Gun",
	"fp" : "3",
	"max_range" : "2"
}
MMG_WEAPON = {
	"type" : "MMG",
	"name" : "Medium Machine Gun",
	"fp" : "5",
	"max_range" : "2"
}

# definition to Type 89 Mortar, added randomly to Japanese infantry squads
TYPE_89_MORTAR_WEAPON = {
	"type" : "Gun",
	"name" : "Mortar",
	"rof" : "30.0",
	"calibre" : "50",
	"long_range" : "S",
	"max_range" : "2",
	"ammo_type_list" : ["HE", "WP"],
	"max_ammo" : "20"
}

# chance that an ineffective firepower attack will still increase the odds of a concealed target being easier to spot
MISSED_FP_REVEAL_CHANCE = 20.0

# AI units won't execute an action with a final score of this or lower
AI_ACTION_MIN = 3.0
# chance after every failed action roll that unit will simply do nothing that activation
AI_PASS_TURN_CHANCE = 10.0

# ballistic attack (eg. mortars) HE fp effect modifier
BALLISTIC_HE_FP_MOD = 0.5

# crewman will receive one automatic level up and advance per this many days between campaigns
CONTINUE_CAMPAIGN_LEVEL_UP_DAYS = 140

# chance upon every move or reposition action that a landmine will be hit, and chance that
# vehicle will be immobilized
LANDMINE_CHANCE = 3.0
LANDMINE_KO_CHANCE = 20.0

# descriptions for different Campaign Day objective types
CD_OBJECTIVES = {
	'Capture' : 'Destroy the enemy presence in this zone and capture it for our side.',
	'Hold' : 'Maintain control of this zone until:',
	'Recon' : 'Recon this zone to determine the level of enemy strength here.',
	'Rescue' : 'An allied unit is in trouble, go to their aid and rescue them from destruction.',
	'Convoy Attack' : 'Destroy the enemy supply convoy in this zone before it moves on.'
}

# multipliers for different campaign length options
CAMPAIGN_LENGTH_MULTIPLIERS = [1.0, 0.8, 0.5, 0.2]

# terrain types in desert that can be captured by either side
DESERT_CAPTURE_ZONES = ['Villages', 'Oasis', 'Fortress', 'Mountain Pass']

# amount that unit destruction and zone capture VP is multipled by in North Africa
DESERT_DESTROY_MULTIPLER = 2.25
DESERT_CAPTURE_MULTIPLIER = 3

# each surviving crewman receives the day's VP times this amount in experience points
EXP_MULTIPLIER = 0.5

# base chance of CD hex zone capture per enemy-held adjacent hex zone
CD_ZONE_CAPTURE_CHANCE = 5.0

# base chance that a unit not in LoS of any enemy units will regain concealment after its side's activation
BASE_RECONCEAL_CHANCE = 20.0

# percent chance per day after minimum stay that a crewman in the Field Hospital will be released
# to active duty
FIELD_HOSPITAL_RELEASE_CHANCE = 4.0

# Spearhead mission zone capture VP values: adds one per this many hexrows reached
SPEARHEAD_HEXROW_LEVELS = 2

# level at which crew become eligible for promotion to the next rank
LEVEL_RANK_LIST = {
	'2' : 1,
	'6' : 2,
	'15' : 3,
	'20' : 4,
	'25' : 5,
	'35' : 6
}

# chance that eligible crew will receive a promotion
PROMOTION_CHANCE = 25.0

# chance that a weapon will jam upon use, chance that it will be unjammed if crewman is operating it
WEAPON_JAM_CHANCE = 0.3
WEAPON_UNJAM_CHANCE = 65.0

# chance of a direct hit during air or artillery attacks
DIRECT_HIT_CHANCE = 3.0

# base crew experience point and level system - higher the exponent, the more expensive future levels will be
BASE_EXP_REQUIRED = 12.0
EXP_EXPONENT = 1.3

# replacement cd_terrain_odds for urban missions
URBAN_CD_TERRAIN_ODDS = {
	'cd_terrain_odds' : {
		'Rubble' : 40,
		'Factories' : 20,
		'Tower Blocks': 10,
		'Cathedral' : 3,		# max 1
		'Town Square' : 5,		# max 1
		'Row Houses' : 10,
		'Storage Tanks' : 10,
		'Train Station' : 5,		# max 1
		'Park' : 10,			# max 2
		'Craters' : 20,
		'Graveyard' : 5,		# max 1
		'Deep Craters' : 5		# max 2
	}
}

# base chance of a ground conditions change during weather update
GROUND_CONDITION_CHANGE_CHANCE = 10.0
# modifier for heavy rain/snow
HEAVY_PRECEP_MOD = 15.0

# list of crew stats and descriptions
CREW_STATS = ['Perception', 'Morale', 'Grit', 'Knowledge']
CREW_STAT_DESC = [
	"Perception represents the crewman's ability to spot and engage with enemy units.",
	"Morale represents the crewman's level of motivation and mental toughness, allowing them to resist Fatigue and negative conditions such as being Stunned.",
	"Grit means physical toughness, representing the crewman's ability to resist and recover from injury.",
	"Knowledge represents practical battlefield knowledge, and gives a small bonus to many different types of actions."
]

# list of commander positions, also positions that player character can be (Commander, etc.)
COMMANDER_POSITIONS = ['Commander', 'Commander/Gunner', 'Commander/Loader']

# length of scenario turn in minutes
TURN_LENGTH = 2

# maximum visible distance when buttoned up
MAX_BU_LOS = 1

# base chance to spot unit at different distances
SPOT_BASE_CHANCE = [95.0, 85.0, 70.0, 50.0, 40.0, 35.0, 32.5, 30.0, 20.0, 10.0]

# each point of Perception increases chance to spot enemy unit by this much
PERCEPTION_SPOTTING_MOD = 5.0

# base chance of moving forward/backward into next hex
BASE_FORWARD_MOVE_CHANCE = 50.0
BASE_REVERSE_MOVE_CHANCE = 20.0

# bonus per unsuccessful move attempt, HD attempt
BASE_MOVE_BONUS = 15.0
BASE_HD_BONUS = 5.0

# base critical hit and miss thresholds
CRITICAL_HIT = 3.0
CRITICAL_MISS = 99.5

# base success chances for point fire attacks
# first column is for vehicle targets, second is everything else
PF_BASE_CHANCE = [
	[98.0, 88.0],			# same hex
	[83.0, 78.0],			# 1 hex range
	[70.0, 68.0],			# 2 "
	[59.0, 58.0],			# 3 "
	[49.0, 48.0],			# 4 "
	[40.0, 38.0],			# 5 "
	[32.0, 28.0]			# 6 "
]

# base success chance for a close combat attack
CC_BASE_CHANCE = [90.0, 80.0]

# acquired target bonus for level 1 and level 2 for point fire
AC_BONUS = [
	[8.0, 15.0],	# same hex 0
	[10.0, 25.0],	# 1 hex range
	[10.0, 25.0],	# 2 "
	[20.0, 35.0],	# 3 "
	[25.0, 45.0],	# 4 "
	[25.0, 45.0],	# 5 "
	[25.0, 45.0]	# 6 "
]

# modifier for target size if target is known
# these modifiers are less if close range
PF_SIZE_MOD = {
	'Very Small' : -20.0,
	'Small' : -12.0,
	'Medium' : 0.0,
	'Large' : 12.0,
	'Very Large' : 20.0,
	'Extra Large' : 30.0
}

# base chance of passing a morale check, eg. to recover from Pinned status
MORALE_CHECK_BASE_CHANCE = 35.0

# effective FP of an HE hit from different weapon calibres
HE_FP_EFFECT = [
	(380, 88),(350, 82),(300, 75),(250, 50),(225, 42),
	(200, 36),(183, 34),(170, 32),(160, 31),(150, 30),(140, 28),(128, 26),(120, 24),
	(107, 22),(105, 22),(100, 20),(95, 19),(88, 18),(85, 17),(80, 16),(75, 14),
	(70, 12),(65, 10),(60, 8),(57, 7),(50, 6),(45, 5),(37, 4),(30, 2),(25, 2),(20, 1)
]

# odds of unarmoured vehicle destruction when resolving FP
VEH_FP_TK = [
	(36, 110.0),(30, 100.0),(24, 97.0),(20, 92.0),(16, 83.0),(12, 72.0),(8, 58.0),(6, 42.0),
	(4, 28.0),(2, 17.0),(1, 8.0)
]

# multiplier for initial AP chance that will result in a crewman being stunned or knocked unconscious
AP_STUN_MULT = 0.5

# amount within an AFV armour save that will result in recall test for an enemy unit
# chance of it being recalled
AP_RECALL_MARGIN = 10.0
AP_RECALL_CHANCE = 20.0

# definitions for terrain types on the Campaign Day map
CD_TERRAIN_TYPES = {
	'Flat' : {
		'description' : 'Mostly flat terrain with few features.',
		'travel_time' : 30,
		'scenario_terrain_odds' : {
			'Open Ground' : 60.0,
			'Broken Ground' : 20.0,
			'Brush' : 10.0,
			'Woods' : 5.0,
			'Wooden Buildings' : 4.0,
			'Rubble' : 1.0
		}
	},
	'Forest' : {
		'description' : 'Dense areas of trees and brush, difficult and time-consuming to traverse.',
		'travel_time' : 45,
		'scenario_terrain_odds' : {
			'Open Ground' : 10.0,
			'Broken Ground' : 15.0,
			'Brush' : 25.0,
			'Woods' : 45.0,
			'Wooden Buildings' : 4.0,
			'Rubble' : 1.0
		}
	},
	'Hills' : {
		'description' : 'Rolling hills, not impassable but can make travel slower.',
		'travel_time' : 40,
		'scenario_terrain_odds' : {
			'Open Ground' : 15.0,
			'Broken Ground' : 10.0,
			'Brush' : 5.0,
			'Woods' : 5.0,
			'Hills' : 50.0,
			'Wooden Buildings' : 4.0,
			'Rubble' : 1.0
		}
	},
	'Fields' : {
		'description' : 'Fields of crops.',
		'travel_time' : 35,
		'scenario_terrain_odds' : {
			'Open Ground' : 20.0,
			'Broken Ground' : 5.0,
			'Brush' : 5.0,
			'Woods' : 5.0,
			'Fields' : 50.0,
			'Wooden Buildings' : 4.0,
			'Rubble' : 1.0
		}
	},
	'Marsh' : {
		'description' : 'Marshy area with standing water, not impassable but risky.',
		'travel_time' : 40,
		'scenario_terrain_odds' : {
			'Open Ground' : 10.0,
			'Broken Ground' : 5.0,
			'Brush' : 5.0,
			'Woods' : 4.0,
			'Marsh' : 60.0,
			'Wooden Buildings' : 5.0,
			'Rubble' : 1.0
		}
	},
	'Villages' : {
		'description' : 'Clusters of small settlements.',
		'travel_time' : 30,
		'scenario_terrain_odds' : {
			'Open Ground' : 5.0,
			'Broken Ground' : 5.0,
			'Brush' : 10.0,
			'Fields' : 15.0,
			'Wooden Buildings' : 45.0,
			'Stone Buildings' : 20.0
		}
	},
	'Scrub' : {
		'description' : 'Small patches of hardy vegetation, sufficient for infantry to find some cover.',
		'travel_time' : 30,
		'scenario_terrain_odds' : {
			'Open Ground' : 45.0,
			'Broken Ground' : 20.0,
			'Brush' : 30.0,
			'Wooden Buildings' : 4.0,
			'Rubble' : 1.0
		}
	},
	'Hamada' : {
		'description' : 'Flat and featureless rocky plateau, covered in a layer of sharp stones.',
		'travel_time' : 20,
		'scenario_terrain_odds' : {
			'Hamada' : 70.0,
			'Open Ground' : 10.0,
			'Broken Ground' : 10.0,
			'Rubble' : 10.0
		}
	},
	'Sand' : {
		'description' : 'A shifting sea of sand and sand dunes.',
		'travel_time' : 30,
		'scenario_terrain_odds' : {
			'Sand' : 65.0,
			'Deep Sand' : 10.0,
			'Open Ground' : 10.0,
			'Broken Ground' : 10.0,
			'Hamada' : 5.0
		}
	},
	'Beach' : {
		'description' : 'A strip of sand and stones along the coast.',
		'travel_time' : 45,
		'scenario_terrain_odds' : {
			'Deep Sand' : 80.0,
			'Sand' : 10.0,
			'Broken Ground' : 10.0
		}
	},
	'Oasis' : {
		'description' : 'A rare green and lush place, built over a natural well.',
		'travel_time' : 30,
		'max_per_map' : 1,
		'scenario_terrain_odds' : {
			'Open Ground' : 70.0,
			'Broken Ground' : 10.0,
			'Stone Buildings' : 15.0,
			'Hills' : 5.0,
		}
	},
	'Fortress' : {
		'description' : 'An ancient stone fortress, a perfect defensive position.',
		'travel_time' : 30,
		'max_per_map' : 2,
		'scenario_terrain_odds' : {
			'Stone Buildings' : 60.0,
			'Open Ground' : 20.0,
			'Broken Ground' : 10.0,
			'Sand' : 10.0
		}
	},
	'Mountains' : {
		'description' : 'High, impassable mountains.',
		'impassible' : True,
		'max_per_map' : 3
	},
	'Mountain Pass' : {
		'description' : 'A narrow pass through the mountains.',
		'travel_time' : 40,
		'max_per_map' : 2,
		'scenario_terrain_odds' : {
			'Open Ground' : 15.0,
			'Hills' : 50.0,
			'Broken Ground' : 20.0,
			'Brush' : 15.0
		}
	},
	'Lake' : {
		'description' : 'An inland lake, impassable.',
		'impassible' : True,
		'max_per_map' : 2
	},
	'Water' : {
		'description' : 'The coast or a major river, impassable to tanks.',
		'impassible' : True
	},
	'Fortification' : {
		'description' : 'A large concrete and stone fortification, a perfect defensive position.',
		'travel_time' : 30,
		'max_per_map' : 2,
		'scenario_terrain_odds' : {
			'Stone Buildings' : 70.0,
			'Open Ground' : 20.0,
			'Broken Ground' : 10.0
		}
	},
	
	
	# Rattenkrieg zone types
	'Rubble' : {
		'description' : 'Mostly flattened buildings and rubble.',
		'travel_time' : 45,
		'scenario_terrain_odds' : {
			'Open Ground' : 20.0,
			'Broken Ground' : 20.0,
			'Concrete Buildings' : 10.0,
			'Rubble' : 50.0
		}
	},
	'Factories' : {
		'description' : 'A group of large, bombed-out factory buildings.',
		'travel_time' : 50,
		'scenario_terrain_odds' : {
			'Concrete Buildings' : 50.0,
			'Broken Ground' : 10.0,
			'Rubble' : 30.0,
			'Boulevard' : 10.0
		}
	},
	'Tower Blocks' : {
		'description' : 'A group of concrete residential tower buildings.',
		'travel_time' : 40,
		'scenario_terrain_odds' : {
			'Concrete Buildings' : 50.0,
			'Open Ground' : 40.0,
			'Boulevard' : 10.0
		}
	},
	'Cathedral' : {
		'description' : 'A massive religious building, now largely a bombed-out shell.',
		'travel_time' : 45,
		'max_per_map' : 1,
		'scenario_terrain_odds' : {
			'Concrete Buildings' : 40.0,
			'Broken Ground' : 10.0,
			'Rubble' : 40.0,
			'Boulevard' : 10.0
		}
	},
	'Town Square' : {
		'description' : 'A large open square, used for political rallies and parades.',
		'travel_time' : 25,
		'max_per_map' : 1,
		'scenario_terrain_odds' : {
			'Open Ground' : 85.0,
			'Boulevard' : 15.0
		}
	},
	'Row Houses' : {
		'description' : 'Two-story brick houses for the working class, laid out in long rows.',
		'travel_time' : 35,
		'scenario_terrain_odds' : {
			'Row Houses' : 70.0,
			'Rubble' : 10.0,
			'Open Ground' : 15.0,
			'Boulevard' : 5.0
		}
	},
	'Storage Tanks' : {
		'description' : 'Large cylindrical storage tanks, used for natural gas or other industrial materials.',
		'travel_time' : 25,
		'scenario_terrain_odds' : {
			'Open Ground' : 40.0,
			'Broken Ground' : 40.0,
			'Rubble' : 20.0
		}
	},
	'Train Station' : {
		'description' : 'An urban terminal station, now bombed out and quiet.',
		'travel_time' : 30,
		'max_per_map' : 1,
		'scenario_terrain_odds' : {
			'Concrete Buildings' : 40.0,
			'Broken Ground' : 30.0,
			'Rubble' : 20.0,
			'Boulevard' : 10.0
		}
	},
	'Park' : {
		'description' : 'An urban park, overgrown and abandoned.',
		'travel_time' : 35,
		'max_per_map' : 2,
		'scenario_terrain_odds' : {
			'Open Ground' : 40.0,
			'Brush' : 40.0,
			'Rubble' : 20.0
		}
	},
	'Craters' : {
		'description' : 'This zone has been torn apart by bombs and artillery fire, leaving only a cratered wasteland.',
		'travel_time' : 45,
		'scenario_terrain_odds' : {
			'Craters' : 40.0,
			'Broken Ground' : 40.0,
			'Rubble' : 20.0
		}
	},
	'Graveyard' : {
		'description' : 'An urban graveyard, silent and overgrown.',
		'travel_time' : 35,
		'max_per_map' : 1,
		'scenario_terrain_odds' : {
			'Open Ground' : 20.0,
			'Broken Ground' : 40.0,
			'Brush' : 30.0,
			'Rubble' : 10.0
		}
	},
	'Deep Craters' : {
		'description' : 'This zone has been completely destroyed artillery fire, it cannot be traversed.',
		'impassible' : True,
		'max_per_map' : 2
	},
	
	# South Pacific / Southeast Asian Terrain
	'Jungle' : {
		'description' : 'A tropical forest with tangled vegetation.',
		'travel_time' : 60,
		'scenario_terrain_odds' : {
			'Jungle' : 60.0,
			'Cogon Grass' : 20.0,
			'Open Ground' : 10.0,
			'Brush' : 5.0,
			'Marsh' : 5.0
		}
	},
	'Dense Jungle' : {
		'description' : 'An especially dense tropical forest with tangled vegetation.',
		'travel_time' : 80,
		'scenario_terrain_odds' : {
			'Jungle' : 75.0,
			'Cogon Grass' : 10.0,
			'Open Ground' : 5.0,
			'Brush' : 5.0,
			'Marsh' : 5.0
		}
	},
	'Bamboo Forest' : {
		'description' : 'An area of thick bamboo groves.',
		'travel_time' : 35,
		'scenario_terrain_odds' : {
			'Bamboo Forest' : 70.0,
			'Cogon Grass' : 15.0,
			'Open Ground' : 12.0,
			'Marsh' : 3.0
		}
	},
	'Palm Trees' : {
		'description' : 'An area where palm trees tower overhead.',
		'travel_time' : 30,
		'scenario_terrain_odds' : {
			'Open Ground' : 90.0,
			'Brush' : 7.0,
			'Marsh' : 3.0
		}
	},
	'Cogon Grass' : {
		'description' : 'Fields of tall tropical grass.',
		'travel_time' : 35,
		'scenario_terrain_odds' : {
			'Cogon Grass' : 80.0,
			'Brush' : 10.0,
			'Open Ground' : 7.0,
			'Marsh' : 3.0
		}
	},
	'Swamp' : {
		'description' : 'A wet morass, impassable to vehicles.',
		'impassible' : True,
		'max_per_map' : 2
	},
	'Rice Paddies' : {
		'description' : 'Carefully cultivated flat flooded fields, surrounded by low banks.',
		'travel_time' : 25,
		'scenario_terrain_odds' : {
			'Rice Paddy' : 75.0,
			'Open Ground' : 25.0
		}
	},
	'Volcanic Sand' : {
		'description' : 'An area of fine black sand, punctuated by tufts of hearty grasses.',
		'travel_time' : 45,
		'scenario_terrain_odds' : {
			'Sand' : 80.0,
			'Brush' : 10.0,
			'Open Ground' : 10.0
		}
	},
	'Hut Villages' : {
		'description' : 'Clusters of huts in jungle clearings.',
		'travel_time' : 30,
		'scenario_terrain_odds' : {
			'Open Ground' : 70.0,
			'Jungle' : 20.0,
			'Wooden Buildings' : 10.0
		}
	}
}


# modifiers and effects for different types of terrain on the scenario layer
SCENARIO_TERRAIN_EFFECTS = {
	'Open Ground' : {
		'HD Chance' : 5.0,
		'los_mod' : 0.0
	},
	'Broken Ground' : {
		'TEM' : {
			'Vehicle' : -10.0,
			'Infantry' : -15.0,
			'Deployed Gun' : -15.0
		},
		'HD Chance' : 10.0,
		'Movement Mod' : -5.0,
		'Bog Mod' : 1.0,
		'los_mod' : 3.0
	},
	'Brush': {
		'TEM' : {
			'All' : -15.0
		},
		'HD Chance' : 10.0,
		'Movement Mod' : -15.0,
		'Bog Mod' : 2.0,
		'Burnable' : True,			# not used yet
		'los_mod' : 5.0
	},
	'Woods': {
		'TEM' : {
			'All' : -25.0
		},
		'HD Chance' : 20.0,
		'Movement Mod' : -30.0,
		'Bog Mod' : 5.0,
		'Double Bog Check' : True,		# player must test to bog before moving out of this terrain type
		'Burnable' : True,
		'los_mod' : 10.0
	},
	'Fields': {
		'TEM' : {
			'All' : -10.0
		},
		'HD Chance' : 5.0,
		'Burnable' : True,
		'los_mod' : 5.0
	},
	'Hills': {
		'TEM' : {
			'All' : -20.0
		},
		'HD Chance' : 40.0,
		'los_mod' : 15.0
	},
	'Wooden Buildings': {
		'TEM' : {
			'Vehicle' : -20.0,
			'Infantry' : -30.0,
			'Deployed Gun' : -30.0
		},
		'HD Chance' : 20.0,
		'los_mod' : 10.0,
		'Burnable' : True
	},
	'Stone Buildings': {
		'TEM' : {
			'Vehicle' : -20.0,
			'Infantry' : -50.0,
			'Deployed Gun' : -50.0
		},
		'HD Chance' : 30.0,
		'los_mod' : 15.0
	},
	'Marsh': {
		'TEM' : {
			'All' : -10.0
		},
		'HD Chance' : 15.0,
		'Movement Mod' : -30.0,
		'Bog Mod' : 10.0,
		'Double Bog Check' : True,
		'los_mod' : 3.0,
		'dug_in_na' : True
	},
	'Rubble': {
		'TEM' : {
			'Vehicle' : -15.0,
			'Infantry' : -30.0,
			'Deployed Gun' : -30.0
		},
		'HD Chance' : 30.0,
		'los_mod' : 10.0,
		'Bog Mod' : 10.0,
		'Double Bog Check' : True
	},
	'Hamada': {
		'los_mod' : 0.0,
		'HD Chance' : 2.0,
		'Movement Mod' : -15.0,
		'Bog Mod' : 10.0,
		'Double Bog Check' : True,
		'dug_in_na' : True
	},
	'Sand': {
		'los_mod' : 0.0,
		'HD Chance' : 2.0,
		'Movement Mod' : -5.0,
		'Bog Mod' : 15.0,
		'dug_in_na' : True
	},
	'Deep Sand': {
		'los_mod' : 0.0,
		'HD Chance' : 1.0,
		'Movement Mod' : -25.0,
		'Bog Mod' : 15.0,
		'Double Bog Check' : True,
		'dug_in_na' : True
	},
	
	# Rattenkrieg terrain types
	'Concrete Buildings': {
		'TEM' : {
			'Vehicle' : -30.0,
			'Infantry' : -60.0,
			'Deployed Gun' : -60.0
		},
		'HD Chance' : 50.0,
		'Movement Mod' : -5.0,
		'los_mod' : 25.0
	},
	'Boulevard' : {
		'HD Chance' : 2.0,
		'los_mod' : 0.0,
		'dug_in_na' : True
	},
	'Row Houses': {
		'TEM' : {
			'Vehicle' : -30.0,
			'Infantry' : -40.0,
			'Deployed Gun' : -40.0
		},
		'HD Chance' : 30.0,
		'los_mod' : 20.0,
		'Burnable' : True
	},
	'Craters' : {
		'TEM' : {
			'Vehicle' : -20.0,
			'Infantry' : -30.0,
			'Deployed Gun' : -30.0
		},
		'HD Chance' : 15.0,
		'Movement Mod' : -15.0,
		'Bog Mod' : 5.0,
		'los_mod' : 10.0
	},
	
	# South Pacific / Southeast Asian Terrain
	'Jungle' : {
		'TEM' : {
			'All' : -35.0
		},
		'HD Chance' : 3.0,
		'Movement Mod' : -20.0,
		'Bog Mod' : 15.0,
		'Double Bog Check' : True,
		'los_mod' : 25.0
	},
	'Cogon Grass': {
		'TEM' : {
			'All' : -20.0
		},
		'HD Chance' : 5.0,
		'Burnable' : True,
		'los_mod' : 15.0
	},
	'Bamboo Forest': {
		'TEM' : {
			'All' : -25.0
		},
		'HD Chance' : 20.0,
		'Movement Mod' : -30.0,
		'Bog Mod' : 5.0,
		'Double Bog Check' : True,
		'Burnable' : True,
		'los_mod' : 10.0
	},
	'Rice Paddy': {
		'TEM' : {
			'All' : -10.0
		},
		'HD Chance' : 15.0,
		'Movement Mod' : -30.0,
		'Bog Mod' : 10.0,
		'Double Bog Check' : True,
		'los_mod' : 3.0,
		'dug_in_na' : True
	}
}

# relative locations to draw greebles for terrain on scenario map
GREEBLE_LOCATIONS = [(-1,-1), (0,-1), (1,-1), (-1,0), (1,0), (-1,1), (0,1), (1,1)]

# modifier for base HD chance
HD_SIZE_MOD = {
	'Very Small' : 12.0, 'Small' : 6.0, 'Normal' : 0.0, 'Large' : -6.0, 'Very Large' : -12.0,
	'Extra Large' : -20.0
}

# base chance of a sniper attack being effective
BASE_SNIPER_TK_CHANCE = 45.0

# base chance of a random event in a scenario
BASE_RANDOM_EVENT_CHANCE = 5.0
# base chance of a random event in a campaign day
BASE_CD_RANDOM_EVENT_CHANCE = 3.0

# base number of minutes between weather update checks
BASE_WEATHER_UPDATE_CLOCK = 30




# Campaign: stores data about a campaign and campaign calendar currently in progress
class Campaign:
	def __init__(self):
		
		self.filename = ''		# short filename (no path) for of campaign definitions
		
		self.options = DEFAULT_CAMPAIGN_OPTIONS.copy()
		
		self.vp_modifier = 0		# total effect on VP from campaign options - in percentage points
		
		self.logs = {}			# dictionary of campaign logs for each combat day
		self.enemies_destroyed = {}	# dictionary of number of enemy units destroyed over entire campaign
		self.journal = {}		# dictionary of events for each combat day
		self.player_unit = None		# placeholder for player unit
		self.player_squad_max = 0	# maximum units in player squad in addition to player
		self.battlegroup_command = 'Fire at Will'	# default command for allied units
		self.player_vp = 0		# total player victory points
		self.max_one_day_vp = 0		# max one-day VP since last check
		self.combat_days = 0		# total number of combat days completed
		self.pc_decorations = 0		# total number of player commander decorations awarded this campaign
		self.stats = {}			# local copy of campaign stats
		self.combat_calendar = []	# list of combat days
		self.refit_days = 0		# number of refit days in calendar
		self.today = None		# pointer to current day in calendar
		self.current_week = None	# " week
		self.portrait_variant = 'STD'	# current portrait variant used
		
		self.latitude = 55.95		# current location in world
		self.longitude = -3.18		# these are placeholder values, will be set by each campaign week
		
		self.hospital = []		# holds crewmen currently in the field hospital
		
		self.active_calendar_menu = 1	# currently active menu in the campaign calendar interface
		self.active_journal_day = None	# currently displayed journal day
		self.journal_scroll_line = 0	# current level of scroll on the journal display
		self.ended = False		# campaign has ended due to player serious injury or death
		self.completed = False		# final results and medals have already been awarded
		self.player_oob = False		# player was seriously injured or killed
		
		# records for end-of-campaign summary
		self.records = {}
		for t in RECORD_LIST:
			self.records[t] = 0
		# only recorded at end of entire campaign, not each campaign day
		self.records['Combat Days'] = 0
		
		self.tutorial_slides = []	# list of tutorial slides that have already been displayed this tutorial campaign
	
	
	# generate a list of units for armoured unit support
	def GenerateArmouredUnitSupportList(self):
		unit_list, more_to_come = self.GeneratePlayerUnitList()
		
		# prune out any armoured cars
		for unit_id in reversed(unit_list):
			if session.unit_types[unit_id]['class'] == 'Armoured Car':
				unit_list.remove(unit_id)
		
		self.stats['player_unit_support']['Armoured'] = unit_list.copy()
	
	
	# generate a list of possible player vehicles for the current date
	# also returns a flag if more player units will become available later in the campaign
	def GeneratePlayerUnitList(self):
		
		unit_list = []
		more_to_come = False
		
		for unit_id in self.stats['player_unit_list']:
			
			# check that unit is available at current point in calendar
			# TODO: also check for units that cease to be available later in campaign?
			if unit_id not in session.unit_types: continue
			if 'rarity' in session.unit_types[unit_id]:
				rarity_ok = True
				for date, chance in session.unit_types[unit_id]['rarity'].items():
					# not yet available at this time
					if date > campaign.today:
						rarity_ok = False
						break
					# earliest rarity date is on or before current date, proceed
					break
			
			if not campaign.options['ahistorical']:
				if not rarity_ok:
					more_to_come = True
					continue
			
			if session.unit_types[unit_id]['class'] == 'Armoured Car':
				if not campaign.options['armoured_cars']:
					continue
			
			# check to see if some player tanks are restricted to a certain date (used eg. for captured tanks)
			if 'player_unit_dates' in self.stats and not campaign.options['ahistorical']:
				if unit_id in self.stats['player_unit_dates']:
					if campaign.today < self.stats['player_unit_dates'][unit_id]:
						more_to_come = True
						continue
			
			unit_list.append(unit_id)
		
		return unit_list, more_to_come
	
	
	# set or update the current unit portrait variant to be used
	def UpdatePortraitVariant(self):
		
		# just starting the campaign, use the earliest date
		if campaign_day is None:
			today = self.combat_calendar[0]
		else:
			today = self.today
		
		# determine portrait variant based on campaign region and current effective date
		if self.stats['region'] == 'North Africa':
			self.portrait_variant = 'DES'
		elif self.stats['region'] in ['Southeast Asia', 'South Pacific']:
			self.portrait_variant = 'TRO'
		else:
			self.portrait_variant = 'STD'
			month = int(today.split('.')[1])
			if self.stats['region'] == 'Nordic':
				if month >= 11 or month <= 3:
					self.portrait_variant = 'WIN'
			else:
				if month == 12 or month <= 2:
					self.portrait_variant = 'WIN'
			
			# early/late-war portraits
			if self.portrait_variant == 'STD':
				if '1939.09.01' <= today < '1941.06.22':
					self.portrait_variant = 'ELW'
				elif '1943.03.01' <= today < '1950.01.01' :
					self.portrait_variant = 'LTW'
		
	
	# do a rarity check for spawning a given type of unit today, returns True if check passed
	# if get_rarity is True, always returns current rarity factor
	# nation is optional
	def DoRarityCheck(self, unit_id, nation=None, get_rarity=False):
		
		# no rarity factor given in unit type def, select automatically
		if 'rarity' not in session.unit_types[unit_id]:
			return 100.0
		
		# some unit types are not available before a given date for certain nations
		if nation is not None:
			if unit_id == 'Heavy Mortar Team' and nation == 'Germany':
				if self.today < '1943.01.01': return False  
		
		# determine if a regional rarity list should be used
		rarity_dict = None
		if 'regional-rarity' in session.unit_types[unit_id]:
			for k, v in session.unit_types[unit_id]['regional-rarity'].items():
				if k == campaign.stats['region']:
					rarity_dict = v
					break
		
		# choose default rarity list
		if rarity_dict is None:
			rarity_dict = session.unit_types[unit_id]['rarity']
		
		rarity = None
		
		# determine if a special rarity list should be used for this week only
		if 'special_unit_rarity' in campaign.current_week:
			if unit_id in campaign.current_week['special_unit_rarity']:
				rarity = int(campaign.current_week['special_unit_rarity'][unit_id])
		
		# roll against rarity for current date if needed
		if rarity is None:
			for date, chance in rarity_dict.items():
				
				# select the earliest rarity factor
				if rarity is None:
					
					# if the earliest rarity factor is still later than current date, do not spawn
					if date > self.today:
						return False
					
					rarity = int(chance)
					continue
				
				# break if this date is later than current date
				if date > self.today: break
					
				# earlier than or equal to today's date, use this rarity factor 
				rarity = int(chance)
		
		# not able to get a rarity factor for today, don't spawn
		if rarity is None:
			return False
		
		# not rolling, just need to check current rarity
		if get_rarity:
			return float(rarity)
		
		# roll against rarity rating
		if GetPercentileRoll() <= float(rarity):
			return True
		return False
		
	
	# do post-init modifier checks, these need to wait until the player unit is generated, etc.
	def DoPostInitChecks(self):
		
		# modify the player unit if required
		
		# if current campaign region is north africa, german and italian vehicles are all unreliable before Oct. 1941
		if self.stats['region'] == 'North Africa' and self.player_unit.nation in ['Germany', 'Italy'] and self.player_unit.GetStat('category') == 'Vehicle':
			
			# if vehicle is not unreliable by default
			if 'unreliable' not in session.unit_types[self.player_unit.unit_id]:
				if self.today < '1941.10.01':
					self.player_unit.stats['unreliable'] = True
		
		# respawn all player unit weapons, to account for changes in regional rare ammo, etc.
		self.player_unit.weapon_list = []
		if 'weapon_list' in self.player_unit.stats:
			for weapon_dict in self.player_unit.stats['weapon_list']:
				if 'available_from' in weapon_dict:
					if weapon_dict['available_from'] > campaign.today:
						continue
				self.player_unit.weapon_list.append(Weapon(self.player_unit, weapon_dict))
		
		# check for radio retrofit
		if 'radio_after' in self.player_unit.stats and not self.player_unit.has_radio:
			if self.today >= self.player_unit.stats['radio_after']:
				self.player_unit.has_radio = True
				ShowMessage('Your vehicle has now been fitted with a radio.',
					longer_pause=True, good_news=True)
		
		# check for enemy_nation_odds modifiers in the first week
		if 'enemy_nation_odds' in self.current_week:
			for k, v in self.current_week['enemy_nation_odds'].items():
				if k in self.stats['enemy_nation_odds']:
					self.stats['enemy_nation_odds'][k] = int(v)
		
		# check for enemy class odds modifiers in the first week
		if 'enemy_class_odds_modifier' in self.current_week:
			for k, v in self.current_week['enemy_class_odds_modifier'].items():
				if k in self.stats['enemy_unit_class_odds']:
					self.stats['enemy_unit_class_odds'][k] = int(v)
		
	
	# check for the start of a new campaign week given the current date, apply any modifiers
	# can potentially jump ahead several weeks
	def CheckForNewWeek(self, skip_stat=False):
		week_index = self.stats['calendar_weeks'].index(self.current_week)
		
		# final week of campaign
		if week_index == len(self.stats['calendar_weeks']) - 1: return
		
		current_month = self.today.split('.')[1]
		
		for i in range(len(self.stats['calendar_weeks']) - week_index - 1):
		
			week_index += 1
			
			if self.today >= self.stats['calendar_weeks'][week_index]['start_date']:
				
				# advance calendar one week
				self.current_week = self.stats['calendar_weeks'][week_index]
				
				# check for modified enemy nation odds
				if 'enemy_nation_odds' in self.current_week:
					
					# create a blank entry if none exists yet
					if 'enemy_nation_odds' not in self.stats:
						self.stats['enemy_nation_odds'] = {}
					
					for k, v in self.current_week['enemy_nation_odds'].items():
						self.stats['enemy_nation_odds'][k] = int(v)
				
				# check for modified class spawn odds
				if 'enemy_class_odds_modifier' in self.current_week:
					for k, v in self.current_week['enemy_class_odds_modifier'].items():
						if k in self.stats['enemy_unit_class_odds']:
							self.stats['enemy_unit_class_odds'][k] = int(v)
				
				# check for a new campaign region
				if 'new_region' in self.current_week:
					campaign.stats['region'] = self.current_week['new_region']
					ShowMessage('Your campaign has brought you into a new region: ' + campaign.stats['region'],
						longer_pause=True)
				
				# if we're skipping stat recording, just continue
				if skip_stat:
					continue
				
				# new month, check for decorations
				if self.current_week['start_date'].split('.')[1] != current_month:
					self.CheckForDecorations()
					current_month = self.current_week['start_date'].split('.')[1]
				
				# check for promotions
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					position.crewman.PromotionCheck()
				
				# increase stat
				session.ModifySteamStat('weeks_passed', 1)
			
			else:
				# we've reached the correct week
				
				# regenerate the list of armoured support units
				self.GenerateArmouredUnitSupportList()
				
				return
	
	
	# handle a Player Commander staying in the field hospital for a period of time
	# returns True if commander was still in the hospital at the end of the current campaign
	def CommanderInAComa(self, crewman):
		
		# reset this to avoid a crash? can't remember why but it seems important...
		self.journal_scroll_line = 0
		
		# calculate number of days that commander will be in field hospital
		(min_days, max_days) = crewman.field_hospital
		
		if 'Fighting Spirit' in crewman.skills:
			min_days = int(min_days * 0.5)
		
		days_spent = libtcod.random_get_int(0, min_days, max_days)
		
		# calculate release date
		start_date = self.today
		(year, month, day) = self.today.split('.')
		a = date(int(year), int(month), int(day)) + timedelta(days=days_spent)
		end_date = str(a.year) + '.' + str(a.month).zfill(2) + '.' + str(a.day).zfill(2)
		
		# try and find a combat/refit day in the calendar that is on or before the release date
		stayed_until_end = False
		day_index = self.combat_calendar.index(self.today)
		
		if day_index == len(self.combat_calendar) - 1:
			stayed_until_end = True
		else:
			for i in range(day_index + 1, len(self.combat_calendar)):
				if self.combat_calendar[i] >= end_date:
					break
			else:
				stayed_until_end = True
		
		# set current date
		if stayed_until_end:
			# to last day in campaign
			self.today = self.combat_calendar[-1]
		else:
			# to date of commander release
			self.today = self.combat_calendar[i]
		
			# check for new campaign portrait variant
			self.UpdatePortraitVariant()
			
			# set current calendar week, but don't count skipped weeks for stats purposes, and don't check for decorations or promotions
			self.CheckForNewWeek(skip_stat=True)
		
		# re-calculate all crew ages
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			position.crewman.CalculateAge()
		for crewman2 in self.hospital:
			crewman2.CalculateAge()
		
		# release player commander from field hospital and resolve any remaining injuries
		self.hospital.remove(crewman)
		self.hospital.sort(key=lambda x: x.field_hospital)
		crewman.field_hospital = None
		crewman.ResolveOutstandingInjuries()
		
		# display message
		if stayed_until_end:	
			ShowMessage('While you are still recovering in the field hospital, you receive word that ' +
				'the campaign has ended.', longer_pause=True)
		else:
			ShowMessage('After ' + str(days_spent) + ' days in the field hospital, you ' +
				'recover and return to active duty on ' + GetDateText(self.today), longer_pause=True)
			
		# roll to release any other crewmen in the field hospital
		# if commander stayed until end of campaign, crewman are held for now until he continues into a new campaign
		returning_crewmen = []
		
		(year2, month2, day2) = self.today.split('.')
		days_passed = (date(int(year2), int(month2), int(day2)) - date(int(year), int(month), int(day))).days
		for crewman2 in reversed(self.hospital):
			
			# apply time passed to time remaining
			(min_days, max_days) = crewman2.field_hospital
			if min_days > 0:
				min_days -= days_passed
				if min_days < 0:
					min_days = 0
			if max_days > 0:
				max_days -= days_passed
				if max_days < 0:
					max_days = 0
			crewman2.field_hospital = (min_days, max_days)
			
			return_crewman = False
			
			# has stayed maximum number of days or more
			if max_days == 0:
				return_crewman = True
			
			# possible to roll to return
			elif min_days == 0 or 'Fighting Spirit' in crewman2.skills:
				if GetPercentileRoll() <= float(days_passed) * FIELD_HOSPITAL_RELEASE_CHANCE:
					return_crewman = True
			
			# crewman stays in field hospital if campaign has neded or max days more than 0 
			if stayed_until_end or not return_crewman:
				continue
			
			# crewman returns to duty
			crewman2.field_hospital = None
			returning_crewmen.append(crewman2)
			self.hospital.remove(crewman2)
			crewman2.ResolveOutstandingInjuries()
		
		# determine fate of tank and remaining active crewmen
		chance = float(days_spent) * 0.1
		if chance > 5.0:
			chance = 5.0
		
		roll = GetPercentileRoll()
		
		# tank was lost with all crewmen
		if roll <= chance:
			
			ShowMessage('While you were in the field hospital, your tank and all its crew was lost in battle.',
				longer_pause=True, good_news=False)
			self.player_unit.alive = False
			
			# show KIA reports for crewmen
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if position.crewman == crewman: continue
				
				position.crewman.alive = False
				position.crewman.condition = 'Dead'
				session.AddMemorial(position.crewman)
				self.DisplayTransferOrKIA(position.crewman)
				position.crewman = None
			
			# if commander finished campaign in the field hospital, temporarily
			# return him to first empty position in the tank
			if stayed_until_end:
				for position in self.player_unit.positions_list:
					if position.crewman is not None: continue
					position.crewman = crewman
					crewman.current_position = position
					crewman.SetCEStatus()
					break
			
			else:
				ShowMessage('You are assigned a new tank and crew.')
				
				# player selects a new tank, and generate a crew for it
				(unit_id, tank_name) = self.TankSelectionMenu()
				self.player_unit = Unit(unit_id, is_player=True)
				self.player_unit.unit_name = tank_name
				self.player_unit.nation = campaign.stats['player_nation']
				
				# try to put the player commander into a commander position in the new unit
				# otherwise, just put him in the first position
				found_position = False
				for position in self.player_unit.positions_list:
					if position.name in COMMANDER_POSITIONS:
						found_position = True
						break
				if not found_position:
					position = self.player_unit.positions_list[0]
				position.crewman = crewman
				crewman.current_position = position
				crewman.unit = self.player_unit
				crewman.SetCEStatus()
				
				if len(returning_crewmen) > 0:
					if len(returning_crewmen) == 1:
						text = 'One crewman has'
					else:
						text = 'Crewmen have'
					text += ' also returned from their stay in the field hospital and may be re-assigned to your tank.'
					ShowNotification(text)
					self.ShowAssignPositionsMenu(unassigned_crewmen = returning_crewmen)
				
				# generate rest of crew and set up the main gun
				self.player_unit.GenerateNewPersonnel()
				self.player_unit.ClearGunAmmo()
		
		# can keep old tank (if alive), some or all of old crew
		else:
			
			# repair any penetrating hit on the player tank
			self.player_unit.ko_hit = False
			
			# return commander to first empty position in tank
			for position in self.player_unit.positions_list:
				if position.crewman is not None: continue
				position.crewman = crewman
				crewman.current_position = position
				crewman.SetCEStatus()
				break
			
			kia_crewmen = 0
			surviving_crewmen = 0
			
			# do survival roll for each remaining crewman, remove if roll is failed
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if not position.crewman.alive: continue
				if position.crewman.is_player_commander: continue
				
				# return crewman to original position (may have bailed out)
				position.crewman.current_position = position
				
				# roll for KIA
				roll = GetPercentileRoll()
				if roll <= float(days_spent) * 0.2:
					position.crewman.alive = False
					position.crewman.condition = 'Dead'
					session.AddMemorial(position.crewman)
					kia_crewmen += 1
					continue
				
				surviving_crewmen += 1
				
				# give the surviving crewman some exp and advances
				advances = int(ceil(days_spent / CONTINUE_CAMPAIGN_LEVEL_UP_DAYS))
				position.crewman.level += advances
				if position.crewman.level > CREWMAN_LEVEL_CAP:
					position.crewman.level = CREWMAN_LEVEL_CAP
				new_exp = GetExpRequiredFor(position.crewman.level)
				if position.crewman.exp < new_exp:
					position.crewman.exp = new_exp
				position.crewman.adv += advances
			
			# if Player Commander finished campaign in field hospital, can bring surviving crew
			# with him into a new campaign
			if stayed_until_end:
				
				if surviving_crewmen == 0:
					text = 'None of your old crew survived.'
				elif kia_crewmen == 0:
					text = 'All your old crew survived the campaign.'
				elif kia_crewmen == 1:
					text = 'One crewman was KIA while you were in the field hospital.'
				else:
					text = str(kia_crewmen) + ' crewmen were KIA while you were in the field hospital.'
				ShowMessage(text, longer_pause=True)
			
			else:
			
				# need to replace the original tank
				if not self.player_unit.alive:
					text = 'You are assigned a new tank '
					if surviving_crewmen == 0:
						text += 'and a new crew.'
					elif kia_crewmen == 0:
						text += 'and all your old crew rejoin you.'
					elif kia_crewmen == 1:
						text += 'but one crewman was KIA and will not rejoin you.'
					else:
						text += 'but ' + str(kia_crewmen) + ' crewmen were KIA and will not rejoin you.'
				else:
					text = 'You rejoin your old tank '
					if kia_crewmen == 0:
						text += 'and all your old crew.'
					elif kia_crewmen == 1:
						text += 'but one crewman was KIA.'
					else:
						text += 'but ' + str(kia_crewmen) + ' crewmen were KIA.'
				ShowMessage(text, longer_pause=True)
			
			# show KIA reports for any crewmen who did not survive, then remove them
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if position.crewman.alive: continue
				self.DisplayTransferOrKIA(position.crewman)
				position.crewman = None
			
			# continuing in current campaign
			if not stayed_until_end:
			
				# allow player to choose a new tank if old one was lost
				if not self.player_unit.alive:
					campaign.ReplacePlayerTank(returning_crewmen=returning_crewmen)
				else:
					# allow player to assign crewmen who also returned from the field hospital
					if len(returning_crewmen) > 0:
						if len(returning_crewmen) == 1:
							text = 'One crewman has'
						else:
							text = 'Crewmen have'
						text += ' also returned from their stay in the field hospital and may be re-assigned to your tank.'
						ShowNotification(text)
						self.ShowAssignPositionsMenu(unassigned_crewmen = returning_crewmen)
				
				# check for crew replacement if there remain any empty positions on the tank
				campaign.DoCrewReplacementCheck(self.player_unit, skip_swapping=True)
				
				# check for reliability change for player unit
				if 'unreliable' in self.player_unit.stats and self.stats['region'] == 'North Africa' and self.player_unit.nation in ['Germany', 'Italy']:
					if self.today < '1941.10.01':
						self.player_unit.stats['unreliable'] = True
					else:
						unit_type = session.unit_types[self.player_unit.unit_id]
						if 'unreliable' not in unit_type:
							self.player_unit.stats['unreliable'] = False
				
		return stayed_until_end
	
	
	# show a menu to handle assigning returning crewmen to a tank position, or crewmen to
	# new positions in a new tank
	def ShowAssignPositionsMenu(self, unassigned_crewmen=[]):
		
		def DrawMenu():
			
			libtcod.console_clear(con)
			
			# list of unassigned crewmen
			libtcod.console_set_default_background(con, libtcod.dark_blue)
			libtcod.console_rect(con, 1, 1, 28, 2, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			libtcod.console_set_default_foreground(con, libtcod.red)
			libtcod.console_print(con, 9, 1, 'Unassigned')
			libtcod.console_print(con, 11, 2, 'Crewmen')
			
			y = 4
			i = 0
			libtcod.console_set_default_foreground(con, libtcod.white)
			if len(unassigned_crewmen) == 0:
				libtcod.console_print(con, 1, y, 'None')
			else:
				for crewman in unassigned_crewmen:
					# highlight and show info if selected
					if i == selected_unassigned:
						libtcod.console_set_default_background(con, libtcod.darker_blue)
						libtcod.console_rect(con, 1, y, 28, 1, True, libtcod.BKGND_SET)
						libtcod.console_set_default_background(con, libtcod.black)
						crewman.DisplaySimpleInfo(con, 1, 14)
					PrintExtended(con, 1, y, crewman.GetCrewmanName(), nation=crewman.nation)
					y += 2
					i += 1
			
			# right column: currently selected position and crewman
			libtcod.console_set_default_background(con, libtcod.dark_blue)
			libtcod.console_rect(con, 60, 1, 28, 1, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			libtcod.console_set_default_foreground(con, libtcod.cyan)
			libtcod.console_print_ex(con, 74, 1, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Crewman in Position')
			
			crewman = campaign.player_unit.positions_list[selected_position].crewman
			if crewman is None:
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				libtcod.console_print_ex(con, 74, 4, libtcod.BKGND_NONE,
					libtcod.CENTER, 'None')
			else:
				crewman.DisplaySimpleInfo(con, 60, 3)
			
			# middle column: player unit and crew
			libtcod.console_set_default_foreground(con, libtcod.white)
			DrawFrame(con, 32, 0, 27, 17)
			DrawFrame(con, 32, 16, 27, 34)
			DisplayUnitInfo(con, 33, 1, self.player_unit.unit_id, self.player_unit, status=False, position_highlight=selected_position)
			DisplayCrew(self.player_unit, con, 33, 18, selected_position, darken_highlight=crewman_highlight)
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 35, 52, GAMEPADCHAR_DPAD_LR)
				DisplayButton(con, 35, 53, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 35, 55, GAMEPADCHAR_Y)
				DisplayButton(con, 35, 56, GAMEPADCHAR_X)
				DisplayButton(con, 35, 57, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 31, 52, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(con, 31, 53, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 31, 55, EnKey('e').upper())
				libtcod.console_print(con, 31, 56, EnKey('f').upper())
				libtcod.console_print(con, 31, 57, 'Enter')
			
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print(con, 37, 52, 'Select Unassigned Crewman')
			libtcod.console_print(con, 37, 53, 'Select Position')
			libtcod.console_print(con, 37, 55, 'Assign Crewman to Position')
			libtcod.console_print(con, 37, 56, 'Unassign Crewman from Position')
			libtcod.console_print(con, 37, 57, 'Commit Changes')
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		selected_unassigned = 0
		selected_position = 0
		crewman_highlight = False
		
		# draw menu screen for the first time
		DrawMenu()
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			key_char = DeKey(chr(key.c).lower())
			
			# confirm and finish
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
				
				# make sure no player commanders would be reassigned
				can_finish = True
				for crewman in unassigned_crewmen:
					if crewman.is_player_commander:
						ShowNotification('You cannot reassign yourself! Your character must be assigned to a position.')
						can_finish = False
						break
				
				if not can_finish: continue
				
				# if any crewmen remain unassigned, confirm exit first
				if len(unassigned_crewmen) > 0:
					if not ShowNotification(str(len(unassigned_crewmen)) + ' crewmen will permanently leave your crew.', confirm=True):
						continue
				exit_menu = True
				continue
			
			# select unassigned crewman if any
			if key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
				if len(unassigned_crewmen) <= 1: continue
				if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
					selected_unassigned -= 1
					if selected_unassigned < 0:
						selected_unassigned = len(unassigned_crewmen) - 1
			
				else:
					selected_unassigned += 1
					if selected_unassigned == len(unassigned_crewmen):
						selected_unassigned = 0
				DrawMenu()
				continue
			
			# select tank position
			elif key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					selected_position -= 1
					if selected_position < 0:
						selected_position = len(campaign.player_unit.positions_list) - 1
			
				else:
					selected_position += 1
					if selected_position == len(campaign.player_unit.positions_list):
						selected_position = 0
				DrawMenu()
				continue
			
			# assign a crewman from the unassigned list to an empty position on the tank
			elif key_char == 'e' or session.gamepad_input == 3:
				
				if len(unassigned_crewmen) == 0: continue
				position = campaign.player_unit.positions_list[selected_position]
				if position.crewman is not None: continue
				
				crewman = unassigned_crewmen[selected_unassigned]
				unassigned_crewmen.remove(crewman)
				campaign.player_unit.positions_list[selected_position].crewman = crewman
				crewman.current_position = campaign.player_unit.positions_list[selected_position]
				crewman.SetCEStatus()
				crewman.unit = campaign.player_unit
				
				# need to select a new unassigned crewman
				if selected_unassigned >= len(unassigned_crewmen):
					selected_unassigned = len(unassigned_crewmen) - 1
				
				DrawMenu()
				continue
			
			# unassign crewman from the selected position
			elif key_char == 'f' or session.gamepad_input == 2:
				
				position = campaign.player_unit.positions_list[selected_position]
				if position.crewman is None: continue
				
				position.crewman.current_position = None
				position.crewman.SetCEStatus()
				unassigned_crewmen.append(position.crewman)
				position.crewman = None
				
				DrawMenu()
				continue
		
		# finished, show a transfer order for each transfered crewman in sequence
		if len(unassigned_crewmen) > 0:
			for crewman in unassigned_crewmen:
				self.DisplayTransferOrKIA(crewman)
	
	
	# add an entry to the journal
	def AddJournal(self, text):
		if campaign_day is None: return
		time = str(campaign_day.day_clock['hour']).zfill(2) + ':' + str(campaign_day.day_clock['minute']).zfill(2)
		# create a new day entry if none exists already
		if self.today not in self.journal:
			self.journal[self.today] = []
		self.journal[self.today].append((time, text))
	
	
	# end the campaign
	def DoEnd(self):
		
		# compatibility check for pre-1.2.4 hotfix
		# player might have already finished this campaign previously, and is loading it to continue into a new campaign with the same crew
		if hasattr(self, 'completed'):			
			if self.completed:
				return
		
		self.ended = True
		self.CheckForDecorations()
		ShowTutorialSlide('end_of_campaign')
		self.DisplayCampaignEpilogue()
		self.SaveAndDisplayCampaignRecord()
		ExportLog()
		self.completed = True
			
	
	# randomly generate a list of combat days for this campaign
	def GenerateCombatCalendar(self, campaign_length):
		
		self.combat_calendar = []
		
		# build a list of possible combat days
		possible_days = []
		for week in self.stats['calendar_weeks']:
			
			# skip refitting weeks for now
			if 'refitting' in week:
				continue
			
			# build list of possible dates this week: add the first date, then the following 6
			
			# only add the first day if this week starts on or after the campaign's start date
			if week['start_date'] >= self.stats['start_date']:
				possible_days.append((week['start_date'], week['combat_chance']))
			
			day_text = week['start_date']
			(year, month, day) = day_text.split('.')
			
			for i in range(6):
				
				# this could be done with datetime now, but it works!
				# find the next day in the calendar
				
				# last day of month
				if int(day) == monthrange(int(year), int(month))[1]:
					
					# also last day of year
					if int(month) == 12:
						year = str(int(year) + 1)
						month = '01'
						day = '01'
					else:
						month = str(int(month) + 1)
						day = '01'
				
				else:
					day = str(int(day) + 1)
				
				day_text = year + '.' + month.zfill(2) + '.' + day.zfill(2)
				
				# if day is past end of calendar week, stop checking week
				if 'end_date' in week:
					if day_text > week['end_date']:
						break
				
				# check that day is not before the start of the campaign or past end of campaign
				if day_text < self.stats['start_date']: continue
				if day_text > self.stats['end_date']: break
				
				possible_days.append((day_text, week['combat_chance']))
		
		# calculate total number of desired days
		total_days = self.stats['combat_days']
		total_days = int(float(total_days) * CAMPAIGN_LENGTH_MULTIPLIERS[campaign_length])
		
		# apply an absolute minimum number of combat days (for continuing into a campaign in progress)
		if total_days < 3:
			total_days = 3
		
		# keep rolling until combat calendar is full
		while len(self.combat_calendar) < total_days and len(possible_days) > 0:
			(day_text, combat_chance) = choice(possible_days)
			if libtcod.random_get_int(0, 1, 100) <= combat_chance:
				self.combat_calendar.append(day_text)
				possible_days.remove((day_text, combat_chance))
		
		# calculate total number of refit days, use final day of refit period
		# if we're playing a shorter campaign, remove some refit days
		refit_days = []
		for week in self.stats['calendar_weeks']:
			if 'refitting' in week:
				if week['end_date'] >= self.stats['start_date']:
					refit_days.append(week['end_date'])
		if len(refit_days) > 0:
			if CAMPAIGN_LENGTH_MULTIPLIERS[campaign_length] != 1.0:
				new_length = int(ceil(len(refit_days) * CAMPAIGN_LENGTH_MULTIPLIERS[campaign_length]))
				if new_length < 1:
					new_length = 1
				refit_days = sample(refit_days, new_length)
			if DEBUG:
				print('Added following refit days: ' + str(refit_days))
			self.combat_calendar += refit_days

		self.combat_calendar.sort()
		
		# make sure that there's no two refit days in a row
		if len(refit_days) > 0:
			prune_list = []
			for i in range(len(self.combat_calendar) - 1):
				if self.combat_calendar[i] not in refit_days: continue
				if self.combat_calendar[i+1] in refit_days:
					prune_list.append(self.combat_calendar[i])
			for day_text in prune_list:
				self.combat_calendar.remove(day_text)
				refit_days.remove(day_text)
		
		# sanity check to remove multiple dates in the calendar
		new_list = []
		for day_text in self.combat_calendar:
			if day_text not in new_list:
				new_list.append(day_text)
			else:
				print('Found and removed a repeated date in the combat calendar: ' + day_text)
				if day_text in refit_days:
					refit_days.remove(day_text)
		self.combat_calendar = new_list.copy()
		
		# if first date in the combat calendar is a refit day, remove it
		if self.combat_calendar[0] in refit_days:
			refit_days.remove(self.combat_calendar[0])
			self.combat_calendar.pop(0)
		
		# if the final date in the combat calendar is also refit day, remove it
		if self.combat_calendar[-1] in refit_days:
			refit_days.remove(self.combat_calendar[-1])
			self.combat_calendar.pop(-1)
		
		# record total number of refit days
		self.refit_days = len(refit_days)
		
		if DEBUG:
			print('Generated a combat calendar of ' + str(len(self.combat_calendar)) + ' days:')
			print(str(self.combat_calendar))
			print('Including ' + str(self.refit_days) + ' refit day(s): ' + str(refit_days))
	
	
	# copy over day's records to a new entry in the campaign record log
	def LogDayRecords(self):
		self.logs[self.today] = campaign_day.records.copy()
	
	
	# award VP to the player
	def AwardVP(self, vp_to_add):
		campaign_day.day_vp += vp_to_add
	
	
	# menu to select a campaign
	# campaign_list specifies a limited list of campaigns that can be chosen
	def CampaignSelectionMenu(self, campaign_list=None, auto_start=None, old_campaign=None):
		
		# update screen with info about the currently selected campaign
		def UpdateCampaignSelectionScreen(active_list, selected_campaign_list, selected_campaign):
			libtcod.console_clear(con)
			
			# list of campaigns if any
			libtcod.console_set_default_foreground(con, libtcod.light_yellow)
			libtcod.console_set_default_background(con, libtcod.darkest_yellow)
			libtcod.console_rect(con, 3, 1, 20, 3, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			libtcod.console_print_ex(con, 13, 2, libtcod.BKGND_NONE, libtcod.CENTER,
				active_list)
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_set_default_background(con, libtcod.dark_blue)
			
			if len(selected_campaign_list) == 0:
				libtcod.console_print(con, 2, 26, 'None Yet Available')
			else:
				y = 5
				s = selected_campaign_list.index(selected_campaign)
				for i in range(s-7, s+10):
					if i < 0:
						y += 3
						continue
					elif i > len(selected_campaign_list) - 1:
						break
					
					if i == selected_campaign_list.index(selected_campaign):
						libtcod.console_rect(con, 1, y, 24, 2, True, libtcod.BKGND_SET)
					lines = wrap(selected_campaign_list[i]['name'], 23)
					y1 = 0
					for line in lines[:2]:
						libtcod.console_print(con, 2, y+y1, line)
						y1 += 1
					
					y += 3
			
			libtcod.console_set_default_background(con, libtcod.black)
			
			# menu title
			DrawFrame(con, 26, 0, 62, 60)
			libtcod.console_set_default_foreground(con, libtcod.light_yellow)
			if old_campaign is None:
				text = 'Campaign Selection'
			else:
				text = 'Campaign Continuation'
			libtcod.console_print_ex(con, 57, 1, libtcod.BKGND_NONE, libtcod.CENTER,
				text)
			
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print_ex(con, 57, 2, libtcod.BKGND_NONE, libtcod.CENTER,
				str(total_campaigns) + ' Campaigns Available')
			
			# selected campaign info if any
			if selected_campaign is not None:
				
				libtcod.console_set_default_background(con, libtcod.darker_grey)
				libtcod.console_rect(con, 27, 4, 60, 4, True, libtcod.BKGND_SET)
				libtcod.console_set_default_background(con, libtcod.black)
				libtcod.console_set_default_foreground(con, PORTRAIT_BG_COL)
				lines = wrap(selected_campaign['name'], 33)
				y = 5
				for line in lines:
					libtcod.console_print_ex(con, 57, y, libtcod.BKGND_NONE, libtcod.CENTER, line)
					y += 1
				
				# note if standard/modded
				libtcod.console_set_default_foreground(con, libtcod.grey)
				if 'mods' not in selected_campaign['filename']:
					text = 'Standard '
				else:
					text = 'Custom '
				libtcod.console_print_ex(con, 57, 8, libtcod.BKGND_NONE, libtcod.CENTER, text + 'Campaign')
				
				# player nation flag
				if selected_campaign['player_nation'] in session.flags:
					
					libtcod.console_set_default_background(con, libtcod.darkest_grey)
					libtcod.console_rect(con, 42, 9, 31, 16, True, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
					libtcod.console_blit(session.flags[selected_campaign['player_nation']],
						0, 0, 0, 0, con, 43, 10)
				
				# campaign start and end dates
				# highlight if player will be joining campaign after its start date
				joining_midway = False
				if old_campaign is not None:
					if old_campaign.stats['end_date'] > selected_campaign['start_date']:
						joining_midway = True
				
				if joining_midway:
					libtcod.console_set_default_foreground(con, libtcod.lighter_yellow)
					text = GetDateText(old_campaign.stats['end_date'])
				else:
					libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
					text = GetDateText(selected_campaign['start_date'])
				text += ' - ' + GetDateText(selected_campaign['end_date'])
				libtcod.console_print_ex(con, 57, 26, libtcod.BKGND_NONE, libtcod.CENTER, text)
				
				if joining_midway:
					libtcod.console_print_ex(con, 57, 27, libtcod.BKGND_NONE, libtcod.CENTER,
						'Joining Campaign in Progress')
				
				# wrapped description text
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				y = 28
				lines = wrap(selected_campaign['desc'], 33)
				for line in lines[:7]:
					libtcod.console_print(con, 41, y, line)
					y+=1
				
				# player and enemy forces
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print_ex(con, 43, 37, libtcod.BKGND_NONE, libtcod.CENTER, 'PLAYER FORCE')
				libtcod.console_print_ex(con, 72, 37, libtcod.BKGND_NONE, libtcod.CENTER, 'ENEMY FORCES')
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				libtcod.console_print_ex(con, 43, 38, libtcod.BKGND_NONE, libtcod.CENTER, selected_campaign['player_nation'])
				text = ''
				for nation_name in selected_campaign['enemy_nations']:
					if selected_campaign['enemy_nations'].index(nation_name) != 0:
						text += ', '
					text += nation_name
				# handle longer lists of enemy nations
				y = 38
				lines = wrap(text, 30)
				for line in lines[:3]:
					libtcod.console_print_ex(con, 72, y, libtcod.BKGND_NONE, libtcod.CENTER, line)
					y += 1
				
				# region, and total combat days
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print_ex(con, 43, 42, libtcod.BKGND_NONE, libtcod.CENTER, 'REGION')
				libtcod.console_print_ex(con, 72, 42, libtcod.BKGND_NONE, libtcod.CENTER, 'COMBAT DAYS')
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				libtcod.console_print_ex(con, 43, 43, libtcod.BKGND_NONE, libtcod.CENTER,
					selected_campaign['region'])
				libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
				i = selected_campaign['combat_days']
				i = int(float(i) * CAMPAIGN_LENGTH_MULTIPLIERS[campaign_length])
				
				# campaign cannot be fewer than one day
				if i < 1: i = 1
				
				libtcod.console_print_ex(con, 72, 43, libtcod.BKGND_NONE, libtcod.CENTER,
					str(i))
				
				# display creator if any given
				if selected_campaign['creator'] is not None:
					libtcod.console_set_default_foreground(con, libtcod.white)
					libtcod.console_print_ex(con, 43, 46, libtcod.BKGND_NONE, libtcod.CENTER, 'CREATOR')
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
					libtcod.console_print_ex(con, 43, 47, libtcod.BKGND_NONE, libtcod.CENTER,
						selected_campaign['creator'])
				
				# display difficulty level if any given
				if selected_campaign['difficulty'] is not None:
					
					# must be 1-10
					if 1 <= int(selected_campaign['difficulty']) <= 10:
						libtcod.console_set_default_foreground(con, libtcod.white)
						libtcod.console_print_ex(con, 72, 46, libtcod.BKGND_NONE,
							libtcod.CENTER, 'DIFFICULTY')
						text = selected_campaign['difficulty']
						if text in ['1', '2', '3']:
							libtcod.console_set_default_foreground(con, libtcod.light_grey)
						elif text in ['4', '5', '6']:
							libtcod.console_set_default_foreground(con, libtcod.light_purple)
						elif text in ['7', '8', '9']:
							libtcod.console_set_default_foreground(con, libtcod.light_red)
						else:
							libtcod.console_set_default_foreground(con, libtcod.red)
						libtcod.console_print_ex(con, 72, 47, libtcod.BKGND_NONE,
							libtcod.CENTER, text + '/10')
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 49, 50, GAMEPADCHAR_LB)
				DisplayButton(con, 50, 50, GAMEPADCHAR_RB)
				DisplayButton(con, 50, 51, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 50, 53, GAMEPADCHAR_DPAD_LR)
				DisplayButton(con, 50, 54, GAMEPADCHAR_Y)
				DisplayButton(con, 50, 56, GAMEPADCHAR_A)
				DisplayButton(con, 50, 57, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 42, 50, EnKey('q').upper() + '/' + EnKey('e').upper())
				libtcod.console_print(con, 42, 51, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 42, 52, 'PgUp/PgDn')
				libtcod.console_print(con, 42, 53, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(con, 42, 54, 'R')
				libtcod.console_print(con, 42, 56, 'Tab')			
				libtcod.console_print(con, 42, 57, 'Esc')
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 53, 50, 'Select Time Period')
			libtcod.console_print(con, 53, 51, 'Select Campaign')
			libtcod.console_print(con, 53, 52, 'Select Campaign (Skip 5)')
			libtcod.console_print(con, 53, 53, 'Select Length')
			libtcod.console_print(con, 53, 54, 'Select Random Campaign')
			libtcod.console_print(con, 53, 56, 'Proceed')
			libtcod.console_print(con, 53, 57, 'Return to Main Menu')
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		
		# load basic information of campaigns into a list of dictionaries
		BASIC_INFO = [
			'name', 'start_date', 'end_date', 'player_nation',
			'enemy_nations', 'region', 'desc', 'combat_days',
			'creator', 'difficulty', 'fixed_length'
		]
		
		# create separate lists for each time period
		# default category list
		CATEGORIES = [
			'Alternate History -1913', 'Great War 1914-1918', 'Interwar 1919-1938',
			'Early War 1939-1941', 'Mid War 1942-1943', 'Late War 1944-1945',
			'Cold War 1946-1989', 'Contemporary 1990-'
		]
		campaigns = {}
		for k in CATEGORIES:
			campaigns[k] = []
		all_campaigns = []
		total_campaigns = 0
		
		for filename in session.campaign_list:
			
			# campaign list has already been defined (for continuing after a completed campaign)
			if campaign_list is not None:
				if filename not in campaign_list: continue
			
			# players might create their own campaigns, so add a check in case json parsing fails
			try:
				with open(filename, encoding='utf8') as data_file:
					campaign_data = json.load(data_file)
			except Exception as e:
				ShowNotification('Error: Unable to parse campaign file ' + filename + ': ' +
					str(e))
				continue
			
			# skip tutorial campaigns if autostart not active
			if not auto_start and 'tutorial_campaign' in campaign_data: continue
			
			new_campaign = {}
			new_campaign['filename'] = filename
			for k in BASIC_INFO:
				# some data is optional (eg. creator)
				if k not in campaign_data:
					new_campaign[k] = None
				else:
					new_campaign[k] = campaign_data[k]
			
			# add to the appropriate list
			year = int(new_campaign['start_date'].split('.')[0])
			if year < 1913:
				campaigns['Alternate History -1913'].append(new_campaign)
			elif 1914 <= year <= 1918:
				campaigns['Great War 1914-1918'].append(new_campaign)
			elif 1919 <= year <= 1938:
				campaigns['Interwar 1919-1938'].append(new_campaign)
			elif 1939 <= year <= 1941:
				campaigns['Early War 1939-1941'].append(new_campaign)
			elif 1942 <= year <= 1943:
				campaigns['Mid War 1942-1943'].append(new_campaign)
			elif 1944 <= year <= 1945:
				campaigns['Late War 1944-1945'].append(new_campaign)
			elif 1946 <= year <= 1989:
				campaigns['Cold War 1946-1989'].append(new_campaign)
			elif year > 1989:
				campaigns['Contemporary 1990-'].append(new_campaign)
			else:
				continue
			all_campaigns.append(new_campaign)
			total_campaigns += 1
			
			del campaign_data
		
		# no campaign files!
		if total_campaigns == 0:
			ShowNotification('Error: No compatible campaign files available!')
			return False
		
		# prune any categories with 0 campaigns and create a new list of categories
		category_list = []
		for k in CATEGORIES:
			if len(campaigns[k]) == 0:
				del campaigns[k]
			else:
				category_list.append(k)
		
		# sort campaigns in each list by start date
		for k, v in campaigns.items():
			campaigns[k] = sorted(v, key = lambda x : (x['start_date']))
		
		active_list = category_list[0]
		selected_campaign = campaigns[active_list][0]
		
		# campaign length selection
		campaign_length = 0
		
		exit_menu = False
		
		# if we are autostarting a campaign
		if auto_start is not None:
			for active_list in category_list:
				for selected_campaign in campaigns[active_list]:
					if selected_campaign['filename'] == auto_start:
						exit_menu = True
						break
				if exit_menu: break
			
			# unable to find autostart campaign
			if not exit_menu:
				auto_start = None
		
		# select first available campaign category and first campaign
		if auto_start is None:
			active_list = category_list[0]
			selected_campaign = campaigns[active_list][0]
		
			# draw menu screen for first time
			UpdateCampaignSelectionScreen(active_list, campaigns[active_list], selected_campaign)
		
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			key_char = DeKey(chr(key.c).lower())
			
			# exit without starting a new campaign
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				
				# if we're continuing a campaign, confirm with the player
				if old_campaign is not None:
					if not ShowNotification('Cancel new campaign? Your current crew will be lost forever!', confirm=True, add_pause=True):
						continue
				
				return False
			
			# proceed with selected campaign
			elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				
				if selected_campaign is None: continue
				
				# check to see whether there's already a saved game for this campaign
				saved_game_path = selected_campaign['filename'].split('.')[0]
				saved_game_path = SAVEPATH + saved_game_path.split(os.sep)[-1]
				if os.path.isdir(saved_game_path):
					if not ShowNotification('WARNING: Saved campaign already exists for this campaign, erase and start a new one?', confirm=True):
						UpdateCampaignSelectionScreen(active_list, campaigns[active_list], selected_campaign)
						continue
				
				exit_menu = True
			
			# change selected category
			if key_char in ['q', 'e'] or session.gamepad_input in [9, 10]:
				i = category_list.index(active_list)
				if key_char == 'e' or session.gamepad_input == 10:
					if i == len(category_list) - 1:
						active_list = category_list[0]
					else:
						active_list = category_list[i+1]
				else:
					if i == 0:
						active_list = category_list[-1]
					else:
						active_list = category_list[i-1]
				selected_campaign = None
				if len(campaigns[active_list]) > 0:
					selected_campaign = campaigns[active_list][0]
				PlaySoundFor(None, 'tab_select')
				UpdateCampaignSelectionScreen(active_list, campaigns[active_list], selected_campaign)
			
			# change selected campaign
			elif key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
				if selected_campaign is None: continue
				i = campaigns[active_list].index(selected_campaign)
				
				if key.vk in [sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN]:
					if key.vk == sdl2.SDLK_PAGEUP or session.gamepad_input == 11:
						if i == 0:
							selected_campaign = campaigns[active_list][-1]
						else:
							i -= 5
							if i < 0: i = 0
							selected_campaign = campaigns[active_list][i]
					else:
						if i == len(campaigns[active_list]) - 1:
							selected_campaign = campaigns[active_list][0]
						else:
							i += 5
							if i > len(campaigns[active_list]) - 1: i = len(campaigns[active_list]) - 1
							selected_campaign = campaigns[active_list][i]
				
				elif key_char == 's' or key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12:
					if i == len(campaigns[active_list]) - 1:
						selected_campaign = campaigns[active_list][0]
					else:
						selected_campaign = campaigns[active_list][i+1]
				else:
					if i == 0:
						selected_campaign = campaigns[active_list][-1]
					else:
						selected_campaign = campaigns[active_list][i-1]
				PlaySoundFor(None, 'menu_select')
				UpdateCampaignSelectionScreen(active_list, campaigns[active_list], selected_campaign)
			
			# cycle campaign length
			elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
				if selected_campaign is None: continue
				if selected_campaign['fixed_length'] is not None:
					ShowNotification('This campaign has a fixed length.')
					continue
				if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
					m = 1
				else:
					m = -1
				campaign_length += m
				if campaign_length < 0:
					campaign_length = len(CAMPAIGN_LENGTH_MULTIPLIERS) - 1
				elif campaign_length >= len(CAMPAIGN_LENGTH_MULTIPLIERS):
					campaign_length = 0
				PlaySoundFor(None, 'menu_select')
				UpdateCampaignSelectionScreen(active_list, campaigns[active_list], selected_campaign)
			
			# select a random period and campaign (not keymapped)
			elif chr(key.c).lower() == 'r' or session.gamepad_input == 3:
				active_list = choice(category_list)
				selected_campaign = choice(campaigns[active_list])
				PlaySoundFor(None, 'menu_select')
				UpdateCampaignSelectionScreen(active_list, campaigns[active_list], selected_campaign)
				
		# set up the new campaign
		# create a local copy of selected campaign stats
		with open(selected_campaign['filename'], encoding='utf8') as data_file:
			
			# need to make sure that modded campaigns have their filename recorded properly too
			self.filename = selected_campaign['filename'].rsplit(os.sep, -1)[-1]
			self.filename = self.filename.rsplit('.', -1)[0]
			self.stats = json.load(data_file)
		
		# we are joining a campaign in progress
		if old_campaign is not None:
			if old_campaign.stats['end_date'] > self.stats['start_date']:
				
				# scale actual combat days to match portion of campaign that we will actually play
				(year1, month1, day1) = self.stats['start_date'].split('.')
				(year2, month2, day2) = old_campaign.stats['end_date'].split('.')
				(year3, month3, day3) = self.stats['end_date'].split('.')
				a = datetime(int(year1), int(month1), int(day1), 0, 0, 0)
				b = datetime(int(year2), int(month2), int(day2), 0, 0, 0)
				c = datetime(int(year3), int(month3), int(day3), 0, 0, 0)
				coef = float((c-b).days) / float((c-a).days)
				self.stats['combat_days'] = ceil(self.stats['combat_days'] * coef)
				
				# set the new campaign start date
				self.stats['start_date'] = old_campaign.stats['end_date']
		
		# generate final list of combat days
		self.GenerateCombatCalendar(campaign_length)
		
		# set current date and week
		self.today = self.combat_calendar[0]
		self.current_week = self.stats['calendar_weeks'][0]
		
		# see if we need to skip to a future calendar week, in case we're joining a campaign in progress
		self.CheckForNewWeek(skip_stat=True)
		
		# generate initial armoured unit support list from possible player units
		self.GenerateArmouredUnitSupportList()
		
		return True
	
	
	# save current campaign options to a JSON file in the user folder
	def SaveCampaignOptions(self):
		with open(HOMEPATH + os.sep + 'campaign_options.json', 'w', encoding='utf8') as write_file:
			json.dump(self.options, write_file, indent=4)
	
	
	# try to load saved campaign options from user folder
	def LoadCampaignOptions(self):
		
		filename = HOMEPATH + os.sep + 'campaign_options.json'
		
		if not os.path.exists(filename): return False
		
		try:
			with open(filename, encoding='utf8') as data_file:
				campaign_option_data = json.load(data_file)
			
			# run through each option and try to set it based on the data in the file
			for k in DEFAULT_CAMPAIGN_OPTIONS:
				if k not in campaign_option_data: continue
				if k == 'ai_difficulty':
					if type(campaign_option_data[k]) != int: continue
					if campaign_option_data[k] < -1 or campaign_option_data[k] > 2: continue
					self.options[k] = campaign_option_data[k]
				else:
					if type(campaign_option_data[k]) != bool: continue
					self.options[k] = campaign_option_data[k]
			
			return True
			
		except:
			os.remove(filename)
			self.options = DEFAULT_CAMPAIGN_OPTIONS.copy()
		
		return False
		
	
	# menu to set campaign options
	def CampaignOptionsMenu(self):
		
		# update menu screen
		def UpdateCampaignOptionsScreen(selected_option):
			libtcod.console_clear(con)
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			DrawFrame(con, 24, 2, 42, 7)
			libtcod.console_set_default_background(con, libtcod.dark_grey)
			libtcod.console_rect(con, 25, 3, 40, 5, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			
			libtcod.console_set_default_foreground(con, libtcod.light_green)
			libtcod.console_print_ex(con, 45, 5, libtcod.BKGND_NONE, libtcod.CENTER,
				'Campaign Options')
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 37, 11, 'Victory Point')
			libtcod.console_print(con, 40, 12, 'Modifier')
			
			i = 0
			y = 15
			vp_mod = 0
			for (name, k, desc, mod) in CAMPAIGN_OPTIONS:
				
				if i == selected_option:
					libtcod.console_set_default_background(con, libtcod.darker_blue)
					libtcod.console_rect(con, 4, y-1, 43, 3, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
					
					# campaign difficulty description is handled below
					if k != 'ai_difficulty':
						lines = wrap(desc, 23)
						y1 = 27 - int(len(lines) / 2)
						libtcod.console_set_default_foreground(con, libtcod.white)
						for line in lines:
							libtcod.console_print(con, 55, y1, line)
							y1 += 1
				
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 5, y, name)
				
				# special - not a bool
				if k == 'ai_difficulty':
					if self.options[k] == -1:
						text = 'Easy'
						mod = -20
					elif self.options[k] == 0:
						text = 'Normal'
						mod = 0
					elif self.options[k] == 1:
						text = 'Hard'
						mod = 15
					else:
						text = 'Very Hard'
						mod = 20
					libtcod.console_set_default_foreground(con, libtcod.white)
					libtcod.console_print(con, 30, y, text)
				else:
				
					if self.options[k]:
						libtcod.console_set_default_foreground(con, libtcod.white)
						libtcod.console_print(con, 30, y, 'ON')
					else:
						libtcod.console_set_default_foreground(con, libtcod.dark_grey)
						libtcod.console_print(con, 30, y, 'OFF')
				
				# campaign difficulty has contextual info
				if i == selected_option and k == 'ai_difficulty':
					lines = wrap(DIFFICULTY_DETAILS[text], 23)
					y1 = 27 - int(len(lines) / 2)
					for line in lines:
						libtcod.console_print(con, 55, y1, line)
						y1 += 1
				
				# display VP modifier as a percentage
				if k != 'ai_difficulty' and not self.options[k]:
					col = libtcod.grey
				else:
					vp_mod += mod
					if mod == 0:
						col = libtcod.grey
					elif mod < 0:
						col = libtcod.light_red
					else:
						col = libtcod.light_green
				libtcod.console_set_default_foreground(con, col)
				
				if mod == 0:
					text = '-'
				else:
					text = ''
					if mod > 0: text += '+'
					text += str(mod) + '%' 
				libtcod.console_print(con, 42, y, text)
				
				y += 3
				i += 1
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 18, 47, 'Total VP Modifier:')
			
			text = ''
			if vp_mod == 0:
				col = libtcod.grey
				text = '--'
			else:
				if vp_mod < 0:
					col = libtcod.light_red
				else:
					col = libtcod.light_green
					text += '+'
				libtcod.console_set_default_foreground(con, col)
				text += str(vp_mod) + '%'
			libtcod.console_print(con, 42, 47, text)
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 37, 52, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 37, 53, GAMEPADCHAR_DPAD_LR)
				DisplayButton(con, 37, 54, GAMEPADCHAR_A)
				DisplayButton(con, 37, 55, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 33, 52, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 33, 53, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(con, 33, 54, 'Tab')
				libtcod.console_print(con, 33, 55, 'Esc')
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 40, 52, 'Select Option')
			libtcod.console_print(con, 40, 53, 'Cycle Option')
			libtcod.console_print(con, 40, 54, 'Proceed with Campaign')
			libtcod.console_print(con, 40, 55, 'Return to Main Menu')
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		selected_option = 0
		
		# draw menu screen for first time
		UpdateCampaignOptionsScreen(selected_option)
		
		exit_menu = False
		skip_menu = False
		
		# tutorial campaigns have a fixed set of options
		if 'tutorial_campaign' in campaign.stats:
			self.options['ai_difficulty'] = -1
			UpdateCampaignOptionsScreen(selected_option)
			libtcod.console_flush()
			ShowNotification("Normally here you can select different options which change the " +
				"game's difficulty. For the tutorial, we'll skip this menu and " +
				"keep things simple.")
			skip_menu = True
		
		# otherwise, try to load set of saved options
		elif self.LoadCampaignOptions():
			UpdateCampaignOptionsScreen(selected_option)
		
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent() and not skip_menu: continue
			key_char = DeKey(chr(key.c).lower())
			
			# exit menu
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				if not ShowNotification('Cancel new campaign and return to the main menu?', confirm=True, add_pause=True):
					continue
				return False
			
			# proceed with current options
			elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or skip_menu or session.gamepad_input == 0:
				
				# calculate and store total vp modifier
				vp_mod = 0
				for (name, k, desc, mod) in CAMPAIGN_OPTIONS:
					
					if k == 'ai_difficulty':
						if self.options[k] == -1:
							mod = -20
						elif self.options[k] == 0:
							mod = 0
						elif self.options[k] == 1:
							mod = 15
						else:
							mod = 20
						vp_mod += mod
						
					else:
						if self.options[k]:
							vp_mod += mod
				
				self.vp_modifier = vp_mod
				self.SaveCampaignOptions()
				return True
			
			# select option
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if selected_option > 0:
						selected_option -= 1
					else:
						selected_option = len(CAMPAIGN_OPTIONS) - 1
				else:
					if selected_option < len(CAMPAIGN_OPTIONS) - 1:
						selected_option += 1
					else:
						selected_option = 0
				PlaySoundFor(None, 'menu_select')
				UpdateCampaignOptionsScreen(selected_option)
				continue
			
			# cycle selected option
			elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
				(name, k, desc, req) = CAMPAIGN_OPTIONS[selected_option]
				if k == 'ai_difficulty':					
					if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
						self.options[k] -= 1
						if self.options[k] == -2:
							self.options[k] = 2
					else:
						self.options[k] += 1
						if self.options[k] == 3:
							self.options[k] = -1
				else:
					self.options[k] = not self.options[k]
				PlaySoundFor(None, 'menu_select')
				UpdateCampaignOptionsScreen(selected_option)
				continue
			
	
	# menu to select player tank
	# also allows input/generation of tank name, and return both
	# can be used when replacing a tank mid-campaign as well
	def TankSelectionMenu(self, replacing_tank=False, starting_campaign=False, old_campaign_stats=None):
		
		def UpdateTankSelectionScreen():
			libtcod.console_clear(con)
			
			if replacing_tank and self.player_unit.alive and not self.player_unit.ko_hit:
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print_ex(con, 77, 32, libtcod.BKGND_NONE, libtcod.CENTER,
					'Current Vehicle')
				DisplayUnitInfo(con, 64, 34, self.player_unit.unit_id,
					self.player_unit, status=False)
				if 'tank_vp_modifiers' in self.stats:
					if self.player_unit.unit_id in self.stats['tank_vp_modifiers']:
						libtcod.console_set_default_foreground(con, libtcod.light_purple)
						libtcod.console_print(con, 64, 50, 'VP Modifier: ')
						modifier = self.stats['tank_vp_modifiers'][self.player_unit.unit_id]
						if modifier > 1.0:
							libtcod.console_set_default_foreground(con, libtcod.light_green)
							text = '+' + str(int(round((modifier - 1.0) * 100.0, 0))) + '%'
						else:
							libtcod.console_set_default_foreground(con, libtcod.light_red)
							text = '-' + str(int(round((1.0 - modifier) * 100.0, 0))) + '%'
						libtcod.console_print(con, 77, 50, text)
				
			libtcod.console_set_default_foreground(con, libtcod.white)
			DrawFrame(con, 26, 1, 37, 58)
			
			libtcod.console_set_default_background(con, libtcod.darker_blue)
			libtcod.console_rect(con, 27, 2, 35, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			
			libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
			libtcod.console_print_ex(con, 45, 3, libtcod.BKGND_NONE, libtcod.CENTER,
				'Player Vehicle Selection')
			libtcod.console_set_default_foreground(con, libtcod.white)
			
			libtcod.console_print_ex(con, 45, 6, libtcod.BKGND_NONE, libtcod.CENTER,
				'Select a vehicle type to command')
			
			# list of tank types
			y = WINDOW_YM - int(len(unit_list) / 2)
			if y < 2: y = 2
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			for unit_type in unit_list:
				if unit_type == selected_unit_id:
					libtcod.console_set_default_background(con, libtcod.darker_blue)
					libtcod.console_rect(con, 1, y, 25, 1, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
				libtcod.console_print(con, 1, y, unit_type)
				y += 1
			
			# add note if list was restricted
			if more_to_come:
				y += 2
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				libtcod.console_print(con, 2, y, 'More options will be')
				libtcod.console_print(con, 2, y+1, 'available later in')
				libtcod.console_print(con, 2, y+2, 'the campaign')
			
			# details on currently selected tank type
			libtcod.console_set_default_foreground(con, libtcod.white)
			DrawFrame(con, 32, 10, 27, 18)
			DisplayUnitInfo(con, 33, 11, selected_unit_id, None, portrait_variant=self.portrait_variant, portrait_nation=session.nations[self.stats['player_nation']]['short_code'])
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			PrintExtended(con, 33, 13, player_tank_name)
			
			if 'tank_vp_modifiers' in self.stats:
				if selected_unit_id in self.stats['tank_vp_modifiers']:
					libtcod.console_set_default_foreground(con, libtcod.light_purple)
					libtcod.console_print(con, 35, 29, 'VP Modifier: ')
					modifier = campaign.stats['tank_vp_modifiers'][selected_unit_id]
					if modifier > 1.0:
						libtcod.console_set_default_foreground(con, libtcod.light_green)
						text = '+' + str(int(round((modifier - 1.0) * 100.0, 0))) + '%'
					else:
						libtcod.console_set_default_foreground(con, libtcod.light_red)
						text = '-' + str(int(round((1.0 - modifier) * 100.0, 0))) + '%'
					libtcod.console_print(con, 48, 29, text)
			
			if 'description' in session.unit_types[selected_unit_id]:
				text = ''
				for t in session.unit_types[selected_unit_id]['description']:
					text += t
				lines = wrap(text, 33)
				y = 32
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				for line in lines[:20]:
					PrintExtended(con, 28, y, line)
					y+=1
			
			# display list of tank positions
			if 'crew_positions' in session.unit_types[selected_unit_id]:
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 65, 13, 'Crew: ' + str(len(session.unit_types[selected_unit_id]['crew_positions'])))
				y = 15
				for position in session.unit_types[selected_unit_id]['crew_positions']:
					libtcod.console_print(con, 66, y, position['name'])
					y += 2
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 36, 52, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 36, 53, GAMEPADCHAR_X)
				if (replacing_tank and self.player_unit.alive and not self.player_unit.ko_hit) or starting_campaign:
					DisplayButton(con, 36, 54, GAMEPADCHAR_B)
				if len(unit_list) > 1:
					DisplayButton(con, 36, 55, GAMEPADCHAR_Y)
				DisplayButton(con, 36, 56, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 32, 52, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 32, 53, 'N')
				if (replacing_tank and self.player_unit.alive and not self.player_unit.ko_hit) or starting_campaign:
					libtcod.console_print(con, 32, 54, 'Esc')
				if len(unit_list) > 1:
					libtcod.console_print(con, 32, 55, 'R')
				libtcod.console_print(con, 32, 56, 'Tab')
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 38, 52, 'Select Unit Type')
			libtcod.console_print(con, 38, 53, 'Set Vehicle Name')
			if replacing_tank and campaign.player_unit.alive and not campaign.player_unit.ko_hit:
				libtcod.console_print(con, 38, 54, 'Keep Current Vehicle')
			elif starting_campaign:
				libtcod.console_print(con, 38, 54, 'Return to Main Menu')
			if len(unit_list) > 1:
				libtcod.console_print(con, 38, 55, 'Assign Random Vehicle')
			libtcod.console_print(con, 38, 56, 'Proceed')
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# generate temporary list of units, one per possible unit type
		unit_list, more_to_come = self.GeneratePlayerUnitList()
		
		# save the full list of possible units for checking obsolence when continuing into a new campaign
		full_unit_list = unit_list.copy()
		
		# if random_tank campaign option is active, limit choices
		if campaign.options['random_tank']:
			
			# check for a player commander with advanced rank
			player_rank = 0
			if campaign.player_unit is not None:
				for position in campaign.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.is_player_commander: continue
					player_rank = position.crewman.rank
					break
			
			# standard is two choices, more if higher rank
			choices = 2
			if player_rank >= 5:
				choices = 4
			elif player_rank >= 3:
				choices = 3
			
			# if refitting, remove current vehicle if it's an option
			if 'refitting' in campaign.current_week and campaign.player_unit is not None:
				for unit_id in reversed(unit_list):
					if unit_id == campaign.player_unit.unit_id:
						unit_list.remove(unit_id)
			
			# loop until we have enough choices in the list
			while len(unit_list) > choices:
				
				unit_id = choice(unit_list)
				
				# do a rarity check and remove if failed
				if not campaign.DoRarityCheck(unit_id):
					unit_list.remove(unit_id)
					continue
				
				# replacing current vehicle
				if replacing_tank:
					
					# try to pick one with same or more number of positions
					if len(campaign.player_unit.positions_list) > len(session.unit_types[unit_id]['crew_positions']):
						if GetPercentileRoll() <= 50.0:
							unit_list.remove(unit_id)
							continue
				
				# small chance that this model will be removed anyway
				if GetPercentileRoll() <= 5.0:
					unit_list.remove(unit_id)
					continue
		
		# just to make sure
		if len(unit_list) == 0:
			ShowNotification('Cannot proceed - no player units available for this campaign!')
			return (None, None)
		
		# select first tank type by default
		selected_unit_id = unit_list[0]
		
		# placeholder for tank name if any
		player_tank_name = ''
		
		# some campaigns end with an evacuation of the battlefield and the player cannot keep their tank
		if old_campaign_stats is not None:
			if replacing_tank and self.player_unit.alive and not self.player_unit.ko_hit and 'final_evacuation' in old_campaign_stats:
				replacing_tank = False
				UpdateTankSelectionScreen()
				libtcod.console_flush()
				ShowNotification("You had to leave your vehicle on the battlefield at the end of your previous campaign, you won't be able to continue with it.")
		
		# if current tank is no longer available in the new campaign, show a message
		if replacing_tank and self.player_unit.alive and not self.player_unit.ko_hit and 'refitting' not in campaign.current_week:
			if self.player_unit.unit_id not in full_unit_list and not campaign.options['ahistorical']:
				replacing_tank = False
				UpdateTankSelectionScreen()
				libtcod.console_flush()
				ShowNotification("Your current vehicle model is not part of the new campaign, you won't be able to continue with it.")
		
		UpdateTankSelectionScreen()
		libtcod.console_flush()
		
		exit_loop = False
		
		# tutorial - only one tank selection
		if 'tutorial_campaign' in campaign.stats:
			ShowNotification("Here you can select the first vehicle that you will command. " +
				"For the tutorial, you will only have one choice: a Ram Mark II tank.")
		
		while not exit_loop:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# proceed with selected vehicle
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				exit_loop = True
			
			# cancel new campaign
			elif (key.vk in [sdl2.SDLK_BACKSPACE, sdl2.SDLK_ESCAPE] or session.gamepad_input == 1) and starting_campaign:
				return (None, None)
			
			# don't choose a new model, keep the current one
			elif (key.vk in [sdl2.SDLK_BACKSPACE, sdl2.SDLK_ESCAPE] or session.gamepad_input == 1) and replacing_tank and campaign.player_unit.alive and not campaign.player_unit.ko_hit:
				
				if not ShowNotification('Keep current vehicle?', confirm=True):
					UpdateTankSelectionScreen()
					continue
				
				return (None, None)
			
			# unmapped keys
			key_char = chr(key.c).lower()
			
			# change/generate player tank name
			if key_char == 'n' or session.gamepad_input == 2:				
				player_tank_name = ShowTextInputMenu('Enter a nickname for your vehicle', player_tank_name, MAX_TANK_NAME_LENGTH, [])
				UpdateTankSelectionScreen()
			
			# choose random tank type and proceed
			elif key_char == 'r' or session.gamepad_input == 3:
				
				if len(unit_list) <= 1: continue
				
				if not ShowNotification('Be assigned a random vehicle from this list? You cannot reverse this choice.', confirm=True):
					UpdateTankSelectionScreen()
					continue
				
				selected_unit_id = choice(unit_list)
				ShowNotification('You are assigned a ' + selected_unit_id + ' tank.')
				exit_loop = True
			
			# mapped keys
			key_char = DeKey(chr(key.c).lower())
			
			# change selected vehicle
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				
				i = unit_list.index(selected_unit_id)
				if key_char == 's' or key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12:
					if i == len(unit_list) - 1:
						selected_unit_id = unit_list[0]
					else:
						selected_unit_id = unit_list[i+1]
				else:
					if i == 0:
						selected_unit_id = unit_list[-1]
					else:
						selected_unit_id = unit_list[i-1]
				PlaySoundFor(None, 'menu_select')
				UpdateTankSelectionScreen()
			
		return (selected_unit_id, player_tank_name)
	
	
	# allow player to choose a new tank after losing one or during a refit period
	def ReplacePlayerTank(self, returning_crewmen=None, old_campaign_stats=None):
		
		# clear any dead crewmen from old positions
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive:
				position.crewman = None
		
		exit_menu = False
		while not exit_menu:
			
			# allow player to choose a new tank model
			(unit_id, tank_name) = self.TankSelectionMenu(replacing_tank=True, old_campaign_stats=old_campaign_stats)
			
			# did not choose a new model
			if unit_id is None:
				
				# we don't have any returning crewmen
				if returning_crewmen is None:
					
					# generate new crewmen to fill vacant positions if required
					self.DoCrewReplacementCheck(self.player_unit, skip_swapping=True)
					return
				
				exit_menu = True
				continue
			
			# run through each current crewmen and see if anyone cannot fit in new model
			positions_open = len(session.unit_types[unit_id]['crew_positions'])
			all_dead = True
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				all_dead = False
				positions_open -= 1
			
			# also account for any returning crewmen
			if returning_crewmen is not None:
				if len(returning_crewmen) > 0:
					positions_open -= len(returning_crewmen)
			
			# if random tank model is on, player must go with the model given
			if campaign.options['random_tank']:
				if positions_open < 0:
					text = 'You will need to reassign ' + str(abs(positions_open)) + ' crewmen who will leave your crew.'
				else:
					text = 'All current crew can be assigned to this tank.'
				ShowNotification(text)
			else:
				if positions_open < 0:
					text = 'You will need to reassign ' + str(abs(positions_open)) + ' crewmen who will leave your crew.'
				elif all_dead:
					text = 'Choose this tank model?'
				else:
					text = 'All current crew can be assigned to this tank.'
				if not ShowNotification(text, confirm=True):
					continue
			
			exit_menu = True
		
		# list to hold extra crewmen who need to be reassigned or swapped into the tank
		extra_crewmen = []

		# we picked a new tank
		if unit_id is not None:
		
			new_unit = Unit(unit_id, is_player=True)
			new_unit.unit_name = tank_name
			new_unit.nation = self.stats['player_nation']
			
			# transfer crew over to new tank
			
			# do an initial pass, trying to place crewman into the same positions as their last tank
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				for new_position in new_unit.positions_list:
					if new_position.crewman is not None: continue
					
					# if new position isn't the same but is still a commander position, it's ok
					if position.name not in COMMANDER_POSITIONS and new_position.name not in COMMANDER_POSITIONS:
						if position.name != new_position.name: continue
					
					# move the crewman
					position.crewman.current_position = new_position
					new_position.crewman = position.crewman
					new_position.crewman.unit = new_unit
					new_position.crewman.SetCEStatus()
					position.crewman = None
					break
			
			# go through remaining crewman and fit them in the new tank from lowest position upward
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				for new_position in reversed(new_unit.positions_list):
					if new_position.crewman is not None: continue
					
					# move the crewman
					position.crewman.current_position = new_position
					new_position.crewman = position.crewman
					new_position.crewman.unit = new_unit
					new_position.crewman.SetCEStatus()
					position.crewman = None
					break
			
			# some crewmen may not be able to be assigned to the new tank 
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				extra_crewmen.append(position.crewman)
			
			# set the player unit to the new unit
			self.player_unit = new_unit
			self.player_unit.ClearGunAmmo()
			self.AddJournal('We transferred to a new tank: ' + self.player_unit.unit_id)
			
		# some crewmen may have returned from the field hospital
		if returning_crewmen is not None:
			for crewman in returning_crewmen:
				extra_crewmen.append(crewman)
		
		# need to reassign 1+ crewmen
		if len(extra_crewmen) > 0:
			if len(extra_crewmen) == 1:
				text = ' crewman'
			else:
				text = ' crewmen'
			ShowNotification(str(len(extra_crewmen)) + text + ' must now be reassigned.')
		else:
			ShowNotification('You may now reassign crewmen if needed. Any reassigned crewmen will leave your crew forever.')
		campaign.ShowAssignPositionsMenu(unassigned_crewmen=extra_crewmen)
		
		# give player a chance to swap crewmen around
		ShowNotification('You can now assign your crew to new positions if required.')
		ShowSwapPositionMenu()
		
		# generate new crewmen to fill vacant positions if required
		self.DoCrewReplacementCheck(self.player_unit, skip_swapping=True)


	# check to see whether positions need to be filled in this unit
	def DoCrewReplacementCheck(self, unit, skip_swapping=False):
		
		# don't do for any unit other than the player unit right now
		if unit != self.player_unit: return
		
		# don't bother for dead units or if campaign is already over
		if not unit.alive or self.ended: return
		
		# see if any crewman needs to be put back into their usual position
		needs_replacing = False
		for position in unit.positions_list:
			if position.crewman is None:
				needs_replacing = True
				break
		
		if not needs_replacing: return
		
		if not skip_swapping:
			ShowMessage('One or more positions are empty; you may now move crew back into their usual position if needed. Any empty positions will receive a new crewman.')
			ShowSwapPositionMenu()
		
		# add new crewmen to fill in any empty positions
		# chance that they start above level 1
		avg_level = 0
		living_crew = 0
		for position in unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			living_crew += 1
			avg_level += position.crewman.level
		
		if avg_level > 1 and living_crew > 0:
			avg_level = int(avg_level / living_crew)
		
		for position in unit.positions_list:
			if position.crewman is None:
				position.crewman = Personnel(unit, unit.nation, position, avg_level=avg_level)
				text = 'A new crewman joins your crew in the ' + position.name + ' position.'
				ShowMessage(text, crewman=position.crewman)

	
	# display an animated screen for the start of a new combat day
	def ShowStartOfDay(self):
		
		libtcod.console_clear(con)
		
		# background gradient
		for y in range(WINDOW_HEIGHT):
			fg_col = libtcod.Color(int(255 * (y / WINDOW_HEIGHT)), int(170 * (y / WINDOW_HEIGHT)), 0)
			bg_col = libtcod.Color(int(255 * ((y + 0.5) / WINDOW_HEIGHT)), int(170 * ((y + 0.5) / WINDOW_HEIGHT)), 0)
			for x in range(0, WINDOW_WIDTH):
				libtcod.console_put_char_ex(con, x, y, 223, fg_col, bg_col)
		
		# text box
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_rect(con, 30, 15, 30, 20, True, libtcod.BKGND_SET)
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		DrawFrame(con, 30, 15, 30, 20)
		libtcod.console_set_default_foreground(con, libtcod.white)
		
		if 'refitting' in self.current_week:
			libtcod.console_print_ex(con, WINDOW_XM, 21, libtcod.BKGND_NONE, libtcod.CENTER,
				'Refitting')
			libtcod.console_print_ex(con, WINDOW_XM, 25, libtcod.BKGND_NONE, libtcod.CENTER,
				GetDateText(self.current_week['start_date']))
			libtcod.console_print_ex(con, WINDOW_XM, 27, libtcod.BKGND_NONE, libtcod.CENTER,
				'to')
			libtcod.console_print_ex(con, WINDOW_XM, 29, libtcod.BKGND_NONE, libtcod.CENTER,
				GetDateText(self.current_week['end_date']))
		else:
			
			y = 21
			for line in wrap(self.current_week['week_title'], 20):
				PrintExtended(con, WINDOW_XM, y, line, center=True)
				y += 1
			
			y += 2
			libtcod.console_print_ex(con, WINDOW_XM, y, libtcod.BKGND_NONE, libtcod.CENTER,
				GetDateText(self.today))
		
		if not DEBUG: PlaySound('morning_song')
		
		# fade in from black
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		for i in range(100, 0, -5):
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			libtcod.console_blit(darken_con, 0, 0, 0, 0, 0, window_x, window_y, 0.0, (i * 0.01))
			libtcod.console_flush()
			if not DEBUG:
				Wait(3, ignore_animations=True)
		if not DEBUG:
			Wait(115, ignore_animations=True)
	
	
	# determine and show results of a completed campaign day: injury results and level ups
	def ShowEndOfDay(self):
		
		MOON_PHASES = [
			'Full Moon', 'Waning Gibbous', 'Last Quarter', 'Waning Crescent',
			'New Moon', 'Waxing Crescent', 'First Quarter', 'Waxing Gibbous'
		]
		
		# create background console
		libtcod.console_clear(con)
		
		# starfield
		for i in range(18):
			x = libtcod.random_get_int(0, 0, WINDOW_WIDTH)
			y = libtcod.random_get_int(0, 0, 18)
			libtcod.console_put_char_ex(con, x, y, 250, libtcod.white, libtcod.black)
		
		# moon phase display
		x = MOON_PHASES.index(campaign_day.moon_phase) * 4
		libtcod.console_blit(LoadXP('moon_phases.xp'), x, 0, 3, 3, con, 7, 3)
		
		# gradient
		for y in range(19, WINDOW_HEIGHT):
			fg_col = libtcod.Color(int(180 * (y / WINDOW_HEIGHT)), 0, 0)
			bg_col = libtcod.Color(int(180 * ((y + 0.5) / WINDOW_HEIGHT)), 0, 0)
			for x in range(0, WINDOW_WIDTH):
				libtcod.console_put_char_ex(con, x, y, 223, fg_col, bg_col)

		# window
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_rect(con, 15, 6, 60, 50, True, libtcod.BKGND_SET)
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		DrawFrame(con, 15, 6, 60, 50)
		
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_rect(con, 39, 7, 12, 3, True, libtcod.BKGND_SET)
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
		libtcod.console_print_ex(con, WINDOW_XM, 8, libtcod.BKGND_NONE, libtcod.CENTER,
			'End of Day')
		
		# column titles
		libtcod.console_set_default_foreground(con, libtcod.red)
		libtcod.console_print(con, 45, 12, 'Fate')
		libtcod.console_set_default_foreground(con, libtcod.light_blue)
		libtcod.console_print(con, 60, 12, 'Level Up')
		
		y = 15
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 18, y, position.name)
			PrintExtended(con, 18, y+1, position.crewman.GetCrewmanName(first_initial=True), nation=position.crewman.nation)
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			for x in range(18, 72):
				libtcod.console_put_char(con, x, y+3, '.')
			y += 6
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		for y1 in range(13, y-3):
			libtcod.console_put_char(con, 38, y1, '.')
			libtcod.console_put_char(con, 56, y1, '.')
		
		PlaySound('evening_song')
		
		# fade in from black
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		for i in range(100, 0, -5):
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			libtcod.console_blit(darken_con, 0, 0, 0, 0, 0, 0, 0, 0.0, (i * 0.01))
			Wait(5, ignore_animations=True)
		
		# award exp for entire day, roll for crew injury resolution, apply results
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			position.crewman.AwardExp(campaign_day.day_vp)
			position.crewman.ResolveInjuries()
		
		# add one completed combat day
		self.combat_days += 1
		
		# add day VP to campaign total, update one-day max if higher
		self.player_vp += campaign_day.day_vp
		if campaign_day.day_vp > self.max_one_day_vp:
			self.max_one_day_vp = campaign_day.day_vp
		
		# add enemies destroyed to campaign total
		for k in campaign_day.enemies_destroyed:
			if k not in self.enemies_destroyed:
				self.enemies_destroyed[k] = campaign_day.enemies_destroyed[k]
			else:
				self.enemies_destroyed[k] += campaign_day.enemies_destroyed[k]
		
		# save now to fix these results in place
		SaveGame()
		
		# display results of crew injury resolution and level ups
		y = 15
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			
			# KIA or field hospital result
			if not position.crewman.alive:
				libtcod.console_set_default_foreground(con, libtcod.red)
				libtcod.console_print(con, 45, y, 'KIA')
			else:
				if position.crewman.field_hospital is None:
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
					libtcod.console_print_ex(con, 47, y, libtcod.BKGND_NONE, libtcod.CENTER,
						'Survived')
				else:
					libtcod.console_set_default_foreground(con, libtcod.dark_red)
					libtcod.console_print_ex(con, 47, y, libtcod.BKGND_NONE, libtcod.CENTER,
						'Field Hospital')
					(days_min, days_max) = position.crewman.field_hospital
					text = str(days_min) + '-' + str(days_max) + ' days'
					libtcod.console_print_ex(con, 47, y+1, libtcod.BKGND_NONE, libtcod.CENTER,
						text)
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			Wait(30, ignore_animations=True)
			
			if not position.crewman.alive:
				libtcod.console_set_default_foreground(con, libtcod.red)
				libtcod.console_print(con, 62, y, 'N/A')
			
			else:
			
				# reset fatigue points if any
				position.crewman.fatigue = BASE_FATIGUE
				
				# crewmen recover from any negative condition
				position.crewman.condition = 'Good Order'
				
				# grant random additional exp
				position.crewman.exp += libtcod.random_get_int(0, 0, 5)
				
				# check for level up
				levels_up = 0
				if position.crewman.level < CREWMAN_LEVEL_CAP:
					for level in range(position.crewman.level+1, CREWMAN_LEVEL_CAP + 1):
						if position.crewman.exp >= GetExpRequiredFor(level):
							levels_up += 1
						else:
							break
				
				if levels_up == 0:
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
					text = 'None'
				else:
					position.crewman.LevelUp(levels_up)
					libtcod.console_set_default_foreground(con, libtcod.white)
					text = '+' + str(levels_up)
				libtcod.console_print_ex(con, 64, y, libtcod.BKGND_NONE,
					libtcod.CENTER, text)
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			Wait(30, ignore_animations=True)
			y += 6
		
		# remove dead crewmen
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive:
				text = 'The body of your ' + position.name + ' is taken away.'
				ShowMessage(text)
				position.crewman = None
				continue
		
		# display KIA reports here
		for crewman in campaign_day.morgue:
			self.DisplayTransferOrKIA(crewman)
		campaign_day.morgue = []
		
		# move crewmen to field hospital where required
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if position.crewman.field_hospital is None: continue
			self.hospital.append(position.crewman)
			position.crewman.current_position = None
			position.crewman = None
		
		# sort current field hospital crewman
		self.hospital.sort(key=lambda x: x.field_hospital)
		
		# repair tank if required
		if self.player_unit.alive:
			self.player_unit.bogged = False
			self.player_unit.broken_down = False
			if self.player_unit.immobilized:
				self.player_unit.immobilized = False
				ShowMessage('Your vehicle has been repaired and is no longer immobilized.',
					good_news=True)
			if self.player_unit.has_radio:
				if self.player_unit.radio_destroyed:
					ShowMessage('Your radio is replaced.', good_news=True)
					self.player_unit.radio_destroyed = False
				elif self.player_unit.radio_damaged:
					ShowMessage('Your radio is repaired.', good_news=True)
					self.player_unit.radio_damaged = False
			for weapon in self.player_unit.weapon_list:
				if weapon.jammed:
					weapon.jammed = False
				if weapon.broken:
					weapon.broken = False
					ShowMessage('Your ' + weapon.GetStat('name') + ' is repaired.',
						good_news=True)
		
		# add to campaign day records
		self.records['Combat Days'] += 1
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 43, 53, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 38, 53, 'Tab')
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		libtcod.console_print(con, 45, 53, 'Continue')
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				exit_menu = True

	# advance the campaign to the next combat or refitting day
	# if hold_returning_crewmen is true, crewmen who would have normaly returned from the field hospital will
	# be held there instead
	def AdvanceToNextDay(self, hold_returning_crewmen=False):
		self.journal_scroll_line = 0
		
		# record what will soon be the previous day
		previous_day = self.today
		
		# set today to next day in calendar
		day_index = self.combat_calendar.index(self.today)
		self.today = self.combat_calendar[day_index+1]
		
		# re-calculate crew ages
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			position.crewman.CalculateAge()
		for crewman in self.hospital:
			crewman.CalculateAge()
		
		# check for reliability change
		if 'unreliable' in self.player_unit.stats and self.stats['region'] == 'North Africa' and self.player_unit.nation in ['Germany', 'Italy']:
			if self.today < '1941.10.01':
				self.player_unit.stats['unreliable'] = True
			else:
				unit_type = session.unit_types[self.player_unit.unit_id]
				if 'unreliable' not in unit_type:
					self.player_unit.stats['unreliable'] = False
		
		# check for new portrait variant
		self.UpdatePortraitVariant()
		
		# check for start of new week
		self.CheckForNewWeek()
		
		# calculate days elapsed
		(year1, month1, day1) = previous_day.split('.')
		(year2, month2, day2) = self.today.split('.')
		a = datetime(int(year1), int(month1), int(day1), 0, 0, 0)
		b = datetime(int(year2), int(month2), int(day2), 0, 0, 0)
		days_past = (b-a).days
		
		# check active crewmen for injuries healing
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			for (k, v) in position.crewman.injury.items():
				
				(status, severity, scarring) = v
				if status is None and severity is None: continue
				
				if severity == 'Light':
					chance = 25.0 * float(days_past)
				elif severity == 'Heavy':
					chance = 10.0 * float(days_past)
				elif severity == 'Serious':
					chance = 5.0 * float(days_past)
				else:
					continue
				
				roll = GetPercentileRoll()
				
				# healed
				if roll <= chance:
					
					if position.crewman.is_player_commander:
						text = 'Your '
					else:
						text = "Your crewman's "
					text += k + ' injury is now healed'
					
					# check for new scarring
					if position.crewman.ScarCheck(k):
						text += ' but has left scarring'
						scarring = True
					text += '.'
					
					# clear rest of wound
					status = None
					severity = None
					position.crewman.injury[k] = (status, severity, scarring)
					
					# display message
					if position.crewman.is_player_commander:
						ShowMessage(text, longer_pause=True)
					else:
						ShowMessage(text, crewman=position.crewman, longer_pause=True)
		
		# no crewmen in field hospital
		if len(self.hospital) == 0: return days_past
		
		# subtract days past from any crewmen in the field hospital, possible return to active service
		# iterate in reverse order since we may remove some crewmen from the list
		returning_crewmen = []
		for crewman in reversed(self.hospital):
			
			(min_days, max_days) = crewman.field_hospital
			
			# skip any crewmen that are eligible for release but are being held
			if hold_returning_crewmen and (min_days == 0 or max_days == 0):
				continue
			
			if min_days > 0:
				min_days -= days_past
				if min_days < 0:
					min_days = 0
			
			if max_days > 0:
				max_days -= days_past
				if max_days < 0:
					max_days = 0
			
			# crewman with 0 max days left are automatically returned to action
			# unless crewmen are being held because the commander is in the hospital too
			if max_days == 0:
				if not hold_returning_crewmen:
					crewman.field_hospital = None
					returning_crewmen.append(crewman)
					self.hospital.remove(crewman)
					crewman.ResolveOutstandingInjuries()
				else:
					crewman.field_hospital = (0,0)
				continue
			
			# possible return to action
			if min_days <= 0 or 'Fighting Spirit' in crewman.skills:
				
				# roll for return to action based on how many days elapsed
				roll = GetPercentileRoll()
				
				# fighting spirit check
				if min_days > 0:
					roll = round(roll * 1.3, 1)
				
				if roll <= days_past * FIELD_HOSPITAL_RELEASE_CHANCE:
					if hold_returning_crewmen:
						crewman.field_hospital = (0,0)
					else:
						crewman.field_hospital = None
						returning_crewmen.append(crewman)
						self.hospital.remove(crewman)
						crewman.ResolveOutstandingInjuries()
						
					# continue to next crewman
					continue
			
			# crewman remains in hospital, update days remaining
			crewman.field_hospital = (min_days, max_days)
		
		# sort remaining crewmen in hospital
		self.hospital.sort(key=lambda x: x.field_hospital)
		
		# give player option to assign returning crew
		if len(returning_crewmen) > 0:
			if len(returning_crewmen) == 1:
				text = 'One crewman has'
			else:
				text = 'Crewmen have'
			text += ' returned from their stay in the field hospital and may be re-assigned to your tank.'
			ShowNotification(text)
			self.ShowAssignPositionsMenu(unassigned_crewmen = returning_crewmen)
		
		return days_past


	# check for decoration awards, either at the start of the first full week of a new calendar month, or at the end of the campaign
	def CheckForDecorations(self):
		
		if 'decorations' not in session.nations[self.player_unit.nation]:
			print('ERROR: No decorations defined for nation: ' + self.player_unit.nation)
			return
		
		# if too few calendar days have passed and campaign is still in progress, skip checking
		if self.combat_days == 0:
			return
		if not self.ended and self.combat_days < 7:
			return
		
		# base chance is based on average combat day VP so far
		avg_daily_vp = int(self.player_vp / self.combat_days)
		
		chance = 0.0
		if avg_daily_vp <= 50:
			chance = 0.0
		elif avg_daily_vp <= 80:
			chance = 0.5
		elif avg_daily_vp <= 100:
			chance = 1.0
		elif avg_daily_vp <= 120:
			chance = 1.5
		else:
			chance = 2.0
		
		# might also have a chance based on the highest one-day VP since last check
		if self.max_one_day_vp > 0:
			if self.max_one_day_vp >= 180 and chance < 2.0:
				chance = 2.0
			elif self.max_one_day_vp >= 160 and chance < 1.5:
				chance = 1.5
			elif self.max_one_day_vp >= 140 and chance < 1.0:
				chance = 1.0
			elif 100 < self.max_one_day_vp <= 120 and chance < 0.5:
				chance = 0.5
			self.max_one_day_vp = 0
		
		# no chance right now
		if chance == 0.0: return
		
		# modify by campaign difficulty if any
		if 'difficulty' in campaign.stats:
			chance = chance + (0.1 * float(campaign.stats['difficulty']))
		
		# end of campaign has a higher chance
		if self.ended:
			chance = chance * 2.0
		
		chance = round(chance, 1)
		
		# find the player commander in the vehicle if any
		player_commander = None
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if position.crewman.is_player_commander:
				player_commander = position.crewman
				break
		
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			
			# apply crewman modifiers to chance
			crewman_chance = chance
			if position.crewman.is_player_commander:
				crewman_chance = crewman_chance * 2.0
			crewman_chance = round(crewman_chance, 1)
			
			for (k, v) in session.nations[self.player_unit.nation]['decorations'].items():
				
				# some decorations only awarded under special circumstances
				if k == 'x': continue
				
				# some awards only available after a certain date
				if v == "Knight's Cross with Oak Leaves" and campaign.today < '1940.07.01': continue
				
				# only possible to get the top-level award once
				if k == '0' and v in position.crewman.decorations: continue
				
				# crewman already has this award, 
				if v in position.crewman.decorations:
					
					# only possible to get all awards max five times
					if position.crewman.decorations[v] >= 5: continue
					
					# lower chance
					crewman_chance = round(crewman_chance * 0.25, 1)
				
				roll = GetPercentileRoll()
				decoration_chance = round(crewman_chance + (float(k) * crewman_chance), 1)
				
				if roll > decoration_chance: continue
				
				# if a crewman, only give award if the Player Commander already has 1+ of them
				if player_commander is not None:
					if v not in player_commander.decorations:
						continue
				
				# give the award
				if v in position.crewman.decorations:
					position.crewman.decorations[v] += 1
				else:
					position.crewman.decorations[v] = 1
				
				if position.crewman.is_player_commander:
					text = 'You have been awarded a decoration in recognition of your service: ' + v
					
					self.pc_decorations += 1
					
					# Steam stat increase
					if self.pc_decorations >= 3:
						session.ModifySteamStat('dec_three_or_more', 1)
					
					if k == '0':
						session.ModifySteamStat('dec_first_class', 1)
						if v == "Knight's Cross with Oak Leaves":
							session.ModifySteamStat('dec_knights', 1)
						elif v == 'Cross of Independence':
							session.ModifySteamStat('dec_independance', 1)
						elif v == 'Order of Lenin':
							session.ModifySteamStat('dec_lenin', 1)
						elif v == 'Victoria Cross':
							session.ModifySteamStat('dec_victoria', 1)
						elif v == 'Medaille Militaire':
							session.ModifySteamStat('dec_militaire', 1)
						elif v == 'Medal of Honor':
							session.ModifySteamStat('dec_congress', 1)
						elif v == 'Ordine Militare di Savoia':
							session.ModifySteamStat('dec_savoia', 1)
						elif v == 'Order of the Cross of Liberty':
							session.ModifySteamStat('dec_liberty', 1)
						elif v == 'Order of the Rising Sun Fifth Class':
							session.ModifySteamStat('dec_rising_sun', 1)
					else:
						session.ModifySteamStat('dec_2nd_class', 1)
					
				else:
					text = 'Your crewman has been awarded a decoration in recognition of their service: ' + v
				
				# also confers order of lenin if crewman doesn't have already
				if v == 'Hero of the Soviet Union' and 'Order of Lenin' not in position.crewman.decorations:
					text += ' as well as the Order of Lenin'
					position.crewman.decorations['Order of Lenin'] = 1
				
				ShowMessage(text, crewman=position.crewman, longer_pause=True, ignore_animations=True, good_news=True)
				
				campaign.AddJournal(position.crewman.GetCrewmanName() + ' was awarded a decoration: ' + v)
				
				break


	# display epilogue text to the screen if any
	def DisplayCampaignEpilogue(self):
		
		if 'epilogue_text' not in self.stats: return
		
		libtcod.console_blit(LoadXP('campaign_epilogue.xp'), 0, 0, 0, 0, con, 0, 0)
		libtcod.console_set_default_foreground(con, libtcod.black)
		
		libtcod.console_print_ex(con, 45, 4, libtcod.BKGND_NONE,
			libtcod.CENTER, campaign.stats['name'])
		libtcod.console_print_ex(con, 45, 6, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Campaign Epilogue')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		Wait(50, ignore_animations=True)
		
		y = 10
		lines = wrap(self.stats['epilogue_text'], 30)
		for line in lines:
			libtcod.console_print(con, 30, y, line)
			y += 2
			if y >= 49: break
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			Wait(30, ignore_animations=True)
		
		if gamepad is not None:
			DisplayButton(con, 44, 54, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 40, 54, 'Tab')
		libtcod.console_set_default_foreground(con, libtcod.black)
		libtcod.console_print(con, 46, 54, 'Continue')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# exit menu
			if key.vk == sdl2.SDLK_TAB or session.gamepad_input == 0:
				PlaySoundFor(None, 'menu_select')
				exit_menu = True
				continue
		
		
	
	# create a new campaign record and display it on the screen
	def SaveAndDisplayCampaignRecord(self):
		
		# try to find the commander
		crewman = None
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if position.crewman.is_player_commander:
				crewman = position.crewman
				break
		
		if crewman is None:
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if position.name in COMMANDER_POSITIONS:
					crewman = position.crewman
					break
		
		if crewman is None:
			print('ERROR: Unable to find commander for campaign record!')
			return
		
		# add a new entry to the campaign records file
		data = {}
		data['campaign_name'] = self.stats['name']
		data['commander_name'] = crewman.GetCrewmanName()
		data['nation'] = crewman.nation
		data['rank'] = session.nations[crewman.nation]['rank_names'][str(crewman.rank)]
		data['level'] = str(crewman.level)
		data['vp'] = self.player_vp
		data['decorations'] = crewman.decorations
		data['game_version'] = VERSION
		data['records'] = self.records
		if not crewman.alive:
			data['fate']  = 'KIA'
		else:
			data['fate']  = 'Survived'
		data['final_date'] = GetDateText(self.today)
		if self.vp_modifier == 0:
			text = '--'
		else:
			if self.vp_modifier > 0:
				text = '+'
			else:
				text = ''
			text += str(self.vp_modifier) + '%'
		data['vp_modifier'] = text
		session.UpdateCampaignRecords(data)
	
		# display the final report to the screen
		DisplayCampaignRecord(data, final_report=True)	
	
	
	# display a transfer order or a KIA report when a crewman leaves the tank
	def DisplayTransferOrKIA(self, crewman):
		
		if DEBUG: return
		
		# create a local copy of the current screen to re-draw when we're done
		temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
		libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
		
		# draw background to screen
		libtcod.console_blit(LoadXP('transfer_KIA.xp'), 0, 0, 0, 0, con, 0, 0)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		libtcod.console_flush()
		Wait(30, ignore_animations=True)
		
		libtcod.console_set_default_foreground(con, libtcod.black)
		
		# key info
		libtcod.console_print(con, 30, 12, 'Name:')
		PrintExtended(con, 39, 12, crewman.GetCrewmanName())
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		Wait(20, ignore_animations=True)
		
		libtcod.console_print(con, 30, 14, 'Age:')
		libtcod.console_print(con, 39, 14, str(crewman.age))
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		Wait(20, ignore_animations=True)
		
		libtcod.console_print(con, 30, 16, 'Rank:')
		libtcod.console_print(con, 39, 16, session.nations[crewman.nation]['rank_names'][str(crewman.rank)])
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		Wait(20, ignore_animations=True)
		
		# stats
		libtcod.console_print(con, 30, 18, 'Stats:')
		libtcod.console_put_char(con, 39, 18, chr(4))
		libtcod.console_put_char(con, 39, 19, chr(3))
		libtcod.console_put_char(con, 39, 20, chr(5))
		libtcod.console_put_char(con, 39, 21, chr(6))
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		Wait(20, ignore_animations=True)
		
		y = 18
		for t in CREW_STATS:
			libtcod.console_print(con, 41, y, t)
			libtcod.console_print_ex(con, 53, y, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(crewman.stats[t]))
			y += 1
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			Wait(10, ignore_animations=True)
		
		# skills
		libtcod.console_print(con, 30, 23, 'Skills:')
		y = 25
		for skill in crewman.skills:
			libtcod.console_print(con, 32, y, skill)
			y += 1
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			Wait(10, ignore_animations=True)
		
		# fate
		if crewman.alive:
			libtcod.console_print(con, 39, 50, 'TRANSFERRED')
		else:
			libtcod.console_set_default_foreground(con, libtcod.light_red)
			libtcod.console_print(con, 36, 50, 'KILLED IN ACTION')
		
		Wait(30, ignore_animations=True)
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 41, 55, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 38, 55, 'Tab')
		libtcod.console_set_default_foreground(con, libtcod.black)
		libtcod.console_print(con, 43, 55, 'Continue')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# get input from player
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				PlaySoundFor(None, 'menu_select')
				exit_menu = True
		
		# re-draw original screen
		libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
	
	#######################################
	#     Campaign Calendar Interface     #
	#######################################
	
	# update the day outline console, 24x22
	def UpdateDayOutlineCon(self):
		libtcod.console_clear(day_outline)
		
		# campaign name, max 2 lines
		libtcod.console_set_default_foreground(day_outline, PORTRAIT_BG_COL)
		lines = wrap(campaign.stats['name'], 20)
		y = 2
		for line in lines[:3]:
			libtcod.console_print_ex(day_outline, 12, y, libtcod.BKGND_NONE,
				libtcod.CENTER, line)
			y += 1
		
		# current date
		libtcod.console_set_default_foreground(day_outline, libtcod.white)
		libtcod.console_print_ex(day_outline, 12, 6, libtcod.BKGND_NONE, libtcod.CENTER,
			GetDateText(campaign.today))
		
		# days passed and days remaining
		libtcod.console_set_default_foreground(day_outline, libtcod.lighter_grey)
		libtcod.console_print_ex(day_outline, 12, 9, libtcod.BKGND_NONE, libtcod.CENTER,
			'Campaign Days:')
		
		libtcod.console_set_default_background(day_outline, libtcod.darker_yellow)
		libtcod.console_rect(day_outline, 0, 10, 24, 1, True, libtcod.BKGND_SET)
		days = campaign.combat_calendar.index(campaign.today) + 1
		total_days = len(campaign.combat_calendar)
		x = int(24.0 * float(days) / float(total_days))
		libtcod.console_set_default_background(day_outline, libtcod.dark_yellow)
		libtcod.console_rect(day_outline, 0, 10, x, 1, True, libtcod.BKGND_SET)
		libtcod.console_set_default_background(day_outline, libtcod.black)
		libtcod.console_set_default_foreground(day_outline, libtcod.black)
		text = str(days) + '/' + str(total_days)
		libtcod.console_print_ex(day_outline, 12, 10, libtcod.BKGND_NONE, libtcod.CENTER,
			text)
		
		if 'refitting' not in campaign.current_week:
			libtcod.console_set_default_foreground(day_outline, libtcod.light_grey)
			libtcod.console_print(day_outline, 1, 30, 'Start of Day:')
			libtcod.console_print(day_outline, 3, 31, 'End of Day:')
			
			libtcod.console_set_default_foreground(day_outline, libtcod.white)
			libtcod.console_print_ex(day_outline, 19, 30, libtcod.BKGND_NONE, libtcod.RIGHT,
				str(campaign_day.start_of_day['hour']).zfill(2) + ':' + str(campaign_day.start_of_day['minute']).zfill(2))
			libtcod.console_print_ex(day_outline, 19, 31, libtcod.BKGND_NONE, libtcod.RIGHT,
				str(campaign_day.end_of_day['hour']).zfill(2) + ':' + str(campaign_day.end_of_day['minute']).zfill(2))
	
		libtcod.console_set_default_foreground(day_outline, libtcod.white)
		libtcod.console_print(day_outline, 2, 34, 'Campaign VP: ' + str(campaign.player_vp))
	
	
	# update the command menu for the campaign calendar interface, 24x21
	def UpdateCalendarCmdCon(self):
		libtcod.console_clear(calendar_cmd_con)
		
		libtcod.console_set_default_foreground(calendar_cmd_con, TITLE_COL)
		libtcod.console_print(calendar_cmd_con, 6, 0, 'Command Menu')
		
		libtcod.console_set_default_foreground(calendar_cmd_con, libtcod.light_grey)
		if gamepad is not None:
			libtcod.console_print(calendar_cmd_con, 0, 19, 'Use indicated buttons')
		else:
			libtcod.console_print(calendar_cmd_con, 0, 19, 'Use highlighted keys')
		libtcod.console_print(calendar_cmd_con, 0, 20, 'to navigate interface')
		
		x = 0
		for (text, num, col) in CC_MENU_LIST:
			libtcod.console_set_default_background(calendar_cmd_con, col)
			libtcod.console_rect(calendar_cmd_con, x, 1, 2, 1, True, libtcod.BKGND_SET)
			
			# display menu activation key, use darker bg colour for visibility
			col2 = col * libtcod.light_grey
			libtcod.console_put_char_ex(calendar_cmd_con, x, 1, str(num), ACTION_KEY_COL, col2)
			x += 2
			
			# display menu text if active
			if self.active_calendar_menu == num:
				libtcod.console_rect(calendar_cmd_con, x, 1, len(text)+2, 1,
					True, libtcod.BKGND_SET)
				libtcod.console_set_default_foreground(calendar_cmd_con, libtcod.white)
				libtcod.console_print(calendar_cmd_con, x, 1, text)
				x += len(text) + 2
		
		# fill in rest of menu line with final colour
		libtcod.console_rect(calendar_cmd_con, x, 1, 25-x, 1, True, libtcod.BKGND_SET)
		libtcod.console_set_default_background(calendar_cmd_con, libtcod.black)
		
		# proceed - start day or continue to next day, summary of expected day
		if self.active_calendar_menu == 1:
			
			# display inputs
			if gamepad is not None:
				DisplayButton(calendar_cmd_con, 7, 10, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(calendar_cmd_con, ACTION_KEY_COL)
				libtcod.console_print(calendar_cmd_con, 2, 10, 'Tab')
			
			libtcod.console_set_default_foreground(calendar_cmd_con, libtcod.light_grey)
			# day has not yet started
			if not campaign_day.started:
				libtcod.console_print(calendar_cmd_con, 9, 10, 'Start Day')
			# day has finished
			else:
				libtcod.console_print(calendar_cmd_con, 9, 10, 'Next Day')
		
		# crew and tank menu
		elif self.active_calendar_menu == 2:
			
			# display inputs
			if gamepad is not None:
				DisplayButton(calendar_cmd_con, 4, 7, GAMEPADCHAR_DPAD_UD)
				DisplayButton(calendar_cmd_con, 4, 8, GAMEPADCHAR_Y)
				DisplayButton(calendar_cmd_con, 4, 9, GAMEPADCHAR_A)
				DisplayButton(calendar_cmd_con, 4, 10, GAMEPADCHAR_X)
			else:
			
				libtcod.console_set_default_foreground(calendar_cmd_con, ACTION_KEY_COL)
				libtcod.console_print(calendar_cmd_con, 2, 7, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(calendar_cmd_con, 2, 8, EnKey('p').upper())
				libtcod.console_print(calendar_cmd_con, 2, 9, EnKey('e').upper())
				libtcod.console_print(calendar_cmd_con, 2, 10, EnKey('t').upper())
			libtcod.console_set_default_foreground(calendar_cmd_con, libtcod.light_grey)
			libtcod.console_print(calendar_cmd_con, 6, 7, 'Select Position')
			libtcod.console_print(calendar_cmd_con, 6, 8, 'Swap Position')
			libtcod.console_print(calendar_cmd_con, 6, 9, 'Crewman Menu')
			libtcod.console_print(calendar_cmd_con, 6, 10, 'Vehicle Name')
		
		# journal menu
		elif self.active_calendar_menu == 3:
			
			# display inputs
			if gamepad is not None:
				DisplayButton(calendar_cmd_con, 7, 8, GAMEPADCHAR_DPAD_UD)
				DisplayButton(calendar_cmd_con, 7, 10, GAMEPADCHAR_DPAD_LR)
			else:
				libtcod.console_set_default_foreground(calendar_cmd_con, ACTION_KEY_COL)
				libtcod.console_print(calendar_cmd_con, 1, 8, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(calendar_cmd_con, 1, 9, 'PgUp/Dn')
				libtcod.console_print(calendar_cmd_con, 1, 10, EnKey('a').upper() + '/' + EnKey('d').upper())
			libtcod.console_set_default_foreground(calendar_cmd_con, libtcod.light_grey)
			libtcod.console_print(calendar_cmd_con, 9, 8, 'Scroll Log')
			libtcod.console_print(calendar_cmd_con, 9, 9, 'Scroll (Skip 5)')
			libtcod.console_print(calendar_cmd_con, 9, 10, 'Select Day')
		
		# field hospital
		elif self.active_calendar_menu == 4:
			
			# no possible commands
			if len(self.hospital) == 0: return
			
			# display inputs
			if gamepad is not None:
				DisplayButton(calendar_cmd_con, 5, 9, GAMEPADCHAR_DPAD_UD)
				DisplayButton(calendar_cmd_con, 5, 10, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(calendar_cmd_con, ACTION_KEY_COL)
				libtcod.console_print(calendar_cmd_con, 2, 9, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(calendar_cmd_con, 2, 10, EnKey('e').upper())
			libtcod.console_set_default_foreground(calendar_cmd_con, libtcod.light_grey)
			libtcod.console_print(calendar_cmd_con, 7, 9, 'Select Crewman')
			libtcod.console_print(calendar_cmd_con, 7, 10, 'Crewman Menu')
	
	
	# update the main calendar display panel 63x58
	def UpdateCCMainPanel(self, selected_position, selected_hospital_crewman):
		libtcod.console_clear(calendar_main_panel)
		
		# proceed menu - show summary of expected day
		if self.active_calendar_menu == 1:
			
			# sunrise/set background gradient
			for y in range(0, 58):
				if campaign_day.ended:
					fg_col = libtcod.Color(0, int(50 * (y / WINDOW_HEIGHT)), int(210 * (y / WINDOW_HEIGHT)))
					bg_col = libtcod.Color(0, int(50 * ((y + 0.5) / WINDOW_HEIGHT)), int(210 * ((y + 0.5) / WINDOW_HEIGHT)))
				else:
					fg_col = libtcod.Color(int(210 * (y / WINDOW_HEIGHT)), int(50 * (y / WINDOW_HEIGHT)), 0)
					bg_col = libtcod.Color(int(210 * ((y + 0.5) / WINDOW_HEIGHT)), int(50 * ((y + 0.5) / WINDOW_HEIGHT)), 0)
				for x in range(0, 63):
					libtcod.console_put_char_ex(calendar_main_panel, x, y, 223, fg_col, bg_col)
			
			# box and frame
			libtcod.console_set_default_background(calendar_main_panel, libtcod.black)
			libtcod.console_rect(calendar_main_panel, 15, 4, 36, 49, True, libtcod.BKGND_SET)
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.dark_yellow)
			DrawFrame(calendar_main_panel, 15, 4, 36, 49)
			
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.white)
			# refitting week
			if 'refitting' in campaign.current_week:
				libtcod.console_print_ex(calendar_main_panel, 33, 6, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Refitting')
			else:
			
				# week title - max 4 lines
				lines = wrap(campaign.current_week['week_title'], 20)
				y = 6
				for line in lines[:4]:
					PrintExtended(calendar_main_panel, 33, y, line, center=True)
					y += 1
			
			# week description
			if 'week_description' in campaign.current_week:
				libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_grey)
				lines = wrap(campaign.current_week['week_description'], 32)
				y = 11
				for line in lines[:18]:
					PrintExtended(calendar_main_panel, 17, y, line)
					y += 1
			
			# day mission type and description
			libtcod.console_set_default_background(calendar_main_panel, libtcod.darker_blue)
			libtcod.console_rect(calendar_main_panel, 16, 32, 34, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(calendar_main_panel, libtcod.black)
			
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_yellow)
			
			# day has finished
			if campaign_day.ended:
				libtcod.console_print_ex(calendar_main_panel, 33, 33, libtcod.BKGND_NONE,
					libtcod.CENTER,	'Day has Ended')
				return
			
			libtcod.console_print_ex(calendar_main_panel, 33, 33, libtcod.BKGND_NONE,
				libtcod.CENTER,	"Today's Mission")
			
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_blue)
			libtcod.console_print_ex(calendar_main_panel, 33, 37, libtcod.BKGND_NONE,
				libtcod.CENTER,	campaign_day.mission)
			
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_grey)
			lines = wrap(MISSION_DESC[campaign_day.mission], 32)
			y = 39
			for line in lines[:7]:
				libtcod.console_print(calendar_main_panel, 17, y, line)
				y+=1
			
			# player support
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.white)
			libtcod.console_print(calendar_main_panel, 20, 48, 'Air Support:')
			libtcod.console_print(calendar_main_panel, 20, 49, 'Artillery Support:')
			libtcod.console_print(calendar_main_panel, 20, 50, 'Unit Support:')
			
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_grey)
			if 'air_support_level' not in campaign.current_week:
				text = 'None'
			else:
				text = str(campaign.current_week['air_support_level'])
			libtcod.console_print(calendar_main_panel, 39, 48, text)
			if 'arty_support_level' not in campaign.current_week:
				text = 'None'
			else:
				text = str(campaign.current_week['arty_support_level'])
			libtcod.console_print(calendar_main_panel, 39, 49, text)
			if 'unit_support_level' not in campaign.current_week:
				text = 'None'
			else:
				text = str(campaign.current_week['unit_support_level'])
			libtcod.console_print(calendar_main_panel, 39, 50, text)
		
		# crew and tank menu
		elif self.active_calendar_menu == 2:
			
			# title
			libtcod.console_set_default_background(calendar_main_panel, libtcod.darker_blue)
			libtcod.console_rect(calendar_main_panel, 15, 1, 32, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(calendar_main_panel, libtcod.black)
			libtcod.console_set_default_foreground(calendar_main_panel, TITLE_COL)
			libtcod.console_print_ex(calendar_main_panel, 31, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Player Vehicle')
			
			# frame
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.dark_blue)
			DrawFrame(calendar_main_panel, 1, 8, 61, 45)
			
			# show list of crewmen
			libtcod.console_set_default_foreground(calendar_main_panel, TITLE_COL)
			libtcod.console_print(calendar_main_panel, 3, 10, 'Positions and Crewmen')
			
			
			DisplayCrew(campaign.player_unit, calendar_main_panel, 4, 13, selected_position, adv_highlight=True)
			
			# show info on player tank if still alive
			if campaign.player_unit.alive:
				DisplayUnitInfo(calendar_main_panel, 34, 13, campaign.player_unit.unit_id,
					campaign.player_unit, status=False, position_highlight=selected_position)
				
				# description of tank
				text = ''
				for t in campaign.player_unit.GetStat('description'):
					text += t
				lines = wrap(text, 27)
				y = 29
				libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_grey)
				for line in lines[:20]:
					libtcod.console_print(calendar_main_panel, 33, y, line)
					y+=1
			
			else:
				libtcod.console_print(calendar_main_panel, 41, 13, 'None')
		
		# journal menu
		elif self.active_calendar_menu == 3:
			
			# if no day selected yet, select the first one
			if self.active_journal_day is None:
				self.active_journal_day = self.today
			
			libtcod.console_set_default_background(calendar_main_panel, libtcod.darker_grey)
			libtcod.console_rect(calendar_main_panel, 15, 1, 32, 4, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(calendar_main_panel, libtcod.black)
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.white)
			libtcod.console_print_ex(calendar_main_panel, 31, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Combat Journal')
			libtcod.console_print_ex(calendar_main_panel, 31, 3, libtcod.BKGND_NONE,
				libtcod.CENTER, GetDateText(self.active_journal_day))
			
			# display journal entries from current scroll position
			n = 0
			y = 6
			for (time, text) in self.journal[self.active_journal_day]:
				
				# skip this entry if we're not yet at the current scroll location
				if self.journal_scroll_line > n:
					n += 1
					continue
				
				# stop displaying if we're near the bottom of the console
				if y >= 56:
					break
				
				libtcod.console_set_default_foreground(calendar_main_panel, libtcod.white)
				libtcod.console_print(calendar_main_panel, 2, y, time)
				
				libtcod.console_set_default_foreground(calendar_main_panel, libtcod.light_grey)
				lines = wrap(text, 44, subsequent_indent=' ')
				for line in lines:
					PrintExtended(calendar_main_panel, 11, y, line)
					y += 1
					if y >= 56: break
		
		# field hospital menu
		elif self.active_calendar_menu == 4:
			
			libtcod.console_set_default_background(calendar_main_panel, libtcod.Color(200, 0, 0))
			libtcod.console_rect(calendar_main_panel, 15, 1, 32, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(calendar_main_panel, libtcod.black)
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.white)
			libtcod.console_print_ex(calendar_main_panel, 31, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, '+ Field Hospital +')
			
			# load and display Field Hospital background image
			libtcod.console_blit(LoadXP('field_hospital.xp'), 0, 0, 0, 0, calendar_main_panel, 1, 5)
			
			libtcod.console_print(calendar_main_panel, 2, 14, 'Crewman')
			libtcod.console_print_ex(calendar_main_panel, 58, 14, libtcod.BKGND_NONE,
				libtcod.RIGHT, 'Days until Recovery')
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.grey)
			for x in range(2, 59):
				libtcod.console_put_char(calendar_main_panel, x, 15, '-')
			
			# list any crewmen currently in the field hospital
			y = 17
			
			if len(campaign.hospital) == 0:
				libtcod.console_set_default_foreground(calendar_main_panel, libtcod.grey)
				libtcod.console_print(calendar_main_panel, 2, y, 'No crewmen currently in hospital')
				return
			
			libtcod.console_set_default_foreground(calendar_main_panel, libtcod.lighter_grey)
			
			# determine which crewman in the list to start on
			if selected_hospital_crewman <= 4:
				n = 0
			else:
				n = selected_hospital_crewman - 4
			for crewman in campaign.hospital[n:]:
				
				if n == selected_hospital_crewman:
					libtcod.console_set_default_background(calendar_main_panel, libtcod.darker_blue)
					libtcod.console_rect(calendar_main_panel, 2, y, 57, 2, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(calendar_main_panel, libtcod.black)
				
				PrintExtended(calendar_main_panel, 2, y, crewman.GetCrewmanName(first_initial=True), nation=crewman.nation)
				
				(days_min, days_max) = crewman.field_hospital
				if days_min == 0:
					text = 'Maximum '
				else:
					text = str(days_min) + '-'
				text += str(days_max)
				libtcod.console_print_ex(calendar_main_panel, 50, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, text)
				y += 4
				n += 1
				
				if y >= 51:
					break
			
			
	# update the display of the campaign calendar interface
	def UpdateCCDisplay(self):
		libtcod.console_blit(calendar_bkg, 0, 0, 0, 0, con, 0, 0)		# background frame
		libtcod.console_blit(day_outline, 0, 0, 0, 0, con, 1, 1)		# summary of current day
		libtcod.console_blit(calendar_cmd_con, 0, 0, 0, 0, con, 1, 38)		# command menu
		libtcod.console_blit(calendar_main_panel, 0, 0, 0, 0, con, 26, 1)	# main panel
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
	
	# main campaign calendar loop
	def DoCampaignCalendarLoop(self):
		
		# consoles for campaign calendar interface
		global calendar_bkg, day_outline, calendar_cmd_con, calendar_main_panel
		global campaign_day
		
		# selected crew position and selected field hospital crewman if any
		selected_position = 0
		selected_hospital_crewman = 0
		
		# create consoles
		calendar_bkg = LoadXP('calendar_bkg.xp')
		day_outline = NewConsole(24, 36, libtcod.black, libtcod.white)
		calendar_cmd_con = NewConsole(24, 21, libtcod.black, libtcod.white)
		calendar_main_panel = NewConsole(63, 58, libtcod.black, libtcod.white)
		
		# generate consoles for the first time
		self.UpdateDayOutlineCon()
		self.UpdateCalendarCmdCon()
		self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
		
		if not (campaign_day.started and not campaign_day.ended) and scenario is None:
			self.UpdateCCDisplay()
		
		ShowTutorialSlide('campaign_calendar_base')
		
		exit_loop = False
		while not exit_loop:
			
			# if we've initiated a campaign day or are resuming a saved game with a
			# campaign day running, go into the campaign day loop now
			# also check to see if we're still in a scenario within the campaign day
			if campaign_day.started and (not campaign_day.ended or scenario is not None):
							
				campaign_day.DoCampaignDayLoop()
				
				# player was taken out
				if campaign.ended:
					
					# do some upkeep that otherwise would be handled by ShowEndOfDay
					campaign.combat_days += 1
					campaign.player_vp += campaign_day.day_vp
					if campaign_day.day_vp > campaign.max_one_day_vp:
						campaign.max_one_day_vp = campaign_day.day_vp
					
					self.LogDayRecords()
					self.DoEnd()
					exit_loop = True
					continue
				
				if session.exiting:
					exit_loop = True
					continue
				
				# do end-of-campaign day stuff
				self.ShowEndOfDay()
				
				ShowTutorialSlide('campaign_calendar_return')
				
				# redraw the screen
				self.UpdateDayOutlineCon()
				self.UpdateCalendarCmdCon()
				self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
				self.UpdateCCDisplay()
				
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# open game menus
			if key.vk in [sdl2.SDLK_ESCAPE, sdl2.SDLK_F1, sdl2.SDLK_F2, sdl2.SDLK_F3, sdl2.SDLK_F4] or session.gamepad_input == 6:
				if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 6:
					session.active_menu_tab = 0
				elif key.vk == sdl2.SDLK_F1:
					session.active_menu_tab = 1
				elif key.vk == sdl2.SDLK_F2:
					session.active_menu_tab = 2
				elif key.vk == sdl2.SDLK_F3:
					session.active_menu_tab = 3
				elif key.vk == sdl2.SDLK_F4:
					session.active_menu_tab = 4
				ShowGameMenu()
				if session.exiting:
					exit_loop = True
					continue
			
			# debug menu
			elif key.vk == sdl2.SDLK_F10:
				if not DEBUG: continue
				ShowDebugMenu()
				continue
			
			# mapped key commands
			key_char = DeKey(chr(key.c).lower())
			
			# switch active menu tab
			if key_char in ['1', '2', '3', '4'] or session.gamepad_input in [9, 10]:
				if session.gamepad_input in [9, 10]:
					if session.gamepad_input == 9:
						self.active_calendar_menu -= 1
					else:
						self.active_calendar_menu += 1
					if self.active_calendar_menu < 1:
						self.active_calendar_menu = 4
					elif self.active_calendar_menu > 4:
						self.active_calendar_menu = 1
				elif self.active_calendar_menu != int(key_char):
					self.active_calendar_menu = int(key_char)
					
				PlaySoundFor(None, 'tab_select')
				self.UpdateCalendarCmdCon()
				self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
				self.UpdateCCDisplay()
				if self.active_calendar_menu == '2':
					ShowTutorialSlide('campaign_calendar_crew_menu')
				elif self.active_calendar_menu == '3':
					ShowTutorialSlide('campaign_calendar_journal_menu')
				elif self.active_calendar_menu == '4':
					ShowTutorialSlide('campaign_calendar_hospital_menu')
					
				continue
			
			# proceed menu active
			if self.active_calendar_menu == 1:
				
				# debug only - skip day
				if chr(key.c).lower() == 's':
					if not DEBUG: continue
					campaign_day.started = True
					campaign_day.ended = True
					self.UpdateCalendarCmdCon()
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
				
				# start or proceed to next day
				if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				
					# start new day
					if not campaign_day.ended:
						campaign_day.AmmoReloadMenu()	# allow player to load ammo
						campaign_day.started = True
						continue			# continue in loop to go into campaign day layer
				
					# proceed to next day or end campaign
					else:
						
						# add day records to campaign log
						self.LogDayRecords()
						
						# if Player Commander is active and the player character has just been sent
						# to the field hospital, need to jump ahead in calendar, choose a new tank, generate a new crew
						commander_in_a_coma = False
						for crewman in self.hospital:
							if not crewman.is_player_commander: continue
							commander_in_a_coma = True
							
							# calculate length of player commander field hospital stay
							# returns True if Commander stays in hospital past end of campaign calendar
							if self.CommanderInAComa(crewman):
								
								# check for completion of a full-length campaign
								if len(campaign.combat_calendar) >= int(campaign.stats['combat_days']):
									session.ModifySteamStat('completed_campaigns', 1)
								
								# save the game here as a backup
								SaveGame()
								self.DoEnd()
								exit_loop = True
							break
						
						if exit_loop:
							continue
						
						# only do the following if commander did not just return from field hospital
						if not commander_in_a_coma:
							
							# check for end of campaign as a result of reaching end of calendar
							day_index = self.combat_calendar.index(self.today)
							if day_index == len(campaign.combat_calendar) - 1:
								
								# check for completion of a full-length campaign
								if len(campaign.combat_calendar) >= int(campaign.stats['combat_days']):
									session.ModifySteamStat('completed_campaigns', 1)
								
								self.DoEnd()
								exit_loop = True
								continue
							
							# if player tank was destroyed or took a KO hit, allow player to choose a new one
							if not self.player_unit.alive or self.player_unit.ko_hit:
								if self.player_unit.alive and self.player_unit.ko_hit:
									ShowNotification('Your current vehicle took a penetrating hit and must be repaired.')
								self.ReplacePlayerTank()
							
							# start new calendar day, may also trigger return of field hospital crewmen
							self.AdvanceToNextDay()
							
							# check for crew replacement if there remain any empty positions on the tank
							campaign.DoCrewReplacementCheck(self.player_unit)
						
						# handle refitting weeks here
						if 'refitting' in self.current_week:
							
							# if Player Commander just returned from the field hospital, no need
							# to give them another tank selection, can skip the refitting day
							if not commander_in_a_coma:
							
								self.ShowStartOfDay()
								
								# allow player to change tanks
								if ShowNotification('Your battlegroup has been recalled for refitting. Do you want to request a new tank?', confirm=True):
									self.ReplacePlayerTank()
							
							# proceed to next combat day
							self.AdvanceToNextDay()
							
							# make sure we don't end up on another refit day
							while 'refitting' in self.current_week:
								
								# ended up with 2+ refitting days at the end of the calendar
								# this should not happen, but if it did, it would cause a crash
								if self.combat_calendar.index(self.today) == len(campaign.combat_calendar) - 1:
									
									# check for completion of a full-length campaign
									if len(campaign.combat_calendar) >= int(campaign.stats['combat_days']):
										session.ModifySteamStat('completed_campaigns', 1)
									
									self.DoEnd()
									exit_loop = True
									break
								
								self.AdvanceToNextDay()
						
						if exit_loop: continue
						
						# create a new campaign day
						campaign_day = CampaignDay()
						for (hx, hy) in CAMPAIGN_DAY_HEXES:
							campaign_day.map_hexes[(hx,hy)].CalcCaptureVP()
						campaign_day.GenerateRoads()
						campaign_day.GenerateRivers()
						
						self.ShowStartOfDay()
						campaign.AddJournal('Start of day')
						
						# set currently displayed journal entry to the new day
						self.active_journal_day = self.today
						
						# make sure currently selected position is still ok for a new tank
						if selected_position >= len(campaign.player_unit.positions_list):
							selected_position = 0
						
						# make sure currently selected field hospital crewman is still ok
						if selected_hospital_crewman >= len(campaign.hospital):
							selected_hospital_crewman = 0
						
						SaveGame()
						BackupGame()
						
						# redraw the screen
						self.UpdateDayOutlineCon()
						self.UpdateCalendarCmdCon()
						self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
						self.UpdateCCDisplay()
						continue
					
			# crew and tank menu
			elif self.active_calendar_menu == 2:
				
				# select different crew position
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
						selected_position -= 1
						if selected_position < 0:
							selected_position = len(campaign.player_unit.positions_list) - 1
					else:
						selected_position += 1
						if selected_position == len(campaign.player_unit.positions_list):
							selected_position = 0
					PlaySoundFor(None, 'menu_select')
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
				
				# open crewman menu
				elif key_char == 'e' or session.gamepad_input == 0:
					crewman = campaign.player_unit.positions_list[selected_position].crewman
					if crewman is None: continue
					crewman.ShowCrewmanMenu()
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
				
				# open swap position menu
				elif key_char == 'p' or session.gamepad_input == 3:
					ShowSwapPositionMenu()
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
				
				# set tank nickname
				elif key_char == 't' or session.gamepad_input == 2:
					player_tank_name = ShowTextInputMenu('Enter a nickname for your vehicle', '', MAX_TANK_NAME_LENGTH, [])
					if player_tank_name != '':
						campaign.player_unit.unit_name = player_tank_name
					self.UpdateCalendarCmdCon()
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
			
			# journal menu
			elif self.active_calendar_menu == 3:
				
				# cycle active journal day displayed
				if key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
					
					keys_list = list(self.journal.keys())
					i = keys_list.index(self.active_journal_day)
					
					if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
						if i == 0:
							i = len(keys_list) - 1
						else:
							i -= 1
					else:
						if i == len(keys_list) - 1:
							i = 0
						else:
							i += 1
					self.active_journal_day = keys_list[i]
					self.journal_scroll_line = 0
					PlaySoundFor(None, 'menu_select')
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
				
				# shift display scroll
				elif key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
					
					if key.vk in [sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN]:
						i = 5
					else:
						i = 1
					
					if key_char == 's' or key.vk in [sdl2.SDLK_DOWN, sdl2.SDLK_PAGEDOWN] or session.gamepad_input == 12:
						self.journal_scroll_line += i
					else:
						self.journal_scroll_line -= i
					
					if self.journal_scroll_line < 0:
						self.journal_scroll_line = 0
					else:
						journal_length = len(self.journal[self.active_journal_day])
						if self.journal_scroll_line > journal_length - 1:
							self.journal_scroll_line = journal_length - 1
						
					PlaySoundFor(None, 'menu_select')
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
			
			# field hospital menu active
			elif self.active_calendar_menu == 4:
				
				# no possible commands
				if len(self.hospital) == 0: continue
				
				# select different crewman
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
						selected_hospital_crewman -= 1
						if selected_hospital_crewman < 0:
							selected_hospital_crewman = len(campaign.hospital) - 1
				
					else:
						selected_hospital_crewman += 1
						if selected_hospital_crewman == len(campaign.hospital):
							selected_hospital_crewman = 0
					PlaySoundFor(None, 'menu_select')
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue
				
				# open crewman menu
				elif key_char == 'e' or session.gamepad_input == 0:
					crewman = campaign.hospital[selected_hospital_crewman]
					crewman.ShowCrewmanMenu()
					self.UpdateCCMainPanel(selected_position, selected_hospital_crewman)
					self.UpdateCCDisplay()
					continue




# Zone Hex: a hex on the campaign day map, each representing a map of scenario hexes
class CDMapHex:
	def __init__(self, hx, hy, mission):
		self.hx = hx
		self.hy = hy
		self.terrain_type = ''		# placeholder for terrain type in this zone
		self.console_seed = libtcod.random_get_int(0, 1, 128)	# seed for console image generation
		self.objective = None		# pointer to objective info if any
		self.landmines = False		# landmines are present in this zone
		
		# road links in 6 directions: false if dirt road, true if stone
		self.road_links = [None,None,None,None,None,None]
		self.rivers = []		# river edges
		self.bridges = []		# bridged edges
		
		self.controlled_by = 1		# which player side currently controls this zone
		self.enemy_strength = 0		# current enemy strength in zone
		self.known_to_player = False	# player knows enemy strength in this zone
		self.enemy_units = []		# list of enemy unit_ids that are present in this zone
		self.enemy_desc = ''		# text description of expected enemy presence here
		
		# VP value if captured by player
		self.vp_value = 0
		
		# Pathfinding stuff
		self.parent = None
		self.g = 0
		self.h = 0
		self.f = 0
		
		self.Reset()
	
	
	# reset zone stats
	def Reset(self):
		self.coordinate = (chr(self.hy+65) + str(5 + int(self.hx - (self.hy - self.hy&1) / 2)))


	# (re)generate enemy strength level, and list of enemy units in this zone
	# if unit_list is not none, use that instead of generating one
	def GenerateStrengthAndUnits(self, mission, skip_strength=False, unit_list=None, player_attacked=False):
		
		self.known_to_player = False
		self.enemy_desc = ''
		
		# impassable zone
		if 'impassible' in CD_TERRAIN_TYPES[self.terrain_type]:
			self.enemy_strength = 0
			self.enemy_units = []
			return
		
		if not player_attacked:
		
			# friendly-controlled zone, not North Africa, and not Rattenkrieg
			if self.controlled_by == 0 and campaign.stats['region'] != 'North Africa' and mission not in RATTENKRIEG_MISSIONS:
				self.enemy_strength = 0
				self.enemy_units = []
				return
			
			# friendly-controlled zone, North Africa, and a place of interest
			if campaign.stats['region'] == 'North Africa' and self.controlled_by == 0:
				if self.terrain_type in DESERT_CAPTURE_ZONES:
					self.enemy_strength = 0
					self.enemy_units = []
					return
		
		if not skip_strength:
			if 'average_resistance' in campaign.current_week:
				avg_strength = campaign.current_week['average_resistance']
			else:
				avg_strength = 5
			
			# apply mission modifiers
			if mission == 'Patrol':
				avg_strength -= 2
			elif mission == 'Advance':
				avg_strength -= 1
			elif mission in ['Battle', 'Major Battle', 'Fighting Withdrawal']:
				avg_strength += 2
			elif mission == 'Counterattack':
				avg_strength += 1
			elif mission in RATTENKRIEG_MISSIONS:
				avg_strength += 3
			
			if avg_strength < 1:
				avg_strength = 1
			
			# roll for actual strength level
			self.enemy_strength = 0
			for i in range(2):
				self.enemy_strength += libtcod.random_get_int(0, 0, avg_strength)
			self.enemy_strength = int(self.enemy_strength / 2) + 1
			
			# modify for forces operating behind friendly lines
			if self.controlled_by == 0:
				self.enemy_strength = int(self.enemy_strength / 3)
			
			# modify for Rescue objective
			if self.objective is not None:
				if self.objective['type'] == 'Rescue':
					self.enemy_strength += 3
			
			if self.enemy_strength < 1:
				self.enemy_strength = 1
			elif self.enemy_strength > 10:
				self.enemy_strength = 10
		
		# clear any existing units in the list
		self.enemy_units = []
		
		# unit list has been provided
		if unit_list is not None:
			for (nation, unit_id) in unit_list:
				self.enemy_units.append((nation, unit_id))
		
		else:
		
			# choose a default enemy nation for these units; other nations are possible
			# but most will be this one
			
			# if enemy_nation_odds is set in a campaign, roll on those
			if 'enemy_nation_odds' in campaign.stats:
				roll = GetPercentileRoll()
				for k, value in campaign.stats['enemy_nation_odds'].items():
					
					# special: if enemy nation is not available this week, don't choose it
					if k not in campaign.current_week['enemy_nations']: continue
					
					if float(value) <= roll:
						default_enemy_nation = k
						break
					roll -= float(value)
				else:
					default_enemy_nation = choice(campaign.current_week['enemy_nations'])
			else:
				default_enemy_nation = choice(campaign.current_week['enemy_nations'])
			
			num_units = 4
			for i in range(3):
				roll = libtcod.random_get_int(0, 0, 5) + libtcod.random_get_int(0, 0, 5)
				if roll >= self.enemy_strength:
					num_units -= 1
			
			# Major Battle day mission
			if mission == 'Major Battle':
				if libtcod.random_get_int(0, 1, 6) <= 4:
					num_units += 1
				else:
					num_units += 2
			
			# convoy attack
			if self.objective is not None:
				if self.objective['type'] == 'Convoy Attack':
					if num_units < 2: num_units = 2
			
			enemy_units_remaining = num_units
			enemy_unit_classes = list(campaign.stats['enemy_unit_class_odds'].items())
			enemy_class_dict = {}
			
			# in case we need to copy unit type from adjacent zones
			zone_list = []
			if player_attacked:
				for direction in range(6):
					(hx, hy) = campaign_day.GetAdjacentCDHex(self.hx, self.hy, direction)
					if (hx, hy) not in campaign_day.map_hexes: continue
					if len(campaign_day.map_hexes[(hx, hy)].enemy_units) == 0: continue
					zone_list.append((hx, hy))
			
			while enemy_units_remaining > 0:
				
				# if player_attacked, possible to copy a unit from an adjacent enemy zone
				if player_attacked and len(zone_list) > 0:
					if GetPercentileRoll() <= 80.0:
						(hx, hy) = choice(zone_list)
						(enemy_nation, selected_unit_id) = choice(campaign_day.map_hexes[(hx, hy)].enemy_units)
						self.enemy_units.append((enemy_nation, selected_unit_id))
						enemy_units_remaining -= 1
						continue
				
				# choose enemy nation for this unit - not always the default
				if GetPercentileRoll() <= 85.0:
					enemy_nation = default_enemy_nation
				else:
					enemy_nation = choice(campaign.current_week['enemy_nations'])
				
				unit_type_list = campaign.stats['enemy_unit_list'][enemy_nation]
				
				# choose a random unit class
				unit_class = None
				while unit_class is None:
					k, value = choice(enemy_unit_classes)
					
					# not possible
					if value == 0: continue
					
					# Rattenkrieg: some unit classes less likely to be encountered
					if mission in RATTENKRIEG_MISSIONS:
						if k in ['Medium Tank', 'Heavy Tank', 'Tank Destroyer', 'Artillery Gun', 'Armoured Train Car']:
							if GetPercentileRoll() > 25.0:
								continue
					
					# one class less likely if player is being attacked
					if player_attacked:
						if k == 'Armoured Train Car':
							if GetPercentileRoll() <= 85.0:
								continue
					
					# some enemy classes less likely in certain zone types
					if self.terrain_type in ['Fortification'] and not player_attacked:
						if k in ['Tankette', 'Light Tank', 'Medium Tank', 'Armoured Car', 'Truck', 'Heavy Tank', 'Armoured Train Car', 'Cavalry Squad', 'Motorcycle Team', 'APC']:
							if GetPercentileRoll() > 15.0:
								continue
					
					# Rescue objective: some classes much less likely
					if self.objective is not None:
						if self.objective['type'] == 'Rescue':
							if k in ['Armoured Car', 'Truck', 'APC', 'Infantry Squad', 'Anti-Aircraft Gun', 'Motorcycle Team', 'Support Weapon Team']:
								if GetPercentileRoll() <= 98.0:
									continue
					
					chance = int(value)
					
					# check for nation-specific odds modifiers
					if 'nation_class_mods' in campaign.stats:
						if enemy_nation in campaign.stats['nation_class_mods']:
							if k in campaign.stats['nation_class_mods'][enemy_nation]:
								chance += int(campaign.stats['nation_class_mods'][enemy_nation][k])
					
					if libtcod.random_get_int(0, 1, 100) <= chance:
						unit_class = k
				
				# if unit type for this class has already been set, use that one instead
				# default nation only
				if enemy_nation == default_enemy_nation and unit_class in enemy_class_dict:
					self.enemy_units.append((enemy_nation, enemy_class_dict[unit_class]))
					enemy_units_remaining -= 1
					continue
				
				# choose a random unit type within this class
				type_list = []
				for unit_id in unit_type_list:
					# unrecognized unit id - maybe not added yet?
					if unit_id not in session.unit_types: continue
					# not the right class
					if session.unit_types[unit_id]['class'] != unit_class: continue
					
					type_list.append(unit_id)
				
				# no unit types of the required class found
				if len(type_list) == 0:
					continue
				
				# select unit type: run through shuffled list and roll against rarity if any
				shuffle(type_list)
				
				selected_unit_id = None
				for unit_id in type_list:
					
					# immobile units cannot spawn as part of an attack
					if player_attacked and 'immobile' in session.unit_types[unit_id]:
						continue
					
					# campaign option active
					if campaign.options['ahistorical']:
						selected_unit_id = unit_id
						break
					
					# check for campaign-defined dates for this unit type
					# and skip if too early to spawn
					if 'enemy_unit_dates' in campaign.stats:
						if unit_id in campaign.stats['enemy_unit_dates']:
							if campaign.stats['enemy_unit_dates'][unit_id] > campaign.today:
								continue
								
					# roll for rarity
					if campaign.DoRarityCheck(unit_id,nation=enemy_nation):
						selected_unit_id = unit_id
						break
				
				# no suitable unit type found, roll for a new unit class
				if selected_unit_id is None: continue
				
				# add this unit_id to the class dict
				# unless it's relatively rare
				if selected_unit_id not in ['Flame Thrower Team', 'Combat Engineer Team']:
					enemy_class_dict[unit_class] = selected_unit_id
				
				# add the final selected unit id to list
				self.enemy_units.append((enemy_nation, selected_unit_id))
				
				# if enemy was a Support Weapon Team, chance that an extra unit will be spawned as well
				if unit_class == 'Support Weapon Team':
					if libtcod.random_get_int(0, 1, 6) == 1:
						continue
				enemy_units_remaining -= 1
		
		
		# if this zone is a Convoy Attack objective, also spawn enemy trucks
		if self.objective is not None:
			if self.objective['type'] == 'Convoy Attack':
				
				num_units = choice([3, 4, 5, 6])
				enemy_nation = choice(campaign.current_week['enemy_nations'])
				unit_type_list = campaign.stats['enemy_unit_list'][enemy_nation]
				
				type_list = []
				for unit_id in unit_type_list:
					if unit_id not in session.unit_types: continue
					if session.unit_types[unit_id]['class'] != 'Truck': continue
					if session.unit_types[unit_id]['size_class'] == 'Very Small': continue
					type_list.append(unit_id)
				
				for i in range(num_units):
					
					# try to select a truck from the list of enemy units, otherwise add the default truck unit
					if 'Truck' not in campaign.stats['enemy_unit_class_odds'].keys():
						self.enemy_units.append((enemy_nation, '3-ton Truck'))
						continue
					
					if len(type_list) == 0:
						self.enemy_units.append((enemy_nation, '3-ton Truck'))
						continue
					
					# run through shuffled list and roll against rarity if any
					shuffle(type_list)
					selected_unit_id = None
					for unit_id in type_list:
						if campaign.options['ahistorical']:
							selected_unit_id = unit_id
							break
						if 'enemy_unit_dates' in campaign.stats:
							if unit_id in campaign.stats['enemy_unit_dates']:
								if campaign.stats['enemy_unit_dates'][unit_id] > campaign.today:
									continue
						if campaign.DoRarityCheck(unit_id, nation=enemy_nation):
							selected_unit_id = unit_id
							break
					
					# could not roll a suitable unit id
					if selected_unit_id is None:
						self.enemy_units.append((enemy_nation, '3-ton Truck'))
						continue
					
					self.enemy_units.append((enemy_nation, selected_unit_id))
		
		
		# run through list of enemy units and generate a text description of enemy presence
		# may be inaccurate, but will be accurate if player saw these units before
		SIMILAR_CLASSES = [
			["Infantry Squad", "Support Weapon Team", "Cavalry Squad"],
			["Tankette", "Light Tank", "Armoured Car", "Truck", "APC", "Self-Propelled AA Gun"],
			["Medium Tank", "Assault Gun", "Tank Destroyer", "Heavy Tank"],
			["Anti-Tank Gun", "Artillery Gun", "Anti-Aircraft Gun"]
		]
		
		possible_classes = list(campaign.stats['enemy_unit_class_odds'])
		
		chance1 = 3.0
		chance2 = 25.0
		chance3 = 10.0
		if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Expert Recon'):
			chance1 = 0.5
			chance2 = 7.0
			chance3 = 2.5
		elif campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Improved Recon'):
			chance1 = 1.5
			chance2 = 15.0
			chance3 = 5.0
		
		class_dict = {}
		
		for (nation, unit_id) in self.enemy_units:
			unit_class = session.unit_types[unit_id]['class']
			
			# chance that this one will not be included
			if len(self.enemy_desc) > 0:
				if GetPercentileRoll() <= chance1 and unit_list is None:
					continue
			
			# chance that an incorrect report will be generated
			if GetPercentileRoll() <= chance2 and unit_list is None:
				for class_list in SIMILAR_CLASSES:
					if unit_class not in class_list: continue
					for wrong_class in sample(class_list, len(class_list)):
						if wrong_class == unit_class: continue
						if wrong_class not in possible_classes: continue
						unit_class = wrong_class
						break
			
			if unit_class not in class_dict:
				class_dict[unit_class] = 1
			else:
				class_dict[unit_class] += 1
		
		# chance that an extra one will be included
		if GetPercentileRoll() <= chance3 and unit_list is None:
			unit_class = choice(list(campaign.stats['enemy_unit_class_odds']))
			if unit_class not in class_dict:
				class_dict[unit_class] = 1
			else:
				class_dict[unit_class] += 1
		
		# build the text description from the dictionary
		for k, v in class_dict.items():
			if len(self.enemy_desc) > 0:
				self.enemy_desc += ', '
			if v == 1:
				self.enemy_desc += k
			else:
				self.enemy_desc += str(v) + 'x ' + k
	
	
	# (re)calculate VP value if captured by player
	def CalcCaptureVP(self):
		
		(hx, hy) = campaign_day.player_unit_location
		
		if campaign.stats['region'] == 'North Africa':
			if self.terrain_type not in DESERT_CAPTURE_ZONES:
				self.vp_value = 0
				return
		
		if campaign_day.mission == 'Spearhead':
			self.vp_value = int(((9 - self.hy) + (campaign_day.maps_traversed * 8)) / SPEARHEAD_HEXROW_LEVELS)
			if self.vp_value < 1:
				self.vp_value = 1
		
		elif campaign_day.mission == 'Hold the Line':
			if self.hy < 2:
				self.vp_value = 0
			else:
				self.vp_value = 3
		
		elif campaign_day.rattenkrieg:
			if self.terrain_type in ['Factories', 'Town Square', 'Train Station']:
				self.vp_value = 6
			else:
				self.vp_value = 3
		
		else:
		
			if self.terrain_type in ['Forest', 'Hills', 'Villages', 'Fortification']:
				self.vp_value = 2
			else:
				self.vp_value = 1
			
			if campaign_day.mission == 'Advance':
				self.vp_value += 1
			elif campaign_day.mission == 'Fighting Withdrawal':
				self.vp_value = self.vp_value * 2
			elif campaign_day.mission == 'Major Battle':
				self.vp_value += 1
			
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Defensive Strategy'):
				self.vp_value -= 1
			elif campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Exceptional Efforts'):
				self.vp_value -= 1
		
		if campaign.stats['region'] == 'North Africa':
			self.vp_value = self.vp_value * DESERT_CAPTURE_MULTIPLIER
		
		if self.vp_value < 0:
			self.vp_value = 0
	
	
	# reset pathfinding info for this zone
	def ClearPathInfo(self):
		self.parent = None
		self.g = 0
		self.h = 0
		self.f = 0
		
	
	# set control of this hex by the given player
	# also handles successful defense of a friendly zone
	# if no_vp is True, player doesn't receive VP or credit for this capture
	def CaptureMe(self, player_num, no_vp=False, no_generation=False):
		
		# day has already started and player has defended a friendly zone
		if campaign_day is not None and self.controlled_by == 0 and player_num == 0:
			campaign.AwardVP(int(ceil(self.vp_value / 3)))
			
			# don't otherwise award vp
			no_vp = True
		
		# friendly zone captured by enemy
		elif player_num == 1:
			self.controlled_by = player_num
			# generate new strength level and enemy unit list
			if not no_generation:
				self.GenerateStrengthAndUnits(campaign_day.mission)
			return
		
		# captured by friendlies
		
		# check for VP reward
		if not no_vp:
			if self.controlled_by == 1:
				campaign_day.AddRecord('Zones Captured', 1)
				campaign.AddJournal('Captured an enemy-held zone')
				# award zone VP value and record steam stat
				campaign.AwardVP(self.vp_value)
				session.ModifySteamStat('zones_captured', 1)
		
		# set new zone control
		self.controlled_by = player_num
		
		# if it's the start of a campaign, set known to player
		if campaign_day is None:
			self.known_to_player = True
			return
		
		# if player is not present, set known to player
		(hx, hy) = campaign_day.player_unit_location
		if not (self.hx == hx and self.hy == hy):
			self.known_to_player = True
		
		# if north africa, some terrain types can still have enemies present
		if campaign.stats['region'] == 'North Africa' and self.terrain_type not in DESERT_CAPTURE_ZONES:
				
			# reduce enemy strength instead
			self.enemy_strength -= libtcod.random_get_int(0, 1, 5)
			if self.enemy_strength < 0:
				self.enemy_strength = 0
			
			# no strength remaining, clear any remaining units
			if self.enemy_strength == 0:
				self.enemy_units = []
			
			else:
			
				# regenerate unit classes present
				self.GenerateStrengthAndUnits(campaign_day.mission, skip_strength=True)
			
		else:
		
			# clear any enemy units
			self.enemy_strength = 0
			self.enemy_units = []
		
		# check for objective completion or clearing
		if self.objective is not None:
			if self.objective['type'] in ['Recon', 'Capture']:
				campaign_day.UpdateCDControlCon()
				campaign_day.UpdateCDDisplay()
				ShowTutorialSlide('campaign_day_completed_objective')
				ShowMessage('You completed an objective!', good_news=True)
				campaign.AwardVP(self.objective['vp_reward'])
				self.objective = None
			
			elif self.objective['type'] == 'Rescue':
				campaign_day.UpdateCDControlCon()
				campaign_day.UpdateCDDisplay()
				# if player is present, gets VP reward
				if self.hx == hx and self.hy == hy:	
					ShowTutorialSlide('campaign_day_completed_objective')
					ShowMessage('You completed an objective!', good_news=True)
					campaign.AwardVP(self.objective['vp_reward'])
				else:
					ShowMessage('Rescue objective was completed by allied forces.')
				self.objective = None
			
			elif self.objective['type'] == 'Convoy Attack':
				campaign_day.UpdateCDControlCon()
				campaign_day.UpdateCDDisplay()
				if self.hx == hx and self.hy == hy:
					ShowTutorialSlide('campaign_day_completed_objective')
					ShowMessage('The enemy convoy has been destroyed or scattered.', good_news=True)
					campaign.AwardVP(self.objective['vp_reward'])
				else:
					ShowMessage('The enemy convoy was attacked by allied forces.')
				self.objective = None
		
		# check for Steam achievement
		if not no_vp and self.hx == hx and self.hy == hy is not None:
			if campaign.player_squad_max > 0 and len(campaign_day.player_squad) == 0:
				session.ModifySteamStat('sole_capture', 1)


	# reveal any enemy activity in this and adjacent friendly-controlled zones
	def RevealAdjacentZones(self):
		for direction in range(6):
			(hx, hy) = campaign_day.GetAdjacentCDHex(self.hx, self.hy, direction)
			if (hx, hy) not in campaign_day.map_hexes: continue
			if campaign_day.map_hexes[(hx, hy)].controlled_by == 1: continue
			campaign_day.map_hexes[(hx, hy)].known_to_player = True
		campaign_day.UpdateCDUnitCon()
		campaign_day.UpdateCDHexInfoCon()
		campaign_day.UpdateCDDisplay()



# Campaign Day: represents one calendar day in a campaign with a 5x7 map of terrain hexes, each of
# which may spawn a Scenario
class CampaignDay:
	def __init__(self):
		
		# campaign day records
		self.records = {}
		for text in RECORD_LIST:
			self.records[text] = 0
		self.enemies_destroyed = {}
		self.message_log = []
		
		self.morgue = []				# holding place for crewmen who were KIA during the day
		
		self.started = False				# day is in progress
		self.ended = False				# day has been completed
		self.maps_traversed = 0				# how many map scrolls have taken place
		self.mission = ''
		self.rattenkrieg = False			# urban combat mode, set by day mission
		self.GenerateMission()				# roll for type of mission today
		
		self.coastal_map = None
		if 'coastal_chance' in campaign.current_week and self.mission != 'Amphibious Assault':
			chance = float(campaign.current_week['coastal_chance'])
			if GetPercentileRoll() <= chance:
				self.coastal_map = choice(['left', 'right'])
		
		# check for setting a new world location
		if 'location' in campaign.current_week:
			location = campaign.current_week['location'].split(',')
			campaign.latitude = float(location[0])
			campaign.longitude = float(location[1])
		
		self.day_vp = 0					# counter of how many VP were earned today
		self.travel_time_spent = False
		
		# current weather conditions, will be set by GenerateWeather
		self.weather = {
			'Cloud Cover' : '',
			'Precipitation' : '',
			'Fog' : 0,
			'Ground' : '',
			'Temperature' : '',
			'Wind' : 0,
			'Storm' : False
		}
		self.weather_update_clock = 0		# number of in-game minutes until next weather update
		self.GenerateWeather()
		
		self.fate_points = 3			# number of fate points protecting the player today
		if campaign.options['fate_points'] is False:
			self.fate_points = 0
		
		# set max number of units in player squad
		if campaign.options['go_it_alone']:
			campaign.player_squad_max = 0
		else:
			player_unit_class = campaign.player_unit.GetStat('class')
			if player_unit_class == 'Tankette':
				campaign.player_squad_max = 4
			elif player_unit_class in ['Light Tank', 'Tank Destroyer', 'Armoured Car']:
				campaign.player_squad_max = 3
			elif player_unit_class in ['Medium Tank', 'Assault Gun', 'Heavy Tank']:
				campaign.player_squad_max = 2
			else:
				campaign.player_squad_max = 1
		
		# spawn player squad units
		self.player_squad = []
		self.SpawnPlayerSquad()
		
		# smoke grenades and smoke mortar ammo
		self.smoke_grenades = 6
		self.smoke_mortar_rounds = 0
		if campaign.player_unit.GetStat('smoke_mortar') is not None:
			self.smoke_mortar_rounds = 10
		
		# calculate start and end of daylight, current moon phase
		self.CalcDaylight()
		
		# combat day length in minutes
		hours = self.end_of_day['hour'] - self.day_clock['hour']
		minutes = self.end_of_day['minute'] - self.day_clock['minute']
		if minutes < 0:
			hours -= 1
			minutes += 60
		self.day_length = minutes + (hours * 60)
		
		# current odds of a random event being triggered
		self.random_event_chance = BASE_CD_RANDOM_EVENT_CHANCE
		
		# generate campaign day map and terrain, placeholder for objectives
		self.map_hexes = {}
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			self.map_hexes[(hx,hy)] = CDMapHex(hx, hy, self.mission)
		self.GenerateCDMapTerrain()
		
		if self.mission in ['Fighting Withdrawal', 'Urban Defense']:
			for (hx, hy) in CAMPAIGN_DAY_HEXES:	
				self.map_hexes[(hx, hy)].controlled_by = 0
		
		elif self.mission == 'Hold the Line':
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				if hy < 3:
					self.map_hexes[(hx, hy)].controlled_by = 1
				else:
					self.map_hexes[(hx, hy)].controlled_by = 0		
		
		elif self.mission == 'Counterattack':
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				self.map_hexes[(hx, hy)].controlled_by = 0
			hy = 0
			hx1 = 0 - floor(hy / 2)
			for hx in range(hx1, hx1 + 5):
				if (hx, hy) not in self.map_hexes: continue
				self.map_hexes[(hx, hy)].controlled_by = 1
		
		elif self.mission in ['Battle', 'Major Battle']:
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				self.map_hexes[(hx, hy)].controlled_by = 1
			for hy in range(6, 9):
				hx1 = 0 - floor(hy / 2)
				for hx in range(hx1, hx1 + 5):
					if (hx, hy) not in self.map_hexes: continue
					self.map_hexes[(hx, hy)].controlled_by = 0
		
		# impassable hexes are held by nobody
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx, hy)].terrain_type]:
				self.map_hexes[(hx, hy)].controlled_by = 2
		
		
		
		# dictionary of screen display locations on the display console
		self.cd_map_index = {}
		
		# list of screen display locations that contain a bridge
		self.cd_map_bridge_locations = []
		
		# set up initial player location
		if self.mission in ['Fighting Withdrawal', 'Urban Defense']:
			hx, hy = 2, 0				# top center of map
		elif self.mission in ['Battle', 'Major Battle', 'Amphibious Assault']:
			hx, hy = -1, 6				# lower center of map
		elif self.mission == 'Counterattack':
			hx, hy = 2, 1				# second row of map
		elif self.mission == 'Hold the Line':
			hx, hy = 0, 4
		else:
			hx, hy = -2, 8				# bottom center of map
		
		# Amphibious Assault starts the player in a water hex, it's ok!
		if self.mission == 'Amphibious Assault':
			self.player_unit_location = (hx, hy)
			self.coastal_map = True
		else:
			# place player as close as possible to target location
			for hx_mod in [0, -1, 1, -2, 2, -3, 3, 4, -4]:
				# target is off map
				if (hx+hx_mod, hy) not in self.map_hexes: continue
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx+hx_mod, hy)].terrain_type]:
					continue
				self.player_unit_location = (hx+hx_mod, hy)
				break
			else:
				print('ERROR: Could not place player in a clear map hex')
				self.player_unit_location = (hx, hy)
		
		self.GenerateObjectives()
		self.GenerateMinefields()
		
		self.active_menu = 3				# number of currently active command menu
		self.selected_position = 0			# selected crew position in crew command menu tab
		self.selected_direction = None			# select direction for support, travel, etc.
		self.abandoned_tank = False			# set to true if player abandoned their tank that day
		self.player_withdrew = False			# set to true if player withdrew from the battle
		self.delayed_resupply = False			# player was attacked while waiting for resupply
		
		self.gun_list = []				# guns on player tank
		self.selected_gun = None			# selected gun for Resupply menu
		
		self.BuildPlayerGunList()
		
		self.air_support_level = 0.0
		if 'air_support_level' in campaign.current_week:
			self.air_support_level = campaign.current_week['air_support_level']
		
		self.arty_support_level = 0.0
		self.no_naval_arty_support = False
		if 'arty_support_level' in campaign.current_week:
			self.arty_support_level = campaign.current_week['arty_support_level']
		
			# check for naval support only in a non-coastal map
			if self.coastal_map is None:
				unit_list = list(campaign.stats['player_arty_support'])
				for unit_id in reversed(unit_list):
					if session.unit_types[unit_id]['class'] == 'Ship':
						unit_list.remove(unit_id)
				if len(unit_list) == 0:
					self.arty_support_level = 0.0
					self.no_naval_arty_support = True
		
		self.unit_support_level = 0.0
		if 'unit_support_level' in campaign.current_week:
			self.unit_support_level = campaign.current_week['unit_support_level']
		
		self.advancing_fire = False			# player is using advancing fire when moving
		self.air_support_request = False		# " requesting air support upon move
		self.arty_support_request = False		# " arty "
		self.unit_support_request = False		# " unit "
		self.unit_support_type = None			# to be selected upon moving into a enemy-held zone
		
		self.encounter_mod = 0.0			# increases every time player caputures an area without resistance
		
		# set player location to player control if required
		self.map_hexes[self.player_unit_location].CaptureMe(0, no_vp=True)
		
		# set enemy strength and units present in each zone
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			self.map_hexes[(hx,hy)].GenerateStrengthAndUnits(self.mission)
		
		# set up initial player comms status
		self.bg_radio_comms = False
		self.hq_radio_comms = False
		if campaign.player_unit.has_radio:
			self.bg_radio_comms = True
			self.hq_radio_comms = True
		
		# animation object; keeps track of active animations on the animation console
		self.animation = {
			'rain_active' : False,
			'rain_drops' : [],
			'snow_active' : False,
			'snowflakes' : [],
			'hex_highlight' : False
		}
	
	
	# do various upkeep and resolution things after a scenario has finished
	# returns true if the DoCampaignDay loop should be broken
	def DoPostScenario(self):
		global scenario
		
		# check for player crew recovery
		self.DoCrewRecoveryCheck(campaign.player_unit)
		
		# check for player character death - ends campaign
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if position.crewman.is_player_commander and not position.crewman.alive:
				scenario = None
				self.ended = True
				campaign.ended = True
				campaign.player_oob = True
				break
		if campaign.ended: return True
		
		# tank was immobilized, abandoned, or destroyed: campaign day is over
		if campaign.player_unit.immobilized or not campaign.player_unit.alive:
			
			if campaign.player_unit.immobilized and campaign.player_unit.alive:
				ShowMessage('Your vehicle is rescued by a recovery team, and ' +
					'your crew transported back to friendly lines.',
					longer_pause=True)
				if GetPercentileRoll() <= 5.0:
					ShowCrewChatter('rescued', None)
			scenario = None
			DisplayTimeInfo(time_con)
			self.UpdateCDPlayerUnitCon()
			self.UpdateCDDisplay()
			libtcod.console_flush()
			self.CheckHoldObjectives()
			self.ended = True
			return True
		
		# check for automatic unbog, weapon unjamming, ready-rack refilling, radio repair
		guns_to_refill = [] # list of gun-type weapons belonging to the player and all squad members.
		if campaign.player_unit.bogged:
			ShowMessage('You free your vehicle from being bogged down.', good_news=True)
			campaign.player_unit.bogged = False
		if campaign.player_unit.broken_down:
			ShowMessage('Your vehicle is repaired and mobile again.', good_news=True)
			campaign.player_unit.broken_down = False
		for weapon in campaign.player_unit.weapon_list:
			if weapon.jammed:
				weapon.jammed = False
				ShowMessage(weapon.GetStat('name') + ' is no longer jammed.', good_news=True)
			# For the player, ready rack refill is a preference setting. Squadmates always top up.
			if weapon.GetStat('type') == 'Gun' and config.getboolean('ArmCom2', 'ready_rack_refill'):
				guns_to_refill.append(weapon)
		if campaign.player_unit.radio_damaged:
			ShowMessage('Your radio is repaired.', good_news=True)
			campaign.player_unit.radio_damaged = False
		
		# reset squadmates' orders
		# also check for broken down squadmates rejoining the squad
		for unit in scenario.units:
			if unit.owning_player == 1: continue
			if not unit.alive: continue
			if unit.ai is None: continue
			unit.ai.leader_command = campaign.battlegroup_command
			
			if not unit.left_squad: continue
			unit.broken_down = False
			unit.left_squad = False
			campaign.player_unit.squad.append(unit)
			ShowMessage(self.unit_id + ' is now repaired and rejoins your squad.', good_news=True)

		for unit in campaign.player_unit.squad:
			for weapon in unit.weapon_list:
				if weapon.GetStat('type') == 'Gun':
					guns_to_refill.append(weapon)

		for gun in guns_to_refill:
			# If there's no player-saved rack, use the default.
			if len(gun.default_ready_rack) == 0:
				target_rack = gun.GenerateDefaultLoadout(True)[1]
			else:
				target_rack = gun.default_ready_rack
			gun.DumpReadyRackToStores()
			gun.FillReadyRackFromStores(target_rack)

		# check for fatigue accumulation
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			position.crewman.DoFatigueCheck()
		
		# update comms status
		self.UpdateCommsStatus()
		self.UpdateCDCampaignCon()
		
		# player has withdrawn from the battle
		if self.player_withdrew:
			
			DisplayTimeInfo(time_con)
			
			# reset flags and get the player's current location
			self.player_withdrew = False			
			(hx1, hy1) = self.player_unit_location
			map_hex = self.map_hexes[(hx1,hy1)]
			
			# capture this zone for the enemy (if possible) but don't generate new enemy units, will do that in next step
			map_hex.CaptureMe(1, no_generation=True)
			
			# any rescue attack objective in this zone is failed
			clear_enemy_units = False
			if map_hex.objective is not None:
				if map_hex.objective['type'] == 'Rescue':
					ShowMessage('You failed in your rescue objective.', good_news=False)
					map_hex.objective = None
					clear_enemy_units = True
					self.UpdateCDControlCon()
				
				elif map_hex.objective['type'] == 'Convoy Attack':
					
					# convoy attack objective failed if any trucks remain
					convoy_destroyed = True
					for unit in scenario.units:
						if not unit.alive: continue
						if not unit.owning_player == 1: continue
						if unit.GetStat('class') == 'Truck':
							convoy_destroyed = False
							break
					
					if not convoy_destroyed:
						ShowMessage('The convoy moves on.', good_news=False)
						map_hex.objective = None
						clear_enemy_units = True
						self.UpdateCDControlCon()
			
			# if possible, set enemy units based on surviving enemies from scenario
			unit_list = []
			if not clear_enemy_units:
				for unit in scenario.units:
					if not unit.alive: continue
					if not unit.owning_player == 1: continue
					if unit.immobilized or unit.routed: continue
					unit_list.append((unit.nation, unit.unit_id))
			
			# clear the scenario object now
			scenario = None
			
			if len(unit_list) > 0:
				map_hex.GenerateStrengthAndUnits(self.mission, unit_list=unit_list)
			else:
				map_hex.GenerateStrengthAndUnits(self.mission)
			
			# check for end of day after withdrawing from a battle
			self.CheckForEndOfDay()
			if self.ended:
				DisplayTimeInfo(time_con)
				self.UpdateCDPlayerUnitCon()
				self.UpdateCDDisplay()
				libtcod.console_flush()
				self.CheckHoldObjectives()
				self.DisplayCampaignDaySummary()
				return True
			
			# move player to adjacent friendly or neutral zone
			# during fighting withdrawl missions, player cannot withdraw to a zone in a higher hexrow
			hex_list = []
			
			for direction in range(6):
				(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
				if (hx2, hy2) not in self.map_hexes: continue
				if self.map_hexes[(hx2,hy2)].controlled_by == 1: continue
				if self.mission == 'Fighting Withdrawal' and hy2 < hy1: continue
				if self.CheckTravel(hx1,hy1,hx2,hy2) != '':
					continue
				hex_list.append((hx2, hy2))
			
			# adjacent friendly or neutral hex found
			if len(hex_list) > 0:
				self.ReconOrTravel(False, self.map_hexes[choice(hex_list)], withdrawing=True)
				self.CheckForCDMapShift()
			
			# no adjacent friendly hex, must move into an enemy-held zone
			else:
				for direction in range(6):
					(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
					if (hx2, hy2) not in self.map_hexes: continue
					if self.map_hexes[(hx2,hy2)].controlled_by == 0: continue
					if self.mission == 'Fighting Withdrawal' and hy2 < hy1: continue
					if self.CheckTravel(hx1,hy1,hx2,hy2) != '':
						continue
					hex_list.append((hx2, hy2))
				
				# something went really wrong!
				if len(hex_list) == 0:
					ShowMessage('ERROR: Could not find an adjacent hex zone!')
				else:
					ShowMessage('You are forced to move into unfriendly territory.',
						good_news=False)
					self.ReconOrTravel(False, self.map_hexes[choice(hex_list)], withdrawing=True)
					self.UpdateCDCampaignCon()
					self.UpdateCDControlCon()
					self.UpdateCDUnitCon()
					self.UpdateCDCommandCon()
					self.UpdateCDHexInfoCon()
					self.UpdateCDDisplay()
		
		# if Fighting Withdrawal mission, we capture but then need to withdraw from this zone
		# but player gets bonus VP
		elif self.mission == 'Fighting Withdrawal':
			
			(hx1, hy1) = self.player_unit_location
			
			# temporarily capture the zone for the player
			self.map_hexes[(hx1, hy1)].CaptureMe(0)
			
			# clear the scenario object
			scenario = None
			
			# check for end of day
			self.CheckForEndOfDay()
			if self.ended:
				DisplayTimeInfo(time_con)
				self.UpdateCDPlayerUnitCon()
				self.UpdateCDDisplay()
				libtcod.console_flush()
				return True
			
			# move player to any adjacent zone in a lower hexrow
			hex_list = []
			
			for direction in range(6):
				(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
				if hy2 <= hy1: continue
				if (hx2, hy2) not in self.map_hexes: continue
				if self.CheckTravel(hx1,hy1,hx2,hy2) != '':
					continue
				hex_list.append((hx2, hy2))
			
			if len(hex_list) == 0:
				for direction in range(6):
					(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
					if hy2 < hy1: continue
					if (hx2, hy2) not in self.map_hexes: continue
					if self.CheckTravel(hx1,hy1,hx2,hy2) != '':
						continue
					hex_list.append((hx2, hy2))
			
			if len(hex_list) == 0:
				if self.player_withdrew:
					text = 'You have nowhere to which you can withdraw! You must stand and fight.'
				else:
					text = 'You have won the encounter, but have nowhere to which you can withdraw! You must stand and fight.'
				ShowMessage(text, longer_pause=True, good_news=False)
			else:
				# choose a random target zone
				(hx2,hy2) = choice(hex_list)
				
				# dead driver, cannot travel
				if 'Driver' in self.CheckTravel(hx1,hy1,hx2,hy2):
					if self.player_withdrew:
						text = "You have nobody in a Driver's position to continue your withdrawal."
					else:
						text = "You have won the encounter, but have nobody in a Driver's position to continue your withdrawal."
					ShowMessage(text, longer_pause=True)
				else:
					if not self.player_withdrew:
						ShowMessage('You have won the encounter, but must continue to withdraw in the face of the overwhelming enemy attack.',
							longer_pause=True)
					self.ReconOrTravel(False, self.map_hexes[choice(hex_list)], withdrawing=True)
					
					# enemy captures the player's previous zone
					self.map_hexes[(hx1, hy1)].CaptureMe(1)
			
			# if player's resupply request was interrupted, resupply now
			if self.delayed_resupply:
				ShowMessage('Your requested resupply finally arrives.', good_news=True)
				self.PlayerResupply()
				self.UpdateCDDisplay()
			
			self.player_withdrew = False
			self.UpdateCDCampaignCon()
			self.UpdateCDControlCon()
			self.UpdateCDUnitCon()
			self.UpdateCDCommandCon()
			self.UpdateCDHexInfoCon()
			self.UpdateCDDisplay()
		
		# otherwise, the player won the scenario and captures the zone
		else:
			# clear the scenario object
			scenario = None
			
			# capture the zone for the player
			self.map_hexes[self.player_unit_location].CaptureMe(0)
			self.map_hexes[self.player_unit_location].known_to_player = True
		
			# if player's resupply request was interrupted, resupply now
			if self.delayed_resupply:
				ShowMessage('Your requested resupply finally arrives.', good_news=True)
				self.PlayerResupply()
				self.UpdateCDDisplay()
		
		# reset any delayed resupply flag and continue
		self.delayed_resupply = False
		DisplayTimeInfo(time_con)
		self.UpdateCDPlayerUnitCon()
		self.UpdateCDDisplay()
		libtcod.console_flush()
		
		self.CheckHoldObjectives()
		
		# another battle was triggered
		if scenario is not None:
			self.BuildPlayerGunList()
			SaveGame()
			return True
		
		# another battle was not triggered
		self.CheckForEndOfDay()
		if not self.ended:
			self.CheckForRandomEvent()
			self.CheckForZoneCapture('capture_zone')
			# recalculate capture VPs
			for (hx, hy), cd_hex in self.map_hexes.items():
				cd_hex.CalcCaptureVP()
			self.CheckForCDMapShift()
		
		self.BuildPlayerGunList()
		SaveGame()
		
		return False
		
	
	# determine current comms status
	def UpdateCommsStatus(self):
		if not campaign.player_unit.has_radio: return
		
		lost_comms = False
		
		# active scenario
		if scenario is not None:
			if scenario.player_unit.radio_damaged or scenario.player_unit.radio_destroyed:
				lost_comms = True
		else:
			if campaign.player_unit.radio_damaged or campaign.player_unit.radio_destroyed:
				lost_comms = True
		
		if lost_comms:
			if self.bg_radio_comms:
				ShowNotification('You have lost radio communication with your battlegroup.')
			if self.hq_radio_comms:
				ShowNotification('You have lost radio communication with your headquarters.')
			self.bg_radio_comms = False
			self.hq_radio_comms = False
			return
		
		roll = GetPercentileRoll()
		if self.weather['Storm']:
			roll += 5.0
		
		if roll <= 99.8:
			if not self.bg_radio_comms:
				ShowNotification('You have re-established radio communication with your battlegroup.')
			self.bg_radio_comms = True
		else:
			if self.bg_radio_comms:
				ShowNotification('You have lost radio communication with your battlegroup. You will automatically attempt to re-acquire it.')
			self.bg_radio_comms = False
		
		roll = GetPercentileRoll()
		if self.weather['Storm']:
			roll += 5.0
		
		if roll <= 97.0:
			if not self.hq_radio_comms:
				ShowNotification('You have re-established radio communication with your headquarters.')
			self.hq_radio_comms = True
		else:
			if self.hq_radio_comms:
				ShowNotification('You have lost radio communication with your headquarters. You will automatically attempt to re-acquire it.')
			self.hq_radio_comms = False
	
	
	# show unit support type selection menu
	def GetUnitSupportChoice(self, map_hex):
		
		# draw the menu console
		def DrawMenuCon(list_scroll):
			
			libtcod.console_clear(game_menu_con)
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			DrawFrame(game_menu_con, 0, 0, 84, 54)
			
			# menu title
			libtcod.console_set_default_background(game_menu_con, libtcod.darker_blue)
			libtcod.console_rect(game_menu_con, 1, 1, 82, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(game_menu_con, libtcod.black)
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print(game_menu_con, 29, 2, 'Select Unit Support Type')
			
			# left column: expected enemies here if any, list of available support categories
			libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_blue)
			libtcod.console_print(game_menu_con, 5, 17, 'Unit Support Type')
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			y = 20
			for text in choice_list:
				if text == selection:
					libtcod.console_set_default_background(game_menu_con, libtcod.darker_blue)
					libtcod.console_rect(game_menu_con, 5, y-1, 20, 3, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(game_menu_con, libtcod.black)
				libtcod.console_print(game_menu_con, 5, y, text)
				y += 3
			
			# display estimated enemies here if any
			if map_hex is not None:
				if map_hex.controlled_by == 1 and map_hex.enemy_strength > 0 and map_hex.known_to_player:
					libtcod.console_set_default_foreground(game_menu_con, libtcod.light_red)
					libtcod.console_print(game_menu_con, 5, 7, 'Estimated Enemies:')
					libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
					lines = wrap(map_hex.enemy_desc, 20)
					y = 9
					for line in lines:
						libtcod.console_print(game_menu_con, 5, y, line)
						y += 1
			
			# details on units in selected type
			libtcod.console_set_default_background(game_menu_con, libtcod.darkest_blue)
			libtcod.console_rect(game_menu_con, 32, 7, 50, 1, False, libtcod.BKGND_SET)
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_blue)
			libtcod.console_print(game_menu_con, 32, 7, 'Possible Support Units')
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			y = 11
			i = 0
			libtcod.console_set_default_background(game_menu_con, libtcod.darkest_grey)
			
			for unit_id in campaign.stats['player_unit_support'][selection]:
				
				# skip if we've scrolled the list past this item
				if i < list_scroll:
					
					# show arrows indicating that there's more above
					if i == 0:
						libtcod.console_put_char_ex(game_menu_con, 34, 10, 24, libtcod.light_grey, libtcod.black)
						libtcod.console_put_char_ex(game_menu_con, 36, 10, 24, libtcod.light_grey, libtcod.black)
						libtcod.console_put_char_ex(game_menu_con, 38, 10, 24, libtcod.light_grey, libtcod.black)
					i+=1
					continue
				
				# stop before we overwrite the commands, show arrows indicating that there's more below
				if y >= 44:
					libtcod.console_put_char_ex(game_menu_con, 34, y, 25, libtcod.light_grey, libtcod.black)
					libtcod.console_put_char_ex(game_menu_con, 36, y, 25, libtcod.light_grey, libtcod.black)
					libtcod.console_put_char_ex(game_menu_con, 38, y, 25, libtcod.light_grey, libtcod.black)
					break
				
				if (y % 2) == 0:
					libtcod.console_rect(game_menu_con, 32, y, 50, 1, False, libtcod.BKGND_SET)
				
				libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
				libtcod.console_print(game_menu_con, 32, y, unit_id)
				libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
				libtcod.console_print(game_menu_con, 59, y, session.unit_types[unit_id]['class'])
				y += 1
				i+=1
			libtcod.console_set_default_background(game_menu_con, libtcod.black)
			
			# display command inputs
			if gamepad is not None:
				DisplayButton(game_menu_con, 36, 46, GAMEPADCHAR_DPAD_UD)
				if self.selected_direction is not None:
					DisplayButton(game_menu_con, 36, 47, GAMEPADCHAR_B)
				DisplayButton(game_menu_con, 36, 48, GAMEPADCHAR_Y)
				DisplayButton(game_menu_con, 36, 49, GAMEPADCHAR_A)
				DisplayButton(game_menu_con, 36, 50, GAMEPADCHAR_DPAD_LR)
				
			else:			
				libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL)
				libtcod.console_print(game_menu_con, 30, 46, EnKey('w').upper() + '/' + EnKey('s').upper())
				if self.selected_direction is not None:
					libtcod.console_print(game_menu_con, 30, 47, 'Esc')
				libtcod.console_print(game_menu_con, 30, 48, 'Bksp')
				libtcod.console_print(game_menu_con, 30, 49, 'Tab')
				libtcod.console_print(game_menu_con, 30, 50, EnKey('a').upper() + '/' + EnKey('d').upper())
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print(game_menu_con, 38, 46, 'Select Support Type')
			if self.selected_direction is not None:
				libtcod.console_print(game_menu_con, 38, 47, 'Cancel Travel')
			libtcod.console_print(game_menu_con, 38, 48, 'Proceed without Support Request')
			libtcod.console_print(game_menu_con, 38, 49, 'Proceed with Selected Request')
			libtcod.console_print(game_menu_con, 38, 50, 'Scroll List')
			
			libtcod.console_blit(game_menu_con, 0, 0, 0, 0, con, 3, 3)
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# use a scrolling list in case there are lots of unit types in a category
		list_scroll = 0
		
		# generate list of choices
		choice_list = list(campaign.stats['player_unit_support'])
		
		# check each unit in each category; if no units currently available in this category, remove entire category
		for category in reversed(choice_list):
			
			no_units_available = True
			
			for unit_id in campaign.stats['player_unit_support'][category]:
				if unit_id not in session.unit_types: continue
				if not campaign.options['ahistorical'] and 'rarity' in session.unit_types[unit_id]:
					if not campaign.DoRarityCheck(unit_id, nation=campaign.stats['player_nation'], get_rarity=True):
						continue
				no_units_available = False
				break
				
			if no_units_available:
				choice_list.remove(category)
		
		# unlikely but possible that no category will have a unit type that can be spawned today
		if len(choice_list) == 0:
			ShowSimpleMessage('No support units are currently available.')
			return False
		
		# select first one by default, but if player previously selected one, try to select it now
		selection = choice_list[0]
		if session.unit_support_selection is not None:
			if session.unit_support_selection in choice_list:
				selection = session.unit_support_selection
			else:
				session.unit_support_selection = None
		
		# darken screen background
		libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
	
		# generate menu console for the first time and blit to screen
		DrawMenuCon(list_scroll)
		
		ShowTutorialSlide('campaign_day_unit_support_menu')
		
		# get input from player
		exit_menu = False
		while not exit_menu:
			
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# cancel travel
			if (key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1) and self.selected_direction is not None:
				return None
			
			# cancel support request - confirm first
			elif key.vk == sdl2.SDLK_BACKSPACE or session.gamepad_input == 3:
				if not ShowNotification('Cancel support request and proceed?', confirm=True):
					continue
				return None
			
			# proceed with selected unit support type
			elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				
				# save this selection in the session object
				session.unit_support_selection = selection
				return selection
			
			key_char = DeKey(chr(key.c).lower())
			
			# change selected option
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				i = choice_list.index(selection)
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if i == 0:
						i = len(choice_list) - 1
					else:
						i -= 1
				else:
					if i == len(choice_list) - 1:
						i = 0
					else:
						i += 1
				selection = choice_list[i]
				# reset any list scrolling
				list_scroll = 0
				DrawMenuCon(list_scroll)
				continue
			
			# scroll a longer list of units
			elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
				
				# skip if list is short enough to be displayed
				if len(campaign.stats['player_unit_support'][selection]) < 33:
					continue
				
				if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
					list_scroll -= 1
					if list_scroll < 0:
						list_scroll = 0
				else:
					list_scroll += 1
					if list_scroll > len(campaign.stats['player_unit_support'][selection]) - 33:
						list_scroll = len(campaign.stats['player_unit_support'][selection]) - 33 
				DrawMenuCon(list_scroll)
				continue				
	
	
	# returns true if travel between these two zones would require a river/wadi crossing
	def RiverCrossing(self, hx1, hy1, hx2, hy2):
		if (hx1, hy1) not in self.map_hexes: return False
		if (hx2, hy2) not in self.map_hexes: return False
		if self.GetDirectionToAdjacentCD(hx1, hy1, hx2, hy2) not in self.map_hexes[(hx1,hy1)].rivers:
			if self.GetDirectionToAdjacentCD(hx2, hy2, hx1, hy1) not in self.map_hexes[(hx2,hy2)].rivers:
				return False
		if self.GetDirectionToAdjacentCD(hx1, hy1, hx2, hy2) in self.map_hexes[(hx1,hy1)].bridges:
			return False
		if self.GetDirectionToAdjacentCD(hx2, hy2, hx1, hy1) in self.map_hexes[(hx2,hy2)].bridges:
			return False
		return True
	
	
	# calculate local sunrise and sunset time, moon phase for this day in the calendar
	def CalcDaylight(self):
		
		location = LocationInfo('', '', '', campaign.latitude, campaign.longitude)
		current_date = campaign.today.split('.')
		year = int(current_date[0])
		month = int(current_date[1])
		day = int(current_date[2])
		try:
			s = sun(location.observer, date=datetime(year, month, day))
			sunrise = s['sunrise']
			sunset = s['sunset']
			
			# account for difference from UTC
			sunrise += timedelta(minutes = int(campaign.longitude * 4))
			sunset += timedelta(minutes = int(campaign.longitude * 4))
		
		# some locations will be too far north for the sun to ever set
		except:
			sunrise = datetime(year, month, day, 4, 0, 0)
			sunset = datetime(year, month, day, 22, 0, 0)
		
		self.start_of_day = {}
		self.start_of_day['hour'] = sunrise.hour
		self.start_of_day['minute'] = sunrise.minute
		
		if self.start_of_day['hour'] < 4:
			self.start_of_day['hour'] = 4
			self.start_of_day['minute'] = 0
		
		# tutorial campaign has a shorter combat day
		if 'tutorial_campaign' in campaign.stats:
			self.start_of_day['hour'] += 2
		
		self.day_clock = {}
		self.day_clock['hour'] = self.start_of_day['hour']
		self.day_clock['minute'] = self.start_of_day['minute']
		
		self.end_of_day = {}
		self.end_of_day['hour'] = sunset.hour
		self.end_of_day['minute'] = sunset.minute
		
		if self.end_of_day['hour'] >= 22:
			self.end_of_day['hour'] = 22
			self.end_of_day['minute'] = 0
		
		# tutorial campaign has a shorter combat day
		if 'tutorial_campaign' in campaign.stats:
			self.end_of_day['hour'] -= 2
		
		# some days will end earlier
		if 'early_day_end' in campaign.current_week:
			if campaign.today in campaign.current_week['early_day_end']:
				early_end = campaign.current_week['early_day_end'][campaign.today]
				self.end_of_day['hour'] = int(early_end.split(':')[0])
				self.end_of_day['minute'] = int(early_end.split(':')[1])	
		
		# calculate current moon phase
		phase = round(moon.phase(date(year, month, day)), 2)
		if phase <= 3.50:
			self.moon_phase = 'New Moon'
		elif phase <= 7.00:
			self.moon_phase = 'Waxing Crescent'
		elif phase <= 10.50:
			self.moon_phase = 'First Quarter'
		elif phase <= 14.00:
			self.moon_phase = 'Waxing Gibbous'
		elif phase <= 17.50:
			self.moon_phase = 'Full Moon'
		elif phase <= 21.00:
			self.moon_phase = 'Waning Gibbous'
		elif phase <= 24.50:
			self.moon_phase = 'Last Quarter'
		else:
			self.moon_phase = 'Waning Crescent'
	
	
	# handle a recon or travel command from the player on the Campaign Day map
	# return amount of minutes taken to travel or recon
	def ReconOrTravel(self, recon, map_hex2, withdrawing=False):
		
		global scenario
		
		# recon
		if recon:
			if map_hex2.known_to_player: return False
			if map_hex2.controlled_by == 0: return False
			
			# Redraw GUI layer with the first cell removed from the direction line and drive one cell in the direction of the target hex.
			self.UpdateCDGUICon(True)
			session.cd_x_offset, session.cd_y_offset = CD_PLOT_DIR[self.selected_direction]
			self.UpdateCDUnitCon()
			self.UpdateCDDisplay()

			PlaySoundFor(None, 'recon')
			
			# special - oasis may turn out to be desert!
			if map_hex2.terrain_type == 'Oasis':
				if GetPercentileRoll() <= 1.0:
					map_hex2.terrain_type = 'Sand'
					map_hex2.vp_value = 0
					self.UpdateCDMapCon()
					self.UpdateCDHexInfoCon()
					self.UpdateCDDisplay()
					ShowMessage("The oasis turned out to be a mirage, it's nothing but sand!",
						cd_highlight=(map_hex2.hx, map_hex2.hy), good_news=False)
			
			map_hex2.known_to_player = True
			ShowTutorialSlide('campaign_day_recon')
			text = 'Estimated enemy strength in zone: ' + str(map_hex2.enemy_strength)
			ShowMessage(text, cd_highlight=(map_hex2.hx, map_hex2.hy))
			
			if self.rattenkrieg:
				minutes = 15
			else:
				minutes = 10
			
			if map_hex2.enemy_strength >= 9:
				if GetPercentileRoll() <= 4.0:
					ShowCrewChatter('high_resistance', None)
			elif map_hex2.enemy_strength <= 2:
				if GetPercentileRoll() <= 4.0:
					ShowCrewChatter('low_resistance', None)
			
			# reset unit position and direction line.
			session.cd_x_offset, session.cd_y_offset = 0,0
			self.UpdateCDGUICon()
			self.UpdateCDUnitCon()
			self.UpdateCDDisplay()
	
			campaign_day.AdvanceClock(0, minutes)
			DisplayTimeInfo(time_con)
			
			# check for objective completion
			if map_hex2.objective is not None:
				if map_hex2.objective['type'] == 'Recon':
					ShowTutorialSlide('campaign_day_completed_objective')
					ShowMessage('You completed an objective!', good_news=True)
					campaign.AwardVP(map_hex2.objective['vp_reward'])
					map_hex2.objective = None
			
			return minutes
		
		# travel
		
		# if unit support request is active, prompt player to select type of support
		if self.unit_support_request and map_hex2.enemy_strength > 0:
			unit_choice = self.GetUnitSupportChoice(map_hex2)
			if unit_choice is None:
				return 0
			elif unit_choice == '':
				self.unit_support_request = False
			else:
				self.unit_support_type = unit_choice

		# clear any selected direction 
		self.selected_direction = None 
		self.UpdateCDGUICon() 
		
		# do sound effect
		PlaySoundFor(campaign.player_unit, 'movement')

		# check for ambush before leaving zone
		if (campaign.stats['region'] == 'North Africa' or self.rattenkrieg) and not withdrawing:
			map_hex = self.map_hexes[self.player_unit_location]
			if map_hex.enemy_strength > 0 and len(map_hex.enemy_units) > 0:
				roll = GetPercentileRoll() - campaign_day.encounter_mod
				odds = float(map_hex.enemy_strength) * 2.0
				
				if DEBUG:
					if session.debug['Never Scenario']:
						roll = 100.0
				
				if roll <= odds:
					
					# cancel any active support requests
					self.air_support_request = False
					self.arty_support_request = False
					self.unit_support_request = False
					
					ShowMessage('Before you can leave your zone, you are ambushed! ' +
						'Any active support requests have been cancelled.',
						longer_pause=True, good_news=False)
					DisplayTimeInfo(time_con)
					DisplayLoadingMsg()
					scenario = Scenario(map_hex)
					self.encounter_mod = 0.0
					self.AddRecord('Engagements Fought', 1)
					campaign.AddJournal('We were ambushed in our own zone')
					return 0
		
		# get player location
		(hx1, hy1) = self.player_unit_location

		# if navigating in a sandstorm, blizzard, or thick fog, the player might end up in a different target zone
		if self.weather['Precipitation'] in ['Sandstorm', 'Blizzard'] or self.weather['Fog'] == 3:
			if GetPercentileRoll() <= 2.0:
				# build a list of possible target hexes
				hex_list = []
				for direction in range(6):
					(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
					if hx2 == map_hex2.hx and hy2 == map_hex2.hy: continue
					if (hx2, hy2) not in CAMPAIGN_DAY_HEXES: continue
					if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]: continue
					hex_list.append((hx2, hy2))
				
				if len(hex_list) > 0:
					# cancel any active support requests, we're going to the wrong hex.
					self.air_support_request = False
					self.arty_support_request = False
					self.unit_support_request = False
					map_hex2 = self.map_hexes[choice(hex_list)]

					if self.weather['Precipitation'] == 'Sandstorm':
						description = ('sandstorm', 'swirling sand')
					elif self.weather['Precipitation'] == 'Blizzard':
						description = ('blizzard', 'blinding snow')
					else:
						description = ('fog', 'impenetrable fog')

					if libtcod.random_get_int(0, 0, 1):
						text = 'You lose your way in the ' + description[0] + '!'
					else:
						text = 'Surrounded by ' + description[1] + ', you lose your sense of direction and become lost!'
					ShowMessage(text, longer_pause = True, good_news = False)

		travel_time = self.CalculateTravelTime(hx1,hy1,map_hex2.hx,map_hex2.hy)

		# calculate animation path 
		(x,y) = self.PlotCDHex(hx1, hy1)
		(x2,y2) = self.PlotCDHex(map_hex2.hx, map_hex2.hy)
		line = GetLine(0, 0, x2-x, y2-y)

		# animate just shy of half the travel distance.
		for i in range(3):
			session.cd_x_offset, session.cd_y_offset = line.pop(0)
			self.UpdateCDUnitCon()
			self.UpdateCDDisplay()
			Wait(20)

		# check for breakdown - increases travel time, or results in immobilization
		# we use the reposition chance because non-combat movement is likely to be more cautious
		campaign.player_unit.BreakdownCheck(reposition=True)
		if campaign.player_unit.broken_down:
			minutes = libtcod.random_get_int(0, 1, 3) * 10
			ShowMessage('Your vehicle breaks down, and it takes you an additional ' +
				str(minutes) + ' minutes to repair it and continue on your way.', good_news=False)
			campaign_day.AdvanceClock(0, minutes)
			campaign.player_unit.broken_down = False
			PlaySoundFor(campaign.player_unit, 'movement')

		elif campaign.player_unit.immobilized:
			ShowMessage('Your vehicle breaks down completely! You are immobilized and your combat day is over.',
				longer_pause=True, good_news=False)
			campaign.AddJournal('Our vehicle broke down completely, ending our combat day')
			if GetPercentileRoll() <= 30.0:
				ShowCrewChatter('breakdown', None)
			self.ended = True
			return 0
		
		# check for river/wadi crossing - only if not withdrawing
		river_time_required = 0
		if self.RiverCrossing(hx1, hy1, map_hex2.hx, map_hex2.hy) and not withdrawing:
			
			roll = GetPercentileRoll()
			
			if self.weather['Temperature'] == 'Extreme Cold':
				roll -= 40.0
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Frogman'):
				roll -= 50.0
			elif campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Explorer'):
				roll -= 25.0
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Prepared Positions'):
				roll = 0.0
			
			# determine additional time required
			if roll <= 10.0:
				river_time_required = 5
			elif roll <= 50.0:
				river_time_required = 20
			elif roll <= 75.0:
				river_time_required = 30
			elif roll <= 95.0:
				river_time_required = 45
			else:
				river_time_required = 60
			
			if campaign.stats['region'] == 'North Africa':
				river_time_required = ceil(river_time_required / 4)

			ShowTutorialSlide('campaign_day_rivers')

			# special: if all units in the squad are amphibious, no extra time required
			amphibious_crossing = True
			if campaign.player_unit.GetStat('amphibious') is None:
				amphibious_crossing = False
			for unit in self.player_squad:
				if unit.GetStat('amphibious') is None:
					amphibious_crossing = False
					break
			
			if campaign.stats['region'] == 'North Africa':
				amphibious_crossing = False
			
			if amphibious_crossing:
				ShowMessage('With your amphibious vehicles, you quickly and safely cross the river.',
					good_news=True)
			else:
				text = ('It takes you an additional ' + str(river_time_required) + ' minutes to find ' +
					'a safe place to cross the ')
				if campaign.stats['region'] == 'North Africa':
					text += 'wadi.'
				else:
					text += 'river.'
				ShowMessage(text)
				campaign_day.AdvanceClock(0, river_time_required)
				DisplayTimeInfo(time_con)

			PlaySoundFor(campaign.player_unit, 'movement')

		# perform advancing fire, if possible
		(advancing_fire_text, advancing_fire_he, advancing_fire_mgs, advancing_fire_success) = self.ResolveAdvancingFire(map_hex2)

		# spread the advancing fire sfx across the movement into enemy hex.
		if advancing_fire_he:
			PlaySound('37mm_he_explosion')
		if advancing_fire_mgs:
			PlaySoundFor(choice(advancing_fire_mgs), 'fire')

		# animate the remaining travel distance.
		for i in range(len(line)):
			if i == 1 and advancing_fire_he:
				PlaySound('37mm_he_explosion')
			session.cd_x_offset, session.cd_y_offset = line.pop(0)
			self.UpdateCDUnitCon()
			self.UpdateCDDisplay()
			Wait(20)

		if advancing_fire_he:
			PlaySound('37mm_he_explosion')
		if advancing_fire_mgs:
			PlaySoundFor(choice(advancing_fire_mgs), 'fire')
		
		# set new player location and advance clock
		session.cd_x_offset, session.cd_y_offset = 0,0
		self.player_unit_location = (map_hex2.hx, map_hex2.hy)
		campaign_day.AdvanceClock(0, travel_time)
		self.map_hexes[self.player_unit_location].RevealAdjacentZones()
		DisplayTimeInfo(time_con)
		DisplayWeatherInfo(cd_weather_con)
		self.UpdateCDUnitCon()
		self.UpdateCDCommandCon()
		self.UpdateCDDisplay()
		
		# fatigue check for player crew if extreme weather
		if self.weather['Temperature'] in ['Extreme Hot', 'Extreme Cold']:
			for position in campaign.player_unit.positions_list:
				if position.crewman is None: continue
				position.crewman.DoFatigueCheck()
		
		# special - oasis may turn out to be desert!
		if map_hex2.terrain_type == 'Oasis' and map_hex2.controlled_by != 0:
			if GetPercentileRoll() <= 2.0:
				map_hex2.terrain_type = 'Sand'
				map_hex2.vp_value = 0
				self.UpdateCDMapCon()
				self.UpdateCDHexInfoCon()
				self.UpdateCDDisplay()
				ShowMessage("The oasis turned out to be a mirage, it's nothing but sand!",
					cd_highlight=(map_hex2.hx, map_hex2.hy), longer_pause=True,
					good_news=False)
		
		# roll to trigger battle encounter if enemies present
		if map_hex2.enemy_strength > 0 and len(map_hex2.enemy_units) > 0:
			
			if map_hex2.controlled_by == 0:
				text = 'You enter the friendly-held zone'
			elif map_hex2.controlled_by == 1:
				text = 'You enter the enemy-held zone'
			else:
				text = 'You enter the neutral zone'
			
			# check for Patrol mission award
			if self.mission == 'Patrol':
				campaign.AwardVP(1)
			
			ShowMessage(text + advancing_fire_text)
										
			# roll for scenario trigger
			roll = GetPercentileRoll() - campaign_day.encounter_mod
			
			if DEBUG:
				if session.debug['Always Scenario']:
					roll = 1.0
				elif session.debug['Never Scenario']:
					roll = 200.0
			
			# lower chance of encounters in North Africa maps
			if campaign.stats['region'] == 'North Africa':
				odds = float(map_hex2.enemy_strength) * 6.5
			# higher chance of encounter in urban combat maps
			elif self.rattenkrieg:
				odds = float(map_hex2.enemy_strength) * 10.5
			# higher chance in Major Battle missions
			elif self.mission == 'Major Battle':
				odds = float(map_hex2.enemy_strength) * 10.0
			else:
				odds = float(map_hex2.enemy_strength) * 8.5
			
			always_battle = False
			
			# always a battle if certain objectives present
			if map_hex2.objective is not None:
				if map_hex2.objective['type'] in ['Rescue', 'Capture', 'Convoy Attack']:
					always_battle = True
					
					# make sure there's at least some resistance
					if map_hex2.enemy_strength < 1:
						map_hex2.enemy_strength = 1
			
			# always a battle in Amphibious Assault missions
			if self.mission == 'Amphibious Assault':
				always_battle = True
			
			# much higher chance for some terrain types
			if map_hex2.terrain_type in ['Mountain Pass', 'Fortress', 'Fortification']:
				odds = odds * 3.0
				if odds > 97.0:
					odds = 97.0
			
			if roll <= odds or always_battle:
				ShowTutorialSlide('campaign_day_resistance')
				ShowMessage('You encounter enemy resistance!', good_news=False)
				DisplayTimeInfo(time_con)
				DisplayLoadingMsg()
				scenario = Scenario(map_hex2, advancing_fire_success)
				scenario.player_attacking = True
				self.encounter_mod = 0.0
				self.AddRecord('Engagements Fought', 1)
				campaign.AddJournal('Entered an enemy-held zone, encountered resistance')
				return river_time_required + travel_time
			ShowTutorialSlide('campaign_day_no_resistance')
			ShowMessage('You find no enemy resistance in this area.', good_news=True)
			if map_hex2.controlled_by == 1:	
				campaign.AddJournal('Entered an enemy-held zone, no resistance.')
			else:
				campaign.AddJournal('Entered a zone with some enemy presence, but found no resistance.')
			map_hex2.CaptureMe(0)
				
			self.encounter_mod += 30.0
			
			# spend support costs and reset flags
			if self.air_support_request:
				if GetPercentileRoll() <= self.air_support_level:
					self.air_support_level -= float(libtcod.random_get_int(0, 1, 3)) * 5.0
				if self.air_support_level < 0.0:
					self.air_support_level = 0.0
				self.air_support_request = False
			
			if self.arty_support_request:
				if GetPercentileRoll() <= self.arty_support_level:
					self.arty_support_level -= float(libtcod.random_get_int(0, 1, 3)) * 5.0
				if self.arty_support_level < 0.0:
					self.arty_support_level = 0.0
				self.arty_support_request = False
			
			if self.unit_support_request:
				if GetPercentileRoll() <= self.unit_support_level:
					self.unit_support_level -= float(libtcod.random_get_int(0, 1, 3)) * 5.0
				if self.unit_support_level < 0.0:
					self.unit_support_level = 0.0
		
		# entering a friendly zone
		else:
			ShowMessage('You enter the friendly-held zone.')
		
		# no battle triggered
		if map_hex2.terrain_type == 'Oasis':
			ShowMessage('Your crew have a chance to rest in the oasis.', good_news=True)
			for position in campaign.player_unit.positions_list:
				if position.crewman is None: continue
				position.crewman.Rest()

		# recalculate VP values and check for map shift
		for (hx, hy), cd_hex in self.map_hexes.items():
			cd_hex.CalcCaptureVP()
		DisplayTimeInfo(time_con)
		self.CheckForCDMapShift()
		return river_time_required + travel_time
	
	
	# resolve advancing fire for player and squad; return a text description of action
	def ResolveAdvancingFire(self, target_map_hex):
		# none to resolve
		if not self.advancing_fire or target_map_hex.enemy_strength <= 0 or len(target_map_hex.enemy_units) == 0:
			return ('.', 0, [], False)
		
		text = ', using advancing fire against anything suspicious.'
		
		# check for HE and MG FP across squad
		unit_list = [campaign.player_unit]
		if len(campaign_day.player_squad) > 0:
			unit_list += campaign_day.player_squad
		
		total_he = 0
		player_he = 0
		total_fp = 0
		mgs_fired = []
		for unit in unit_list:
			
			# build a list of weapons that will be fired
			firing_list = []
			for weapon in unit.weapon_list:
				
				if weapon.GetStat('type') != 'Gun' and weapon.GetStat('type') not in MG_WEAPONS: continue
				if weapon.broken: continue
				
				# if player unit, needs to have a crewman in the correct position
				if unit.is_player:
					if weapon.GetStat('fired_by') is not None:
						crewman_found = False
						position_list = weapon.GetStat('fired_by')
						for position in position_list:
							crewman = unit.GetPersonnelByPosition(position)
							if crewman is None: continue
							if not crewman.alive: continue
							crewman_found = True
							break
						
						if not crewman_found: continue
				
				if weapon.GetStat('type') == 'Gun':
					if 'HE' not in weapon.ammo_stores: continue
					if weapon.ammo_stores['HE'] == 0: continue
					
					# don't use HE if limited
					if 'special_ammo' in weapon.stats:
						if 'HE' in weapon.stats['special_ammo']:
							continue
				
				firing_list.append(weapon)
			
			# determine total firepower from all firing weapons
			for weapon in firing_list:
				
				if weapon.GetStat('type') == 'Gun':
					
					# determine how many shells are fired
					max_shells = 7
					if weapon.max_ammo <= 60:
						max_shells = 3
					
					i = libtcod.random_get_int(0, 1, max_shells)
					if i > weapon.ammo_stores['HE']:
						i = weapon.ammo_stores['HE']
					weapon.ammo_stores['HE'] -= i
					total_he += i
					total_fp += weapon.GetEffectiveFP() * i
					if unit.is_player:
						player_he += i
				
				elif weapon.GetStat('type') in MG_WEAPONS:
					total_fp += int(weapon.GetStat('fp')) * libtcod.random_get_int(0, 0, 3)
					mgs_fired.append(weapon)
		
		# no possible effective advancing fire
		if total_fp == 0:
			return ('.', 0, [], False)
		
		if player_he > 0:
			text += ' You fired a total of ' + str(player_he) + ' HE rounds.'
		
		# do the effectiveness roll based on total FP
		if GetPercentileRoll() > round(float(total_fp) * 0.4, 1):
			advancing_fire_success = False
		else:
			advancing_fire_success = True
		
		return (text, total_he, mgs_fired, advancing_fire_success)
		
	
	# set landmine zones for this map
	def GenerateMinefields(self):
		
		# Amphibious Assault missions have landmines on the beach but nowhere else
		if self.mission == 'Amphibious Assault':
			for hx in range(-2, 2):
				self.map_hexes[(hx,5)].landmines = True
			return
		
		if 'landmines_chance' not in campaign.current_week: return
		chance = float(campaign.current_week['landmines_chance'])
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]:
				continue
			if GetPercentileRoll() <= chance:
				self.map_hexes[(hx,hy)].landmines = True
	
	
	# generate objectives for this map
	def GenerateObjectives(self):
		
		# some missions have a special sequence
		if self.mission == 'Hold the Line':
			objective = {}
			objective['type'] = 'Hold'
			objective['hold_until'] = (self.end_of_day['hour'], self.end_of_day['minute']) 
			
			# determine total number of objective zones
			hex_list = []
			for hx in range(-2, 3):
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx, 4)].terrain_type]:
					continue
				hex_list.append((hx, 4))
			
			# calculate value of remaining zones
			if len(hex_list) == 5:
				objective['vp_reward'] = 8
			elif len(hex_list) == 4:
				objective['vp_reward'] = 10
			elif len(hex_list) == 3:
				objective['vp_reward'] = 14
			else:
				objective['vp_reward'] = 20
			
			# set objectives
			for (hx, hy) in hex_list:
				self.map_hexes[(hx, hy)].objective = objective
			return
		
		elif self.mission == 'Amphibious Assault':
			
			objective = {}
			objective['type'] = 'Capture'
			objective['vp_reward'] = 20
			
			# set objectives
			for hx in range(-2, 3):
				self.map_hexes[(hx,4)].objective = objective
			return
		
		# initial objective types
		OBJECTIVE_CHOICES = ['Capture', 'Recon', 'Hold', 'Rescue', 'Convoy Attack']
		PATROL_CHOICES = ['Recon', 'Recon', 'Recon', 'Capture', 'Convoy Attack']
		
		(phx, phy) = self.player_unit_location
		locations = []
		
		# determine current number of objectives already on map
		current_objectives = 0
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if self.map_hexes[(hx, hy)].objective is not None:
				current_objectives += 1
		
		# roll for total number of objectives
		total_objectives = 3
		roll = libtcod.random_get_int(0, 1, 10)
		if 6 <= roll <= 8:
			total_objectives = 4
		elif roll >= 9:
			total_objectives = 5
		if current_objectives >= total_objectives: return
		
		# build initial list of possible hexes
		hex_list = []
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx, hy)].terrain_type]:
				continue
			if GetHexDistance(hx, hy, phx, phy) < 2: continue
			if len(self.GetHexPath(hx, hy, phx, phy)) == 0: continue
			hex_list.append((hx, hy))
		
		# no possible locations (should not happen)
		if len(hex_list) == 0: return
		
		(p_hx, p_hy) = self.player_unit_location
		
		# set to true when we have already placed a Convoy Attack objective in this map area
		convoy_objective_placed = False
		
		# generate enough objectives to bring total up to desired number
		for i in range(total_objectives - current_objectives):	
			for tries in range(300):
			
				objective = {}
				
				# select random type
				if self.mission == 'Patrol':
					objective['type'] = choice(PATROL_CHOICES)
				else:
					objective['type'] = choice(OBJECTIVE_CHOICES)
				
				# no chance of hold objectives in these missions
				if self.mission in ['Advance', 'Spearhead', 'Urban Assault']:
					if objective['type'] == 'Hold':
						continue
				
				# no chance of rescue missions in this mission
				if self.mission == 'Spearhead':
					if objective['type'] == 'Rescue':
						continue
				
				# greater chance of hold objective in these missions
				elif self.mission in ['Fighting Withdrawal', 'Counterattack', 'Urban Defense']:
					if objective['type'] != 'Hold':
						objective['type'] = choice(OBJECTIVE_CHOICES)
				
				if objective['type'] == 'Convoy Attack':
					
					# only one Convoy Attack objective per map area
					if convoy_objective_placed: continue
					
					# less chance of Convoy Attack overall
					if GetPercentileRoll() <= 80.0:
						continue
				
				# try to find a suitable location
				suitable_hex_list = []
				for (hx, hy) in hex_list:
					
					# don't place if player moving to this zone would require a map shift
					if hy not in [0, 8] and not (self.rattenkrieg or self.mission == 'Hold the Line'):
						if self.mission in ['Fighting Withdrawal', 'Counterattack']:
							if len(self.GetHexPath(p_hx, p_hy, hx, hy, avoid_rows=[8])) == 0:
								continue
						else:
							if len(self.GetHexPath(p_hx, p_hy, hx, hy, avoid_rows=[0])) == 0:
								continue
					
					# already an objective here
					if self.map_hexes[(hx, hy)].objective is not None: continue
					
					if objective['type'] == 'Recon':
						if self.map_hexes[(hx, hy)].known_to_player: continue
						if self.map_hexes[(hx, hy)].controlled_by == 0: continue
					elif objective['type'] == 'Convoy Attack':
						if self.map_hexes[(hx, hy)].controlled_by == 0: continue
					elif objective['type'] in ['Capture', 'Rescue']:
						if self.map_hexes[(hx, hy)].controlled_by != 1: continue
					elif objective['type'] == 'Hold':
						if self.map_hexes[(hx, hy)].controlled_by != 0: continue
					
					# don't place Hold objectives too high on the map in Fighting Withdrawl
					if self.mission == 'Fighting Withdrawal' and objective['type'] == 'Hold':
						if hy <= 1: continue
	
					# make sure it's not too close to another objective
					too_close = False
					for (hx2, hy2) in locations:
						if GetHexDistance(hx, hy, hx2, hy2) == 1:
							too_close = True
							break
					if too_close: continue
						
					suitable_hex_list.append((hx, hy))
				
				# no suitable locations for this objective type
				if len(suitable_hex_list) == 0:
					continue
				
				# place objective in random good location
				(hx, hy) = choice(suitable_hex_list)
				objective['hx'] = hx
				objective['hy'] = hy
				
				if objective['type'] == 'Recon':
					objective['vp_reward'] = 4
				
				elif objective['type'] == 'Convoy Attack':
					objective['vp_reward'] = 3
					convoy_objective_placed = True
				
				elif objective['type'] == 'Capture':
					objective['vp_reward'] = 10
					self.map_hexes[(hx, hy)].enemy_strength += libtcod.random_get_int(0, 4, 6)
					if self.map_hexes[(hx, hy)].enemy_strength > 10:
						self.map_hexes[(hx, hy)].enemy_strength = 10
				
				elif objective['type'] == 'Hold':
					objective['vp_reward'] = 6
					hour = int(self.day_clock['hour'])
					minute = int(self.day_clock['minute']) + (libtcod.random_get_int(0, 14, 24) * 15)
					while minute >= 60:
						hour += 1
						minute -= 60
					if hour > self.end_of_day['hour']:
						hour = self.end_of_day['hour']
					if hour == self.end_of_day['hour']:
						if minute > self.end_of_day['minute']:
							minute = self.end_of_day['minute']
					objective['hold_until'] = (hour, minute) 
				
				elif objective['type'] == 'Rescue':
					objective['vp_reward'] = 10
					objective['rescue_unit'] = None
					self.map_hexes[(hx, hy)].enemy_strength += libtcod.random_get_int(0, 2, 5)
					if self.map_hexes[(hx, hy)].enemy_strength > 10:
						self.map_hexes[(hx, hy)].enemy_strength = 10
				
				self.map_hexes[(hx, hy)].objective = objective
				locations.append((hx, hy))
				break
	
	
	# check to see what happens when the player waits for resupply
	def DoResupplyCheck(self):
		
		global scenario
		
		# roll for possible attack on player hex
		# odds based on average strength of enemy-held adjacent hexes, plus enemy strength
		# in player hex if neutral
		total_strength = 0
		(hx, hy) = self.player_unit_location
		if self.map_hexes[(hx,hy)].controlled_by == 2:
			total_strength += self.map_hexes[(hx,hy)].enemy_strength
		
		for direction in range(6):
			(hx1, hy1) = self.GetAdjacentCDHex(hx, hy, direction)
			if (hx1, hy1) not in CAMPAIGN_DAY_HEXES: continue
			if self.map_hexes[(hx1,hy1)].controlled_by == 0: continue
			total_strength += self.map_hexes[(hx1,hy1)].enemy_strength
		
		total_strength = float(total_strength) / 6.0
		if total_strength <= 1.0:
			total_strength = 0.0
		
		roll = GetPercentileRoll()
		
		if DEBUG:
			if session.debug['Never Scenario']:
				roll = 200.0
		
		if roll <= total_strength * 10.0:
			self.delayed_resupply = True
			self.AdvanceClock(0, 5 * libtcod.random_get_int(0, 1, 3))
			DisplayTimeInfo(time_con)
			ShowMessage('While you are waiting for resupply, enemy forces attack your zone!',
				longer_pause=True, good_news=False)
			campaign.AddJournal('Enemy forces attacked our zone while we were waiting for resupply.')
			
			if GetPercentileRoll() <= 2.0:
				ShowCrewChatter('attacked_during_resupply', None)
			
			DisplayLoadingMsg()
			scenario = Scenario(self.map_hexes[(hx,hy)])
			self.AddRecord('Engagements Fought', 1)
			self.UpdateCDUnitCon()
			self.UpdateCDControlCon()
			self.UpdateCDGUICon()
			self.UpdateCDCommandCon()
			self.UpdateCDHexInfoCon()
			self.UpdateCDDisplay()
			return
		
		# roll for time required
		minutes = 5 * libtcod.random_get_int(0, 4, 7)
		
		# check for radio connection
		if self.hq_radio_comms:
			minutes -= 5 * libtcod.random_get_int(0, 1, 3)
			for position in campaign.player_unit.positions_list:
				if position.crewman is None: continue
				if not position.crewman.alive: continue
				if position.name == 'Radio Operator':
					minutes -= 5 * libtcod.random_get_int(0, 1, 3)
					break
		
			if minutes < 10:
				minutes = 10
		
		else:
		
			# check weather conditions
			if self.weather['Precipitation'] == 'Sandstorm':
				minutes += 5 * libtcod.random_get_int(0, 1, 3)
			
			# check for clear path to friendly edge; North African and Rattenkrieg days don't need this
			if not self.PlayerHasPath():
				minutes += 5 * libtcod.random_get_int(0, 2, 4)
		
		# spend time
		self.AdvanceClock(0, minutes)
		DisplayTimeInfo(time_con)
		self.UpdateCDDisplay()
		
		ShowMessage('Resupply trucks arrive ' + str(minutes) + ' minutes later.')
		campaign.AddJournal('We have been resupplied.')
		session.ModifySteamStat('resupplied', 1)
		if GetPercentileRoll() <= 2.0:
			ShowCrewChatter('resupplied', None)
		self.PlayerResupply()
		self.UpdateCDDisplay()
		self.CheckForZoneCapture('resupply')
		self.CheckForRandomEvent()
		SaveGame()
	
	
	# allow player to replenish ammo, also replenish smoke grenades and mortar rounds
	def PlayerResupply(self):
		
		# reload player squad units too
		for unit in self.player_squad:
			if not unit.alive: continue
			for weapon in unit.weapon_list:
				if weapon.GetStat('type') == 'Gun':
					weapon.GenerateRareAmmo(True)
					weapon.AddDefaultAmmoLoad()
				elif weapon.GetStat('type') == 'Flame Thrower':
					weapon.flame_ammo = weapon.flame_ammo_max
		
		self.AmmoReloadMenu(resupply=True)
		self.smoke_grenades = 6
		if campaign.player_unit.GetStat('smoke_mortar') is not None:
			self.smoke_mortar_rounds = 10
		self.UpdateCDDisplay()
		
		# check for dead crewman removal, living crew have a chance to rest 
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive:
				position.crewman = None
				self.UpdateCDPlayerUnitCon()
				self.UpdateCDDisplay()
				ShowMessage('The body of your ' + position.name + ' is taken back by the supply team.')
			else:
				position.crewman.Rest()
		
	
	# check to see if clear path between hexes in top and bottom row
	def CheckClearMapPath(self):
		path_good = False
		STARTING_HEXES = [(-4,8), (-3,8), (-2,8), (-1,8), (0,8)]
		ENDING_HEXES = [(4,0), (3,0), (2,0), (1,0), (0,0)]
		
		for (hx1, hy1) in STARTING_HEXES:
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx1,hy1)].terrain_type]: continue
			for (hx2, hy2) in ENDING_HEXES:
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]: continue
				if len(self.GetHexPath(hx1, hy1, hx2, hy2)) == 0:
					continue
				path_good = True
				break
			if path_good:
				break
		
		return path_good
	
	
	# returns a path from one campaign day hex zone to another
	# can be set to be blocked by enemy-held zones
	# based on function from ArmCom 1, which was based on:
	# http://stackoverflow.com/questions/4159331/python-speed-up-an-a-star-pathfinding-algorithm
	# http://www.policyalmanac.org/games/aStarTutorial.htm
	def GetHexPath(self, hx1, hy1, hx2, hy2, avoid_terrain=[], avoid_rows=[], enemy_zones_block=False):
		
		# retrace a set of nodes and return the best path
		def RetracePath(end_node):
			path = []
			node = end_node
			done = False
			while not done:
				path.append((node.hx, node.hy))
				if node.parent is None: break	# we've reached the end
				node = node.parent	
			path.reverse()
			return path
		
		# clear any old pathfinding info
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			self.map_hexes[(hx,hy)].ClearPathInfo()
		
		node1 = self.map_hexes[(hx1, hy1)]
		node2 = self.map_hexes[(hx2, hy2)]
		open_list = set()	# contains the nodes that may be traversed by the path
		closed_list = set()	# contains the nodes that will be traversed by the path
		start = node1
		start.h = GetHexDistance(node1.hx, node1.hy, node2.hx, node2.hy)
		start.f = start.g + start.h
		end = node2
		open_list.add(start)		# add the start node to the open list
		
		while open_list:
			
			# grab the node with the best H value from the list of open nodes
			current = sorted(open_list, key=lambda inst:inst.f)[0]
			
			# we've reached our destination
			if current == end:
				return RetracePath(current)
			
			# move this node from the open to the closed list
			open_list.remove(current)
			closed_list.add(current)
			
			# add the nodes connected to this one to the open list
			for direction in range(6):
				
				# get the hex coordinates in this direction
				hx, hy = self.GetAdjacentCDHex(current.hx, current.hy, direction)
				
				# no map hex exists here, skip
				if (hx, hy) not in CAMPAIGN_DAY_HEXES: continue
				
				node = self.map_hexes[(hx,hy)]
				
				# hex terrain is impassable, skip
				if 'impassible' in CD_TERRAIN_TYPES[node.terrain_type]: continue
				
				# ignore nodes on closed list
				if node in closed_list: continue
				
				# if we hit a restricted row, don't allow a path here
				if hy in avoid_rows: continue
								
				if enemy_zones_block:
					if node.controlled_by == 1:
						continue
				
				if len(avoid_terrain) > 0:
					if node.terrain_type in avoid_terrain:
						continue
				
				# not really used yet
				cost = 1
				
				g = current.g + cost
				
				# if not in open list, add it
				if node not in open_list:
					node.g = g
					node.h = GetHexDistance(node.hx, node.hy, node2.hx, node2.hy)
					node.f = node.g + node.h
					node.parent = current
					open_list.add(node)
				# if already in open list, check to see if can make a better path
				else:
					if g < node.g:
						node.parent = current
						node.g = g
						node.f = node.g + node.h
		
		# no path possible
		return []
	
	
	# generate terrain for this campaign map
	def GenerateCDMapTerrain(self, avoid_y=False):
		cd_hex_numbers = {}
		
		# if urban mission, use URBAN_CD_TERRAIN_ODDS['cd_terrain_odds'] instead,
		# don't apply any terrain_odds_modifier
		if self.rattenkrieg:
			terrain_dict = URBAN_CD_TERRAIN_ODDS['cd_terrain_odds']
		else:
		
			terrain_dict = session.regions[campaign.stats['region']]['cd_terrain_odds'].copy()
			
			# check to see if current campaign week modifies this and change dictionary value
			if 'terrain_odds_modifier' in campaign.current_week:
				for k, v in campaign.current_week['terrain_odds_modifier'].items():
					terrain_dict[k] = v
			
			# check to see whether current season modifies odds
			if self.weather['Season'] == 'Southwest Monsoon':
				terrain_dict['Swamp'] += 15
			
		# base odds should total 100, but campaign week may modify this, so we can scale the odds
		total_chance = 0
		for terrain_type, odds in terrain_dict.items():
			total_chance += odds
		
		for tries in range(300):
			
			# check for coastal daymap
			if self.coastal_map is not None:
				if self.coastal_map == 'left':
					hx = 0
				else:
					hx = 4
				hy = 0
				for i in range(9):
					self.map_hexes[(hx,hy)].terrain_type = 'Water'
					if self.coastal_map == 'right':
						if self.GetAdjacentCDHex(hx, hy, 2) in CAMPAIGN_DAY_HEXES:
							(hx, hy) = self.GetAdjacentCDHex(hx, hy, 2)
						else:
							(hx, hy) = self.GetAdjacentCDHex(hx, hy, 3)
					else:
						if self.GetAdjacentCDHex(hx, hy, 3) in CAMPAIGN_DAY_HEXES:
							(hx, hy) = self.GetAdjacentCDHex(hx, hy, 3)
						else:
							(hx, hy) = self.GetAdjacentCDHex(hx, hy, 2)
		
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				
				if avoid_y:
					if hy == avoid_y:
						continue
				
				map_hex = self.map_hexes[(hx,hy)]
				
				while map_hex.terrain_type == '':
					
					terrain_type = choice(list(terrain_dict.keys()))
					odds = terrain_dict[terrain_type]
					
					# check for terrain types that have already been spawned
					if 'max_per_map' in CD_TERRAIN_TYPES[terrain_type]:
						if terrain_type in cd_hex_numbers:
							if cd_hex_numbers[terrain_type] == CD_TERRAIN_TYPES[terrain_type]['max_per_map']:
								continue
					
					# don't allow two impassible terrain types next to each other
					if 'impassible' in CD_TERRAIN_TYPES[terrain_type]:
						blocked_by_adjacent = False
						for direction in range(6):
							(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
							# off map
							if (hx2, hy2) not in self.map_hexes: continue
							if self.map_hexes[(hx2,hy2)].terrain_type == '': continue
							if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]:
								blocked_by_adjacent = True
								break
						if blocked_by_adjacent:
							continue
					
					if libtcod.random_get_int(0, 0, total_chance) <= odds:
						map_hex.terrain_type = terrain_type
						
						# record addition of this terrain type
						if terrain_type in cd_hex_numbers:
							cd_hex_numbers[terrain_type] += 1
						else:
							cd_hex_numbers[terrain_type] = 1
						break
			
			# map terrain is finished, make sure that it can be traversed
			if self.CheckClearMapPath():
				break
			
			# clear all terrain
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				self.map_hexes[(hx,hy)].terrain_type = ''
		
		# terrain generation is complete, some missions have special modifiers to the base map
		if self.mission == 'Amphibious Assault':
			
			# beachhead
			for hx in range(-2, 2):
				self.map_hexes[(hx,5)].terrain_type = 'Beach'
			
			# ocean
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				if hy < 6: continue
				self.map_hexes[(hx,hy)].terrain_type = 'Water'
			
			# coastal town and defenses
			if campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
				terrain_list1 = ['Fortification', 'Hut Villages', 'Hut Villages', 'Cogon Grass', 'Hills']
				terrain_list2 = ['Fortification', 'Hut Villages', 'Cogon Grass', 'Hills']
			elif campaign.stats['region'] == 'North Africa':
				terrain_list1 = ['Fortification', 'Villages', 'Villages', 'Sand', 'Sand']
				terrain_list2 = ['Fortification', 'Sand', 'Sand', 'Flat', 'Flat']
			else:
				terrain_list1 = ['Fortification', 'Town Square', 'Row Houses', 'Row Houses', 'Row Houses']
				terrain_list2 = ['Fortification', 'Train Station', 'Row Houses', 'Park', 'Villages']
			for hx in range(-2, 3):
				terrain = choice(terrain_list1)
				self.map_hexes[(hx,4)].terrain_type = terrain
			for hx in range(-1, 3):
				terrain = choice(terrain_list2)
				self.map_hexes[(hx,3)].terrain_type = terrain
			
	
	# checks to see if player has a clear path back to the friendly map edge
	def PlayerHasPath(self):
		
		if campaign.stats['region'] == 'North Africa' or self.rattenkrieg:
			return True
		
		path_good = False
		(hx1, hy1) = self.player_unit_location
		
		if hy1 == 8:
			path_good = True
		else:
			for hx2 in range(-4, 1):
				if len(self.GetHexPath(hx1, hy1, hx2, 8, enemy_zones_block=True)) != 0:
					path_good = True
					break
		return path_good
		
	
	# set up the list of player guns and select the first one if any
	def BuildPlayerGunList(self):
		self.gun_list = []
		self.selected_gun = None
		for weapon in campaign.player_unit.weapon_list:
			if weapon.GetStat('type') == 'Gun':
				self.gun_list.append(weapon)
		if len(self.gun_list) > 0:
			self.selected_gun = self.gun_list[0]
	
	
	# spawn squad members to bring player squad up to full strength
	def SpawnPlayerSquad(self):
		
		if campaign.player_squad_max == 0: return
		
		while(len(self.player_squad) < campaign.player_squad_max):
			
			unit_id = None
			
			# determine unit type
			if 'player_squad_list' in campaign.stats:
				if campaign.player_unit.unit_id not in campaign.stats['player_squad_list']:
					unit_id = campaign.player_unit.unit_id
			else:
				unit_id = campaign.player_unit.unit_id
			
			if unit_id is not None:
				unit = Unit(unit_id)
				unit.nation = campaign.player_unit.nation
				self.player_squad.append(unit)
				unit.ai = AI(unit)
				unit.ai.Reset(squadmember=True)
				unit.GenerateNewPersonnel()
				continue
			
			unit_list = campaign.stats['player_squad_list'][campaign.player_unit.unit_id].copy()
			shuffle(unit_list)
			
			# find a suitable unit_id from the list, or fallback on player's own model
			unit_ok = False
			for unit_id in unit_list:
				if not campaign.options['ahistorical'] and 'rarity' in session.unit_types[unit_id]:
					unit_ok = True
					for date, chance in session.unit_types[unit_id]['rarity'].items():
						if date > campaign.today:
							unit_ok = False
							break
						break
					if not unit_ok:
						continue
			
			if not unit_ok:
				unit_id = campaign.player_unit.unit_id
			
			unit = Unit(unit_id)
			unit.nation = campaign.player_unit.nation
			self.player_squad.append(unit)
			unit.ai = AI(unit)
			unit.ai.Reset(squadmember=True)
			unit.GenerateNewPersonnel()
	
	
	# check for shift of campaign day map:
	# shift displayed map up or down, triggered by player reaching other end of map
	def CheckForCDMapShift(self):
		
		(player_hx, player_hy) = self.player_unit_location
		
		if self.rattenkrieg or self.mission in ['Hold the Line', 'Amphibious Assault']:
			return
		elif self.mission in ['Fighting Withdrawal', 'Counterattack']:
			if player_hy != 8: return
		else:
			if player_hy != 0: return
		
		ShowMessage('You enter a new map area.')
		campaign.AddJournal('Entered a new map area')
		self.maps_traversed += 1
		session.ModifySteamStat('areas_advanced', 1)
		DisplayTimeInfo(time_con)
		
		# determine direction to shift map based on current player location
		if player_hy == 8:
			shift_down = False
		elif player_hy == 0:
			shift_down = True
		else:
			return
		
		if shift_down:
			new_hy = 8
			hx_mod = -4
		else:
			new_hy = 0
			hx_mod = +4
		
		# copy terrain for current player row to new row
		for hx in range(player_hx-4, player_hx+5):
			if (hx, player_hy) not in CAMPAIGN_DAY_HEXES: continue
			self.map_hexes[(hx+hx_mod, new_hy)] = self.map_hexes[(hx, player_hy)]
			self.map_hexes[(hx+hx_mod, new_hy)].hx = hx+hx_mod
			self.map_hexes[(hx+hx_mod, new_hy)].hy = new_hy
			self.map_hexes[(hx+hx_mod, new_hy)].Reset()
		
		self.player_unit_location = (player_hx+hx_mod, new_hy)
		
		# generate new map hexes and terrain for remainder of map
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if hy == new_hy: continue
			self.map_hexes[(hx,hy)] = CDMapHex(hx, hy, self.mission)
		self.GenerateCDMapTerrain(avoid_y=new_hy)
		
		# calculate capture VP for all map zones, generate roads and rivers
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			self.map_hexes[(hx,hy)].CalcCaptureVP()
		campaign_day.GenerateRoads(link_roads=True)
		campaign_day.GenerateRivers(link_rivers=True)
	
		# set up zone control for new map
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if (hx, hy) == self.player_unit_location: continue
			if hy == new_hy: continue
			if self.mission in ['Fighting Withdrawal', 'Counterattack']:
				self.map_hexes[(hx, hy)].controlled_by = 0
			else:
				self.map_hexes[(hx, hy)].controlled_by = 1
		
		# set new enemy strength and units for all new zones
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if hy == new_hy: continue
			self.map_hexes[(hx,hy)].GenerateStrengthAndUnits(self.mission)
		
		# generate new objectives and landmines
		self.GenerateObjectives()
		self.GenerateMinefields()
		
		# update consoles
		self.UpdateCDMapCon()
		self.UpdateCDGUICon()
		self.UpdateCDPlayerUnitCon()
		
		SaveGame()
		
		
	# roll for type of mission for today
	def GenerateMission(self):
		
		# possible that today's mission is set by the campaign week
		if 'mission_days' in campaign.current_week:
			if campaign.today in campaign.current_week['mission_days']:
				self.mission = campaign.current_week['mission_days'][campaign.today]
				return
		
		roll = GetPercentileRoll()
		for k, v in campaign.current_week['mission_odds'].items():
			if roll <= v:
				self.mission = k
				if self.mission in RATTENKRIEG_MISSIONS:
					self.rattenkrieg = True
				return
			roll -= float(v)
		
		print('ERROR: unable to set a mission for today, choosing default')
		for k, v in campaign.current_week['mission_odds'].items():
			self.mission = k
			if self.mission in RATTENKRIEG_MISSIONS:
				self.rattenkrieg = True
			return
	
	
	# check to see if travel between hexes on the Campaign Day map is possible
	def CheckTravel(self, hx1, hy1, hx2, hy2):
		
		# check for impassable terrain
		if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]:
			return 'N/A: Impassable'
		
		# check for missing or dead driver/rear driver
		crewman = campaign.player_unit.GetPersonnelByPosition('Driver')
		if crewman is None:
			crewman = campaign.player_unit.GetPersonnelByPosition('Rear Driver')
		else:
			if not crewman.alive:
				crewman = campaign.player_unit.GetPersonnelByPosition('Rear Driver')
		if crewman is None:
			return 'N/A: No Driver'
		if not crewman.alive:
			return 'N/A: Driver is dead'
		
		return ''
		
	
	# calculate required travel time in minutes from one zone to another
	def CalculateTravelTime(self, hx1, hy1, hx2, hy2):
		
		direction = self.GetDirectionToAdjacentCD(hx1, hy1, hx2, hy2)
		
		# check for road link
		if self.map_hexes[(hx1,hy1)].road_links[direction] is not None:
			# dirt road
			if self.map_hexes[(hx1,hy1)].road_links[direction] is False:
				mins = 15
			# stone road
			else:
				mins = 10
			
			# poor quality roads
			if 'poor_quality_roads' in session.regions[campaign.stats['region']]:
				if self.weather['Ground'] == 'Muddy':
					mins = mins * 2
			
		else:
			mins = CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]['travel_time']
		
		# check ground conditions
		if self.weather['Ground'] == 'Deep Snow':
			mins += 15
		elif self.weather['Ground'] in ['Muddy', 'Snow']:
			mins += 10
		elif self.weather['Precipitation'] != 'None':
			mins += 5
		
		# check for sandstorm
		if self.weather['Precipitation'] == 'Sandstorm':
			mins += 10
		
		# some missions take more time to move
		if self.mission == 'Amphibious Assault':
			mins += 15
		
		# check for active support request flag(s) when moving into enemy or neutral zone
		if self.map_hexes[(hx2,hy2)].controlled_by in [1, 2]:
			
			support_time = 0
			ad_hoc = False
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Ad Hoc'):
				ad_hoc = True
			
			if self.arty_support_request:
				if ad_hoc:
					time_req = 10
				else:
					time_req = 15
				if not self.hq_radio_comms:
					time_req += 10
				if time_req > support_time:
					support_time = time_req
			if self.air_support_request:
				if ad_hoc:
					time_req = 5
				else:
					time_req = 10
				if not self.hq_radio_comms:
					time_req += 10
				if time_req > support_time:
					support_time = time_req
			if self.unit_support_request:
				if ad_hoc:
					time_req = 10
				else:
					time_req = 15
				if not self.hq_radio_comms:
					time_req += 10
				if time_req > support_time:
					support_time = time_req
			
			if support_time > 0:
				mins += support_time
				
		return mins
		
	
	# increments one of the combat day records, also increments campaign record
	def AddRecord(self, name, i):
		
		# compatibility check
		if name == 'Engagements Fought' and name not in self.records:
			self.records[name] = self.records['Battles Fought']
		if name == 'Engagements Fought' and name not in campaign.records:
			campaign.records[name] = campaign.records['Battles Fought']
		
		self.records[name] += i
		campaign.records[name] += i
	
	
	# generate a new random set of initial weather conditions, should only be called when day is created
	def GenerateWeather(self):
		
		# determine current calendar season
		weather_odds_dict = session.regions[campaign.stats['region']]['season_weather_odds']
		date = campaign.today[campaign.today.find('.') + 1:]
		
		for season, value in weather_odds_dict.items():
			if date <= value['end_date']:
				break
		else:
			# catch cases where date is late in the calendar year
			if campaign.stats['region'] == 'Southeast Asia':
				season = 'Northeast Monsoon'
			elif campaign.stats['region'] == 'South Pacific':
				season = 'Wet Season'
			else:
				season = 'Winter'
		
		self.weather['Season'] = season
		
		### modify actual odds based on time to previous/next season ###
		if season == 'Winter':
			previous_season = 'Autumn'
			next_season = 'Spring'
		elif season == 'Spring':
			previous_season = 'Winter'
			next_season = 'Summer'
		elif season == 'Summer':
			previous_season = 'Spring'
			next_season = 'Autumn'
		elif season == 'Autumn':
			previous_season = 'Summer'
			next_season = 'Winter'
		
		# Southeast Asian seasons
		elif season == 'Northeast Monsoon':
			previous_season = 'Southwest Monsoon'
			next_season = 'Intermonsoon'
		elif season == 'Intermonsoon':
			previous_season = 'Northeast Monsoon'
			next_season = 'Southwest Monsoon'
		elif season == 'Southwest Monsoon':
			previous_season = 'Intermonsoon'
			next_season = 'Northeast Monsoon'
		
		# South Pacific seasons
		elif season == 'Dry Season':
			previous_season = 'Wet Season'
			next_season = 'Wet Season'
		elif season == 'Wet Season':
			previous_season = 'Dry Season'
			next_season = 'Dry Season'
		
		# determine how close current date is to the previous or the next seasonal transition date
		previous_transition = weather_odds_dict[previous_season]['end_date']
		next_transition = weather_odds_dict[season]['end_date']
		
		# add years
		# need to skip back a year
		if previous_transition > date:
			previous_transition = str(int(campaign.today.split('.')[0])-1) + '.' + previous_transition
		else:
			previous_transition = campaign.today.split('.')[0] + '.' + previous_transition
		
		# need to skip forward a year
		if next_transition < date:
			next_transition = str(int(campaign.today.split('.')[0])+1) + '.' + next_transition
		else:
			next_transition = campaign.today.split('.')[0] + '.' + next_transition
		
		(year1, month1, day1) = previous_transition.split('.')
		(year2, month2, day2) = campaign.today.split('.')
		(year3, month3, day3) = next_transition.split('.')
		a = datetime(int(year1), int(month1), int(day1), 0, 0, 0)
		b = datetime(int(year2), int(month2), int(day2), 0, 0, 0)
		c = datetime(int(year3), int(month3), int(day3), 0, 0, 0)
		days_since = (b-a).days
		total_days = (c-a).days
		
		# grab the base odds
		weather_odds = weather_odds_dict[season]
		
		delta = days_since / total_days
		compare_season = session.regions[campaign.stats['region']]['season_weather_odds'][next_season]
		
		if 0.0 < delta < 1.0:
			for weather_key in ['ground_conditions', 'temperature', 'cloud_cover', 'precipitation']:
				for k, v in weather_odds[weather_key].items():
					mod = compare_season[weather_key][k] - weather_odds[weather_key][k]
					if mod == 0.0: continue
					mod = mod * delta
					weather_odds[weather_key][k] = round(weather_odds[weather_key][k] + mod, 1)
		
		# special exception to avoid snow in summer
		if season == 'Summer':
			weather_odds['ground_conditions']['Snow'] = 0.0
			weather_odds['ground_conditions']['Deep Snow'] = 0.0
			weather_odds['precipitation']['Light Snow'] = 0.0
			weather_odds['precipitation']['Snow'] = 0.0
			weather_odds['precipitation']['Blizzard'] = 0.0
		
		# roll for ground cover
		self.weather['Ground'] = None
		roll = GetPercentileRoll()
		for result, chance in weather_odds['ground_conditions'].items():
			if chance == 0.0: continue
			if result == 'Deep Snow' and self.rattenkrieg:
				continue
			if roll <= chance:
				self.weather['Ground'] = result
				break
			roll -= chance
		
		# choose first possible result as default
		if self.weather['Ground'] == None:
			for result, chance in weather_odds['ground_conditions'].items():
				if chance > 0.0:
					self.weather['Ground'] = result
					break
		
		# roll for temperature
		self.weather['Temperature'] = None
		roll = GetPercentileRoll()
		for result, chance in weather_odds['temperature'].items():
			if chance == 0.0: continue
			if roll <= chance:
				self.weather['Temperature'] = result
				break
			roll -= chance
		if self.weather['Temperature'] == None:
			for result, chance in weather_odds['temperature'].items():
				if chance > 0.0:
					self.weather['Temperature'] = result
					break
		
		# roll for cloud cover
		self.weather['Cloud Cover'] = None
		roll = GetPercentileRoll()
		for result, chance in weather_odds['cloud_cover'].items():
			if chance == 0.0: continue
			if roll <= chance:
				self.weather['Cloud Cover'] = result
				break
			roll -= chance
		if self.weather['Cloud Cover'] == None:
			for result, chance in weather_odds['cloud_cover'].items():
				if chance > 0.0:
					self.weather['Cloud Cover'] = result
					break
		
		# roll for precipitation
		roll = GetPercentileRoll()
		for result, chance in weather_odds['precipitation'].items():
			
			if chance == 0.0: continue
			
			# don't allow rain if extreme hot
			if self.weather['Temperature'] == 'Extreme Hot' and result != 'Sandstorm':
				continue
			
			# only allow snow if weather is cold
			if result in ['Light Snow', 'Snow', 'Blizzard'] and self.weather['Temperature'] not in ['Extreme Cold', 'Cold']:
				roll -= chance
				continue
			# only allow rain if weather is warm
			if result in ['Rain', 'Heavy Rain'] and self.weather['Temperature'] in ['Extreme Cold', 'Cold']:
				roll -= chance
				continue
			
			if roll <= chance:
				self.weather['Precipitation'] = result
				break
			roll -= chance
		else:
			self.weather['Precipitation'] = 'None'
		
		# roll for wind
		roll = GetPercentileRoll()
		if roll <= 50.0:
			self.weather['Wind'] = 0
		elif roll <= 75.0:
			self.weather['Wind'] = 1
		elif roll <= 95.0:
			self.weather['Wind'] = 2
		else:
			self.weather['Wind'] = 3
		
		# if precipitation has been rolled, fix clear cloud cover
		if self.weather['Precipitation'] != 'None' and self.weather['Cloud Cover'] == 'Clear':
			self.weather['Cloud Cover'] = choice(['Scattered', 'Heavy', 'Overcast'])
		
		# if extreme cold, fix ground conditions
		if self.weather['Temperature'] == 'Extreme Cold' and self.weather['Ground'] in ['Wet', 'Muddy']:
			self.weather['Ground'] = 'Dry'
		
		# check for stormy conditions
		if self.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
			roll = GetPercentileRoll()
			if roll <= 5.0:
				self.weather['Storm'] = True
				self.weather['Wind'] += 1
				if self.weather['Wind'] > 3:
					self.weather['Wind'] = 3
		
		# fog level: 0-3
		self.weather['Fog'] = 0
		if campaign.stats['region'] not in ['North Africa', 'South Pacific', 'Southeast Asia'] and self.weather['Cloud Cover'] != 'Clear' and self.weather['Temperature'] in ['Cold', 'Mild', 'Warm']:
			
			roll = GetPercentileRoll()
			
			if self.weather['Precipitation'] in ['Snow', 'Blizzard']:
				roll -= 40.0
			elif self.weather['Season'] in ['Spring', 'Autumn']:
				roll += 10.0
			if self.weather['Ground'] in ['Wet', 'Muddy']:
				roll += 20.0
			
			if roll <= 80.0:
				self.weather['Fog'] = 0
			elif roll <= 93.0:
				self.weather['Fog'] = 1
			elif roll <= 98.0:
				self.weather['Fog'] = 2
			else:
				self.weather['Fog'] = 3
		
		# set first weather update countdown
		self.weather_update_clock = BASE_WEATHER_UPDATE_CLOCK + (libtcod.random_get_int(0, 1, 16))
	
	
	# update weather conditions, possibly changing them
	def UpdateWeather(self):
		
		# reset update clock
		self.weather_update_clock = BASE_WEATHER_UPDATE_CLOCK + (libtcod.random_get_int(0, 1, 16))
		
		# 1.2.0 compatibility check
		if self.weather['Season'] not in session.regions[campaign.stats['region']]['season_weather_odds']:
			self.GenerateWeather()
		
		# get weather odds for region
		weather_odds_dict = session.regions[campaign.stats['region']]['season_weather_odds'][self.weather['Season']]
		
		# check for ground condition update
		roll = GetPercentileRoll()
		
		# muddy ground drying out or freezing
		if self.weather['Ground'] == 'Muddy':
			if self.weather['Temperature'] == 'Extreme Cold':
				self.weather['Ground'] = 'Dry'
				ShowMessage('The ground has frozen solid.')
			else:
				if self.weather['Precipitation'] == 'None':
					if self.weather['Wind'] > 0:
						roll -= 10.0
					if roll <= GROUND_CONDITION_CHANGE_CHANCE:
						self.weather['Ground'] = 'Wet'
						ShowMessage('The muddy ground has dried out a little.')
		
		# wet ground drying out
		elif self.weather['Ground'] == 'Wet':
			if self.weather['Temperature'] == 'Extreme Cold':
				self.weather['Ground'] = 'Dry'
				ShowMessage('The ground has frozen solid.')
			else:
				if self.weather['Precipitation'] == 'None':
					if self.weather['Wind'] > 0:
						roll -= 10.0
					if roll <= GROUND_CONDITION_CHANGE_CHANCE:
						self.weather['Ground'] = 'Dry'
						ShowMessage('The ground has completely dried out.')
				elif self.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
					if self.weather['Precipitation'] == 'Heavy Rain':
						roll -= HEAVY_PRECEP_MOD
					if roll <= GROUND_CONDITION_CHANGE_CHANCE:
						self.weather['Ground'] = 'Muddy'
						ShowMessage('The ground has become muddy.')
		
		# snowy ground deepening
		elif self.weather['Ground'] == 'Snow':
			if self.weather['Precipitation'] in ['Snow', 'Blizzard']:
				if self.weather['Precipitation'] == 'Blizzard':
					roll -= HEAVY_PRECEP_MOD
				if roll <= GROUND_CONDITION_CHANGE_CHANCE and not self.rattenkrieg:
					self.weather['Ground'] = 'Deep Snow'
					ShowMessage('The snow has accumulated and is now deep.')
		
		# dry ground - can get wet or snowy
		elif self.weather['Ground'] != 'Deep Snow':
			if self.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
				if self.weather['Precipitation'] == 'Heavy Rain':
					roll -= HEAVY_PRECEP_MOD
				if roll <= GROUND_CONDITION_CHANGE_CHANCE:
					self.weather['Ground'] = 'Wet'
					ShowMessage('The ground has become wet.')
			elif self.weather['Precipitation'] in ['Snow', 'Blizzard']:
				if self.weather['Precipitation'] == 'Blizzard':
					roll -= HEAVY_PRECEP_MOD
				if roll <= GROUND_CONDITION_CHANGE_CHANCE:
					self.weather['Ground'] = 'Snow'
					ShowMessage('The ground is now covered in snow.')
					
					# update map consoles to reflect new ground cover
					campaign_day.UpdateCDMapCon()
					if scenario is not None:
						scenario.UpdateHexmapCon()
		
		# fog dissipation check
		if self.weather['Fog'] > 0:
			
			roll = GetPercentileRoll()
			
			# apply cloud cover modifier to roll
			if self.weather['Cloud Cover'] == 'Clear':
				roll -= 60.0
			elif self.weather['Cloud Cover'] == 'Scattered':
				roll -= 35.0
			elif self.weather['Cloud Cover'] == 'Heavy':
				roll -= 20.0
			else:
				roll += 10.0
			
			if self.weather['Wind'] == 1:
				roll -= 10.0
			elif self.weather['Wind'] > 1:
				roll -= 25.0
			
			if self.weather['Precipitation'] != 'None':
				roll -= 20.0
			
			if roll <= 20.0:
				if self.weather['Fog'] == 1:
					self.weather['Fog'] = 0
					ShowMessage('The fog has completely cleared.')
				elif self.weather['Fog'] == 2:
					self.weather['Fog'] = 1
					ShowMessage('The fog thins out a little.')
				elif self.weather['Fog'] == 3:
					self.weather['Fog'] = 2
					ShowMessage('The fog thins out somewhat.')
				
				if scenario is not None:
					scenario.UpdateHexmapCon()
			
		
		# roll to see weather change takes place
		if GetPercentileRoll() > 15.0: return
		
		# roll for possible type of weather change
		roll = GetPercentileRoll()
		
		# change in wind level
		if roll <= 4.0:
			if self.weather['Wind'] == 0:
				self.weather['Wind'] = 1
				ShowMessage('The wind begins to pick up a little bit.')
			elif self.weather['Wind'] == 3:
				self.weather['Wind'] = 2
				ShowMessage('The wind has died down a little.')
			else:
				roll = GetPercentileRoll()
				if roll <= 50.0:
					if self.weather['Wind'] == 1:
						self.weather['Wind'] = 0
						ShowMessage('The wind has completely stopped.')
					else:
						self.weather['Wind'] -= 1
						ShowMessage('The wind has died down a little.')
				else:
					self.weather['Wind'] += 1
					ShowMessage('The wind has picked up a little.')
		
		# change in precipitation level
		elif roll <= 70.0:
			
			# no change possible
			if self.weather['Cloud Cover'] == 'Clear':
				return
			
			roll = GetPercentileRoll()
			
			if self.weather['Precipitation'] == 'None':
				
				if self.weather['Temperature'] in ['Cold', 'Extreme Cold']:
					
					if roll <= weather_odds_dict['precipitation']['Light Snow']:
						self.weather['Precipitation'] = 'Light Snow'
						ShowMessage('Light snow begins to fall.')
					elif roll <= weather_odds_dict['precipitation']['Snow']:
						self.weather['Precipitation'] = 'Snow'
						ShowMessage('Snow begins to fall.')
					else:
						return
				else:
					
					if roll <= weather_odds_dict['precipitation']['Mist']:
						self.weather['Precipitation'] = 'Mist'
						ShowMessage('A light mist begins to fall.')
					elif roll <= weather_odds_dict['precipitation']['Rain']:
						self.weather['Precipitation'] = 'Rain'
						ShowMessage('Rain begins to fall.')
					elif roll <= weather_odds_dict['precipitation']['Heavy Rain']:
						self.weather['Precipitation'] = 'Heavy Rain'
						ShowMessage('A heavy downpour suddenly begins to fall.')
					else:
						return
			
			elif self.weather['Precipitation'] == 'Mist':
				if roll <= 40.0:
					self.weather['Precipitation'] = 'None'
					ShowMessage('The light mist has cleared up.')
				elif roll <= weather_odds_dict['precipitation']['Rain']:
					self.weather['Precipitation'] = 'Rain'
					ShowMessage('The light mist thickens into a steady rain.')
				elif roll <= weather_odds_dict['precipitation']['Heavy Rain']:
					self.weather['Precipitation'] = 'Heavy Rain'
					ShowMessage('The light mist suddenly turns into a heavy downpour.')
				else:
					return
			
			elif self.weather['Precipitation'] == 'Rain':
				if roll <= 30.0:
					self.weather['Precipitation'] = 'None'
					ShowMessage('The rain has cleared up.')
				elif roll <= weather_odds_dict['precipitation']['Mist']:
					self.weather['Precipitation'] = 'Mist'
					ShowMessage('The rain turns into a light mist.')
				elif roll <= weather_odds_dict['precipitation']['Heavy Rain']:
					self.weather['Precipitation'] = 'Heavy Rain'
					ShowMessage('The rain gets heavier.')
				else:
					return
			
			elif self.weather['Precipitation'] == 'Heavy Rain':
				if roll <= weather_odds_dict['precipitation']['Mist']:
					self.weather['Precipitation'] = 'Mist'
					ShowMessage('The rain turns into a light mist.')
				elif roll <= weather_odds_dict['precipitation']['Rain']:
					self.weather['Precipitation'] = 'Rain'
					ShowMessage('The rain lightens a little.')
				else:
					return

			elif self.weather['Precipitation'] == 'Light Snow':
				if roll <= 30.0:
					self.weather['Precipitation'] = 'None'
					ShowMessage('The snow stops falling.')
				elif roll <= weather_odds_dict['precipitation']['Snow']:
					self.weather['Precipitation'] = 'Snow'
					ShowMessage('The snow gets a little heavier.')
				elif roll <= weather_odds_dict['precipitation']['Blizzard']:
					self.weather['Precipitation'] = 'Blizzard'
					ShowMessage('The snow starts falling very heavily.')
				else:
					return
			
			elif self.weather['Precipitation'] == 'Snow':
				if roll <= 20.0:
					self.weather['Precipitation'] = 'None'
					ShowMessage('The snow stops falling.')
				elif roll <= weather_odds_dict['precipitation']['Light Snow']:
					self.weather['Precipitation'] = 'Light Snow'
					ShowMessage('The snow gets a little lighter.')
				elif roll <= weather_odds_dict['precipitation']['Blizzard']:
					self.weather['Precipitation'] = 'Blizzard'
					ShowMessage('The snow starts falling very heavily.')
				else:
					return
			
			elif self.weather['Precipitation'] == 'Blizzard':
				if roll <= weather_odds_dict['precipitation']['Light Snow']:
					self.weather['Precipitation'] = 'Light Snow'
					ShowMessage('The snow gets quite a bit lighter.')
				elif roll <= weather_odds_dict['precipitation']['Snow']:
					self.weather['Precipitation'] = 'Snow'
					ShowMessage('The snow gets a bit lighter.')
				else:
					return
			
			elif self.weather['Precipitation'] == 'Sandstorm':
				if roll <= 2.0:
					self.weather['Precipitation'] = 'None'
					ShowMessage('The sandstorm suddenly passes.', good_news=True)
				else:
					return
			
			# update animations
			self.InitAnimations()
			if scenario is not None:
				scenario.InitAnimations()
		
		# fog possibly arrives
		elif roll <= 75.0:
			if campaign.stats['region'] == 'North Africa': return
			if self.weather['Fog'] > 0: return
			if self.weather['Cloud Cover'] == 'Clear' or self.weather['Temperature'] not in ['Cold', 'Mild', 'Warm']: return
			
			roll = GetPercentileRoll()
			
			if self.weather['Precipitation'] in ['Snow', 'Blizzard']:
				roll += 10.0
			if self.weather['Season'] in ['Spring', 'Autumn']:
				roll -= 10.0
			if self.weather['Ground'] in ['Wet', 'Muddy']:
				roll -= 5.0
			
			if roll <= 25.0:	
				self.weather['Fog'] = 1
				ShowMessage('A light fog spreads across the area.')
				if scenario is not None:
					scenario.UpdateHexmapCon()
		
		# change in cloud level
		else:
			
			if weather_odds_dict['cloud_cover']['Heavy'] == 0.0: return
			
			roll = GetPercentileRoll()
			
			if self.weather['Cloud Cover'] == 'Clear':
				if roll <= 85.0:
					self.weather['Cloud Cover'] = 'Scattered'
					ShowMessage('Scattered clouds begin to form.')
				else:
					self.weather['Cloud Cover'] = 'Heavy'
					ShowMessage('A heavy cloud front rolls in.')
			
			elif self.weather['Cloud Cover'] == 'Scattered':
				if roll <= 75.0:
					self.weather['Cloud Cover'] = 'Clear'
					ShowMessage('The clouds part and the sky is clear.')
				elif roll <= 90.0:
					self.weather['Cloud Cover'] = 'Heavy'
					ShowMessage('The cloud cover gets thicker.')
				else:
					self.weather['Cloud Cover'] = 'Overcast'
					ShowMessage('The clouds thicken very quickly and become overcast.')
			
			elif self.weather['Cloud Cover'] == 'Heavy':
				if roll <= 85.0:
					self.weather['Cloud Cover'] = 'Scattered'
					ShowMessage('The clouds begin to thin out.')
				else:
					self.weather['Cloud Cover'] = 'Overcast'
					ShowMessage('The cloud cover thickens.')
			
			# overcast
			else:
				self.weather['Cloud Cover'] = 'Heavy'
				ShowMessage('The cloud cover begins to thin out but remains heavy.')
			
			# stop any precipitation if clouds have cleared up
			if self.weather['Cloud Cover'] == 'Clear' and self.weather['Precipitation'] != 'None':
				self.weather['Precipitation'] = 'None'
				
				# stop animation
				self.InitAnimations()
				if scenario is not None:
					scenario.InitAnimations()
		
		# check for change in storm status
		if self.weather['Storm']:
			if self.weather['Precipitation'] not in ['Rain', 'Heavy Rain']:
				self.weather['Storm'] = False
		else:
			if self.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
				if GetPercentileRoll() <= 1.0:
					self.weather['Storm'] = True

	# check for failure or completion of Hold objectives
	def CheckHoldObjectives(self):
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if self.map_hexes[(hx,hy)].objective is None: continue
			if self.map_hexes[(hx,hy)].objective['type'] != 'Hold': continue
			(hour, minute) = self.map_hexes[(hx,hy)].objective['hold_until']
			if self.day_clock['hour'] > hour or (self.day_clock['hour'] == hour and self.day_clock['minute'] >= minute):
				
				# still enemy held
				if self.map_hexes[(hx,hy)].controlled_by == 1:
					
					# if player is present in zone, give them time to capture it before the day is up
					if self.player_unit_location == (hx, hy):
						continue
					
					ShowMessage('You failed a Hold objective.', cd_highlight=(hx, hy),
						good_news=False)
				else:
					ShowTutorialSlide('campaign_day_completed_objective')
					ShowMessage('You completed a Hold objective!', cd_highlight=(hx, hy),
						good_news=True) 
					self.day_vp += self.map_hexes[(hx,hy)].objective['vp_reward']
				
				# clear objective
				self.map_hexes[(hx,hy)].objective = None


	# advance the current campaign day time, check for end of day, and also weather conditions update
	def AdvanceClock(self, hours, minutes, skip_checks=False):
		self.day_clock['hour'] += hours
		self.day_clock['minute'] += minutes
		while self.day_clock['minute'] >= 60:
			self.day_clock['hour'] += 1
			self.day_clock['minute'] -= 60
		
		if skip_checks: return
		
		# check for hold objective completion
		if scenario is None:
			self.CheckHoldObjectives()
		
		self.CheckForEndOfDay()
		
		# check for weather update
		self.weather_update_clock -= hours * 60
		self.weather_update_clock -= minutes
		
		if self.weather_update_clock <= 0:
			# check for weather conditions change, update relevant consoles
			self.UpdateWeather()
			self.UpdateCDCommandCon()
			DisplayWeatherInfo(cd_weather_con)
			if scenario is not None:
				if scenario.init_complete:
					DisplayWeatherInfo(scen_weather_con)
		
	
	# sets flag if we've met or exceeded the set length of the combat day
	def CheckForEndOfDay(self):
		# day already ended
		if self.ended: return
		if self.day_clock['hour'] > self.end_of_day['hour']:
			self.ended = True
		if self.day_clock['hour'] == self.end_of_day['hour']:
			if self.day_clock['minute'] >= self.end_of_day['minute']:
				self.ended = True
	
	
	# roll for trigger of random Campaign Day event
	def CheckForRandomEvent(self):
		
		# don't trigger an event if day has already ended
		if self.ended: return
		
		# don't trigger if a scenario just started
		if scenario is not None: return
		
		if 'tutorial_campaign' in campaign.stats: return
		
		roll = GetPercentileRoll()
		if DEBUG:
			if session.debug['Always CD Random Event']:
				roll = 1.0
		
		# no event this time, increase chance for next time
		if roll > self.random_event_chance:
			self.random_event_chance += 2.0
			return
		
		# roll for type of event
		roll = GetPercentileRoll()
		
		# radio breaks down
		if roll <= 0.3:
			if not campaign.player_unit.has_radio: return
			if campaign.player_unit.radio_destroyed: return
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage('Your radio suddenly breaks down completely - it will need to be replaced at the end of the day.',
				longer_pause=True, good_news=False)
			campaign.player_unit.radio_damaged = False
			campaign.player_unit.radio_destroyed = True
			self.UpdateCommsStatus()
			self.UpdateCDCampaignCon()
			self.UpdateCDPlayerUnitCon()
			self.UpdateCDDisplay()
		
		# artillery creates craters / river floods 
		elif roll <= 1.0:
			
			if self.rattenkrieg:
				hex_list = []
				for (hx, hy) in self.map_hexes:
					map_hex = self.map_hexes[(hx,hy)]
					if 'impassible' in CD_TERRAIN_TYPES[map_hex.terrain_type]:
						continue
					if map_hex.objective is not None:
						if map_hex.objective['type'] == 'Convoy Attack':
							continue
					hex_list.append((hx, hy))
				
				if len(hex_list) == 0:
					return
				
				(hx, hy) = choice(hex_list)
				self.map_hexes[(hx, hy)].terrain_type = 'Craters'
				ShowMessage('Campaign Day Random Event!', no_log=True)
				self.UpdateCDMapCon()
				self.UpdateCDDisplay()
				ShowMessage('Intense artillery fire has turned an zone into craters.',
					cd_highlight=(hx,hy), longer_pause=False)
				
			else:
			
				hex_list = []
				for (hx, hy) in self.map_hexes:
					map_hex = self.map_hexes[(hx,hy)]
					good_hex = False
					
					if 'impassible' in CD_TERRAIN_TYPES[map_hex.terrain_type]:
						continue
					if map_hex.objective is not None:
						if map_hex.objective['type'] == 'Convoy Attack':
							continue
					
					if len(map_hex.rivers) > 0:
						good_hex = True
					else:
						for direction in range(6):
							(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
							if (hx2, hy2) not in CAMPAIGN_DAY_HEXES: continue
							if self.map_hexes[(hx2, hy2)].terrain_type in ['Water', 'Lake', 'Marsh']:
								good_hex = True
								break
					
					if good_hex:
						hex_list.append((hx, hy))
				
				if len(hex_list) == 0:
					return
				
				(hx, hy) = choice(hex_list)
				self.map_hexes[(hx, hy)].terrain_type = 'Marsh'
				ShowMessage('Campaign Day Random Event!', no_log=True)
				self.UpdateCDMapCon()
				self.UpdateCDDisplay()
				ShowMessage('A zone has flooded!', cd_highlight=(hx,hy),
					longer_pause=True, good_news=False)
		
		# enemy strength increases
		elif roll <= 30.0:
			hex_list = []
			for (hx, hy) in self.map_hexes:
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]: continue
				if self.map_hexes[(hx,hy)].controlled_by == 0: continue
				hex_list.append((hx, hy))
			
			if len(hex_list) == 0:
				return
			
			(hx, hy) = choice(hex_list)
			map_hex = self.map_hexes[(hx,hy)]
			
			map_hex.enemy_strength += libtcod.random_get_int(0, 1, 3)
			if map_hex.enemy_strength > 10:
				map_hex.enemy_strength = 10
			
			map_hex.GenerateStrengthAndUnits(self.mission, skip_strength=True)
			
			# don't show anything if zone not known to player
			if not map_hex.known_to_player: return
			
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage('We have reports of increased enemy strength in a zone!',
				cd_highlight=(hx,hy), longer_pause=True, good_news=False)
		
		# reveal enemy strength and units
		elif roll <= 40.0:
			
			hex_list = []
			for (hx, hy) in self.map_hexes:
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]: continue
				if self.map_hexes[(hx,hy)].controlled_by == 0: continue
				if self.map_hexes[(hx,hy)].known_to_player: continue
				if self.map_hexes[(hx,hy)].objective is not None: continue
				
				friendly_adjacent = False
				for direction in range(6):
					(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
					if (hx2, hy2) not in self.map_hexes: continue
					if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]: continue
					if self.map_hexes[(hx2,hy2)].controlled_by != 0: continue
					friendly_adjacent = True
					break
				
				if not friendly_adjacent:
					continue
				
				hex_list.append((hx, hy))
			
			if len(hex_list) == 0:
				return
			
			(hx, hy) = choice(hex_list)
			self.map_hexes[(hx,hy)].known_to_player = True
			
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage('We have received information about expected enemy presence in an area.',
				cd_highlight=(hx,hy), longer_pause=True)
		
		# loss of recon knowledge and possible change in strength/enemy units
		elif roll <= 60.0:
			
			hex_list = []
			for (hx, hy) in self.map_hexes:
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]: continue
				if self.map_hexes[(hx,hy)].controlled_by == 0: continue
				if not self.map_hexes[(hx,hy)].known_to_player: continue
				
				# never apply to a Convoy Attack objective
				if self.map_hexes[(hx,hy)].objective is not None:
					if self.map_hexes[(hx,hy)].objective['type'] == 'Convoy Attack':
						continue
				
				hex_list.append((hx, hy))
			
			if len(hex_list) == 0:
				return
			
			(hx, hy) = choice(hex_list)
			map_hex = self.map_hexes[(hx,hy)]
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage('Enemy movement reported in a map zone, estimated strength no longer certain.',
				cd_highlight=(hx,hy), longer_pause=True)
			map_hex.GenerateStrengthAndUnits(self.mission)
		
		# decrease or increase a current support level
		elif roll <= 75.0:
			
			choices = []
			if 'air_support_level' in campaign.current_week:
				choices.append('air_support_level')
			if 'arty_support_level' in campaign.current_week:
				choices.append('arty_support_level')
			if 'unit_support_level' in campaign.current_week:
				choices.append('unit_support_level')
			
			if len(choices) == 0: return
			
			support_type = choice(choices)
			
			if GetPercentileRoll() <= 95.0:
			
				text = 'Additional '
				if support_type == 'air_support_level':
					text += 'air'
					self.air_support_level += (5.0 * float(libtcod.random_get_int(0, 2, 5)))
					# make sure does not go beyond 100%
					if self.air_support_level > 100.0:
						self.air_support_level = 100.0
				elif support_type == 'arty_support_level':
					text += 'artillery'
					self.arty_support_level += (5.0 * float(libtcod.random_get_int(0, 2, 5)))
					if self.arty_support_level > 100.0:
						self.arty_support_level = 100.0
				else:
					text += 'unit'
					self.unit_support_level += (5.0 * float(libtcod.random_get_int(0, 2, 5)))
					if self.unit_support_level > 100.0:
						self.unit_support_level = 100.0
				
				text += ' support has made available to you from Command.'
			
			else:
				text = 'Bad news! Command reports that some of your '
				if support_type == 'air_support_level':
					text += 'air'
					self.air_support_level -= (5.0 * float(libtcod.random_get_int(0, 1, 3)))
					if self.air_support_level < 0.0:
						self.air_support_level = 0.0
					
				elif support_type == 'arty_support_level':
					text += 'artillery'
					self.arty_support_level -= (5.0 * float(libtcod.random_get_int(0, 1, 3)))
					if self.arty_support_level < 0.0:
						self.arty_support_level = 0.0
				else:
					text += 'unit'
					self.unit_support_level -= (5.0 * float(libtcod.random_get_int(0, 1, 3)))
					if self.unit_support_level < 0.0:
						self.unit_support_level = 0.0
				
				text += ' support has been redirected elsewhere.'
			
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage(text, longer_pause=True)
		
		# crewmen lose fatigue points
		elif roll <= 85.0:
			for position in campaign.player_unit.positions_list:
				if position.crewman is None: continue
				if not position.crewman.alive: continue
				position.crewman.fatigue -= int(position.crewman.stats['Morale'] / 2)
				if position.crewman.fatigue < BASE_FATIGUE:
					position.crewman.fatigue = BASE_FATIGUE
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage('Your crew feel a little less fatigued than before.',
				longer_pause=True, good_news=True)
		
		# possible new squadmate(s)
		elif roll <= 88.0:
			if campaign.player_squad_max == 0: return
			if len(self.player_squad) == campaign.player_squad_max: return
			ShowMessage('Campaign Day Random Event!', no_log=True)
			ShowMessage('You encounter some units that have been separated from their group, and they join your squad for the rest of the day!',
				longer_pause=True, good_news=True)
			self.SpawnPlayerSquad()
		
		# landmines discovered/cleared
		elif roll <= 94.0:
			if 'landmines_chance' not in campaign.current_week: return
			
			# landmines removed
			if GetPercentileRoll() <= 50.0:
				hex_list = []
				for (hx, hy) in CAMPAIGN_DAY_HEXES:
					if self.map_hexes[(hx,hy)].landmines:
						hex_list.append((hx, hy))
				if len(hex_list) == 0: return
				(hx, hy) = choice(hex_list)
				self.map_hexes[(hx,hy)].landmines = False
				ShowMessage('Campaign Day Random Event!', no_log=True)
				self.UpdateCDMapCon()
				self.UpdateCDDisplay()
				ShowMessage('Command reports that the landmines in this zone have been cleared.',
					cd_highlight=(hx, hy), longer_pause=True, good_news=True)
				return
			
			# landmines added
			hex_list = CAMPAIGN_DAY_HEXES.copy()
			shuffle(hex_list)
			for (hx, hy) in hex_list:
				if self.map_hexes[(hx,hy)].landmines: continue
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]:
					continue
				self.map_hexes[(hx,hy)].landmines = True
				ShowMessage('Campaign Day Random Event!', no_log=True)
				self.UpdateCDMapCon()
				self.UpdateCDDisplay()
				ShowMessage('Command reports that landmines have been discovered in this zone!',
					cd_highlight=(hx, hy), longer_pause=True, good_news=False)
				return
		
		# no other random events
		else:
			return
		
		# random event finished: reset random event chance, update consoles and screen
		self.random_event_chance = BASE_CD_RANDOM_EVENT_CHANCE
		self.UpdateCDUnitCon()
		self.UpdateCDControlCon()
		self.UpdateCDGUICon()
		self.UpdateCDCommandCon()
		self.UpdateCDHexInfoCon()
		self.UpdateCDDisplay()
	
	
	# check for zone capture/loss
	# if last player action was 'capture_zone', then the player's own zone won't be selected as one that
	# the enemy captures
	def CheckForZoneCapture(self, last_player_action):
		
		global scenario
		
		# don't trigger zone capture checks if day has already ended
		if self.ended: return
		
		# get player location
		(player_hx, player_hy) = self.player_unit_location
		
		# set modifiers for base odds of enemy/friendly zone capture
		if campaign_day.mission == 'Advance':
			friendly_multiplier = 3.0
			enemy_multipler = 0.3
		elif campaign_day.mission == 'Spearhead':
			friendly_multiplier = 0.5
			enemy_multipler = 0.2
		elif campaign_day.mission == 'Battle':
			friendly_multiplier = 1.0
			enemy_multipler = 1.0
		elif campaign_day.mission == 'Major Battle':
			friendly_multiplier = 2.0
			enemy_multipler = 2.0
		elif campaign_day.mission == 'Fighting Withdrawal':
			friendly_multiplier = 0.0
			enemy_multipler = 2.0
		elif campaign_day.mission == 'Counterattack':
			friendly_multiplier = 0.3
			enemy_multipler = 3.0
		elif campaign_day.mission == 'Hold the Line':
			friendly_multiplier = 0.2
			enemy_multipler = 1.2
		elif campaign_day.mission == 'Patrol':
			friendly_multiplier = 0.1
			enemy_multipler = 0.1
		elif campaign_day.mission == 'Urban Assault':
			friendly_multiplier = 0.5
			enemy_multipler = 0.25
		elif campaign_day.mission == 'Urban Defense':
			friendly_multiplier = 0.25
			enemy_multipler = 3.0
		elif campaign_day.mission == 'Amphibious Assault':
			friendly_multiplier = 0.7
			enemy_multipler = 0.4
		# no other missions for now
		else:
			return
		
		# build a list of hex zones that are liable to be captured, plus odds of their capture
		hex_list = []
		for (hx, hy) in self.map_hexes:
			
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]:
				continue
			
			# skip if player present and just captured this zone
			if last_player_action == 'capture_zone':
				if hx == player_hx and hy == player_hy:
					continue
			
			# skip if player present and 'never scenario' debug flag is on
			if DEBUG:
				if hx == player_hx and hy == player_hy:
					if session.debug['Never Scenario']:
						continue
			
			# skip objective hexes other than Hold/Rescue objectives
			if self.map_hexes[(hx,hy)].objective is not None:
				if self.map_hexes[(hx,hy)].objective['type'] not in ['Hold', 'Rescue']:
					continue
			
			map_hex = self.map_hexes[(hx,hy)]
			
			# Hold the Line - friendly units won't capture hexrows above 1
			if campaign_day.mission == 'Hold the Line' and map_hex.controlled_by == 1:
				if hy < 1: continue
			
			# determine number of adjacent hexes held by other side
			adjacent_enemy_hexes = 0
			edge_adjacent = False
			for direction in range(6):
				(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
				if (hx2, hy2) not in self.map_hexes:
					edge_adjacent = True
					continue
				
				# impassable hex
				if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]:
					continue
				
				if self.map_hexes[(hx2,hy2)].controlled_by != map_hex.controlled_by:
					
					# if river crossing, chance that this one doesn't count
					if self.RiverCrossing(hx, hy, hx2, hy2):
						if GetPercentileRoll() <= 75.0:
							continue
					adjacent_enemy_hexes += 1
			
			# zones on top/bottom row automatically count as bordering two enemy hexes
			# if held by other side
			if campaign_day.mission in ['Fighting Withdrawal', 'Counterattack', 'Urban Defense', 'Hold the Line']:
				if hy == 0 and map_hex.controlled_by == 0:
					adjacent_enemy_hexes += 2
			elif campaign_day.mission in ['Advance', 'Spearhead', 'Battle', 'Major Battle', 'Patrol', 'Urban Assault']:
				if hy == 8 and map_hex.controlled_by == 1:
					adjacent_enemy_hexes += 2
			
			if adjacent_enemy_hexes == 0: continue
			
			# enemy-held zone has been cut off
			if adjacent_enemy_hexes == 6 and map_hex.controlled_by == 1:
				if not campaign_day.rattenkrieg:
					map_hex.enemy_strength = int(map_hex.enemy_strength / 2)
					if map_hex.enemy_strength < 1:
						map_hex.enemy_strength = 1
			
			# add the hex to list of possible capture targets
			hex_list.append((hx, hy, adjacent_enemy_hexes))
			
		if len(hex_list) == 0:
			return
		
		# roll for each possible captured hex zone
		shuffle(hex_list)
		capture_list = []
		friendly_captures = 0
		enemy_captures = 0
		for (hx, hy, adjacent_enemy_hexes) in hex_list:
			
			odds = adjacent_enemy_hexes * CD_ZONE_CAPTURE_CHANCE
			
			if self.map_hexes[(hx,hy)].controlled_by == 0:
				odds = round(odds * enemy_multipler, 1)
			else:
				odds = round(odds * friendly_multiplier, 1)
			
			# modify final odds by last player action that triggered this check
			if last_player_action == 'recon':
				odds = round(odds * 0.03, 1)
			elif last_player_action == 'wait':
				odds = round(odds * 1.3, 1)
			elif last_player_action == 'quick_move':
				odds = round(odds * 0.5, 1)
			elif last_player_action == 'slow_move':
				odds = round(odds * 0.85, 1)
			
			# during Fighting Withdrawl, any zones above the player's current location will automatically be captured
			if campaign_day.mission == 'Fighting Withdrawal' and hy < player_hy:
				if self.map_hexes[(hx,hy)].controlled_by == 0:
					odds = 100.0
				elif self.map_hexes[(hx,hy)].controlled_by == 1:
					odds = -100.0
			
			if GetPercentileRoll() > odds: continue
			
			capture_list.append((hx, hy))
			
			# skip for now if this is player location
			if (hx, hy) == self.player_unit_location:
				if last_player_action == 'recon':
					break
				continue
			
			# friendly hex zone captured
			if self.map_hexes[(hx,hy)].controlled_by == 0:
				self.map_hexes[(hx,hy)].CaptureMe(1)
				enemy_captures += 1
				
			# enemy hex zone captured
			else:
				self.map_hexes[(hx,hy)].CaptureMe(0, no_vp=True)
				friendly_captures += 1
			
			# if after recon action, only allow maximum one capture
			if last_player_action == 'recon':
				if enemy_captures > 0 or friendly_captures > 0:
					break
				
		# show messages for captured zones
		if enemy_captures > 0:
			self.UpdateCDControlCon()
			self.UpdateCDDisplay()
			libtcod.console_flush()
			ShowTutorialSlide('campaign_day_zone_capture')
			if enemy_captures == 1:
				ShowMessage('Enemy forces have captured a friendly-held zone!',
					good_news=False)
			else:
				ShowMessage('Enemy forces have captured multiple friendly-held zones!',
					good_news=False)
		
		if friendly_captures > 0:
			self.UpdateCDControlCon()
			self.UpdateCDDisplay()
			libtcod.console_flush()
			ShowTutorialSlide('campaign_day_zone_capture')
			if friendly_captures == 1:
				ShowMessage('Friendly forces have captured an enemy-held zone!',
					good_news=True) 
			else:
				ShowMessage('Friendly forces have captured multiple enemy-held zones!',
					good_news=True)

		# update visibility of adjacent zones
		self.map_hexes[self.player_unit_location].RevealAdjacentZones()

		# player zone was in the capture list, trigger a scenario
		if self.player_unit_location in capture_list:
			ShowTutorialSlide('campaign_day_attacked_in_zone')
			ShowMessage('Enemy forces have attacked your zone!', longer_pause=True,
				good_news=False)
			campaign.AddJournal('Enemy forces attacked our zone.')
			session.ModifySteamStat('attacked_in_zone', 1)
			DisplayLoadingMsg()
			map_hex = self.map_hexes[self.player_unit_location]
			scenario = Scenario(map_hex)
			self.AddRecord('Engagements Fought', 1)
		
		# update consoles and screen
		self.UpdateCDUnitCon()
		self.UpdateCDControlCon()
		self.UpdateCDGUICon()
		self.UpdateCDCommandCon()
		self.UpdateCDHexInfoCon()
		self.UpdateCDDisplay()
	
	
	# menu for restocking ammo for main guns on the player tank
	# is resupply is true, player is resupplying in the middle of a combat day
	def AmmoReloadMenu(self, resupply=False):
		
		# update the menu console and draw to screen
		def UpdateMenuCon():
			
			libtcod.console_clear(con)
			
			# window title
			libtcod.console_set_default_background(con, libtcod.dark_blue)
			libtcod.console_rect(con, 0, 1, WINDOW_WIDTH, 5, True, libtcod.BKGND_SET)
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print_ex(con, WINDOW_XM, 3, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Ammo Loading')
			
			# left column: description of ammo types available to current gun
			x = 1
			y = 8
			
			libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
			libtcod.console_print(con, x, y, 'Available Ammo Types')
			y += 3
			
			for ammo_type in weapon.stats['ammo_type_list']:
				
				if ammo_type not in AMMO_DESCRIPTIONS: continue
				
				(text1, text2) = AMMO_DESCRIPTIONS[ammo_type]
				libtcod.console_set_default_foreground(con, libtcod.white)
				
				lines = wrap(text1 + ' (' + ammo_type + ')', 26)
				for line in lines:
					libtcod.console_print(con, x, y, line)
					y += 1
				
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				lines = wrap(text2, 27)
				for line in lines:
					libtcod.console_print(con, x+1, y, line)
					y += 1
				
				# rare ammo type, not yet available
				if ammo_type in weapon.rare_ammo_na:
					libtcod.console_set_default_foreground(con, libtcod.light_red)
					libtcod.console_print(con, x, y, '(Not Yet Available)')
					y += 1
				
				# rare or otherwise limited ammo type
				elif ammo_type in weapon.rare_ammo:
					libtcod.console_set_default_foreground(con, libtcod.light_blue)
					libtcod.console_print(con, x, y, '(Limited Availability)')
					y += 1
				
				y += 2
			
			# dividing line
			libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			libtcod.console_vline(con, 30, 8, 48)
			
			# player unit portrait
			x = 33
			y = 8
			libtcod.console_set_default_background(con, PORTRAIT_BG_COL)
			libtcod.console_rect(con, x, y, 25, 8, True, libtcod.BKGND_SET)
			
			DisplayUnitPortrait(con, x, y, campaign.player_unit, campaign.portrait_variant)
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			if campaign.player_unit.unit_name != '':
				PrintExtended(con, x, y, campaign.player_unit.unit_name)
			libtcod.console_set_default_background(con, libtcod.black)
			
			# list guns in gun list
			y = 17
			for gun in gun_list:
				if gun == weapon:
					libtcod.console_set_default_background(con, libtcod.dark_blue)
					libtcod.console_rect(con, WINDOW_XM-10, y, 20, 1, True, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
				libtcod.console_print_ex(con, WINDOW_XM, y, libtcod.BKGND_NONE,
					libtcod.CENTER, gun.GetStat('name'))
				y += 1
			
			
			# show current numerical values for each ammo type
			# also which type is currently selected
			x = 37
			y = 25
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_set_default_background(con, libtcod.darker_yellow)
			if not use_rr:
				libtcod.console_rect(con, x+9, y, 2, 1, False, libtcod.BKGND_SET)
			else:
				libtcod.console_rect(con, x+12, y, 2, 1, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			libtcod.console_print(con, x+9, y, 'ST')
			libtcod.console_print(con, x+12, y, 'RR')
			y += 1
			total_loaded = 0
			for ammo_type in weapon.stats['ammo_type_list']:
				if ammo_type in weapon.ammo_stores:
					
					# display amount remaining if limited supply
					if ammo_type in weapon.rare_ammo:
						
						# not yet available
						if ammo_type in weapon.rare_ammo_na:
							libtcod.console_print(con, x-4, y, 'N/A')
						else:
							amount = weapon.rare_ammo[ammo_type] - weapon.ammo_stores[ammo_type] - weapon.ready_rack[ammo_type]
							libtcod.console_set_default_foreground(con, AMMO_TYPE_COLOUR[ammo_type])
							libtcod.console_print(con, x-3, y, str(amount))
					
					if selected_ammo_type == ammo_type:
						libtcod.console_set_default_background(con, libtcod.dark_blue)
						libtcod.console_rect(con, x+2, y, 12, 1, True, libtcod.BKGND_SET)
						libtcod.console_set_default_background(con, libtcod.black)
					
					libtcod.console_put_char_ex(con, x, y, 7, AMMO_TYPE_COLOUR[ammo_type],
						libtcod.black)
					
					libtcod.console_set_default_foreground(con, libtcod.white)
					libtcod.console_print(con, x+2, y, ammo_type)
					
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
					libtcod.console_print_ex(con, x+10, y, libtcod.BKGND_NONE,
						libtcod.RIGHT, str(weapon.ammo_stores[ammo_type]))
					libtcod.console_print_ex(con, x+13, y, libtcod.BKGND_NONE,
						libtcod.RIGHT, str(weapon.ready_rack[ammo_type]))
					total_loaded += weapon.ammo_stores[ammo_type]
					
					y += 1
			
			y += 1
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, x+2, y, 'Total')
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print_ex(con, x+10, y, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(ammo_num))
			libtcod.console_print_ex(con, x+13, y, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(rr_num))
			
			y += 1
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print(con, x+2, y, '------------')
			
			y += 1
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, x+2, y, 'Max')
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print_ex(con, x+10, y, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(weapon.max_ammo))
			libtcod.console_print_ex(con, x+13, y, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(weapon.rr_size))
			
			# note maximum possible extra ammo
			y += 2
			if total_loaded > weapon.max_ammo:
				libtcod.console_set_default_foreground(con, libtcod.light_red)
				text = str(total_loaded - weapon.max_ammo)
			else:
				text = '0'
			text += '/' + str(weapon.max_plus_extra_ammo - weapon.max_ammo)
			libtcod.console_print(con, x+2, y, 'Extra:')
			libtcod.console_print_ex(con, x+13, y, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			
			# display flamethrower ammo if any
			y = 10
			libtcod.console_set_default_foreground(con, libtcod.white)
			for weapon2 in campaign.player_unit.weapon_list:
				if weapon2.stats['type'] != 'Flame Thrower': continue
				text = weapon2.stats['mount']+ ' FTR Fuel: '
				text += str(weapon2.flame_ammo) + '/' + str(weapon2.flame_ammo_max)
				libtcod.console_print(con, 61, y, text)
				y+=1
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 36, 43, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 36, 44, GAMEPADCHAR_RS)
				DisplayButton(con, 36, 46, GAMEPADCHAR_DPAD_LR)
				DisplayButton(con, 36, 55, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 34, 43, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 34, 44, EnKey('r').upper())
				libtcod.console_print(con, 34, 46, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(con, 34, 55, 'Tab')
			
			# cycle selected gun
			libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			if len(gun_list) > 1:
				if gamepad is not None:
					DisplayButton(con, 35, 42, GAMEPADCHAR_LB)
					DisplayButton(con, 36, 42, GAMEPADCHAR_RB)
				else:
					libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
					libtcod.console_print(con, 34, 42, EnKey('q').upper())
			
			# apply saved ammo loadout, unless there is none or we've already applied it
			libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			if len(weapon.default_ammo_stores) > 0 and not (weapon.ammo_stores == possible_saved_storage and weapon.ready_rack == possible_saved_rr):
				if gamepad is not None:
					DisplayButton(con, 36, 49, GAMEPADCHAR_Y)
				else:
					libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
					libtcod.console_print(con, 34, 49, EnKey('f').upper())
			
			# save loadout, but not if it's already saved or there is nothing loaded
			# Note: this is the exact saved loadout, not the nearest-fit one.
			display_button = True
			if (ammo_num + rr_num == 0) or (weapon.ammo_stores == weapon.default_ammo_stores and weapon.ready_rack == weapon.default_ready_rack):
				display_button = False
			
			if gamepad is not None:
				if display_button:
					DisplayButton(con, 36, 50, GAMEPADCHAR_B)
			else:
				if display_button:
					libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				else:
					libtcod.console_set_default_foreground(con, libtcod.dark_grey)
				libtcod.console_print(con, 34, 50, EnKey('v').upper()) 
			
			# fill stores and RR with default ammo load
			if weapon.ammo_stores != default_ammo or weapon.ready_rack != default_rr:
				if gamepad is not None:
					DisplayButton(con, 36, 52, GAMEPADCHAR_X)
				else:
					libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
					libtcod.console_print(con, 34, 52, EnKey('x').upper()) 

			# empty gun
			if ammo_num + rr_num > 0:
				if gamepad is not None:
					DisplayButton(con, 36, 53, GAMEPADCHAR_BACK)
				else:
					libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
					libtcod.console_print(con, 34, 53, EnKey('c').upper())

			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 38, 43, 'Select Ammo Type')
			libtcod.console_print(con, 38, 44, 'Toggle Ready Rack')
			libtcod.console_print(con, 38, 46, 'Unload/Load 1')
			if gamepad is None:
				libtcod.console_print(con, 38, 47, '[Shift for 10]')
			libtcod.console_print(con, 38, 55, 'Accept and Continue')

			if len(gun_list) == 1:
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			libtcod.console_print(con, 38, 42, 'Cycle Selected Gun')

			if len(weapon.default_ammo_stores) == 0 or (weapon.ammo_stores == possible_saved_storage and weapon.ready_rack == possible_saved_rr):
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			else:
				libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 38, 49, 'Apply Saved Loadout')

			if (ammo_num + rr_num == 0) or (weapon.ammo_stores == weapon.default_ammo_stores and weapon.ready_rack == weapon.default_ready_rack):
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			else:
				libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 38, 50, 'Save Loadout')
			
			if weapon.ammo_stores == default_ammo and weapon.ready_rack == default_rr:
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			else:
				libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 38, 52, 'Autofill Recommended Loadout')

			if ammo_num + rr_num == 0:
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			else:
				libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 38, 53, 'Clear Gun Ammo')
			
			# right column: visual depiction of main stores and ready rack
			x = 61
			y = 24
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, x, y, 'Stores')
			libtcod.console_print(con, x+10, y, 'Ready Rack')
			
			# highlight active stores
			libtcod.console_set_default_background(con, libtcod.darker_yellow)
			if not use_rr:
				xh = x
				w = 9
			else:
				xh = x+10
				w = 10
			libtcod.console_rect(con, xh, y, w, 1, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			
			y += 2
			
			ammo_count = weapon.ammo_stores.copy()
			rr_count = weapon.ready_rack.copy()
			
			# main stores
			libtcod.console_set_default_foreground(con, libtcod.darker_grey)
			xm = 0
			ym = 0
			total = 0
			bg_col = libtcod.black
			for ammo_type in AMMO_TYPES:
				if ammo_type in ammo_count:
					for i in range(ammo_count[ammo_type]):
						
						# if we're in extra ammo territory, set background colour to red
						if total >= weapon.max_ammo:
							bg_col = libtcod.dark_red
	
						libtcod.console_put_char_ex(con, x+xm, y+ym, 7,
							AMMO_TYPE_COLOUR[ammo_type], bg_col)
						
						if xm == 8:
							xm = 0
							ym += 1
						else:
							xm += 1
						
						total += 1
			
			# fill out empty slots up to max ammo
			if total < weapon.max_ammo:
				for i in range(weapon.max_ammo - total):
					libtcod.console_put_char(con, x+xm, y+ym, 9)
					if xm == 8:
						xm = 0
						ym += 1
					else:
						xm += 1
			
			# ready rack
			x += 10
			libtcod.console_set_default_foreground(con, libtcod.darker_grey)
			xm = 0
			ym = 0
			total = 0
			for ammo_type in AMMO_TYPES:
				if ammo_type in rr_count:
					for i in range(rr_count[ammo_type]):
						libtcod.console_put_char_ex(con, x+xm, y+ym, 7,
							AMMO_TYPE_COLOUR[ammo_type], libtcod.black)
						if xm == 8:
							xm = 0
							ym += 1
						else:
							xm += 1
						
						total += 1
			
			# fill out empty slots up to max ready rack size
			if total < weapon.rr_size:
				for i in range(weapon.rr_size - total):
					libtcod.console_put_char(con, x+xm, y+ym, 9)
					if xm == 8:
						xm = 0
						ym += 1
					else:
						xm += 1
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		
		# (re)calculate total ammo loads, max load, and max extra ammo
		def CalculateAmmoLoads():
			ammo_num = 0
			for ammo_type in AMMO_TYPES:
				if ammo_type in weapon.ammo_stores:
					ammo_num += weapon.ammo_stores[ammo_type]
			rr_num = 0
			for ammo_type in AMMO_TYPES:
				if ammo_type in weapon.ready_rack:
					rr_num += weapon.ready_rack[ammo_type]
			return (ammo_num, rr_num)
		
		
		ammo_num = 0
		rr_num = 0
		use_rr = False
		
		# refill any flamethrowers
		for weapon in campaign.player_unit.weapon_list:
			if weapon.stats['type'] != 'Flame Thrower': continue
			if weapon.flame_ammo == weapon.flame_ammo_max: continue
			weapon.flame_ammo = weapon.flame_ammo_max
			if resupply:
				ShowMessage('Your ' + weapon.stats['mount'] + ' flamethrower fuel is refilled.')
		
		# Build list of all guns on unit
		gun_list = []
		for weapon in campaign.player_unit.weapon_list:
			if weapon.stats['type'] != 'Gun': continue
			if 'ammo_type_list' not in weapon.stats: continue
			gun_list.append(weapon)
		
		# no guns to load
		if len(gun_list) == 0: return
		
		# build list of rare ammo
		for weapon in gun_list:
			weapon.GenerateRareAmmo(resupply=resupply)
			
		# select first weapon in list and first ammo type
		weapon = gun_list[0]
		selected_ammo_type = weapon.stats['ammo_type_list'][0]
		
		# calculate current ammo load
		(ammo_num, rr_num) = CalculateAmmoLoads()

		# calculate default loadouts for this weapon, adjust the saved loadout if there isn't enough ammo to apply it, and note any missing ammo types for messaging to player.
		(default_ammo, default_rr) = weapon.GenerateDefaultLoadout()
		(possible_saved_rr, possible_saved_storage, insufficient_saved_ammo) = weapon.CheckLoadoutTemplate(weapon.default_ready_rack, weapon.default_ammo_stores, True)
		
		# draw screen for first time
		UpdateMenuCon()
		
		ShowTutorialSlide('ammo_loading')
		
		# menu input loop
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			key_char = DeKey(chr(key.c).lower())
			
			# proceed
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				
				# check to see if player might have skipped this step by mistake
				no_ammo_loaded = False
				for gun in gun_list:
					total_ammo = 0
					for ammo_type in AMMO_TYPES:
						if ammo_type in gun.ammo_stores:
							total_ammo += gun.ammo_stores[ammo_type]
					
					if total_ammo == 0:
						no_ammo_loaded = True
						break
				
				if no_ammo_loaded:
					text = 'No ammo loaded in at least one gun! Are you sure you want to proceed?'
					if ShowNotification(text, confirm=True):
						exit_menu = True
						continue
				else:
					exit_menu = True
					continue
			
			# cycle selected gun
			if key_char == 'q' or session.gamepad_input in [9, 10]:
				if len(gun_list) == 1: continue
				
				i = gun_list.index(weapon)
				if i == len(gun_list) - 1:
					weapon = gun_list[0]
				else:
					weapon = gun_list[i+1]
				
				# select first ammo type in this gun
				selected_ammo_type = weapon.stats['ammo_type_list'][0]
				
				# calculate ammo load numbers for this gun
				(ammo_num, rr_num) = CalculateAmmoLoads()

				# calculate default loadouts for this weapon, adjust the saved loadout if there isn't enough ammo to apply it, and note any missing ammo types for messaging to player.
				(default_ammo, default_rr) = weapon.GenerateDefaultLoadout()
				(possible_saved_rr, possible_saved_storage, insufficient_saved_ammo) = weapon.CheckLoadoutTemplate(weapon.default_ready_rack, weapon.default_ammo_stores, True)

				PlaySoundFor(None, 'menu_select')
				UpdateMenuCon()
				continue
			
			# change selected ammo type
			elif key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				i = weapon.stats['ammo_type_list'].index(selected_ammo_type)
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if i == 0:
						i = len(weapon.stats['ammo_type_list']) - 1
					else:
						i -= 1
				else:
					if i == len(weapon.stats['ammo_type_list']) - 1:
						i = 0
					else:
						i += 1
				selected_ammo_type = weapon.stats['ammo_type_list'][i]
				PlaySoundFor(None, 'menu_select')
				UpdateMenuCon()
				continue
			
			# toggle load/unload ready rack (RS)
			elif key_char == 'r' or session.gamepad_input == 8:
				use_rr = not use_rr
				PlaySoundFor(None, 'menu_select')
				UpdateMenuCon()
				continue
			
			# load 1/10 shells of selected type
			elif key_char == 'd' or key.vk == sdl2.SDLK_RIGHT or session.gamepad_input == 14:
				
				if key.shift:
					add_num = 10
				else:
					add_num = 1
				
				# if rare ammo, make sure enough remains to load selected amount
				if selected_ammo_type in weapon.rare_ammo:
					if weapon.rare_ammo[selected_ammo_type] == 0: continue
					
					# if not enough to add selected amount, try to add as many as possible
					if weapon.rare_ammo[selected_ammo_type] - weapon.ammo_stores[selected_ammo_type] - weapon.ready_rack[selected_ammo_type] - add_num < 0:
						add_num = weapon.rare_ammo[selected_ammo_type] - weapon.ammo_stores[selected_ammo_type] - weapon.ready_rack[selected_ammo_type]
						if add_num < 0: add_num = 0
					
					if add_num == 0: continue
				
				# make sure there is enough room before loading, otherwise add as many as possible
				if use_rr:
					if rr_num + add_num > weapon.rr_size:
						add_num = weapon.rr_size - rr_num
						if add_num < 0: add_num = 0
					weapon.ready_rack[selected_ammo_type] += add_num
					rr_num += add_num
				else:
					if ammo_num + add_num > weapon.max_plus_extra_ammo:
						add_num = weapon.max_plus_extra_ammo - ammo_num
						if add_num < 0: add_num = 0
					weapon.ammo_stores[selected_ammo_type] += add_num
					ammo_num += add_num
				
				if add_num == 0: continue
				
				if add_num == 1:
					PlaySoundFor(None, 'shell_move_1')
				else:
					PlaySoundFor(None, 'shell_move_10')
				UpdateMenuCon()
				continue
			
			# unload 1/10 shell of selected type
			elif key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
				
				if key.shift:
					add_num = 10
				else:
					add_num = 1
				
				# make sure shell(s) are available, remove as many as possible
				if use_rr:
					if weapon.ready_rack[selected_ammo_type] - add_num < 0:
						add_num = weapon.ready_rack[selected_ammo_type]
					weapon.ready_rack[selected_ammo_type] -= add_num
					rr_num -= add_num
				else:
				
					if weapon.ammo_stores[selected_ammo_type] - add_num < 0:
						add_num = weapon.ammo_stores[selected_ammo_type]
					weapon.ammo_stores[selected_ammo_type] -= add_num
					ammo_num -= add_num
				
				if add_num == 0: continue
				
				if add_num == 1:
					PlaySoundFor(None, 'shell_move_1')
				else:
					PlaySoundFor(None, 'shell_move_10')
				UpdateMenuCon()
				continue
			
			# try to apply saved loadout
			elif key_char == 'f' or session.gamepad_input == 3:
				# no saved loadout set, or it's already applied
				if len(weapon.default_ammo_stores) == 0 or (weapon.ammo_stores == possible_saved_storage and weapon.ready_rack == possible_saved_rr):
					continue
				
				ammo_num = 0
				rr_num = 0
				# CheckLoadoutTemplate() has capped the loadout to our available special ammo, if necessary.
				for ammo_type in weapon.stats['ammo_type_list']:
					weapon.ammo_stores[ammo_type] = possible_saved_storage[ammo_type]
					ammo_num += possible_saved_storage[ammo_type]
					weapon.ready_rack[ammo_type] = possible_saved_rr[ammo_type]
					rr_num += possible_saved_rr[ammo_type]
				
				PlaySoundFor(None, 'shell_move_10')
				UpdateMenuCon()

				if len(insufficient_saved_ammo):
					ShowSimpleMessage("There are not enough " + GenerateEnglishList(insufficient_saved_ammo) + " rounds to apply the saved loadout.")
				continue
			
			# save current loadout
			elif key_char == 'v' or session.gamepad_input == 1:
				# Can't save if there's no loadout, or if the loadout is already saved. Note: this checks *exact* saved loadout, rather than the nearest possible match.
				if (ammo_num + rr_num == 0) or (weapon.ammo_stores == weapon.default_ammo_stores and weapon.ready_rack == weapon.default_ready_rack):
					continue
				weapon.default_ammo_stores = weapon.ammo_stores.copy()
				weapon.default_ready_rack = weapon.ready_rack.copy()
				possible_saved_storage = weapon.ammo_stores.copy()
				possible_saved_rr = weapon.ready_rack.copy()
				insufficient_saved_ammo = []
				PlaySoundFor(None, 'menu_select')
				UpdateMenuCon()
				continue
			
			# autofill with recommended loadout
			elif key_char == 'x' or session.gamepad_input == 2:
				if weapon.ammo_stores == default_ammo and weapon.ready_rack == default_rr:
					continue

				ammo_num = 0
				rr_num = 0

				for ammo_type in weapon.stats['ammo_type_list']:
					weapon.ammo_stores[ammo_type] = default_ammo[ammo_type]
					ammo_num += default_ammo[ammo_type]
					weapon.ready_rack[ammo_type] = default_rr[ammo_type]
					rr_num += default_rr[ammo_type]
				
				PlaySoundFor(None, 'shell_move_10')
				UpdateMenuCon()
				continue

			# clear gun load
			elif key_char == 'c' or session.gamepad_input == 4:
				# Can't clear if it's already empty.
				if ammo_num + rr_num == 0:
					continue
				for ammo_type in weapon.stats['ammo_type_list']:
					weapon.ammo_stores[ammo_type] = 0
					weapon.ready_rack[ammo_type] = 0
				ammo_num = 0
				rr_num = 0
				PlaySoundFor(None, 'shell_move_10')
				UpdateMenuCon()
				continue
		
		# exiting menu - for each gun, select the first ammo type as default
		for weapon in gun_list:
			weapon.ammo_type = weapon.stats['ammo_type_list'][0]
		
	
	# check to see whether crew within this unit recover from negative statuses
	# called after a scenario is finished
	# at present this is only used for player unit, but in future could be used for AI units as well
	def DoCrewRecoveryCheck(self, unit):
		
		# don't bother if campaign is already over
		if campaign.ended: return
		
		for position in unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
		
			# Shaken, Stunned, and Unconscious crew automatically recover
			position.crewman.condition = 'Good Order'
			
			# do a check for each wound
			for (k, v) in position.crewman.injury.items():
				
				(status, severity, scarring) = v
				if status is None and severity is None: continue
				
				# any still-fresh critical injuries may result in death
				if status == 'Fresh' and severity == 'Critical':
					roll = GetPercentileRoll()
					if roll < 98.0:
						severity = 'Serious'
					else:
						# check for fate point usage
						if position.crewman.is_player_commander and campaign_day.fate_points > 0:
							campaign_day.fate_points -= 1
							severity = 'Serious'
						else:
							if position.crewman.is_player_commander:
								text = 'You succumb to your ' + k + ' injury and die. Your campaign is over.'
								ShowMessage(text, crewman=position.crewman, force_tab=True, good_news=False)
							else:
								text = 'Your crewman succumbed to their ' + k + ' injury and has died.'
								ShowMessage(text, crewman=position.crewman, longer_pause=True, good_news=False)
							campaign.AddJournal(text)
							position.crewman.KIA()
				
				if not position.crewman.alive: break
				
				# patch up any fresh injuries
				if status == 'Fresh':
					status = 'Patched Up'
				
				position.crewman.injury[k] = (status, severity, scarring)


	# generate roads linking zones
	# if link_roads is True, extend any existing roads on the map
	def GenerateRoads(self, link_roads=False):
		
		# tags for if a road network is generated on this map
		dirt_road = False
		stone_road = False
		
		if not link_roads:
		
			# clear any existing roads
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				for direction in range(6):
					self.map_hexes[(hx,hy)].road_links[direction] = None
			
			if GetPercentileRoll() <= float(session.regions[campaign.stats['region']]['stone_road_odds']):
				stone_road = True
			if GetPercentileRoll() <= float(session.regions[campaign.stats['region']]['dirt_road_odds']):
				dirt_road = True
		
		else:
			
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				for direction in range(6):
					hex_road = self.map_hexes[(hx,hy)].road_links[direction]
					if hex_road is None: continue
					if hex_road is False:
						dirt_road = True
						break
					elif hex_road is True:
						stone_road = True
						break
		
		# no roads to be generated
		if not dirt_road and not stone_road: return
		
		
		# choose a random edge hex
		edge_list = []
		road_list = []
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			
			# don't include impassable hexes for starting point
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]:
				continue
			
			for d in range(6):
				if self.GetAdjacentCDHex(hx, hy, d) not in CAMPAIGN_DAY_HEXES:
					edge_list.append((hx, hy))
					
					# check for existing road
					if link_roads:
						if self.map_hexes[(hx,hy)].road_links[direction] is not None:
							road_list.append((hx, hy))
					
					break
		
		# if we're extending an existing road
		if link_roads and len(road_list) > 0:
			(hx1, hy1) = choice(road_list)
		else:
			(hx1, hy1) = choice(edge_list)
		
		# find the hex on opposite edge of map
		hx2 = hx1 * -1
		if hy1 > 4:
			hy2 = hy1 - ((hy1 - 4) * 2)
		elif hy1 == 4:
			hy2 = 4
		else:
			hy2 = hy1 + ((4 - hy1) * 2)
		
		# plot the road
		hex_path = self.GetHexPath(hx1, hy1, hx2, hy2, avoid_terrain=['Fortress', 'Fortification'])
		
		for i in range(len(hex_path)-1):
			(hx1,hy1) = hex_path[i]
			(hx2,hy2) = hex_path[i+1]
			d = self.GetDirectionToAdjacentCD(hx1,hy1,hx2,hy2)
			if stone_road:
				self.map_hexes[(hx1,hy1)].road_links[d] = True
				self.map_hexes[(hx2,hy2)].road_links[ConstrainDir(d + 3)] = True
			else:
				self.map_hexes[(hx1,hy1)].road_links[d] = False
				self.map_hexes[(hx2,hy2)].road_links[ConstrainDir(d + 3)] = False
		
		
		# link all settled hexes to a road branch - using dirt roads only
		# build a list of all settled hexes
		hex_list = []
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if self.map_hexes[(hx,hy)].terrain_type in ['Villages']:
				
				# already on a road
				if self.map_hexes[(hx,hy)].road_links != [None,None,None,None,None,None]: continue
							
				hex_list.append((hx, hy))
		
		if len(hex_list) > 0:
			shuffle(hex_list)
			for (hx1, hy1) in hex_list:
				
				# find the nearest CD map hex with at least one road link
				link_list = []
				for (hx2, hy2) in CAMPAIGN_DAY_HEXES:
					# same hex
					if hx2 == hx1 and hy2 == hy1: continue
					
					# no roads there
					if self.map_hexes[(hx2,hy2)].road_links == [None,None,None,None,None,None]: continue
										
					# get the distance to the possible link
					d = GetHexDistance(hx1, hy1, hx2, hy2)
					
					link_list.append((d,hx2,hy2))
				
				# no possible links!
				if len(link_list) == 0:
					continue
				
				# sort the list by distance and get the nearest one
				link_list.sort(key = lambda x: x[0])
				(d,hx2,hy2) = link_list[0]
				
				# generate a road to link the two
				hex_path = self.GetHexPath(hx1, hy1, hx2, hy2, avoid_terrain=['Fortress', 'Fortification'])
				for i in range(len(hex_path)-1):
					(hx1,hy1) = hex_path[i]
					(hx2,hy2) = hex_path[i+1]
					d = self.GetDirectionToAdjacentCD(hx1,hy1,hx2,hy2)
					self.map_hexes[(hx1,hy1)].road_links[d] = False
					self.map_hexes[(hx2,hy2)].road_links[ConstrainDir(d + 3)] = False
				
	
	
	# generate rivers/wadis and bridges along hex zone edges
	def GenerateRivers(self, link_rivers=False):
		
		self.cd_map_bridge_locations = []
		
		# no rivers in this region at all
		if 'river_odds' not in session.regions[campaign.stats['region']]:
			return
		
		# no rivers ever in urban combat
		if self.rattenkrieg:
			return
		
		rivers = 0
		river_hexes = []
		
		if not link_rivers:
		
			# clear any existing rivers and bridges
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				self.map_hexes[(hx,hy)].rivers = []
				self.map_hexes[(hx,hy)].bridges = []
			
			# roll for how many rivers are on map (max 2)
			rivers = 0
			odds = float(session.regions[campaign.stats['region']]['river_odds'])
			if GetPercentileRoll() <= odds:
				rivers += 1
				if GetPercentileRoll() <= odds:
					rivers += 1
		
		else:
			for (hx, hy) in CAMPAIGN_DAY_HEXES:
				if len(self.map_hexes[(hx,hy)].rivers) > 0:
					rivers = 1
					river_hexes.append((hx, hy))
		
		if rivers == 0: return
		
		# build a list of map edge hexes
		edge_list = []
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if self.map_hexes[(hx,hy)].terrain_type == 'Water': continue
			for d in range(6):
				if self.GetAdjacentCDHex(hx, hy, d) not in CAMPAIGN_DAY_HEXES:
					edge_list.append((hx, hy))
					break
				if self.map_hexes[self.GetAdjacentCDHex(hx, hy, d)].terrain_type == 'Water':
					edge_list.append((hx, hy))
					break
		
		# create the rivers
		for i in range(rivers):
			
			# determine starting hex
			if link_rivers and len(river_hexes) > 0:
				(hx1, hy1) = choice(river_hexes)
			else:
				(hx1, hy1) = choice(edge_list)
			
			# determine ending hex 
			shuffle(edge_list)
			for (hx2, hy2) in edge_list:
				if GetHexDistance(hx1, hy1, hx2, hy2) < 5: continue
				break
			
			# run through the hex line
			hex_line = GetHexLine(hx1, hy1, hx2, hy2)
			for index in range(len(hex_line)):
			
				(hx, hy) = hex_line[index]
				
				# hex is off map; should not happen
				if (hx, hy) not in CAMPAIGN_DAY_HEXES: continue
				
				# chance that river will end within map
				if GetPercentileRoll() <= 2.0:
					break
				
				# each hex needs 1+ hexsides to become rivers
				
				# determine direction to previous hex
				if hx == hx1 and hy == hy1:
					
					# for first hex, we need to use off-board hex as previous location
					for direction1 in range(6):
						if self.GetAdjacentCDHex(hx, hy, direction1) not in CAMPAIGN_DAY_HEXES:
							break
				
				else:
					# otherwise use direction toward previous hex
					(hx_n, hy_n) = hex_line[index-1]
					direction1 = self.GetDirectionToAdjacentCD(hx, hy, hx_n, hy_n)
				
				# determine direction to next hex
				
				# for final hex, we need to use an off-board hex as next location
				if index == len(hex_line) - 1:
					for direction2 in range(6):
						if self.GetAdjacentCDHex(hx, hy, direction2) not in CAMPAIGN_DAY_HEXES:
							break
				else:
					# otherwise try to use direction toward next hex
					(hx_n, hy_n) = hex_line[index+1]
					direction2 = self.GetDirectionToAdjacentCD(hx, hy, hx_n, hy_n)
				
				# determine rotation path (clockwise or counter clockwise)
				path1 = []
				for i in range(6):
					path1.append(ConstrainDir(direction1 + i))
					if ConstrainDir(direction1 + i) == direction2: break
					
				path2 = []
				for i in range(6):
					path2.append(ConstrainDir(direction1 - i))
					if ConstrainDir(direction1 - i) == direction2: break
				
				# pick shortest path
				if len(path1) < len(path2):
					path = path1
				else:
					path = path2
				
				for direction in path[1:]:
					
					# don't add if this zone is impassable
					if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx,hy)].terrain_type]:
						continue
					
					# may have already been added by an earlier river
					if direction in self.map_hexes[(hx,hy)].rivers: continue
					
					# if adjacent hex in this direction is water, skip
					(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
					if (hx2, hy2) in CAMPAIGN_DAY_HEXES:
						if self.map_hexes[(hx2, hy2)].terrain_type == 'Water':
							continue
				
					self.map_hexes[(hx,hy)].rivers.append(direction)
					
					# bridges
					
					# don't add in North Africa region
					if campaign.stats['region'] == 'North Africa': continue
					
					# always add a bridge if road already present connecting the two hexes
					if self.map_hexes[(hx,hy)].road_links[direction] is not None:
						if direction not in self.map_hexes[(hx,hy)].bridges:
							self.map_hexes[(hx,hy)].bridges.append(direction)
						continue
					
					# check for random bridge addition
					if direction not in self.map_hexes[(hx,hy)].bridges:
						
						# don't add if zone in this direction is off map or impassable
						(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
						
						if (hx2, hy2) not in CAMPAIGN_DAY_HEXES: continue
						if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[(hx2,hy2)].terrain_type]:
							continue
						
						if GetPercentileRoll() <= 10.0:
							self.map_hexes[(hx,hy)].bridges.append(direction)
		
		
	# plot the centre of a day map hex location onto the map console
	# top left of hex 0,0 will appear at cell 2,2
	def PlotCDHex(self, hx, hy):
		x = (hx*6) + (hy*3)
		y = (hy*5)
		return (x+5,y+6)
	
	
	# returns the hx, hy location of the adjacent hex in direction
	def GetAdjacentCDHex(self, hx1, hy1, direction):
		(hx_m, hy_m) = CD_DESTHEX[direction]
		return (hx1+hx_m, hy1+hy_m)
	
	
	# returns the direction toward an adjacent hex
	def GetDirectionToAdjacentCD(self, hx1, hy1, hx2, hy2):
		hx_mod = hx2 - hx1
		hy_mod = hy2 - hy1
		if (hx_mod, hy_mod) in CD_DESTHEX:
			return CD_DESTHEX.index((hx_mod, hy_mod))
		# hex is not adjacent
		return -1
	
	
	# display an after-action report with information on a completed campaign day
	def DisplayCampaignDaySummary(self):
		
		# clear console
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_clear(con)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		libtcod.console_flush()
		
		# check for special end of day report text
		if 'day_end_text' in campaign.current_week:
			if campaign.today in campaign.current_week['day_end_text']:
				text = campaign.current_week['day_end_text'][campaign.today]
				lines = wrap(text, 32)
				h = len(lines) + 9
				if h > 88: h = 88
				y = 30 - int((h/2))
				DrawFrame(con, 28, y, 36, h)
				
				libtcod.console_print_ex(con, 46, y+2, libtcod.BKGND_NONE, libtcod.CENTER,
					'Report for ' + GetDateText(campaign.today))
				
				libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
				y1 = y+4
				for line in lines:
					libtcod.console_print(con, 30, y1, line)
					y1 += 1
					if y1 >= y+h-4: break
				
				# display button/key prompt
				if gamepad is not None:
					DisplayButton(con, 41, y+h-3, GAMEPADCHAR_A)
				else:
					libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
					libtcod.console_print(con, 40, y+h-3, 'Tab')
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 45, y+h-3, 'Continue')
				
				# blit console to screen and wait for player to continue
				libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
				libtcod.console_flush()
				WaitForContinue(ignore_animations=True)
				libtcod.console_clear(con)
		
		# load and display AAR background image
		libtcod.console_blit(LoadXP('aar_report_bkg.xp'), 0, 0, 0, 0, con, 0, 0)
		libtcod.console_set_default_foreground(con, libtcod.black)
		
		# campaign name, menu title, and date
		lines = wrap(campaign.stats['name'], 26)
		y = 3
		for line in lines[:2]:
			libtcod.console_print_ex(con, 26, y, libtcod.BKGND_NONE, libtcod.CENTER,
				line)
			y+=1
		libtcod.console_print_ex(con, 26, 6, libtcod.BKGND_NONE, libtcod.CENTER,
			'After-Action Report')
		
		text = 'Day ' + str(campaign.combat_calendar.index(campaign.today) + 1)
		libtcod.console_print_ex(con, 26, 8, libtcod.BKGND_NONE, libtcod.CENTER,
			text)
		libtcod.console_print_ex(con, 26, 9, libtcod.BKGND_NONE, libtcod.CENTER,
			GetDateText(campaign.today))
		
		libtcod.console_print_ex(con, 26, 11, libtcod.BKGND_NONE, libtcod.CENTER,
			campaign_day.mission)
		
		libtcod.console_print_ex(con, 26, 13, libtcod.BKGND_NONE, libtcod.CENTER,
			campaign.player_unit.unit_id)
		
		libtcod.console_print(con, 10, 15, '. . . . . . . . . . . . . . . . .')
		
		# day result: survived or destroyed
		libtcod.console_print(con, 10, 17, 'Outcome of Day:')
		
		if campaign.player_oob:
			col = libtcod.red
			text = 'COMMANDER OUT OF ACTION'
		elif campaign_day.abandoned_tank:
			col = libtcod.light_grey
			text = 'ABANDONED VEHICLE'
		elif campaign.player_unit.immobilized and campaign.player_unit.alive:
			col = libtcod.light_red
			text = 'IMMOBILIZED'
		elif campaign.player_unit.alive:
			col = libtcod.light_blue
			text = 'SURVIVED'
		else:
			col = ENEMY_UNIT_COL
			text = 'VEHICLE LOST'
		libtcod.console_set_default_foreground(con, col)
		libtcod.console_print_ex(con, 26, 19, libtcod.BKGND_NONE, libtcod.CENTER,
			text)
		
		# player survived another combat day
		if text == 'SURVIVED':
			session.ModifySteamStat('days_survived', 1)
		
		# stats
		libtcod.console_set_default_foreground(con, libtcod.black)
		libtcod.console_print(con, 10, 23, 'Stats:')
		y = 25
		for text in RECORD_LIST:
			libtcod.console_print(con, 13, y, text + ':')
			libtcod.console_print_ex(con, 39, y, libtcod.BKGND_NONE, libtcod.RIGHT,
				str(campaign_day.records[text]))
			y += 1
			if y == 40:
				break
		
		# second page
		# enemy units destroyed
		libtcod.console_print_ex(con, 63, 4, libtcod.BKGND_NONE, libtcod.CENTER,
			'Enemy Units Destroyed')
		y = 7
		
		if len(campaign_day.enemies_destroyed) == 0:
			libtcod.console_print(con, 48, y, 'None')
		else:
			for (unit_id, number) in campaign_day.enemies_destroyed.items():
				libtcod.console_print(con, 48, y, unit_id)
				libtcod.console_print_ex(con, 79, y, libtcod.BKGND_NONE, libtcod.RIGHT,
					'x ' + str(number))
				y += 1
				if y == 41: break
		
		libtcod.console_print(con, 47, 43, '. . . . . . . . . . . . . . . . .')
		
		# VP earned
		libtcod.console_print(con, 47, 46, 'Base VP Earned:')
		libtcod.console_print(con, 47, 47, 'Campaign Options Modifier:')
		libtcod.console_print(con, 47, 48, 'Player Unit Modifier:')
		libtcod.console_print(con, 47, 50, 'Total VP Earned Today:')
		
		libtcod.console_set_default_foreground(con, libtcod.blue)
		
		# display base day vp
		libtcod.console_print_ex(con, 79, 46, libtcod.BKGND_NONE, libtcod.RIGHT,
			str(self.day_vp))
		
		# campaign options modifier if any
		if campaign.vp_modifier == 0:
			text = '--'
		else:
			if campaign.vp_modifier > 0:
				text = '+'
			else:
				text = ''
			text += str(campaign.vp_modifier) + '%'
		libtcod.console_print_ex(con, 79, 47, libtcod.BKGND_NONE, libtcod.RIGHT,
			text)
		
		# tank model vp modifier if any
		text = '--'
		if 'tank_vp_modifiers' in campaign.stats:
			if campaign.player_unit.unit_id in campaign.stats['tank_vp_modifiers']:
				text = ''
				modifier = campaign.stats['tank_vp_modifiers'][campaign.player_unit.unit_id]
				if modifier > 1.0:
					text = '+'
				text += str(int(round((modifier - 1.0) * 100.0, 0))) + '%'
		libtcod.console_print_ex(con, 79, 48, libtcod.BKGND_NONE, libtcod.RIGHT,
			text)
		
		# calculate final earned VP
		multiplier = float(campaign.vp_modifier) * 0.01
		if 'tank_vp_modifiers' in campaign.stats:
			if campaign.player_unit.unit_id in campaign.stats['tank_vp_modifiers']:
				multiplier += (campaign.stats['tank_vp_modifiers'][campaign.player_unit.unit_id] - 1.0)		
		self.day_vp += int(ceil(float(self.day_vp) * multiplier))
		
		# final earned VP
		libtcod.console_print_ex(con, 79, 50, libtcod.BKGND_NONE, libtcod.RIGHT,
			str(self.day_vp))
		
		libtcod.console_set_default_foreground(con, libtcod.black)
		libtcod.console_print(con, 47, 52, '. . . . . . . . . . . . . . . . .')
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 62, 55, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 56, 55, 'Tab')
		libtcod.console_set_default_foreground(con, libtcod.black)
		libtcod.console_print(con, 64, 55, 'Continue')
		
		# display console to screen
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# get input from player
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# end menu
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				exit_menu = True
	
	
	##### Campaign Day Console Functions #####
	
	# generate/update the campaign day map console, 35x53
	def UpdateCDMapCon(self):
		
		def RecordScreenLocations(hx, hy):
			self.cd_map_index[(x, y-3)] = (hx, hy)
			for x1 in range(x-1, x+2):
				self.cd_map_index[(x1, y-2)] = (hx, hy)
				self.cd_map_index[(x1, y+2)] = (hx, hy)
			for x1 in range(x-2, x+3):
				self.cd_map_index[(x1, y-1)] = (hx, hy)
				self.cd_map_index[(x1, y)] = (hx, hy)
				self.cd_map_index[(x1, y+1)] = (hx, hy)
			self.cd_map_index[(x, y+3)] = (hx, hy)
		
		CHAR_LOCATIONS = [
			(3,1), (2,2), (3,2), (4,2), (1,3), (2,3), (3,3), (4,3), (5,3),
			(1,4), (2,4), (4,4), (5,4), (1,5), (2,5), (3,5), (4,5), (5,5),
			(2,6), (3,6), (4,6), (3,7)
		]
		CLOSE_CHAR_LOCATIONS = [
			(3,2), (2,3), (3,3), (4,3), (2,4), (4,4), (2,5), (3,5), (4,5),
			(3,6)
		]
		
		def GetRandomLocation():
			return CHAR_LOCATIONS[libtcod.random_get_int(generator, 0, 21)]
		
		libtcod.console_clear(cd_map_con)
		self.cd_map_index = {}
		
		# draw map hexes to console
		# load base zone image - depends on day mission, region, and current ground conditions
		if self.rattenkrieg:
			dayhex = LoadXP('dayhex_urban.xp')
			bg_col = libtcod.Color(77,77,77)
		elif campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
			dayhex = LoadXP('dayhex_openground_sp.xp')
			bg_col = libtcod.Color(0,102,0)
		elif self.weather['Ground'] in ['Snow', 'Deep Snow']:
			dayhex = LoadXP('dayhex_openground_snow.xp')
			bg_col = libtcod.Color(191,191,191)
		elif campaign.stats['region'] == 'North Africa':
			dayhex = LoadXP('dayhex_openground_desert.xp')
			bg_col = libtcod.Color(128,102,64)
		# winter season, no snow cover
		elif self.weather['Season'] == 'Winter':
			dayhex = LoadXP('dayhex_openground_winter.xp')
			bg_col = libtcod.Color(51,41,26)
		else:
			dayhex = LoadXP('dayhex_openground.xp')
			bg_col = libtcod.Color(0,64,0)
		temp_con = libtcod.console_new(7, 9)
		libtcod.console_set_key_color(temp_con, KEY_COLOR)
		
		# set river/water colour
		if campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
			river_col = libtcod.Color(0,108,217)
		elif campaign.stats['region'] == 'North Africa':
			river_col = libtcod.Color(100,80,50)
		else:
			river_col = libtcod.Color(0, 0, 140)
		
		# draw any Ocean hexes first, so that other hexes are drawn overtop
		for (hx, hy), cd_hex in self.map_hexes.items():
			if cd_hex.terrain_type != 'Water': continue
			(x,y) = self.PlotCDHex(hx, hy)
			# use special hex image here
			if campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
				libtcod.console_blit(LoadXP('dayhex_ocean_sp.xp'), 0, 0, 0, 0, temp_con, 0, 0)
			else:
				libtcod.console_blit(LoadXP('dayhex_ocean.xp'), 0, 0, 0, 0, temp_con, 0, 0)
			libtcod.console_blit(temp_con, 0, 0, 0, 0, cd_map_con, x-3, y-4)
			RecordScreenLocations(hx, hy)
		
		for (hx, hy), cd_hex in self.map_hexes.items():
			
			if cd_hex.terrain_type == 'Water': continue
			
			# generate console image for this zone's terrain type
			libtcod.console_blit(dayhex, 0, 0, 0, 0, temp_con, 0, 0)
			
			generator = libtcod.random_new_from_seed(cd_hex.console_seed)
			
			if campaign.stats['region'] == 'North Africa' and cd_hex.terrain_type == 'Flat':
				for (x,y) in CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 30) <= 29: continue
					libtcod.console_put_char_ex(temp_con, x, y, 240, libtcod.Color(102,82,51), bg_col)
			
			elif cd_hex.terrain_type == 'Forest':
				for (x,y) in CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 10) <= 4: continue
					
					char = 6
					if self.weather['Ground'] in ['Snow', 'Deep Snow']:
						if libtcod.random_get_int(generator, 1, 2) == 1:
							char = 24
							if libtcod.random_get_int(generator, 1, 3) == 1: char += 100
							col = libtcod.Color(libtcod.random_get_int(generator, 60, 100),20,20)
						else:
							col = libtcod.Color(0,libtcod.random_get_int(generator, 100, 170),0)
					
					elif campaign.stats['region'] == 'North Africa':
						col = libtcod.Color(0,libtcod.random_get_int(generator, 60, 100),0)
					
					elif self.weather['Season'] == 'Spring':
						if libtcod.random_get_int(generator, 1, 20) == 1:
							c = libtcod.random_get_int(generator, 200, 220)
							col = libtcod.Color(c,50,c)
						else:
							col = libtcod.Color(0,libtcod.random_get_int(generator, 100, 170),0)
					
					elif self.weather['Season'] == 'Autumn':
						roll = libtcod.random_get_int(generator, 1, 10)
						if roll <= 2:
							c = libtcod.random_get_int(generator, 120, 160)
							col = libtcod.Color(c,0,0)
						elif roll <= 4:
							c = libtcod.random_get_int(generator, 90, 110)
							col = libtcod.Color(c*2,c,0)
						elif roll <= 4:
							c = libtcod.random_get_int(generator, 80, 100)
							col = libtcod.Color(c,80,50)
						else:
							col = libtcod.Color(0,libtcod.random_get_int(generator, 100, 170),0)
					
					else:
						col = libtcod.Color(0,libtcod.random_get_int(generator, 100, 170),0)
					
					libtcod.console_put_char_ex(temp_con, x, y, char, col, bg_col)
				
			elif cd_hex.terrain_type == 'Hills':
				if campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
					col = libtcod.Color(61,libtcod.random_get_int(generator, 30, 150),0)
				elif self.weather['Ground'] in ['Snow', 'Deep Snow']:
					c = libtcod.random_get_int(generator, 200, 250)
					col = libtcod.Color(c,c,c)
				elif campaign.stats['region'] == 'North Africa':
					c = libtcod.random_get_int(generator, -15, 15)
					col = libtcod.Color(160+c,130+c,100+c)
				else:
					col = libtcod.Color(70,libtcod.random_get_int(generator, 110, 150),0)
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 2, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 2, 237, col, bg_col)
				
				if libtcod.random_get_int(generator, 0, 1) == 0:
					x = 1
				else:
					x = 4
				libtcod.console_put_char_ex(temp_con, x, 4, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 4, 237, col, bg_col)
				
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 6, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 6, 237, col, bg_col)
			
			elif cd_hex.terrain_type == 'Mountains':
				c = libtcod.random_get_int(generator, -5, 5)
				col = libtcod.Color(75+c,75+c,75+c)
				col2 = libtcod.Color(75+c-10,75+c-10,75+c-10)
				
				for (x,y) in CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 3) == 1: continue
					libtcod.console_put_char_ex(temp_con, x, y, 177, col2, bg_col)
				
				# top and bottom rows
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 2, 16, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 2, 31, col, bg_col)
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 6, 16, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 6, 31, col, bg_col)
				
				# second and fourth rows
				for y in [3,5]:
					x = libtcod.random_get_int(generator, 1, 4)
					libtcod.console_put_char_ex(temp_con, x, y, 16, col, bg_col)
					libtcod.console_put_char_ex(temp_con, x+1, y, 31, col, bg_col)
				
				# middle row
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 4, 16, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 4, 31, col, bg_col)
			
			elif cd_hex.terrain_type == 'Mountain Pass':
				c = libtcod.random_get_int(generator, -5, 5)
				col = libtcod.Color(75+c,75+c,75+c)
				col2 = libtcod.Color(75+c-10,75+c-10,75+c-10)
				
				for (x,y) in CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 2) == 1: continue
					libtcod.console_put_char_ex(temp_con, x, y, 177, col2, bg_col)
				
				# top and bottom rows
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 2, 16, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 2, 31, col, bg_col)
				x = libtcod.random_get_int(generator, 2, 3)
				libtcod.console_put_char_ex(temp_con, x, 6, 16, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x+1, 6, 31, col, bg_col)
			
			elif cd_hex.terrain_type == 'Fields':
				for (x,y) in CHAR_LOCATIONS:
					if self.weather['Ground'] in ['Snow', 'Deep Snow']:
						col = libtcod.Color(50,40,20)
						char = 124
					else:
						c = libtcod.random_get_int(generator, 120, 190)
						col = libtcod.Color(c,c,0)
						char = 176
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, bg_col)
				
			elif cd_hex.terrain_type == 'Marsh':
				elements = libtcod.random_get_int(generator, 7, 13)
				while elements > 0:
					(x,y) = GetRandomLocation()
					if libtcod.console_get_char(temp_con, x, y) == 176: continue
					libtcod.console_put_char_ex(temp_con, x, y, 176,
						libtcod.Color(45,0,180), bg_col)
					elements -= 1
				
			elif cd_hex.terrain_type == 'Villages':
				for (x,y) in CLOSE_CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 2) == 1: continue
					c = libtcod.random_get_int(generator, 1, 4)
					if c <= 3:
						char = 249
						if campaign.stats['region'] == 'North Africa':
							col = libtcod.Color(190,170,140)
						else:
							col = libtcod.Color(77,77,77)
					else:
						char = 15
						col = libtcod.darkest_green
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, bg_col)
			
			elif cd_hex.terrain_type == 'Scrub':
				for (x,y) in CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 10) <= 8: continue
					if libtcod.random_get_int(generator, 1, 2) == 1:
						char = 240
					else:
						char = 15
					libtcod.console_put_char_ex(temp_con, x, y, char, libtcod.Color(32,64,0), bg_col)
			
			elif cd_hex.terrain_type == 'Hamada':
				elements = libtcod.random_get_int(generator, 7, 11)
				while elements > 0:
					(x,y) = GetRandomLocation()
					if libtcod.random_get_int(generator, 1, 3) <= 2:
						char = 177
					else:
						char = 250
					libtcod.console_put_char_ex(temp_con, x, y, char, libtcod.Color(51,51,51), bg_col)
					elements -= 1
			
			elif cd_hex.terrain_type == 'Sand':
				for (x,y) in CHAR_LOCATIONS:
					c = libtcod.random_get_int(generator, 130, 150)
					libtcod.console_put_char_ex(temp_con, x, y, 176,
						libtcod.Color(c,c,0), bg_col)
			
			elif cd_hex.terrain_type == 'Beach':
				for (x,y) in CHAR_LOCATIONS:
					c = libtcod.random_get_int(generator, 130, 150)
					libtcod.console_put_char_ex(temp_con, x, y, 177,
						libtcod.Color(c,c,0), libtcod.Color(c-10,c-10,0))
				
				# special: change background colour
				bg_col = libtcod.Color(130,130,0)
			
			elif cd_hex.terrain_type == 'Oasis':
				for (x,y) in CLOSE_CHAR_LOCATIONS:
					c = libtcod.random_get_int(generator, 1, 3)
					if c == 1:
						char = 7
						col = libtcod.Color(0,0,255)
					elif c == 2:
						char = 6
						col = libtcod.dark_green
					else:
						char = 15
						col = libtcod.darkest_green
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, bg_col)
			
			elif cd_hex.terrain_type == 'Fortress':
				c = libtcod.random_get_int(generator, -15, 15)
				col = libtcod.Color(190+c,170+c,140+c)
				col2 = libtcod.Color(190+c+30,170+c+30,140+c+30)
				
				# corner towers
				libtcod.console_put_char_ex(temp_con, 2, 3, 10,
					col, col2)
				libtcod.console_put_char_ex(temp_con, 4, 3, 10,
					col, col2)
				libtcod.console_put_char_ex(temp_con, 2, 5, 10,
					col, col2)
				libtcod.console_put_char_ex(temp_con, 4, 5, 10,
					col, col2)
				
				# walls
				libtcod.console_put_char_ex(temp_con, 3, 3, 205,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 4, 186,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 4, 186,
					col, bg_col)
				
				# gate
				libtcod.console_put_char_ex(temp_con, 3, 5, 61,
					col, bg_col)
			
			elif cd_hex.terrain_type == 'Lake':
				for (x,y) in CHAR_LOCATIONS:
					libtcod.console_put_char_ex(temp_con, x, y, 0,
						libtcod.black, river_col)
				libtcod.console_set_char_background(temp_con, 3, 4,
					river_col, libtcod.BKGND_SET)
			
			elif cd_hex.terrain_type == 'Fortification':
				c = libtcod.random_get_int(generator, -15, 15)
				col = libtcod.Color(80+c,80+c,80+c)
				
				# corner towers
				libtcod.console_put_char_ex(temp_con, 2, 3, 10,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 3, 10,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 5, 10,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 5, 10,
					col, bg_col)
				
				# walls
				libtcod.console_put_char_ex(temp_con, 3, 3, 205,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 4, 186,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 4, 186,
					col, bg_col)
				libtcod.console_put_char_ex(temp_con, 3, 5, 205,
					col, bg_col)
			
			# Rattenkrieg terrain types
			elif cd_hex.terrain_type == 'Rubble':
				elements = libtcod.random_get_int(generator, 3, 8)
				while elements > 0:
					(x,y) = GetRandomLocation()
					c = libtcod.random_get_int(generator, 1, 5)
					if c <= 2:
						char = 249
						col = libtcod.sepia
					elif c <= 4:
						char = 250
						col = libtcod.dark_grey
					else:
						char = 7
						col = libtcod.darkest_grey
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, bg_col)
					elements -= 1
			
			elif cd_hex.terrain_type == 'Factories':
				col = libtcod.grey
				col2 = libtcod.darker_sepia
				for x in range(2, 5):
					libtcod.console_put_char_ex(temp_con, x, 2, 220,
						col, col2)
					libtcod.console_put_char_ex(temp_con, x, 5, 220,
						col, col2)
					libtcod.console_put_char_ex(temp_con, x, 3, 223,
						col, col2)
					libtcod.console_put_char_ex(temp_con, x, 6, 223,
						col, col2)
				elements = libtcod.random_get_int(generator, 1, 3)
				while elements > 0:
					(x,y) = GetRandomLocation()
					libtcod.console_set_char(temp_con, x, y, 7)
					libtcod.console_set_char_foreground(temp_con, x, y,
						libtcod.black)
					elements -= 1
			
			elif cd_hex.terrain_type == 'Tower Blocks':
				col = libtcod.light_grey
				col2 = libtcod.dark_grey
				y = libtcod.random_get_int(generator, 3, 4)
				libtcod.console_put_char_ex(temp_con, 1, y, 201,
					col, col2)
				libtcod.console_put_char_ex(temp_con, 2, y, 187,
					col, col2)
				libtcod.console_put_char_ex(temp_con, 1, y+1, 200,
					col, col2)
				libtcod.console_put_char_ex(temp_con, 2, y+1, 188,
					col, col2)
				
				if y == 3:
					x = 3
				else:
					x = 2
				libtcod.console_put_char_ex(temp_con, x, 2, 201,
					col, col2)
				libtcod.console_put_char_ex(temp_con, x+1, 2, 187,
					col, col2)
				libtcod.console_put_char_ex(temp_con, x, 3, 200,
					col, col2)
				libtcod.console_put_char_ex(temp_con, x+1, 3, 188,
					col, col2)
				
				if libtcod.random_get_int(generator, 1, 2) == 1:
					x, y = 3, 5
				else:
					x, y = 4, 4
				libtcod.console_put_char_ex(temp_con, x, y, 201,
					col, col2)
				libtcod.console_put_char_ex(temp_con, x+1, y, 187,
					col, col2)
				libtcod.console_put_char_ex(temp_con, x, y+1, 200,
					col, col2)
				libtcod.console_put_char_ex(temp_con, x+1, y+1, 188,
					col, col2)
			
			elif cd_hex.terrain_type == 'Cathedral':
				col = libtcod.light_grey
				col2 = libtcod.dark_grey
				col3 = libtcod.lightest_grey
				for y in range(2, 7):
					libtcod.console_put_char_ex(temp_con, 2, y, 222,
						col, col2)
					if y != 4:
						libtcod.console_put_char_ex(temp_con, 3, y, 179,
							col3, col)
					libtcod.console_put_char_ex(temp_con, 4, y, 221,
						col, col2)
				libtcod.console_put_char_ex(temp_con, 3, 1, 219, col3, col)
				libtcod.console_put_char_ex(temp_con, 3, 2, 219, col3, col)
				
				elements = libtcod.random_get_int(generator, 1, 3)
				while elements > 0:
					(x,y) = GetRandomLocation()
					libtcod.console_set_char(temp_con, x, y, 7)
					libtcod.console_set_char_foreground(temp_con, x, y,
						libtcod.black)
					elements -= 1
			
			elif cd_hex.terrain_type == 'Town Square':
				for (x,y) in CHAR_LOCATIONS:
					libtcod.console_put_char_ex(temp_con, x, y, 177,
						libtcod.grey, bg_col)
			
			elif cd_hex.terrain_type == 'Row Houses':
				col = libtcod.light_sepia
				col2 = libtcod.sepia
				col3 = libtcod.darkest_sepia
				for y in range(1, 4):
					libtcod.console_put_char_ex(temp_con, 3, y, 179,
						col3, bg_col)
				for y in range(5, 8):
					libtcod.console_put_char_ex(temp_con, 3, y, 179,
						col3, bg_col)
				
				for (x,y) in CHAR_LOCATIONS:
					if x == 3: continue
					if libtcod.random_get_int(generator, 1, 15) == 1: continue
					libtcod.console_put_char_ex(temp_con, x, y, 179,
						col, col2)
			
			elif cd_hex.terrain_type == 'Storage Tanks':
				col = libtcod.light_grey
				libtcod.console_put_char_ex(temp_con, 2, 2, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 3, 2, 237, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 3, 238, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 3, 3, 239, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 3, 5, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 5, 237, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 3, 6, 238, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 6, 239, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 3, 191, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 6, 218, col, bg_col)
			
			elif cd_hex.terrain_type == 'Train Station':
				col = libtcod.darkest_grey
				for x in range(1, 6):
					libtcod.console_put_char_ex(temp_con, x, 5, 205, col, bg_col)
				col = libtcod.lightest_grey
				col2 = libtcod.lighter_grey
				libtcod.console_put_char_ex(temp_con, 2, 4, 179, col, col2)
				libtcod.console_put_char_ex(temp_con, 2, 3, 218, col, col2)
				libtcod.console_put_char_ex(temp_con, 3, 3, 196, col, col2)
				libtcod.console_put_char_ex(temp_con, 4, 3, 219, col, col2)
				libtcod.console_put_char_ex(temp_con, 4, 4, 179, col, col2)
				col2 = libtcod.dark_sepia
				libtcod.console_put_char_ex(temp_con, 3, 1, 0, col, col2)
				libtcod.console_put_char_ex(temp_con, 3, 2, 0, col, col2)
			
			elif cd_hex.terrain_type == 'Park':
				col = libtcod.sepia
				col2 = libtcod.darkest_green
				for (x,y) in CHAR_LOCATIONS:
					char = 0
					roll = libtcod.random_get_int(generator, 1, 8)
					if roll == 1:
						char = 5
					elif roll == 2:
						char = 47
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, col2)
				libtcod.console_set_char_background(temp_con, 3, 4,
					col2, libtcod.BKGND_SET)
			
			elif cd_hex.terrain_type == 'Craters':
				for (x,y) in CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 5) == 1: continue
					roll = libtcod.random_get_int(generator, 1, 5)
					if roll == 1:
						col = libtcod.dark_sepia
						char = 94
					elif roll == 2:
						col = libtcod.dark_sepia
						char = 47
					else:
						col = libtcod.darkest_grey
						char = 7
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, bg_col)
			
			elif cd_hex.terrain_type == 'Graveyard':
				col = libtcod.dark_grey
				col2 = libtcod.darkest_green
				for (x,y) in CHAR_LOCATIONS:
					char = 0
					roll = libtcod.random_get_int(generator, 1, 8)
					if roll == 1:
						char = 5
					elif roll == 2:
						char = 6
					libtcod.console_put_char_ex(temp_con, x, y, char,
						col, col2)
				libtcod.console_set_char_background(temp_con, 3, 4,
					col2, libtcod.BKGND_SET)
			
			elif cd_hex.terrain_type == 'Deep Craters':
				col = libtcod.darkest_grey
				libtcod.console_put_char_ex(temp_con, 3, 2, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 2, 237, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 3, 3, 238, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 3, 239, col, bg_col)
				
				libtcod.console_put_char_ex(temp_con, 1, 4, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 4, 237, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 1, 5, 238, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 2, 5, 239, col, bg_col)
				
				libtcod.console_put_char_ex(temp_con, 4, 4, 236, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 5, 4, 237, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 4, 5, 238, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 5, 5, 239, col, bg_col)
			
			# South Pacific / Southeast Asian Terrain
			elif cd_hex.terrain_type in ['Jungle', 'Dense Jungle']:
				for (x,y) in CHAR_LOCATIONS:
					if cd_hex.terrain_type == 'Jungle':
						if libtcod.random_get_int(generator, 1, 10) < 3: continue
					roll = libtcod.random_get_int(generator, 1, 10)
					if roll == 1:
						col = libtcod.Color(102,82,51)
						libtcod.console_put_char_ex(temp_con, x, y, 124, col, bg_col)
					elif roll <= 4:
						col = libtcod.Color(0,64,0)
						libtcod.console_put_char_ex(temp_con, x, y, 177, col, bg_col)
					elif roll <= 6:
						col = libtcod.Color(0,64,0)
						libtcod.console_put_char_ex(temp_con, x, y, 7, col, bg_col)
					else:
						col = libtcod.Color(0,102,0)
						libtcod.console_put_char_ex(temp_con, x, y, 167, col, bg_col)
			
			elif cd_hex.terrain_type == 'Bamboo Forest':
				col = libtcod.Color(140,140,0)
				col2 = libtcod.Color(0,217,0)
				for (x,y) in CHAR_LOCATIONS:
					roll = libtcod.random_get_int(generator, 1, 10)
					if roll == 1: continue
					if roll <= 8:
						libtcod.console_put_char_ex(temp_con, x, y, 124, col, bg_col)
					elif roll <= 9:
						libtcod.console_put_char_ex(temp_con, x, y, 47, col, bg_col)
					else:
						libtcod.console_put_char_ex(temp_con, x, y, 5, col2, bg_col)
			
			elif cd_hex.terrain_type == 'Palm Trees':
				col = libtcod.Color(89,178,0)
				col2 = libtcod.Color(102,82,51)
				x = libtcod.random_get_int(generator, 2, 4)
				libtcod.console_put_char_ex(temp_con, x, 2, 42, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x, 3, 179, col2, bg_col)
				y = libtcod.random_get_int(generator, 3, 4)
				libtcod.console_put_char_ex(temp_con, 1, y, 42, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 1, y+1, 179, col2, bg_col)
				if y == 3:
					y = 4
				else:
					y = 3
				libtcod.console_put_char_ex(temp_con, 5, y, 42, col, bg_col)
				libtcod.console_put_char_ex(temp_con, 5, y+1, 179, col2, bg_col)
				x = libtcod.random_get_int(generator, 2, 4)
				libtcod.console_put_char_ex(temp_con, x, 5, 42, col, bg_col)
				libtcod.console_put_char_ex(temp_con, x, 6, 179, col2, bg_col)
			
			elif cd_hex.terrain_type == 'Cogon Grass':
				col = libtcod.Color(108,217,0)
				for (x,y) in CHAR_LOCATIONS:
					libtcod.console_put_char_ex(temp_con, x, y, 176, col, bg_col)
			
			elif cd_hex.terrain_type == 'Rice Paddies':
				col = libtcod.Color(134,178,0)
				for (x,y) in CHAR_LOCATIONS:
					libtcod.console_put_char_ex(temp_con, x, y, 19, col, bg_col)
			
			elif cd_hex.terrain_type == 'Volcanic Sand':
				col = libtcod.Color(51,51,51)
				for (x,y) in CHAR_LOCATIONS:
					libtcod.console_put_char_ex(temp_con, x, y, 177, col, bg_col)
			
			elif cd_hex.terrain_type == 'Hut Villages':
				col = libtcod.Color(128,102,64)
				col2 = libtcod.Color(0,64,0)
				for (x,y) in CHAR_LOCATIONS:
					roll = libtcod.random_get_int(generator, 1, 10)
					if roll <= 7: continue
					libtcod.console_put_char_ex(temp_con, x, y, 177, col2, bg_col)
				for (x,y) in CLOSE_CHAR_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 5) < 5: continue
					libtcod.console_put_char_ex(temp_con, x, y, 249, col, bg_col)
			
			elif cd_hex.terrain_type == 'Swamp':
				col = libtcod.Color(0,0,140)
				col2 = libtcod.Color(0,102,0)
				for (x,y) in CHAR_LOCATIONS:
					roll = libtcod.random_get_int(generator, 1, 10)
					if roll <= 9:
						libtcod.console_put_char_ex(temp_con, x, y, 176, col, bg_col)
					else:
						libtcod.console_put_char_ex(temp_con, x, y, 167, col2, bg_col)
					
			
			# draw landmine depictions if any on top
			if cd_hex.landmines:
				elements = libtcod.random_get_int(generator, 2, 5)
				while elements > 0:
					(x,y) = GetRandomLocation()
					# don't overwrite fortresses
					if libtcod.console_get_char(temp_con, x, y) in [10, 61, 186, 205]: continue
					libtcod.console_put_char_ex(temp_con, x, y, 250,
						libtcod.red, bg_col)
					elements -= 1
			
			# draw the final image to the map console
			(x,y) = self.PlotCDHex(hx, hy)
			libtcod.console_blit(temp_con, 0, 0, 0, 0, cd_map_con, x-3, y-4)
			
			# record screen locations of hex
			RecordScreenLocations(hx, hy)
			
		del temp_con, dayhex
		
		# set a default road color in case we need to draw an edge road first
		if campaign.stats['region'] == 'North Africa':
			col = libtcod.Color(160,130,100)
		else:
			col = DIRT_ROAD_COL
		
		# draw stone and dirt roads overtop
		for (hx, hy), map_hex in self.map_hexes.items():
			if map_hex.road_links == [None,None,None,None,None,None]: continue
			
			road_num = 0
			
			(x1, y1) = self.PlotCDHex(hx, hy)
			
			for direction in range(3):
				
				if map_hex.road_links[direction] is None: continue
				
				# get the other zone linked by road
				(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
				if (hx2, hy2) not in self.map_hexes: continue
				
				road_num += 1
				
				# paint road
				if map_hex.road_links[direction] is False:
					if campaign.stats['region'] == 'North Africa':
						col = libtcod.Color(160,130,100)
					else:
						col = DIRT_ROAD_COL
				else:
					col = STONE_ROAD_COL
				(x2, y2) = self.PlotCDHex(hx2, hy2)
				line = GetLine(x1, y1, x2, y2)
				for (x, y) in line:
				
					# don't paint outside of map area
					if libtcod.console_get_char_background(cd_map_con, x, y) == libtcod.black:
						continue
					libtcod.console_set_char_background(cd_map_con, x, y,
						col, libtcod.BKGND_SET)
					
					# if greeble is a field, erase it
					char = libtcod.console_get_char(cd_map_con, x, y)
					if char in [176]:
						libtcod.console_put_char(cd_map_con, x, y, 0)
			
			# if map hex is on edge and has 1 road connection, draw a road leading off the edge of the map
			if road_num > 1: continue
			
			off_map_hexes = []
			for direction in range(6):
				(hx2, hy2) = self.GetAdjacentCDHex(hx, hy, direction)
				if (hx2, hy2) not in self.map_hexes:
					off_map_hexes.append((hx2, hy2))
			if len(off_map_hexes) == 0: continue
			
			(hx2, hy2) = off_map_hexes[0]
			(x2, y2) = self.PlotCDHex(hx2, hy2)
			for (x, y) in GetLine(x1, y1, x2, y2):
				if libtcod.console_get_char_background(cd_map_con, x, y) == libtcod.black:
					break
					
				libtcod.console_set_char_background(cd_map_con, x, y,
					col, libtcod.BKGND_SET)
					
				# if character is not blank or hex edge, remove it
				if libtcod.console_get_char(cd_map_con, x, y) not in [0, 249, 250]:
					libtcod.console_set_char(cd_map_con, x, y, 0)
		
		# draw rivers overtop
		for (hx, hy), map_hex in self.map_hexes.items():
			if len(map_hex.rivers) == 0: continue
			
			(x, y) = self.PlotCDHex(hx, hy)
			
			# draw each river edge
			for direction in map_hex.rivers:
				for (xm, ym) in CD_HEX_EDGE_CELLS[direction]:
					libtcod.console_put_char_ex(cd_map_con, x+xm, y+ym, 0,
						libtcod.white, river_col)
					
			# draw any bridges
			for direction in map_hex.bridges:
				for (xm, ym) in CD_HEX_EDGE_CELLS[direction][1:-1]:
					bg_col = libtcod.console_get_char_background(cd_map_con, x+xm, y+ym)
					if direction in [0, 3]:
						char = 47
					elif direction in [2, 5]:
						char = 92
					else:
						char = 45
					libtcod.console_put_char_ex(cd_map_con, x+xm, y+ym, char,
						libtcod.dark_sepia, bg_col)
					# also record location
					self.cd_map_bridge_locations.append((x+xm, y+ym))
		
		# draw hex row and column guides
		for i in range(0, 9):
			libtcod.console_put_char_ex(cd_map_con, 0, 6+(i*5), chr(i+65),
				libtcod.light_green, libtcod.black)
		for i in range(0, 5):
			libtcod.console_put_char_ex(cd_map_con, 7+(i*6), 50, chr(i+49),
				libtcod.light_green, libtcod.black)
		for i in range(5, 9):
			libtcod.console_put_char_ex(cd_map_con, 32, 39-((i-5)*10), chr(i+49),
				libtcod.light_green, libtcod.black)
		
		# draw arrows in direction of possible travel
		if self.rattenkrieg or self.mission in ['Hold the Line', 'Amphibious Assault']:
			return
		
		if self.mission in ['Fighting Withdrawal', 'Counterattack']:
			y = 52
			char = 25
		else:
			y = 0
			char = 24
		
		for i in range(0, 5):
			libtcod.console_put_char_ex(cd_map_con, 5+(i*6), y, char, libtcod.black,
				libtcod.darkest_green)
	
	
	# generate/update the campaign day unit layer console
	def UpdateCDUnitCon(self):
		libtcod.console_clear(cd_unit_con)
		libtcod.console_set_default_foreground(cd_unit_con, libtcod.white)
		
		# enemy strength level, player arty/air support
		libtcod.console_set_default_foreground(cd_unit_con, libtcod.red)
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			map_hex = self.map_hexes[(hx,hy)]
			if map_hex.enemy_strength > 0 and map_hex.known_to_player:
				(x,y) = self.PlotCDHex(hx, hy)
				libtcod.console_print(cd_unit_con, x, y-1, str(map_hex.enemy_strength))
		
		# draw player unit group
		(hx, hy) = self.player_unit_location
		(x,y) = self.PlotCDHex(hx, hy)
		
		# apply animation offset if any
		x += session.cd_x_offset
		y += session.cd_y_offset
		
		libtcod.console_put_char_ex(cd_unit_con, x, y, '@', libtcod.white, libtcod.black)
	
	
	# generate/update the zone control console, showing the battlefront between two sides
	def UpdateCDControlCon(self):
		libtcod.console_clear(cd_control_con)
		
		# run through every hex, if it's not under enemy control, see if there an adjacent
		# enemy-controlled hex and if so, draw a border there
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if self.map_hexes[(hx,hy)].controlled_by == 1: continue
			
			for direction in range(6):
				(hx_m, hy_m) = CD_DESTHEX[direction]
				hx2 = hx+hx_m
				hy2 = hy+hy_m
				
				# hex is off map
				if (hx2, hy2) not in self.map_hexes: continue
				# hex is not enemy-controlled
				if self.map_hexes[(hx2,hy2)].controlled_by != 1: continue
				
				# draw a border
				(x,y) = self.PlotCDHex(hx, hy)
				
				# urban maps have more greebles and no rivers, so we draw the borders along the hex
				# edges
				if self.rattenkrieg:
					edge_cells = CD_HEX_EDGE_CELLS
				else:
					edge_cells = CD_HEX_EDGE_CELLS2
				for (xm,ym) in edge_cells[direction]:
					libtcod.console_put_char_ex(cd_control_con, x+xm,
						y+ym, chr(249), libtcod.red, libtcod.black)
		
		# highlight any objective hexes
		for (hx, hy) in CAMPAIGN_DAY_HEXES:
			if self.map_hexes[(hx,hy)].objective is None: continue
			(x,y) = self.PlotCDHex(hx, hy)
			libtcod.console_put_char_ex(cd_control_con, x, y, chr(249),
				libtcod.yellow, libtcod.black)
	
	
	# generate/update the GUI console. recon var tells it to skip a spot in the drive direction line.
	def UpdateCDGUICon(self, recon = False):
		libtcod.console_clear(cd_gui_con)
		
		# movement menu tab active
		if self.active_menu == 3:
			
			# map hex view mode active
			if session.cd_view_mode:
				
				if session.cd_view_hex is None: return
				(hx, hy) = session.cd_view_hex
				(x,y) = self.PlotCDHex(hx, hy)
				libtcod.console_blit(session.cd_hex_highlight_con, 0, 0, 0, 0,
					cd_gui_con, x-3, y-4, 1.0, 0.0)
				return
			
			# a direction is currently selected
			elif self.selected_direction is not None:
				# draw directional line
				(hx, hy) = self.player_unit_location
				(x1,y1) = self.PlotCDHex(hx, hy)
				(hx, hy) = self.GetAdjacentCDHex(hx, hy, self.selected_direction)
				if (hx, hy) in self.map_hexes:
					(x2,y2) = self.PlotCDHex(hx, hy)
					line = GetLine(x1,y1,x2,y2)
					if recon:
						line.pop(0)
					for (x,y) in line[1:-1]:
						libtcod.console_put_char_ex(cd_gui_con, x, y, 250, libtcod.green,
							libtcod.black)
					(x,y) = line[-1]
					libtcod.console_put_char_ex(cd_gui_con, x, y, CD_DIR_ARROW[self.selected_direction],
						libtcod.green, libtcod.black)
		
	
	# generate/update the player unit console
	# On supply pane, highlight the selected weapon. On crew pane, highlight weapons operated by the selected position.
	def UpdateCDPlayerUnitCon(self):
		libtcod.console_clear(cd_player_unit_con)
		weapon = None
		position = None
		if self.active_menu == 1:
			weapon = self.selected_gun
		elif self.active_menu == 2:
			position = self.selected_position
		DisplayUnitInfo(cd_player_unit_con, 0, 0, campaign.player_unit.unit_id, campaign.player_unit,
			status=False, weapon_highlight=weapon, position_highlight=position)
	
	
	# generate/update the command menu console 25x41
	def UpdateCDCommandCon(self):
		libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
		libtcod.console_set_default_background(cd_command_con, libtcod.black)
		libtcod.console_clear(cd_command_con)
		
		libtcod.console_set_default_foreground(cd_command_con, TITLE_COL)
		libtcod.console_print(cd_command_con, 6, 0, 'Command Menu')
		
		x = 0
		for (text, num, col) in CD_MENU_LIST:
			libtcod.console_set_default_background(cd_command_con, col)
			libtcod.console_rect(cd_command_con, x, 1, 2, 1, True, libtcod.BKGND_SET)
			
			# display menu number
			libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
			libtcod.console_print(cd_command_con, x, 1, str(num))
			libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			
			x += 2
			
			# display menu text if tab is active
			if self.active_menu == num:
				libtcod.console_rect(cd_command_con, x, 1, len(text)+2, 1,
					True, libtcod.BKGND_SET)
				libtcod.console_print(cd_command_con, x, 1, text)
				x += len(text) + 2
		
		# fill in rest of menu line with final colour
		libtcod.console_rect(cd_command_con, x, 1, 25-x, 1, True, libtcod.BKGND_SET)
		libtcod.console_set_default_background(cd_command_con, libtcod.black)
		
		# supply
		if self.active_menu == 1:
			y = 3
			# list guns in gun list
			for gun in self.gun_list:
				if gun == self.selected_gun:
					libtcod.console_set_default_background(cd_command_con, libtcod.darker_blue)
					libtcod.console_rect(cd_command_con, 5, y, 15, 1, True, libtcod.BKGND_SET)
					libtcod.console_set_default_background(cd_command_con, libtcod.black)
				libtcod.console_print_ex(cd_command_con, 12, y, libtcod.BKGND_NONE, libtcod.CENTER, gun.GetStat('name'))
				y += 1

			if self.selected_gun is not None:
				y = self.selected_gun.DisplayAmmo(cd_command_con, 6, y) + 3 # +3 to always be below any extra ammo line, and so text doesn't joggle when adding/removing extra shells.

				# Generate modified saved & default ready rack templates, in case there's not enough ammo to fill them.
				possible_saved_rr = self.selected_gun.CheckLoadoutTemplate(self.selected_gun.default_ready_rack)[0]
				possible_default_rr = self.selected_gun.CheckLoadoutTemplate(self.selected_gun.GenerateDefaultLoadout(True)[1])[0]

				# Count how many rounds are loaded in the ready rack, so we can't save an empty rack as a preset, ensuring consistency with resupply screen behaviour.
				rr_num = 0
				for ammo_type in self.selected_gun.ready_rack:
					rr_num += self.selected_gun.ready_rack[ammo_type]
				
				# display inputs
				post_ammo_y = y
				
				# cycle selected gun
				if len(self.gun_list) > 1:
					if gamepad is not None:
						DisplayButton(cd_command_con, 3, y, GAMEPADCHAR_LB)
						DisplayButton(cd_command_con, 4, y, GAMEPADCHAR_RB)
					else:
						libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
						libtcod.console_print(cd_command_con, 4, y, EnKey('q').upper()) 
				y += 2
				
				# select ammo type / remove or add ammo
				if gamepad is not None:
					DisplayButton(cd_command_con, 4, y, GAMEPADCHAR_DPAD_UD)
					y += 1
					DisplayButton(cd_command_con, 4, y, GAMEPADCHAR_DPAD_LR)
				else:
					libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
					libtcod.console_print(cd_command_con, 2, y, EnKey('w').upper() + '/' + EnKey('s').upper()) 
					y += 1
					libtcod.console_print(cd_command_con, 2, y, EnKey('a').upper() + '/' + EnKey('d').upper()) # remove/add ammo
				y += 1
				
				# TODO: possible to add gamepad inputs for these?
				HOTKEYS = ['t', 'g', 'b'] # Buttons to fill RR with first 3 ammo types, almost always HE/AP/APCR or the like.
				for i in range(min(3, len(self.selected_gun.stats['ammo_type_list']))):
					ammotype = self.selected_gun.stats['ammo_type_list'][i]
					if self.selected_gun.ready_rack[ammotype] == self.selected_gun.rr_size or self.selected_gun.ammo_stores[ammotype] == 0:
						libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
					else:
						libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
					libtcod.console_print(cd_command_con, 4, y, EnKey(HOTKEYS[i]).upper())
					y += 1
				y += 1

				if len(self.selected_gun.default_ready_rack) == 0 or possible_saved_rr == self.selected_gun.ready_rack:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				libtcod.console_print(cd_command_con, 4, y, EnKey('f').upper()) # saved RR
				y += 1
				if rr_num == 0 or self.selected_gun.ready_rack == self.selected_gun.default_ready_rack:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				libtcod.console_print(cd_command_con, 4, y, EnKey('v').upper()) # save current RR
				
				y += 2
				if possible_default_rr != self.selected_gun.ready_rack:
					if gamepad is not None:
						DisplayButton(cd_command_con, 4, y, GAMEPADCHAR_X)
					else:
						libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
						libtcod.console_print(cd_command_con, 4, y, EnKey('x').upper()) # default RR

				# display input descriptions
				y = post_ammo_y
				if len(self.gun_list) == 1:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 6, y, 'Cycle Selected Gun')
				y += 2
				libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 6, y, 'Select Ammo Type')
				y += 1
				libtcod.console_print(cd_command_con, 6, y, 'Remove/Add Round')
				y += 1

				for i in range(min(3, len(self.selected_gun.stats['ammo_type_list']))):
					ammotype = self.selected_gun.stats['ammo_type_list'][i]
					if self.selected_gun.ready_rack[ammotype] == self.selected_gun.rr_size or self.selected_gun.ammo_stores[ammotype] == 0:
						libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
					else:
						libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
					libtcod.console_print(cd_command_con, 6, y, 'Fill RR with ' + ammotype)
					y += 1
				y += 1

				if len(self.selected_gun.default_ready_rack) == 0 or possible_saved_rr == self.selected_gun.ready_rack:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 6, y, 'Apply Saved RR')
				y += 1

				if rr_num == 0 or self.selected_gun.ready_rack == self.selected_gun.default_ready_rack:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 6, y, 'Save Ready Rack')
				y += 2

				if possible_default_rr == self.selected_gun.ready_rack:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 6, y, 'Apply Default RR')

			# Now count upwards: flamethrower ammo, smoke grenades, smoke mortar, resupply button at the very bottom.
			if gamepad is not None:
				DisplayButton(cd_command_con, 4, 37, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL) 
				libtcod.console_print(cd_command_con, 4, 37, EnKey('r').upper())
			libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
			libtcod.console_print(cd_command_con, 6, 37, 'Request Resupply')

			y = 34
			# display smoke grenades and smoke mortar ammo if any
			if campaign.player_unit.GetStat('smoke_mortar') is not None:
				if self.smoke_mortar_rounds == 0:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.light_red)
				else:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
				text = 'Smoke Mortar Rounds: ' + str(self.smoke_mortar_rounds)
				libtcod.console_print_ex(cd_command_con, 12, y, libtcod.BKGND_NONE, libtcod.CENTER, text)
				y -= 1

			if self.smoke_grenades == 0:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.light_red)
			else:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			text = 'Smoke Grenades: ' + str(self.smoke_grenades)
			libtcod.console_print_ex(cd_command_con, 12, y, libtcod.BKGND_NONE, libtcod.CENTER, text)

			y -= 2
			# display flamethrower fuel, if any, sorting weapons in reverse order since we're going backwards.
			for weapon in campaign.player_unit.weapon_list[::-1]:
				if weapon.stats['type'] != 'Flame Thrower': continue
				if weapon.flame_ammo == 0:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.light_red)
				else:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
				text = weapon.stats['mount'] + ' FTR Fuel: ' + str(weapon.flame_ammo) + '/' + str(weapon.flame_ammo_max)
				libtcod.console_print_ex(cd_command_con, 12, y, libtcod.BKGND_NONE, libtcod.CENTER, text)
				y -= 1

		# crew
		elif self.active_menu == 2:
			
			DisplayCrew(campaign.player_unit, cd_command_con, 0, 3,
				self.selected_position, show_default=True)
			
			# display inputs
			if gamepad is not None:
				DisplayButton(cd_command_con, 6, 33, GAMEPADCHAR_Y)
				DisplayButton(cd_command_con, 6, 34, GAMEPADCHAR_DPAD_UD)
				DisplayButton(cd_command_con, 6, 35, GAMEPADCHAR_B)
				DisplayButton(cd_command_con, 6, 36, GAMEPADCHAR_A)
				DisplayButton(cd_command_con, 6, 37, GAMEPADCHAR_X)
				DisplayButton(cd_command_con, 6, 38, GAMEPADCHAR_BACK)
			else:
				libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				libtcod.console_print(cd_command_con, 3, 33, 'Tab')
				libtcod.console_print(cd_command_con, 3, 34, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(cd_command_con, 3, 35, EnKey('p').upper())
				libtcod.console_print(cd_command_con, 3, 36, EnKey('e').upper())
				libtcod.console_print(cd_command_con, 3, 37, EnKey('h').upper())
				libtcod.console_print(cd_command_con, 3, 38, EnKey('b').upper())
				libtcod.console_print(cd_command_con, 3, 39, EnKey('c').upper())
			
			libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
			libtcod.console_print(cd_command_con, 8, 33, 'Wait/Rest')
			libtcod.console_print(cd_command_con, 8, 34, 'Select Position')
			libtcod.console_print(cd_command_con, 8, 35, 'Swap Position')
			libtcod.console_print(cd_command_con, 8, 36, 'Crewman Menu')
			libtcod.console_print(cd_command_con, 8, 37, 'Toggle Hatch')
			libtcod.console_print(cd_command_con, 8, 38, 'Button/Open Up!')
			libtcod.console_print(cd_command_con, 8, 39, 'Clear Default')
		
		# travel
		elif self.active_menu == 3:
			
			# map hex view mode is enabled
			if session.cd_view_mode:
				
				libtcod.console_set_default_foreground(cd_command_con, libtcod.light_green)
				libtcod.console_print_ex(cd_command_con, 12, 3, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Map Zone View Mode')
				
				libtcod.console_set_default_foreground(cd_command_con, libtcod.light_grey)
				libtcod.console_print(cd_command_con, 0, 5, 'Move Highlight to display')
				libtcod.console_print(cd_command_con, 0, 6, 'info in bottom right')
				
				# display and highlight move directions
				x1 = 12
				y1 = 10
				for direction in range(6):
					
					(k, x, y, char) = CD_TRAVEL_CMDS[direction]
					if gamepad is not None:
						DisplayButton(cd_command_con, x1+x, y1+y, GAMEPADCHAR_LS)
					else:
						libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
						libtcod.console_put_char(cd_command_con, x1+x, y1+y, EnKey(k).upper())
					if direction <= 2:
						x+=1
					else:
						x-=1
					libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_green)
					libtcod.console_put_char(cd_command_con, x1+x, y1+y, chr(char))
				
				libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				if gamepad is not None:
					DisplayButton(cd_command_con, 1, 39, GAMEPADCHAR_LSB)
				else:
					libtcod.console_print(cd_command_con, 1, 39, EnKey('v').upper())
				
				libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 5, 39, 'Exit View Mode')
				return
			
			# display current support levels at top
			y = 3
			if 'air_support_level' in campaign.current_week:
				libtcod.console_print(cd_command_con, 0, y, 'Air Support:')
				if self.weather['Cloud Cover'] == 'Overcast' or self.weather['Fog'] > 0 or self.weather['Precipitation'] == 'Sandstorm':
					text = 'Not Possible'
				else:
					text = str(int(self.air_support_level)) + '%'
				libtcod.console_print_ex(cd_command_con, 24, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, text)
				y += 1
			
			if 'arty_support_level' in campaign.current_week:
				libtcod.console_print(cd_command_con, 0, y, 'Artillery Support:')
				text = str(int(self.arty_support_level)) + '%'
				libtcod.console_print_ex(cd_command_con, 24, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, text)
				y += 1
			
			if 'player_unit_support' in campaign.stats:
				libtcod.console_print(cd_command_con, 0, y, 'Unit Support:')
				text = str(int(self.unit_support_level)) + '%'
				libtcod.console_print_ex(cd_command_con, 24, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, text)
			
			# display directional options
			x1 = 12
			y1 = 10
			
			# display possible support/move/recon directions
			libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			libtcod.console_put_char(cd_command_con, x1, y1, '@')
			
			for direction in range(6):
				libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				
				if self.selected_direction is not None:
					if self.selected_direction == direction:
						libtcod.console_set_default_foreground(cd_command_con, libtcod.light_green)
				
				(k, x, y, char) = CD_TRAVEL_CMDS[direction]
				if gamepad is not None:
					DisplayButton(cd_command_con, x1+x, y1+y, GAMEPADCHAR_LS)
				else:
					libtcod.console_put_char(cd_command_con, x1+x, y1+y, EnKey(k).upper())
				if direction <= 2:
					x+=1
				else:
					x-=1
				libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_green)
				libtcod.console_put_char(cd_command_con, x1+x, y1+y, chr(char))
			
			if self.selected_direction is None:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.light_grey)
				libtcod.console_print_ex(cd_command_con, 13, y1+4, libtcod.BKGND_NONE, libtcod.CENTER,
					'Select a Direction')
			
			# display View Mode, Return to Base, and Wait commands (always available)
			libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
			if gamepad is not None:
				DisplayButton(cd_command_con, 1, 35, GAMEPADCHAR_LSB)
				DisplayButton(cd_command_con, 1, 36, GAMEPADCHAR_BACK)
				DisplayButton(cd_command_con, 1, 37, GAMEPADCHAR_Y)
			else:
				libtcod.console_print(cd_command_con, 1, 35, EnKey('v').upper())
				libtcod.console_print(cd_command_con, 1, 36, EnKey('i').upper())
				libtcod.console_print(cd_command_con, 1, 37, EnKey('w').upper())
			
			libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
			libtcod.console_print(cd_command_con, 5, 35, 'Enter View Mode')
			libtcod.console_print(cd_command_con, 5, 36, 'Return to Base')
			libtcod.console_print(cd_command_con, 5, 37, 'Wait/Rest')
			
			# check to see whether travel in selected direction is possible
			map_hex = None
			if self.selected_direction is not None:
				
				(hx1, hy1) = self.player_unit_location
				(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, self.selected_direction)
				if (hx2, hy2) not in self.map_hexes: return
				
				# calculate and display travel time
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
				libtcod.console_print(cd_command_con, 0, 20, 'Travel Time:')
				travel_text = self.CheckTravel(hx1, hy1, hx2, hy2)
				
				# travel not allowed
				if travel_text != '':
					libtcod.console_set_default_foreground(cd_command_con, libtcod.light_red)
				else:
					travel_time = self.CalculateTravelTime(hx1, hy1, hx2, hy2)
					travel_text = str(travel_time) + ' mins.'
					
					# change display colour based on travel time
					if travel_time <= 15:
						col = libtcod.light_green
					elif travel_time <= 30:
						col = libtcod.green
					elif travel_time <= 45:
						col = libtcod.dark_yellow
					elif travel_time <= 60:
						col = libtcod.light_yellow
					else:
						col = libtcod.yellow
					libtcod.console_set_default_foreground(cd_command_con, col)
					
				libtcod.console_print(cd_command_con, 1, 21, travel_text)
				
				# don't display anything further if travel is N/A
				if 'N/A' in travel_text:
					return
				
				# river crossing
				if self.RiverCrossing(hx1, hy1, hx2, hy2):
					if campaign.stats['region'] == 'North Africa':
						text = 'Wadi Crossing'
					else:
						text = 'River Crossing'
					libtcod.console_print(cd_command_con, 1, 22, text)
				
				# display enemy strength/organization if any and chance of encounter
				map_hex = self.map_hexes[(hx2,hy2)]
				if map_hex.controlled_by in [1, 2]:
					
					libtcod.console_set_default_foreground(cd_command_con, libtcod.red)
					libtcod.console_print(cd_command_con, 3, 15, 'Destination is')
					if map_hex.controlled_by == 1:
						text = 'Enemy Controlled'
					else:
						text = 'Neutral Territory'
					
					libtcod.console_print(cd_command_con, 3, 16, text)
					
					# display recon option if strength is unknown and travel is possible
					if not map_hex.known_to_player and 'N/A' not in text and self.mission != 'Amphibious Assault':
						libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
						libtcod.console_print(cd_command_con, 0, 18, 'Recon: 10 mins.')
						
						# display inputs
						if gamepad is not None:
							DisplayButton(cd_command_con, 1, 38, GAMEPADCHAR_X)
						else:
							libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
							libtcod.console_print(cd_command_con, 1, 38, EnKey('r').upper())
						libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
						libtcod.console_print(cd_command_con, 5, 38, 'Recon')
					
				# display enemy strength if present and known
				if map_hex.enemy_strength > 0 and map_hex.known_to_player:
					libtcod.console_set_default_foreground(cd_command_con, libtcod.red)
					if map_hex.controlled_by != 1:
						libtcod.console_print(cd_command_con, 3, 15, 'Enemy forces active')
						libtcod.console_print(cd_command_con, 3, 16, 'in this area')
					libtcod.console_print(cd_command_con, 3, 17, 'Strength: ' + str(map_hex.enemy_strength))
					libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
				
				# display inputs
				if gamepad is not None:
					DisplayButton(cd_command_con, 1, 39, GAMEPADCHAR_A)
				else:
					libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
					libtcod.console_print(cd_command_con, 1, 39, 'Tab')
				libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				libtcod.console_print(cd_command_con, 5, 39, 'Proceed')
			
			# determine if offensive support options should be displayed
			attack_options = False
			waiting = False
			if self.selected_direction is not None:
				if map_hex.enemy_strength > 0:
					attack_options = True
			else:
				waiting = True
			
			libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			libtcod.console_print(cd_command_con, 1, 28, 'Support Options')
			
			# display inputs
			if gamepad is not None:
				DisplayButton(cd_command_con, 1, 30, 24)
				DisplayButton(cd_command_con, 1, 31, 26)
				DisplayButton(cd_command_con, 1, 32, 25)
				DisplayButton(cd_command_con, 1, 33, 27)
			else:
				libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				libtcod.console_print(cd_command_con, 1, 30, EnKey('t').upper())
				libtcod.console_print(cd_command_con, 1, 31, EnKey('g').upper())
				libtcod.console_print(cd_command_con, 1, 32, EnKey('b').upper())
				libtcod.console_print(cd_command_con, 1, 33, EnKey('n').upper())
			
			# advancing fire
			if not attack_options:
				libtcod.console_set_default_background(cd_command_con, libtcod.darkest_grey)
				libtcod.console_rect(cd_command_con, 3, 30, 20, 1, True, libtcod.BKGND_SET)
				libtcod.console_set_default_foreground(cd_command_con, libtcod.black)
			elif self.advancing_fire:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			else:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
			libtcod.console_print(cd_command_con, 3, 30, 'Advancing Fire')
			
			# air support request
			if not attack_options or 'air_support_level' not in campaign.current_week or self.weather['Cloud Cover'] == 'Overcast' or self.weather['Fog'] > 0 or self.weather['Precipitation'] == 'Sandstorm':
				libtcod.console_set_default_background(cd_command_con, libtcod.darkest_grey)
				libtcod.console_rect(cd_command_con, 3, 31, 20, 1, True, libtcod.BKGND_SET)
				libtcod.console_set_default_foreground(cd_command_con, libtcod.black)
			elif self.air_support_request:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			else:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
			libtcod.console_print(cd_command_con, 3, 31, 'Request Air Support')
			
			# artillery support request
			if not attack_options or 'arty_support_level' not in campaign.current_week:
				libtcod.console_set_default_background(cd_command_con, libtcod.darkest_grey)
				libtcod.console_rect(cd_command_con, 3, 32, 20, 1, True, libtcod.BKGND_SET)
				libtcod.console_set_default_foreground(cd_command_con, libtcod.black)
			elif self.arty_support_request:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			else:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
			libtcod.console_print(cd_command_con, 3, 32, 'Request Arty Support')
			
			# unit support request
			if 'unit_support_level' not in campaign.current_week or not (attack_options or waiting):
				libtcod.console_set_default_background(cd_command_con, libtcod.darkest_grey)
				libtcod.console_rect(cd_command_con, 3, 33, 20, 1, True, libtcod.BKGND_SET)
				libtcod.console_set_default_foreground(cd_command_con, libtcod.black)
			elif self.unit_support_request:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			else:
				libtcod.console_set_default_foreground(cd_command_con, libtcod.dark_grey)
			libtcod.console_print(cd_command_con, 3, 33, 'Request Unit Support')
			
			libtcod.console_set_default_background(cd_command_con, libtcod.black)
			
		# squad
		elif self.active_menu == 4:
			
			libtcod.console_set_default_foreground(cd_command_con, TITLE_COL)
			libtcod.console_print(cd_command_con, 0, 3, 'Squad:')
			
			y = 4
			for unit in self.player_squad:
				
				# unit ID
				libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
				libtcod.console_print(cd_command_con, 0, y, unit.unit_id)
				
				# commander surname
				if unit.positions_list[0].crewman is not None:
					y += 1
					libtcod.console_set_default_foreground(cd_command_con, libtcod.light_grey)
					PrintExtended(cd_command_con, 1, y, unit.positions_list[0].crewman.last_name)
				
				# display weapon statuses if any
				libtcod.console_set_default_foreground(cd_command_con, libtcod.lighter_grey)
				for weapon in unit.weapon_list:
					if weapon.broken:
						y += 1
						libtcod.console_print(cd_command_con, 2, y, weapon.GetStat('name') + ' broken')
						continue
					
					if weapon.GetStat('type') == 'Gun':
						out_of_ammo = True
						for ammo_type in weapon.stats['ammo_type_list']:
							if ammo_type in weapon.ammo_stores:
								if weapon.ammo_stores[ammo_type] > 0:
									out_of_ammo = False
									break
								if weapon.ready_rack[ammo_type] > 0:
									out_of_ammo = False
									break
						if out_of_ammo:
							y += 1
							libtcod.console_print(cd_command_con, 2, y, weapon.GetStat('name') + ' out of ammo')
					
					elif weapon.stats['type'] == 'Flame Thrower':
						if weapon.flame_ammo == 0:
							y += 1
							libtcod.console_print(cd_command_con, 2, y, weapon.GetStat('name') + ' out of fuel')
				y += 2
				if y >= 31: break
			
			libtcod.console_set_default_foreground(cd_command_con, libtcod.white)
			libtcod.console_print_ex(cd_command_con, 12, 33, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Current Command:')	
			libtcod.console_set_default_foreground(cd_command_con, libtcod.light_purple)
			libtcod.console_print_ex(cd_command_con, 12, 34, libtcod.BKGND_NONE,
				libtcod.CENTER, campaign.battlegroup_command)
			
			# display inputs
			if gamepad is not None:
				DisplayButton(cd_command_con, 1, 36, GAMEPADCHAR_A)
				DisplayButton(cd_command_con, 1, 37, GAMEPADCHAR_B)
				DisplayButton(cd_command_con, 1, 38, GAMEPADCHAR_X)
				DisplayButton(cd_command_con, 1, 39, GAMEPADCHAR_Y)
			else:
				libtcod.console_set_default_foreground(cd_command_con, ACTION_KEY_COL)
				libtcod.console_print(cd_command_con, 1, 36, EnKey('q').upper())
				libtcod.console_print(cd_command_con, 1, 37, EnKey('a').upper())
				libtcod.console_print(cd_command_con, 1, 38, EnKey('z').upper())
				libtcod.console_print(cd_command_con, 1, 39, EnKey('x').upper())
			
			libtcod.console_set_default_foreground(cd_command_con, libtcod.light_grey)
			libtcod.console_print(cd_command_con, 6, 36, 'Fire at Will')
			libtcod.console_print(cd_command_con, 6, 37, 'Attack my Target')
			libtcod.console_print(cd_command_con, 6, 38, 'Hold Fire')
			libtcod.console_print(cd_command_con, 6, 39, 'On my Mark')
	
	
	# generate/update the campaign info console 23x9
	def UpdateCDCampaignCon(self):
		libtcod.console_set_default_background(cd_campaign_con, libtcod.darkest_blue)
		libtcod.console_clear(cd_campaign_con)
		libtcod.console_set_default_foreground(cd_campaign_con, libtcod.light_blue)
		libtcod.console_print_ex(cd_campaign_con, 11, 0, libtcod.BKGND_NONE, libtcod.CENTER,
			'Mission')
		libtcod.console_print_ex(cd_campaign_con, 11, 3, libtcod.BKGND_NONE, libtcod.CENTER,
			'VP Today')
		libtcod.console_print_ex(cd_campaign_con, 11, 6, libtcod.BKGND_NONE, libtcod.CENTER,
			'Radio Comms')
		
		libtcod.console_set_default_foreground(cd_campaign_con, libtcod.white)
		libtcod.console_print_ex(cd_campaign_con, 11, 1, libtcod.BKGND_NONE, libtcod.CENTER,
			self.mission)
		libtcod.console_print_ex(cd_campaign_con, 11, 4, libtcod.BKGND_NONE, libtcod.CENTER,
			str(self.day_vp))
		
		libtcod.console_set_default_foreground(cd_campaign_con, libtcod.light_grey)
		text = 'BG'
		if self.bg_radio_comms:
			text += chr(251)
		else:
			text += 'x'
		libtcod.console_print(cd_campaign_con, 8, 7, text)
		
		text = 'HQ'
		if self.hq_radio_comms:
			text += chr(251)
		else:
			text += 'x'
		libtcod.console_print(cd_campaign_con, 12, 7, text)
		
	
	# generate/update the zone info console 23x35
	def UpdateCDHexInfoCon(self):
		libtcod.console_clear(cd_hex_info_con)
		
		libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.blue)
		libtcod.console_print_ex(cd_hex_info_con, 11, 0, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Zone Info')
		
		# map hex view mode active
		if session.cd_view_mode:
			
			if session.cd_view_hex is None: return
			(hx, hy) = session.cd_view_hex
			cd_hex = self.map_hexes[(hx, hy)]
			
		else:
		
			x = mouse.cx - 29 - window_x
			y = mouse.cy - 6 - window_y
			
			# bridge location
			if (x,y) in self.cd_map_bridge_locations:
				libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.dark_sepia)
				libtcod.console_print(cd_hex_info_con, 2, 2, 'Bridge')
				return
			
			# no zone here or mouse cursor outside of map area
			if (x,y) not in self.cd_map_index or x < 2 or x > 30:
				
				# no zone currently selected for recon or travel
				if self.selected_direction is None:
					libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_grey)
					libtcod.console_print(cd_hex_info_con, 2, 2, 'Mouseover an area')
					libtcod.console_print(cd_hex_info_con, 2, 3, 'for info')
					return
				
				# get the zone currently selected for recon or travel
				(hx, hy) = self.player_unit_location
				(hx, hy) = self.GetAdjacentCDHex(hx, hy, self.selected_direction)
			
			else:
			
				# find the hex under the mouse cursor
				(hx, hy) = self.cd_map_index[(x,y)]
			
			cd_hex = self.map_hexes[(hx, hy)]
		
		# display hex zone coordinates
		libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_green)
		libtcod.console_print_ex(cd_hex_info_con, 11, 1, libtcod.BKGND_NONE,
			libtcod.CENTER, cd_hex.coordinate)
		
		# debug mode only - display hx and hy
		if DEBUG:
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.yellow)
			libtcod.console_print_ex(cd_hex_info_con, 22, 0, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(hx) + ',' + str(hy))
		
		# terrain and description
		libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.white)
		libtcod.console_print(cd_hex_info_con, 0, 3, cd_hex.terrain_type)
		
		libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_grey)
		y = 5
		lines = wrap(CD_TERRAIN_TYPES[cd_hex.terrain_type]['description'], 21)
		for line in lines:
			libtcod.console_print(cd_hex_info_con, 1, y, line)
			y += 1
			if y == 10: break
		
		if 'impassible' in CD_TERRAIN_TYPES[cd_hex.terrain_type]:
			return
		
		# control
		if cd_hex.controlled_by == 0:
			libtcod.console_set_default_foreground(cd_hex_info_con, ALLIED_UNIT_COL)
			libtcod.console_print(cd_hex_info_con, 0, 12, 'Friendly controlled')
		else:
			# enemy-controlled
			if cd_hex.controlled_by == 1:
				col = ENEMY_UNIT_COL
				text = 'Enemy controlled'
			else:
				col = libtcod.sepia
				text = 'Neutral Territory'
			libtcod.console_set_default_foreground(cd_hex_info_con, col)
			libtcod.console_print(cd_hex_info_con, 0, 12, text)
			
		# VP value if captured
		if cd_hex.controlled_by == 1:
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_blue)
			libtcod.console_print(cd_hex_info_con, 0, 13, 'Capture VP Value: ' + str(cd_hex.vp_value))
		
		# roads
		if False in cd_hex.road_links:
			libtcod.console_set_default_foreground(cd_hex_info_con, DIRT_ROAD_COL)
			text = 'Dirt Road'
			if 'poor_quality_roads' in session.regions[campaign.stats['region']]:
				if self.weather['Ground'] == 'Muddy':
					text += ' - MUD'
			libtcod.console_print(cd_hex_info_con, 0, 14, text)
		if True in cd_hex.road_links:
			libtcod.console_set_default_foreground(cd_hex_info_con, STONE_ROAD_COL)
			libtcod.console_print(cd_hex_info_con, 0, 15, 'Stone Road')
		
		# landmines
		if cd_hex.landmines:
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_red)
			libtcod.console_print(cd_hex_info_con, 0, 16, 'Landmines')
		
		# description of enemy resistance if known
		if cd_hex.enemy_strength > 0 and cd_hex.known_to_player:
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_red)
			libtcod.console_print(cd_hex_info_con, 0, 18, 'Estimated Enemies:')
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_grey)
			lines = wrap(cd_hex.enemy_desc, 20)
			y = 19
			for line in lines:
				libtcod.console_print(cd_hex_info_con, 0, y, line)
				y += 1
		
		# objective if any
		if cd_hex.objective is not None:
			libtcod.console_set_default_background(cd_hex_info_con, libtcod.darkest_blue)
			libtcod.console_rect(cd_hex_info_con, 0, 26, 22, 1, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(cd_hex_info_con, libtcod.black)
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.yellow)
			libtcod.console_print(cd_hex_info_con, 0, 26, cd_hex.objective['type'])
			
			# vp reward
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_grey)
			libtcod.console_print(cd_hex_info_con, 0, 27, 'Reward:')
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.white)
			libtcod.console_print(cd_hex_info_con, 8, 27, str(cd_hex.objective['vp_reward']) + ' VP')
			
			if cd_hex.objective['type'] == 'Convoy Attack':
				libtcod.console_print(cd_hex_info_con, 0, 28, '+4 per truck destroyed')
			
			# objective description
			libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.light_grey)
			y = 29
			lines = wrap(CD_OBJECTIVES[cd_hex.objective['type']], 22)
			for line in lines:
				libtcod.console_print(cd_hex_info_con, 0, y, line)
				y += 1
			
			# hold until time (if any)
			if 'hold_until' in cd_hex.objective:
				libtcod.console_set_default_foreground(cd_hex_info_con, libtcod.white)
				text = str(cd_hex.objective['hold_until'][0]).zfill(2) + ':' + str(cd_hex.objective['hold_until'][1]).zfill(2)
				libtcod.console_print(cd_hex_info_con, 0, y, text)
	
	
	# starts or re-starts looping animations based on weather conditions
	# this is for the Campaign Day interface
	def InitAnimations(self):
		
		# reset animations
		self.animation['rain_active'] = False
		self.animation['rain_drops'] = []
		self.animation['snow_active'] = False
		self.animation['snowflakes'] = []
		self.animation['sandstorm_active'] = False
		self.animation['sand'] = []
		self.animation['hex_highlight'] = False
		self.animation['hex_flash'] = 0
		
		# check for rain/snow/sandstorm animation
		if campaign_day.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
			self.animation['rain_active'] = True
		elif campaign_day.weather['Precipitation'] in ['Light Snow', 'Snow', 'Blizzard']:
			self.animation['snow_active'] = True
		elif campaign_day.weather['Precipitation'] == 'Sandstorm':
			self.animation['sandstorm_active'] = True
		
		# set up rain if any
		if self.animation['rain_active']:
			num = 8
			if campaign_day.weather['Precipitation'] == 'Heavy Rain':
				num = 16
			for i in range(num):
				x = libtcod.random_get_int(0, 4, 36)
				y = libtcod.random_get_int(0, 0, 50)
				lifespan = libtcod.random_get_int(0, 1, 5)
				self.animation['rain_drops'].append((x, y, lifespan))		
		
		# set up snow if any
		if self.animation['snow_active']:
			if campaign_day.weather['Precipitation'] == 'Light Snow':
				num = 4
			elif campaign_day.weather['Precipitation'] == 'Snow':
				num = 8
			else:
				num = 16
			for i in range(num):
				x = libtcod.random_get_int(0, 4, 36)
				y = libtcod.random_get_int(0, 0, 50)
				lifespan = libtcod.random_get_int(0, 4, 10)
				self.animation['snowflakes'].append((x, y, lifespan))
		
		# set up sandstorm if any
		if self.animation['sandstorm_active']:
			for i in range(32):
				x = libtcod.random_get_int(0, 4, 30)
				y = libtcod.random_get_int(0, 0, 50)
				lifespan = libtcod.random_get_int(0, 4, 10)
				self.animation['sand'].append((x, y, lifespan))
		
	
	# update campaign day animation frame and console 36x52
	def UpdateAnimCon(self, weather=False):
		
		libtcod.console_clear(cd_anim_con)
		
		# update either weather animations or single-shot ones
		
		# weather/looping animations
		if weather:
		
			# check for storm lightning effect
			if self.weather['Storm']:
				if libtcod.random_get_int(0, 0, 200) == 1:
					x = libtcod.random_get_int(0, window_x+35, window_x+60)
					for y in range(window_y, WINDOW_HEIGHT):
						libtcod.console_set_char_background(0, x, y,
							libtcod.yellow, libtcod.BKGND_SET)
						roll = libtcod.random_get_int(0, 1, 10)
						if roll <= 2:
							x -= 1
						elif roll >= 9:
							x += 1
						
						if x < window_x+35:
							x = window_x+35
						elif x > window_x+60:
							x = window_x+60
					
					for i in range(3):
						libtcod.console_flush()
					libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
					libtcod.console_flush()
					PlaySoundFor(None, 'thunder')
			
			libtcod.console_clear(cd_anim_con)
			
			# update rain
			if self.animation['rain_active']:
				for i in range(len(self.animation['rain_drops'])):
					(x, y, lifespan) = self.animation['rain_drops'][i]
					if lifespan == 0:
						x = libtcod.random_get_int(0, 4, 36)
						y = libtcod.random_get_int(0, 0, 50)
						lifespan = libtcod.random_get_int(0, 1, 5)
					else:
						y += 2
						lifespan -= 1
					self.animation['rain_drops'][i] = (x, y, lifespan)
			
			# update snow
			if self.animation['snow_active']:
				for i in range(len(self.animation['snowflakes'])):
					(x, y, lifespan) = self.animation['snowflakes'][i]
					if lifespan == 0:
						x = libtcod.random_get_int(0, 4, 36)
						y = libtcod.random_get_int(0, 0, 50)
						lifespan = libtcod.random_get_int(0, 4, 10)
					else:
						x += choice([-1, 0, 1])
						y += 1
						lifespan -= 1
					self.animation['snowflakes'][i] = (x, y, lifespan)
			
			# update sandstorm display
			if self.animation['sandstorm_active']:
				for i in range(len(self.animation['sand'])):
					(x, y, lifespan) = self.animation['sand'][i]
					if lifespan == 0 or x >= 36:
						x = libtcod.random_get_int(0, 4, 30)
						y = libtcod.random_get_int(0, 0, 50)
						lifespan = libtcod.random_get_int(0, 4, 10)
					else:
						x += 1
						lifespan -= 1
					self.animation['sand'][i] = (x, y, lifespan)
			
			session.weather_anim_timer = time.time()
		
		# single-shot animations
		else:
			
			# update hex highlight
			if self.animation['hex_highlight']:
				if self.animation['hex_flash'] == 1:
					self.animation['hex_flash'] = 0
				else:
					self.animation['hex_flash'] = 1
			
			session.anim_timer  = time.time()
		
		# draw all active animations to animation console
		if self.animation['rain_active']:
			for (x, y, lifespan) in self.animation['rain_drops']:
				if x < 0 or y > 50: continue
				if lifespan == 0:
					char = 111
				else:
					char = 124
				libtcod.console_put_char_ex(cd_anim_con, x, y, char, libtcod.light_blue,
					libtcod.black)
		if self.animation['snow_active']:
			for (x, y, lifespan) in self.animation['snowflakes']:
				if x < 0 or y > 50: continue
				libtcod.console_put_char_ex(cd_anim_con, x, y, 249, libtcod.white,
					libtcod.black)
		if self.animation['sandstorm_active']:
			for (x, y, lifespan) in self.animation['sand']:	
				if x < 0 or y > 50: continue	
				libtcod.console_put_char_ex(cd_anim_con, x, y, 177, libtcod.light_sepia,
					libtcod.darker_sepia)
		if self.animation['hex_highlight']:
			(hx, hy) = self.animation['hex_highlight']
			(x,y) = self.PlotCDHex(hx, hy)
			x += 1
			y -= 1
			if self.animation['hex_flash'] == 1:
				char = 250
			else:
				char = 249
			for direction in range(6):
				for (xm,ym) in CD_HEX_EDGE_CELLS[direction]:
					libtcod.console_put_char_ex(cd_anim_con, x+xm, y+ym,
						char, libtcod.light_blue, libtcod.black)
	
	
	# draw all campaign day consoles to screen
	def UpdateCDDisplay(self):
		libtcod.console_clear(con)
		libtcod.console_blit(daymap_bkg, 0, 0, 0, 0, con, 0, 0)			# background frame
		libtcod.console_blit(cd_map_con, 0, 0, 0, 0, con, 29, 6)		# terrain map
		libtcod.console_blit(cd_control_con, 0, 0, 0, 0, con, 29, 6, 1.0, 0.0)	# zone control layer
		libtcod.console_blit(cd_unit_con, 0, 0, 0, 0, con, 29, 6, 1.0, 0.0)	# unit group layer
		libtcod.console_blit(cd_gui_con, 0, 0, 0, 0, con, 29, 6, 1.0, 0.0)	# GUI layer
		libtcod.console_blit(cd_anim_con, 0, 0, 0, 0, con, 28, 7, 1.0, 0.0)	# animation console
		libtcod.console_blit(time_con, 0, 0, 0, 0, con, 36, 1)			# date and time
		libtcod.console_blit(cd_player_unit_con, 0, 0, 0, 0, con, 1, 1)		# player unit info		
		libtcod.console_blit(cd_command_con, 0, 0, 0, 0, con, 1, 18)		# command menu
		libtcod.console_blit(cd_weather_con, 0, 0, 0, 0, con, 69, 1)		# weather info
		libtcod.console_blit(cd_campaign_con, 0, 0, 0, 0, con, 66, 14)		# campaign info
		libtcod.console_blit(cd_hex_info_con, 0, 0, 0, 0, con, 66, 24)		# zone info
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	
	# main campaign day input loop
	def DoCampaignDayLoop(self):
		
		def WaitInPlace():
			
			# in an amphibious assault, player cannot wait in water zone
			if 'impassible' in CD_TERRAIN_TYPES[self.map_hexes[self.player_unit_location].terrain_type]:
				ShowNotification('You cannot wait here - you must assault the beach.')
				return
			
			ShowTutorialSlide('campaign_day_wait')
			if not ShowNotification('Remain in place for 15 minutes?', confirm=True): return
			
			# if unit support is active, show menu now
			if self.unit_support_request:
				unit_choice = self.GetUnitSupportChoice(None)
				if unit_choice is None:
					self.unit_support_request = False
					self.unit_support_type = None
				else:
					self.unit_support_type = unit_choice
			
			ShowMessage('You remain in place, ready for possible attack.')
			self.selected_direction = None
			self.AdvanceClock(0, 15)
			DisplayTimeInfo(time_con)
			self.UpdateCDDisplay()
			self.CheckForZoneCapture('wait')
			
			# if attacked 
			if scenario is not None:
				
				if GetPercentileRoll() <= 4.0:
					ShowCrewChatter('attacked_in_zone', None)
				
				# if attacked during Fighting Withdrawl/Counterattack mission, award VP
				if self.mission in ['Fighting Withdrawal', 'Counterattack']:
					campaign.AwardVP(3)
			
			# check for random event, crewmen can rest if no battle triggered
			else:
				self.CheckForRandomEvent()
				for position in campaign.player_unit.positions_list:
					if position.crewman is None: continue
					position.crewman.Rest()
				self.UpdateCDCommandCon()
				self.UpdateCommsStatus()
				self.UpdateCDCampaignCon()
				self.UpdateCDDisplay()
			
			SaveGame()
		
		# consoles for day map interface
		global daymap_bkg, cd_map_con, cd_anim_con, cd_unit_con, cd_control_con, cd_command_con
		global cd_player_unit_con, cd_gui_con, time_con, cd_campaign_con, cd_weather_con
		global cd_hex_info_con
		global scenario
		
		# create consoles
		daymap_bkg = LoadXP('daymap_bkg.xp')
		cd_map_con = NewConsole(35, 53, libtcod.black, libtcod.white)
		cd_anim_con = NewConsole(36, 52, libtcod.black, libtcod.white)
		cd_unit_con = NewConsole(35, 53, KEY_COLOR, libtcod.white)
		cd_control_con = NewConsole(35, 53, KEY_COLOR, libtcod.red)
		cd_gui_con = NewConsole(35, 53, KEY_COLOR, libtcod.red)
		time_con = NewConsole(21, 5, libtcod.darkest_grey, libtcod.white)
		cd_player_unit_con = NewConsole(25, 16, libtcod.black, libtcod.white)
		cd_command_con = NewConsole(25, 41, libtcod.black, libtcod.white)
		cd_weather_con = NewConsole(18, 12, libtcod.darkest_grey, libtcod.white)
		cd_campaign_con = NewConsole(23, 9, libtcod.black, libtcod.white)
		cd_hex_info_con = NewConsole(23, 35, libtcod.black, libtcod.white)
		
		# generate consoles for the first time
		self.UpdateCDMapCon()
		self.UpdateCDUnitCon()
		self.UpdateCDControlCon()
		self.UpdateCDGUICon()
		self.UpdateCDPlayerUnitCon()
		self.UpdateCDCommandCon()
		self.UpdateCDCampaignCon()
		self.UpdateCDHexInfoCon()
		DisplayWeatherInfo(cd_weather_con)
		DisplayTimeInfo(time_con)
		
		if scenario is None:
			self.UpdateCDDisplay()
		
		# init looping animations
		self.InitAnimations()
		
		# calculate initial time to travel to front lines
		if not self.travel_time_spent:
			
			ShowMessage('The sun rises at ' + str(self.day_clock['hour']).zfill(2) +
				':' + str(self.day_clock['minute']).zfill(2) + ", and will set at " +				str(self.end_of_day['hour']).zfill(2) + ':' +
				str(self.end_of_day['minute']).zfill(2) + '.')
			
			minutes = 5 + (libtcod.random_get_int(0, 1, 3) * 10)
			
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Ad Hoc'):
				minutes -= 15
				if minutes < 5:
					minutes = 5
			
			# weather conditions modifiers
			if self.weather['Ground'] in ['Snow', 'Deep Snow']:
				minutes += (libtcod.random_get_int(0, 1, 5) * 5)
			if self.weather['Temperature'] in ['Extreme Hot', 'Extreme Cold']:
				minutes += (libtcod.random_get_int(0, 1, 5) * 5)
			
			# day mission modifiers
			if self.mission in ['Hold the Line', 'Counterattack', 'Fighting Withdrawal']:
				minutes = ceil(minutes / 3)
			
			self.AdvanceClock(0, minutes, skip_checks=True)
			DisplayTimeInfo(time_con)
			if self.mission == 'Amphibious Assault':
				text = 'It takes you ' + str(minutes) + ' minutes for the landing craft to transport your squad to the beach.'
			else:
				text = 'It takes you ' + str(minutes) + ' minutes to prepare your vehicle and travel to the front lines.'
			ShowMessage(text)
			campaign.AddJournal('Arrived at front lines')
			self.travel_time_spent = True
			
			if GetPercentileRoll() <= 3.0:
				ShowCrewChatter('start_of_day', None)
			
			# recon adjacent friendly hexes if needed
			self.map_hexes[self.player_unit_location].RevealAdjacentZones()
			
			# show message if no naval support today
			if self.arty_support_level == 0.0:
				
				# compatibility check for pre-1.1.0
				if hasattr(self, 'no_naval_arty_support'):
					if self.no_naval_arty_support:
						ShowMessage('Naval gun support unavailable today, we are too far from the coast.',
							longer_pause=True, good_news=False)
		
		# Required because otherwise selected_gun can be pointing to an outdated version
		self.BuildPlayerGunList()
		
		libtcod.console_flush()
		ShowTutorialSlide('campaign_day_base')
		
		# record mouse cursor position to check when it has moved
		mouse_x = -1
		mouse_y = -1
		
		# start music if any
		if scenario is None:
			session.MusicHandler('cd_music', True)
		
		exit_loop = False
		while not exit_loop:
			
			# player was taken out of action
			if campaign.player_oob:
				self.DisplayCampaignDaySummary()
				exit_loop = True
				continue
			
			# if we've initiated a scenario or are resuming a saved game with a scenario
			# running, go into the scenario loop now
			if scenario is not None:
				
				# stop music if any
				session.MusicHandler('', False)
				
				scenario.DoScenarioLoop()
				
				if session.exiting:
					exit_loop = True
					continue
				
				# scenario is finished - DoPostScenario returns True if day/campaign is over
				if scenario.finished:
					if self.DoPostScenario(): continue
					
				DisplayTimeInfo(time_con)
				self.UpdateCDCampaignCon()
				self.UpdateCDControlCon()
				self.UpdateCDUnitCon()
				self.UpdateCDCommandCon()
				self.UpdateCDHexInfoCon()
				self.UpdateCDDisplay()
			
			# check for end of campaign day
			if self.ended:
				ShowTutorialSlide('campaign_day_end')
				ShowMessage('Your combat day has ended.')
				# do a final check for any remaining hold objectives
				self.CheckHoldObjectives()
				campaign.AddJournal('End of day')
				if GetPercentileRoll() <= 1.0:
					ShowCrewChatter('survived_another_day', None)
				self.DisplayCampaignDaySummary()
				# final check for player crew recovery
				self.DoCrewRecoveryCheck(campaign.player_unit)
				exit_loop = True
				continue
			
			CheckForAnimationUpdate()
			libtcod.console_flush()
			
			# check to see if mouse cursor has moved
			if mouse.cx != mouse_x or mouse.cy != mouse_y:
				mouse_x = mouse.cx
				mouse_y = mouse.cy
				self.UpdateCDHexInfoCon()
				self.UpdateCDDisplay()
			
			# check to see if music track has finished and music needs to be restarted
			if session.music is not None:
				if mixer.Mix_PlayingMusic() == 0:
					session.MusicHandler('cd_music', True)
			
			if not GetInputEvent(): continue
			
			# game menus
			if key.vk in [sdl2.SDLK_ESCAPE, sdl2.SDLK_F1, sdl2.SDLK_F2, sdl2.SDLK_F3, sdl2.SDLK_F4] or session.gamepad_input == 6:
				if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 6:
					session.active_menu_tab = 0
				elif key.vk == sdl2.SDLK_F1:
					session.active_menu_tab = 1
				elif key.vk == sdl2.SDLK_F2:
					session.active_menu_tab = 2
				elif key.vk == sdl2.SDLK_F3:
					session.active_menu_tab = 3
				elif key.vk == sdl2.SDLK_F4:
					session.active_menu_tab = 4
				ShowGameMenu()
				if session.exiting:
					exit_loop = True
					continue
			
			# debug menu
			elif key.vk == sdl2.SDLK_F10:
				if not DEBUG: continue
				ShowDebugMenu()
				continue
			
			# mapped key commands
			key_char = DeKey(chr(key.c).lower())
			
			# switch active menu
			if (key_char in ['1', '2', '3', '4'] or session.gamepad_input in [9, 10]) and not session.cd_view_mode:
				if session.gamepad_input in [9, 10]:
					if session.gamepad_input == 9:
						self.active_menu -= 1
					else:
						self.active_menu += 1
					if self.active_menu < 1:
						self.active_menu = 4
					elif self.active_menu > 4:
						self.active_menu = 1
				elif self.active_menu != int(key_char):
					self.active_menu = int(key_char)
				PlaySoundFor(None, 'tab_select')
				self.UpdateCDGUICon()
				self.UpdateCDPlayerUnitCon()
				self.UpdateCDCommandCon()
				self.UpdateCDDisplay()
				if self.active_menu == '1':
					ShowTutorialSlide('campaign_day_supply')
				elif self.active_menu == '2':
					ShowTutorialSlide('campaign_day_crew')
				elif self.active_menu == '4':
					ShowTutorialSlide('campaign_day_battlegroup')
				continue
			
			# supply menu active
			if self.active_menu == 1:
				
				if self.selected_gun is not None:
					
					# cycle active ammo type
					if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
						forward = True
						if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 1:
							forward = False
						if self.selected_gun.SelectAmmoType(forward):
							PlaySoundFor(None, 'menu_select')
							self.UpdateCDCommandCon()
							self.UpdateCDDisplay()
						continue
				
					# move shell to/from ready rack
					elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
						if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
							add_num = -1
						else:
							add_num = 1
						if self.selected_gun.ManageRR(add_num):
							self.UpdateCDCommandCon()
							self.UpdateCDDisplay()
						continue
					
					# cycle selected gun
					elif key_char == 'q' or session.gamepad_input in [9, 10]:
						if len(self.gun_list) <= 1: continue
						i = self.gun_list.index(self.selected_gun)
						if i == len(self.gun_list) - 1:
							i = 0
						else:
							i += 1
						self.selected_gun = self.gun_list[i]
						PlaySoundFor(None, 'menu_select')
						self.UpdateCDPlayerUnitCon()
						self.UpdateCDCommandCon()
						self.UpdateCDDisplay()
						continue
					
					# hotkeys: fill RR with a given ammo type
					elif key_char in ['t', 'g', 'b']:
						i = ['t', 'g', 'b'].index(key_char)
						if i > len(self.selected_gun.stats['ammo_type_list']) - 1: continue
						ammotype = self.selected_gun.stats['ammo_type_list'][i]
						if self.selected_gun.ready_rack[ammotype] == self.selected_gun.rr_size or self.selected_gun.ammo_stores[ammotype] == 0:
							continue
						
						# Empty current rack.
						self.selected_gun.DumpReadyRackToStores()
						
						# save current ammo type so we can switch back
						old_ammo_type = self.selected_gun.ammo_type
						self.selected_gun.ammo_type = ammotype
						self.selected_gun.ManageRR(self.selected_gun.rr_size)
						self.selected_gun.ammo_type = old_ammo_type	
						self.UpdateCDCommandCon()
						self.UpdateCDDisplay()
						continue

					# fill rack with default or saved load
					elif key_char in ['x', 'f'] or session.gamepad_input == 2:
						if key_char == 'x' or session.gamepad_input == 2:
							target_rack = self.selected_gun.GenerateDefaultLoadout(True)[1]
						elif len(self.selected_gun.default_ready_rack) == 0:
							continue
						else:
							target_rack = self.selected_gun.default_ready_rack

						(target_rack, inadequate_ammo) = self.selected_gun.CheckLoadoutTemplate(target_rack)[::2]

						if self.selected_gun.ready_rack == target_rack: continue

						# Empty current rack.
						self.selected_gun.DumpReadyRackToStores()

						# fill it per the template
						self.selected_gun.FillReadyRackFromStores(target_rack)
						
						PlaySoundFor(None, 'shell_move_10')
						self.UpdateCDCommandCon()
						self.UpdateCDDisplay()

						# message if there's too little ammo.
						if len(inadequate_ammo):
							ShowMessage("There are not enough " + GenerateEnglishList(inadequate_ammo) + " rounds to fill the ready rack!")
						continue

					# save ready rack
					elif key_char == 'v':
						rr_num = 0
						for ammo_type in self.selected_gun.ready_rack:
							rr_num += self.selected_gun.ready_rack[ammo_type]
						if rr_num == 0 or self.selected_gun.ready_rack == self.selected_gun.default_ready_rack: continue
						self.selected_gun.default_ready_rack = self.selected_gun.ready_rack.copy()
						# If there's no pre-existing saved loadout, save a default template so that resupply screen works properly. This may not be exactly
						# accurate, since it assume some rare ammo is in the ready rack, but it's better than a blank bin or the current (depleted) ammo supply.
						if len(self.selected_gun.default_ammo_stores) == 0:
							self.selected_gun.default_ammo_stores = self.selected_gun.GenerateDefaultLoadout(True)[0]

						PlaySoundFor(None, 'menu_select')
						self.UpdateCDCommandCon()
						self.UpdateCDDisplay()
						continue

				# request resupply
				if key_char == 'r' or session.gamepad_input == 0:
					if not ShowNotification('Transmit a request for resupply?', confirm=True):
						continue	
					self.DoResupplyCheck()	
					continue
			
			# crew menu active
			elif self.active_menu == 2:
				
				# wait/defend/rest
				if key.vk == sdl2.SDLK_TAB or session.gamepad_input == 3:
					WaitInPlace()
					self.UpdateCDPlayerUnitCon()
					self.UpdateCDDisplay()
					continue
				
				# change selected crew position
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
						self.selected_position -= 1
						if self.selected_position < 0:
							self.selected_position = len(campaign.player_unit.positions_list) - 1
					else:
						self.selected_position += 1
						if self.selected_position == len(campaign.player_unit.positions_list):
							self.selected_position = 0
					PlaySoundFor(None, 'menu_select')
					self.UpdateCDPlayerUnitCon()
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# open crewman menu
				elif key_char == 'e' or session.gamepad_input == 0:
					crewman = campaign.player_unit.positions_list[self.selected_position].crewman
					if crewman is None: continue
					crewman.ShowCrewmanMenu()
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# swap position menu
				elif key_char == 'p' or session.gamepad_input == 1:
					ShowSwapPositionMenu()
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# toggle hatch for selected crewman
				elif key_char == 'h' or session.gamepad_input == 2:
					crewman = campaign.player_unit.positions_list[self.selected_position].crewman
					if crewman is None: continue
					if crewman.ToggleHatch():
						PlaySoundFor(crewman.current_position, 'hatch')
						self.UpdateCDCommandCon()
						self.UpdateCDDisplay()
						continue
				
				# button / open up
				elif key_char == 'b' or session.gamepad_input == 4:
					close_all = False
					for position in campaign.player_unit.positions_list:
						if position.crewman is None: continue
						if not position.crewman.alive: continue
						if not position.hatch: continue
						if position.crewman.ce:
							close_all = True
							break
					
					for position in campaign.player_unit.positions_list:
						if position.crewman is None: continue
						if not position.crewman.alive: continue
						
						if close_all and not position.crewman.ce: continue
						if not close_all and position.crewman.ce: continue
						
						if position.crewman.ToggleHatch():
							PlaySoundFor(position, 'hatch')
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# clear default command and hatch status
				elif key_char == 'c':
					crewman = campaign.player_unit.positions_list[self.selected_position].crewman
					if crewman is None: continue
					if crewman.default_start is None: continue
					ShowTutorialSlide('campaign_day_clear_command')
					crewman.default_start = None
					ShowMessage("Crewman's default command and hatch status has been cleared.")
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
			
			# travel menu active
			elif self.active_menu == 3:
				
				# select a direction - can use keyboard input or controller left stick 
				direction = None
				if key_char in DIRECTION_KEYS:
					direction = DIRECTION_KEYS.index(key_char)
				elif session.left_stick_direction is not None:
					direction = session.left_stick_direction
					
				
				# map hex view mode enabled
				if session.cd_view_mode:
					
					# move highlight hex around map
					# in view mode, we don't want repeated left stick inputs
					if direction is not None and not session.left_stick_hold_repeat:
						session.left_stick_hold_repeat = True
						if session.cd_view_hex is None: continue
						(hx1, hy1) = session.cd_view_hex
						(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
						if (hx2, hy2) not in self.map_hexes: continue
						session.cd_view_hex = (hx2, hy2)
						self.UpdateCDCommandCon()
						self.UpdateCDGUICon()
						self.UpdateCDHexInfoCon()
						self.UpdateCDDisplay()
					
					# exit view mode
					elif key_char == 'v' or session.gamepad_input == 7:
						session.cd_view_mode = False
						session.cd_view_hex = None
						self.UpdateCDCommandCon()
						self.UpdateCDGUICon()
						self.UpdateCDHexInfoCon()
						self.UpdateCDDisplay()
					
					continue
				
				# wait/defend
				if key_char == 'w' or session.gamepad_input == 3:
					WaitInPlace()
					continue
				
				# select direction 
				elif direction is not None:
					
					# if no zone in this direction, don't allow it to be selected
					(hx1, hy1) = self.player_unit_location
					(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, direction)
					if (hx2, hy2) not in self.map_hexes: continue
					
					if self.selected_direction is None:
						self.selected_direction = direction
					else:
						# cancel currently selected direction - keyboard only
						if self.selected_direction == direction and session.left_stick_direction is None:
							self.selected_direction = None
						else:
							self.selected_direction = direction
					self.UpdateCDGUICon()
					self.UpdateCDCommandCon()
					self.UpdateCDHexInfoCon()
					self.UpdateCDDisplay()
				
				# return to base
				if key_char == 'i' or session.gamepad_input == 4:
					
					if self.mission == 'Amphibious Assault':
						ShowMessage('You cannot return to base before the assault is finished!',
							longer_pause=True)
						continue
					
					# check for clear path to friendly edge if needed
					if not self.PlayerHasPath():
						ShowMessage('You are cut off from friendly forces! You must have a clear path to the bottom map edge to return.',
							longer_pause=True, good_news=False)
						continue
					
					free_return = False
					if campaign.player_unit.ko_hit:
						free_return = True
					for weapon in campaign.player_unit.weapon_list:
						if weapon.broken:
							if weapon.GetStat('type') == 'Gun' or len(campaign.player_unit.weapon_list) == 1:
								free_return = True
								break
					for position in campaign.player_unit.positions_list:
						if position.crewman is None:
							free_return = True
							break
						if not position.crewman.alive:
							free_return = True
							break
					
					ShowTutorialSlide('campaign_day_return_to_base')
					
					text = 'Return to Base?'
					if not free_return:
						text += " You will forfeit half of today's VP."
					
					if ShowNotification(text, confirm=True):	
						if not free_return:
							self.day_vp -= int(self.day_vp / 2)	
						ShowMessage('You return to base.')
						campaign.AddJournal('Returned to base')
						self.ended = True
					continue
				
				# enter map hex view mode
				elif key_char == 'v' or session.gamepad_input == 7:
					session.cd_view_mode = True
					session.cd_view_hex = self.player_unit_location
					self.UpdateCDCommandCon()
					self.UpdateCDGUICon()
					self.UpdateCDHexInfoCon()
					self.UpdateCDDisplay()
					continue
				
				# toggle unit support request
				elif key_char == 'n' or session.gamepad_input == 13:
					if 'unit_support_level' not in campaign.current_week:
						continue
					if self.unit_support_level <= 0.0:
						self.unit_support_request = False
						continue
					ShowTutorialSlide('campaign_day_unit_support')
					self.unit_support_request = not self.unit_support_request
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# no direction selected
				if self.selected_direction is None: continue
				
				# if travel is not possible, no more commands available
				(hx1, hy1) = self.player_unit_location
				(hx2, hy2) = self.GetAdjacentCDHex(hx1, hy1, self.selected_direction)
				if (hx2, hy2) not in self.map_hexes:
					continue
				map_hex2 = self.map_hexes[(hx2,hy2)]
				if self.CheckTravel(hx1,hy1,hx2,hy2) != '':
					continue
				
				# toggle advancing fire
				if key_char == 't' or session.gamepad_input == 11:
					ShowTutorialSlide('campaign_day_advancing_fire')
					self.advancing_fire = not self.advancing_fire
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# toggle air support request
				if key_char == 'g' or session.gamepad_input == 14:
					if 'air_support_level' not in campaign.current_week:
						continue
					if self.air_support_level <= 0.0:
						self.air_support_level = False
						continue
					ShowTutorialSlide('campaign_day_air_support')
					if self.weather['Cloud Cover'] == 'Overcast' or self.weather['Fog'] > 0 or self.weather['Precipitation'] == 'Sandstorm':
						continue
					self.air_support_request = not self.air_support_request
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# toggle artillery support request
				if key_char == 'b' or session.gamepad_input == 12:
					if 'arty_support_level' not in campaign.current_week:
						continue
					if self.arty_support_level <= 0.0:
						self.arty_support_level = False
						continue
					ShowTutorialSlide('campaign_day_arty_support')
					self.arty_support_request = not self.arty_support_request
					self.UpdateCDCommandCon()
					self.UpdateCDDisplay()
					continue
				
				# recon or proceed with travel
				if key_char == 'r' or key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input in [0, 2]:
					
					# no direction set
					if self.selected_direction is None:
						continue
					
					# recon N/A in this mission
					if (key_char == 'r' or session.gamepad_input == 2) and self.mission == 'Amphibious Assault':
						continue
					
					time_taken = self.ReconOrTravel(key_char == 'r' or session.gamepad_input == 2, map_hex2)
						
					# update consoles
					self.UpdateCDCampaignCon()
					self.UpdateCDControlCon()
					self.UpdateCDUnitCon()
					self.UpdateCDCommandCon()
					self.UpdateCDHexInfoCon()
					self.UpdateCDDisplay()
					
					# if action was taken and no battle was triggered, do random event and zone capture checks
					if time_taken > 0 and scenario is None:
						
						# recon action
						if key_char == 'r' or session.gamepad_input == 2:
							self.CheckForZoneCapture('recon')
						else:
							self.CheckForRandomEvent()
							if time_taken <= 20:
								self.CheckForZoneCapture('quick_move')
							else:
								self.CheckForZoneCapture('slow_move')
							
							# player was not attacked in own zone - clear any unit support flags
							if scenario is None:
								self.UpdateCommsStatus()
								self.UpdateCDCampaignCon()
								self.unit_support_request = False
								self.unit_support_type = None
						
					SaveGame()
					continue
			
			# battlegroup menu active
			elif self.active_menu == 4:
				
				if key_char not in ['q', 'a', 'z', 'x']: continue
				
				PlaySoundFor(None, 'menu_select')
				if key_char == 'q' or session.gamepad_input == 0:
					text = 'Fire at Will'
				elif key_char == 'a'  or session.gamepad_input == 1:
					text = 'Attack my Target'
				elif key_char == 'z'  or session.gamepad_input == 2:
					text = 'Hold Fire'
				elif key_char == 'x' or session.gamepad_input == 3:
					text = 'On my Mark'
				campaign.battlegroup_command = text
				self.UpdateCDCommandCon()
				self.UpdateCDDisplay()
				continue
	
		# exiting layer, reset flags
		session.cd_view_mode = False
		session.cd_view_hex = None
		
		# stop music if any
		session.MusicHandler('', False)



# Scenario: represents a single battle encounter
class Scenario:
	def __init__(self, cd_map_hex, advancing_fire_success = False):
		
		self.init_complete = False			# flag to say that scenario has already been set up
		self.player_attacking = False			# the player moved into a new zone to start the battle
		self.cd_map_hex = cd_map_hex			# Campaign Day map hex where this scenario is taking place
		self.advancing_fire = advancing_fire_success	# Whether player is attacking and successfully suppressed.
		self.ambush = False				# enemy units activate first, greater chance of spawning behind player
		self.finished = False				# Scenario has ended, returning to Campaign Day map
		self.recon_spotting = False			# Recon unit support arrived and can spot before battle starts
		self.class_type_dict = {}			# dictionary of unit types for each class; once set, further units will be of the same type
		
		# animation object; keeps track of active animations on the animation console
		self.animation = {
			'attack_animation_active' : False,
			'rain_active' : False,
			'rain_drops' : [],
			'snow_active' : False,
			'snowflakes' : [],
			'gun_fire_active' : False,
			'gun_fire_line' : [],
			'canister_fire' : False,
			'canister_fire_lifetime' : 0,
			'canister_hit' : False,
			'canister_hit_lifetime' : 0,
			'small_arms_fire_action' : False,
			'small_arms_fire_line' : [],
			'small_arms_lifetime' : 0,
			'air_attack' : None,
			'air_attack_arrived' : False,
			'air_attack_line' : [],
			'bomb_effect' : None,
			'bomb_effect_lifetime' : 0,
			'smoke_effect' : None,
			'smoke_effect_lifetime' : 0,
			'grenade_effect' : None,
			'grenade_effect_lifetime' : 0,
			'ft_effect' : None,
			'ft_effect_lifetime' : 0,
			'psk_fire_action' : False,
			'psk_fire_line' : [],
			'hex_highlight' : False,
			'hex_flash' : 0
		}
		
		# current odds of a random event being triggered
		self.random_event_chance = BASE_RANDOM_EVENT_CHANCE
		
		# number of times enemy reinforcement random event has been triggered
		self.enemy_reinforcements = 0
		
		# generate hex map: single hex surrounded by 4 hex rings. Final ring is not normally
		# part of play and stores units that are coming on or going off of the map proper
		# also store pointers to hexes in a dictionary for quick access
		self.map_hexes = []
		self.hex_dict = {}
		for r in range(0, 5):
			for (hx, hy) in GetHexRing(0, 0, r):
				self.map_hexes.append(MapHex(hx,hy))
				self.hex_dict[(hx,hy)] = self.map_hexes[-1]
		
		# dictionary of console cells covered by map hexes
		self.hex_map_index = {}
		self.BuildHexmapDict()
		
		self.attack_con_active = False				# attack console display is active
		self.units = []						# list of units in play
		self.player_unit = None					# placeholder for player unit
		self.enemy_units_spawned = 0				# tracker for number of enemy units spawned
		self.battlegroup_command = campaign.battlegroup_command	# command for squad members and support units
		
		self.current_turn = 1					# current scenario turn
		self.active_player = 0					# currently active player (0 is human player)
		self.phase = PHASE_COMMAND				# current phase
		self.advance_phase = False				# flag for input loop to automatically advance to next phase/turn
		self.player_pivot = 0					# keeps track of player unit pivoting
		
		self.target_list = []					# list of possible player targets
		self.selected_weapon = None				# player's currently selected weapon
		self.selected_position = 0				# index of selected position in player unit
	
	
	# return whether an immobilization attempt is possible
	def CanImmobilize(self, attacker, weapon, target):
		if attacker is None or weapon is None or target is None: return False
		if weapon.ammo_type is None: return False
		if not target.spotted: return False
		if target.immobilized: return False
		if 'armour' not in target.stats: return False
		if weapon.ammo_type not in IMM_AMMO_TYPES: return False
		if 'immobile' in target.stats: return False
		if target.stats['category'] != 'Vehicle': return False
		return True
		
	
	# crew first aid menu
	def ShowFirstAidMenu(self, crewman):
		
		def DrawMenu():
			libtcod.console_clear(menu_con)
			libtcod.console_set_default_foreground(menu_con, libtcod.grey)
			DrawFrame(menu_con, 0, 0, 43, 36)
			libtcod.console_set_default_foreground(menu_con, TITLE_COL)
			libtcod.console_print_ex(menu_con, 22, 2, libtcod.BKGND_NONE, libtcod.CENTER,
				'First Aid')
			
			# display list of crewmen, injuries
			i = 0
			y = 4
			for position in self.player_unit.positions_list:
				
				# selected position
				if i == selected_choice:
					libtcod.console_set_default_background(menu_con, libtcod.darker_blue)
					libtcod.console_rect(menu_con, 3, y, 38, 2, True, libtcod.BKGND_SET)
					libtcod.console_set_default_background(menu_con, libtcod.black)
				
				libtcod.console_set_default_foreground(menu_con, libtcod.white)
				libtcod.console_print(menu_con, 3, y, position.name)
				
				if position.crewman is None:
					libtcod.console_print(menu_con, 3, y+1, 'Empty')
				else:
					PrintExtended(menu_con, 3, y+1, position.crewman.GetCrewmanName(first_initial=True), nation=position.crewman.nation)
				
					if not position.crewman.alive:
						libtcod.console_set_default_foreground(menu_con, libtcod.dark_grey)
						libtcod.console_print(menu_con, 24, y+1, 'Dead')
					else:
						fresh_injury = False
						critical_injury = False
						for (k, v) in position.crewman.injury.items():
							if v[1] is None: continue
							if v[0] == 'Fresh':
								fresh_injury = True
							if v[1] == 'Critical':
								critical_injury = True
						
						if critical_injury:
							libtcod.console_set_default_foreground(menu_con, libtcod.light_red)
							libtcod.console_print_ex(menu_con, 40, y, libtcod.BKGND_NONE,
								libtcod.RIGHT, 'Critical Injury')
						if fresh_injury:
							libtcod.console_set_default_foreground(menu_con, libtcod.light_red)
							libtcod.console_print_ex(menu_con, 40, y+1, libtcod.BKGND_NONE,
								libtcod.RIGHT, 'Fresh Injury')
				
				i += 1
				y += 3
			
			# display inputs
			if gamepad is not None:
				DisplayButton(menu_con, 16, 30, GAMEPADCHAR_DPAD_UD)
				DisplayButton(menu_con, 16, 31, GAMEPADCHAR_X)
				DisplayButton(menu_con, 16, 32, GAMEPADCHAR_Y)
				DisplayButton(menu_con, 16, 33, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(menu_con, ACTION_KEY_COL)
				libtcod.console_print(menu_con, 13, 30, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(menu_con, 13, 31, EnKey('r').upper())
				libtcod.console_print(menu_con, 13, 32, EnKey('f').upper())
				libtcod.console_print(menu_con, 13, 33, 'Esc')
			
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			libtcod.console_print(menu_con, 18, 30, 'Select Crewman')
			libtcod.console_print(menu_con, 18, 31, 'Stabilize')
			libtcod.console_print(menu_con, 18, 32, 'Patch Up')
			libtcod.console_print(menu_con, 18, 33, 'Cancel Action')
			
			libtcod.console_blit(menu_con, 0, 0, 0, 0, con, 24, 12)
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# create a local copy of the current screen to re-draw when we're done
		temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
		libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
		
		# darken background 
		libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.5)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# create display console
		menu_con = NewConsole(43, 36, libtcod.black, libtcod.white)
		
		selected_choice = 0
		
		# draw menu for first time
		DrawMenu()
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# cancel action
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				exit_menu = True
				PlaySoundFor(None, 'menu_select')
				continue
			
			key_char = DeKey(chr(key.c).lower())
			
			# select crewman
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if selected_choice == 0:
						selected_choice = len(self.player_unit.positions_list) - 1
					else:
						selected_choice -= 1
				else:
					if selected_choice == len(self.player_unit.positions_list) - 1:
						selected_choice = 0
					else:
						selected_choice += 1
				
				DrawMenu()
				PlaySoundFor(None, 'menu_select')
				continue
			
			# attempt to stabilize a critical injury
			elif key_char in ['r', 'f'] or session.gamepad_input in [2, 3]:
				position = self.player_unit.positions_list[selected_choice]
				if position.crewman is None: continue
				if not position.crewman.alive: continue
				
				for (k, v) in position.crewman.injury.items():
					(status, severity, scarring) = v
					if status is None and severity is None: continue
					
					# attempt to stabilize this critical injury
					if severity == 'Critical' and (key_char == 'r' or session.gamepad_input == 2):
						crewman.first_aid_action_taken = True
						
						chance = 40.0
						if position.crewman == crewman:
							chance -= 15.0
						
						modifier = 0.0
						if 'Medical Training' in crewman.skills:
							modifier += 30.0
						elif 'Medical Experience' in crewman.skills:
							modifier += 15.0
						roll = GetPercentileRoll() - crewman.GetActionMod(modifier)
						
						if roll <= chance:
							severity = 'Serious'
							position.crewman.injury[k] = (status, severity, scarring)
							
							if position.crewman.is_player_commander:
								text = 'Your ' + k + ' injury has been stabilized.'
								ShowMessage(text, longer_pause=True, good_news=True)
							else:
								text = "Your crewman's " + k + ' injury has been stabilized.'
								ShowMessage(text, crewman=position.crewman, longer_pause=True,
									good_news=True)
						else:
							ShowMessage('Injury stabilization attempt failed.',
								good_news=False)
						
						exit_menu = True
						break
					
					elif status == 'Fresh' and (key_char == 'f' or session.gamepad_input == 3):
						crewman.first_aid_action_taken = True
						
						chance = 80.0
						if position.crewman == crewman:
							chance -= 15.0
						
						modifier = 0.0
						if 'Medical Training' in crewman.skills:
							modifier += 30.0
						elif 'Medical Experience' in crewman.skills:
							modifier += 15.0
						roll = GetPercentileRoll() - crewman.GetActionMod(modifier)
						
						if roll <= chance:
							
							status = 'Patched Up'
							position.crewman.injury[k] = (status, severity, scarring)
							
							if position.crewman.is_player_commander:
								text = 'Your ' + k + ' injury has been patched up.'
								ShowMessage(text, good_news=True)
							else:
								text = "Your crewman's " + k + ' injury has been patched up.'
								ShowMessage(text, crewman=position.crewman, longer_pause=True,
									good_news=True)
						else:
							ShowMessage('Injury patch-up attempt failed.',
								good_news=False)
						
						exit_menu = True
						break
		
		# re-draw the original screen
		libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
		
	
	# spawn friendly reinforcement unit into a battle in progress
	def SpawnFriendlyReinforcements(self, rescue_spawn=False, unit_list=None):
		
		location = None
		if rescue_spawn:
			hx, hy = 0, -2
			# check to see if already occupied
			if len(self.hex_dict[(hx,hy)].unit_stack) > 0:
				if self.hex_dict[(hx,hy)].unit_stack[0].owning_player == 1:
					location = None
			
		if location is None:
			# build a list of possible spawn locations around the edge of the map
			hex_list = []
			for (hx, hy) in GetHexRing(0, 0, 3):
				if len(self.hex_dict[(hx,hy)].unit_stack) > 0:
					if self.hex_dict[(hx,hy)].unit_stack[0].owning_player == 1:
						continue
				hex_list.append((hx, hy))
			if len(hex_list) == 0: return
			(hx, hy) = choice(hex_list)
		
		# build a list of possible units if none provided
		if unit_list is None:
			unit_list = []
			for unit_id in campaign.stats['player_unit_list']:
				
				# check availability of unit_id
				if unit_id not in session.unit_types: continue
				
				if not campaign.options['ahistorical']:
					
					# do player availibility check
					if 'player_unit_dates' in campaign.stats:
						if unit_id in campaign.stats['player_unit_dates']:
							if campaign.stats['player_unit_dates'][unit_id] > campaign.today:
								continue
					
					# do rarity check based on current date
					if not campaign.DoRarityCheck(unit_id):
						continue
					
				unit_list.append(unit_id)
			
			for support_category in list(campaign.stats['player_unit_support']):
				for unit_id in campaign.stats['player_unit_support'][support_category]:
					
					# sanity check
					if unit_id not in session.unit_types:
						continue
					
					# some support units won't wander into a battle
					if not rescue_spawn and session.unit_types[unit_id]['category'] in ['Gun', 'Train Car']:
						continue
					
					if rescue_spawn:
						if session.unit_types[unit_id]['class'] in ['Truck', 'APC', 'Tractor']:
							continue
					
					# do rarity check based on current date
					if not campaign.DoRarityCheck(unit_id, nation=campaign.stats['player_nation']):
						continue
					
					unit_list.append(unit_id)
		
		# shouldn't happen, but you never know
		if len(unit_list) == 0: return None
		
		# select and spawn the unit
		unit = Unit(choice(unit_list))
		unit.nation = campaign.player_unit.nation
		unit.ai = AI(unit)
		unit.ai.Reset()
		unit.GenerateNewPersonnel()
		unit.SpawnAt(hx, hy)
		direction = GetDirectionToward(hx, hy, 0, 0)
		unit.facing = direction
		
		for weapon in unit.weapon_list:
			weapon.UpdateCoveredHexes()
		
		unit.CheckForHD(spawn=True)
		if 'turret' in unit.stats:
			unit.turret_facing = direction
		unit.CheckForTractorSpawn(force_tractor=True)
		unit.DeploymentCheck()
		
		if rescue_spawn:
			
			unit.PinMe()
			
			# set objective info
			if self.cd_map_hex.objective is not None:
				self.cd_map_hex.objective['rescue_unit'] = unit
			
			# rescue units may start dug-in, entrenched, or fortified
			if unit.GetStat('category') in ['Infantry', 'Gun']:
				roll = GetPercentileRoll()
				
				# packed-up guns can't start in any of these statuses
				if unit.GetStat('category') == 'Gun' and not unit.deployed:
					roll = 100.0
				
				if roll <= 3.0:
					unit.fortified = True
				elif roll <= 20.0:
					unit.entrenched = True
				elif roll <= 65.0:	
					unit.dug_in = True
			
			# rescue units will often also have something wrong with them
			elif unit.stats['category'] == 'Vehicle' and 'immobile' not in unit.stats:
				roll = GetPercentileRoll()
				if roll <= 50.0:
					unit.bogged = True
				elif roll <= 75.0:
					unit.immobilized = True
		
		else:
			unit.moving = True
		
		self.GenerateUnitLoS(unit)
		
		# set up additional passenger unit if any
		if 'friendly_transported_units' in campaign.stats:
			transport_dict = campaign.stats['friendly_transported_units']
			if unit.unit_id in transport_dict:
				transport_list = list(transport_dict[unit.unit_id].items())
				shuffle(transport_list)
				for k, value in transport_list:
					if libtcod.random_get_int(0, 1, 100) <= value:
						unit.transport = k
						break
		
		self.UpdateUnitCon()
		self.UpdateScenarioDisplay()
		
		return unit
	
	
	# calculate current chance of player withdrawing from the battle
	def GetWithdrawChance(self):
		
		enemies_in_range = 0
		for unit in self.units:
			if not unit.alive: continue
			if unit.owning_player == 0: continue
			if not self.player_unit.los_table[unit]: continue
			distance = GetHexDistance(unit.hx, unit.hy, 0, 0)
			if distance == 1:
				enemies_in_range += 3
			elif distance == 2:
				enemies_in_range += 2
			else:
				enemies_in_range += 1
		
		if campaign_day.rattenkrieg:
			enemies_in_range += 2
		
		chance = 50.0 - (float(enemies_in_range) * 10.0)
		if self.player_unit.smoke > 0:
			chance += 30.0 * float(self.player_unit.smoke)
		if self.player_unit.dust > 0:
			chance += 15.0 * float(self.player_unit.smoke)
		
		if chance < 15.0:
			chance = 15.0
		
		return chance
		
	
	# player attempts to withdraw from the battle
	def AttemptWithdraw(self):
		roll = GetPercentileRoll()
		for position in COMMANDER_POSITIONS:
			crewman = self.player_unit.GetPersonnelByPosition(position)
			if crewman is None: continue
			if crewman.current_cmd == 'Direct Movement':
				if 'Better Part of Valour' in crewman.skills:
					roll -= 50.0
				elif 'Tactical Retreat' in crewman.skills:
					roll -= 30.0
				else:
					roll -= 15.0
				break
		if roll <= self.GetWithdrawChance():
			return True
		return False
	
	
	# return the chance for unit1 to spot unit2
	def CalcSpotChance(self, unit1, unit2, crewman=None):
		
		distance = GetHexDistance(unit1.hx, unit1.hy, unit2.hx, unit2.hy)	
		chance = SPOT_BASE_CHANCE[distance]
		
		# target size
		size_class = unit2.GetStat('size_class')
		if size_class is not None:
			if size_class == 'Small':
				chance -= 7.0
			elif size_class == 'Very Small':
				chance -= 18.0
			elif size_class == 'Large':
				chance += 7.0
			elif size_class == 'Very Large':
				chance += 18.0
			elif size_class == 'Extra Large':
				chance += 25.0
		
		# precipitation/sandstorm modifier
		if campaign_day.weather['Precipitation'] in ['Rain', 'Snow']:
			chance -= 5.0 * float(distance)
		elif campaign_day.weather['Precipitation'] in ['Heavy Rain', 'Blizzard']:
			chance -= 10.0 * float(distance)
		elif campaign_day.weather['Precipitation'] == 'Sandstorm':
			chance -= 15.0 * float(distance)
		
		# fog, smoke, or dust concealment - only apply the one that will have the most effect
		vision_mod = 1.0
		
		if campaign_day.weather['Fog'] > 0:
			if 4 - distance <= campaign_day.weather['Fog']:
				mod = round(0.75 / distance, 2)
				if mod < vision_mod:
					vision_mod = mod
		
		effective_smoke = (float(unit1.smoke) * 0.5) + float(unit2.smoke)
		if effective_smoke > 0.0:
			mod = round(0.75 / effective_smoke, 2)
			if mod < vision_mod:
				vision_mod = mod
		
		effective_dust = (float(unit1.dust) * 0.5) + float(unit2.dust)
		if effective_dust > 0.0:
			mod = round(0.75 / effective_dust, 2)
			if mod < vision_mod:
				vision_mod = mod
		
		if vision_mod < 1.0:
			chance = chance * vision_mod
		
		# target moved and/or fired
		if unit2.moving: chance = chance * 1.5
		if unit2.fired:
			if unit2.GetStat('stealthy_firing') is None:
				chance = chance * 2.0
		
		# infantry are not as good at spotting from their lower position
		if unit1.GetStat('category') == 'Infantry' and distance > 1:
			if distance == 2:
				chance = chance * 0.75
			else:
				chance = chance * 0.5
		
		# penalty for player's allies
		if unit1.owning_player == 0 and not unit1.is_player:
			chance = chance * 0.75
		
		# recce units better at spotting, better at staying concealed
		if 'recce' in unit1.stats:
			chance = chance * 2.0
		if 'recce' in unit2.stats:
			chance = chance * 0.5
		
		# towing or being towed
		if unit2.towed_by is not None or unit2.towing is not None:
			chance = chance * 2.0
		
		# target terrain
		terrain_mod = unit2.GetTEM()
		
		if campaign_day.rattenkrieg and unit2.GetStat('category') in ['Infantry', 'Gun']:
			terrain_mod = round(terrain_mod * 1.5, 1)
		
		chance += terrain_mod
		
		# crewman modifiers if any
		if crewman is not None:
		
			modifier = float(crewman.stats['Perception'] * PERCEPTION_SPOTTING_MOD)
			if not crewman.ce:
				modifier = modifier * 0.8
			elif crewman.current_position is not None:
				if crewman.current_position.large_hatch:
					modifier = modifier * 1.1
			chance = chance * modifier
			
			if crewman.current_cmd != 'Spot':
				chance = chance * 0.8
			
			# skill modifier
			if crewman.ce:
				modifier = crewman.GetSkillMod('Eagle Eyed', 15.0)
				if modifier is not None:
					chance += modifier
			else:
				modifier = crewman.GetSkillMod('Trap Spotter', 15.0)
				if modifier is not None:
					chance += modifier
			
			# spotting crewman head/neck injury
			if crewman.injury['Head & Neck'][1] is not None:
				if crewman.injury['Head & Neck'][1] != 'Light':
					chance = chance * 0.5
		
		# target is HD to spotter
		if len(unit2.hull_down) > 0:
			if len(unit2.hull_down) == 6:
				chance = chance * 0.5
			elif GetDirectionToward(unit2.hx, unit2.hy, unit1.hx, unit1.hy) in unit2.hull_down:
				chance = chance * 0.5
		
		# target has been hit by effective fp
		if unit2.hit_by_fp:
			chance = chance * 4.0
		
		return round(chance, 1)
	
	
	# do a round of spotting for AI units on one side, uses a simplified procedure
	def DoAISpotChecks(self, owning_player, support_only=False):
		
		for unit1 in self.units:
			if not unit1.alive: continue
			if unit1.owning_player != owning_player: continue
			if unit1.is_player: continue
			
			# sometimes only the support units get a chance to spot
			if support_only:
				if unit1 in self.player_unit.squad: continue
			
			# build list of units that it's possible to spot
			spot_list = []
			for unit2 in scenario.units:
				if unit2.owning_player == owning_player: continue
				if not unit2.alive: continue
				if unit2.spotted: continue
				if not unit1.los_table[unit2]: continue
				spot_list.append(unit2)
			
			# no units possible to spot
			if len(spot_list) == 0: continue
			
			# roll once for each unit
			for unit2 in spot_list:
				chance = scenario.CalcSpotChance(unit1, unit2)
				if chance <= 0.0: continue
				if GetPercentileRoll() <= chance:
					
					# if spotting unit is lax, make them alert
					if unit1.ai is not None:
						if unit1.ai.state == 'Lax':
							unit1.ai.state = 'Alert'
					
					unit2.MoveToTopOfStack()
					unit2.SpotMe()
					scenario.UpdateUnitCon()
					scenario.UpdateScenarioDisplay()
					
					# don't display message if friendly unit
					if unit2 != scenario.player_unit and unit2.owning_player == 0: continue
					
					if unit1.owning_player == 0:
						ShowTutorialSlide('scenario_ally_spotted')
					
					if unit2 == scenario.player_unit:
						text = 'You were'
					else:
						text = unit2.GetName()
						if unit2.owning_player == 0:
							text += ' was'
					text += ' spotted'
					if unit2.owning_player == 0:
						text += ' by ' + unit1.GetName()
					else:
						text += ' by an allied unit'
					text += '!'
					ShowMessage(text, portrait=unit2, scenario_highlight=(unit2.hx, unit2.hy))
					
					if unit2.owning_player == 1:
						if unit2.GetStat('class') == 'Medium Tank':
							ShowTutorialSlide('scenario_tank_spotted')
						elif unit2.GetStat('class') == 'Infantry Squad':
							ShowTutorialSlide('scenario_riflemen_spotted')
						elif unit2.GetStat('class') == 'Armoured Car':
							ShowTutorialSlide('scenario_ac_spotted')
						elif unit2.GetStat('class') == 'Anti-Tank Gun':
							ShowTutorialSlide('scenario_at_gun_spotted')
						elif unit2.GetStat('class') == 'Artillery Gun':
							ShowTutorialSlide('scenario_art_gun_spotted')
						elif unit2.GetStat('class') == 'Support Weapon Team':
							ShowTutorialSlide('scenario_team_spotted')
	
	# roll to see whether two units on the scenario map have LoS to each other
	# if chance_only, will only calculate chance and return that
	def DoLoSRoll(self, unit1, unit2, chance_only=False):
		
		# no need for dead units
		if not unit1.alive or not unit2.alive: return False
		
		# if unit1 is on Overrun and unit2 is directly ahead, automatically has LoS
		if unit1.overrun and unit2.hx == 0 and unit2.hy == -1:
			return True
		
		# base odds of LoS based on range between the two units
		distance = GetHexDistance(unit1.hx, unit1.hy, unit2.hx, unit2.hy)
		if distance == 0:		# same hex
			chance = 100.0
		elif distance == 1:		# close range
			chance = 97.0
		elif distance == 2:		# medium range
			chance = 90.0
		elif distance == 3:		# long range
			chance = 85.0
		else:
			return False		# off map: no chance
		
		# modify base chance by terrain of both units
		terrain_mod = 0.0
		
		if unit1.terrain is not None:
			terrain_mod -= SCENARIO_TERRAIN_EFFECTS[unit1.terrain]['los_mod']
		if unit2.terrain is not None:
			terrain_mod -= SCENARIO_TERRAIN_EFFECTS[unit2.terrain]['los_mod']
		chance += terrain_mod
		
		# zone type modifier
		if self.cd_map_hex.terrain_type == 'Mountain Pass':
			chance = round(chance * 0.8, 1)
		
		chance = round(chance, 1)
		
		if chance_only: return chance
		
		if GetPercentileRoll() <= chance:
			return True
		return False
	
	
	# do the initial line of sight checks between all units
	def GenerateLoS(self):
		
		def AddLoS(unit1, unit2):
			unit1.los_table[unit2] = True
			unit2.los_table[unit1] = True
		
		# clear all LoS tables
		for unit in self.units:
			unit.los_table = {}
		
		# check each unit against every other
		for unit1 in self.units:
			for unit2 in self.units:
				
				# already added in opposite direction
				if unit1 in unit2.los_table: continue
				
				# same unit
				if unit1 == unit2:
					AddLoS(unit1, unit2)
					continue
				
				# same side and same hex
				if unit1.owning_player == unit2.owning_player and unit1.hx == unit2.hx and unit1.hy == unit2.hy:
					AddLoS(unit1, unit2)
					continue
				
				# roll for LoS between the units
				if self.DoLoSRoll(unit1, unit2):
					AddLoS(unit1, unit2)
					continue
				
				unit1.los_table[unit2] = False
				unit2.los_table[unit1] = False


	# add a newly spawned unit to the existing units' LoS tables
	# can also regenerate LoS links between this unit and every other unit
	def GenerateUnitLoS(self, unit1):
		
		def AddLoS(unit1, unit2):
			unit1.los_table[unit2] = True
			unit2.los_table[unit1] = True
		
		unit1.los_table = {}
		
		for unit2 in self.units:
			
			# same unit
			if unit1 == unit2:
				AddLoS(unit1, unit2)
				continue
			
			# same side and same hex
			if unit1.owning_player == unit2.owning_player and unit1.hx == unit2.hx and unit1.hy == unit2.hy:
				AddLoS(unit1, unit2)
				continue
			
			# roll for LoS between the units
			if self.DoLoSRoll(unit1, unit2):
				AddLoS(unit1, unit2)
				continue
			
			unit1.los_table[unit2] = False
			unit2.los_table[unit1] = False


	# roll at start of scenario to see whether player has been ambushed
	def DoAmbushRoll(self):
		
		# skip roll entirely if no enemy units remaining
		all_enemies_dead = True
		for unit in self.units:
			if unit.owning_player == 1 and unit.alive:
				all_enemies_dead = False
				break
		if all_enemies_dead: return
		
		# no ambush possible if player has Motti national skill
		if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Motti'):
			return
		
		# skip if tutorial
		if 'tutorial_campaign' in campaign.stats: return
		
		chance = 10.0
		
		if campaign_day.weather['Precipitation'] in ['Heavy Rain', 'Snow', 'Blizzard']:
			chance += 10.0
		
		if campaign_day.mission == 'Patrol':
			chance -= 5.0
		elif campaign_day.mission in ['Advance', 'Spearhead']:
			chance += 10.0
		elif campaign_day.rattenkrieg:
			chance += 25.0
		
		if self.cd_map_hex.terrain_type == 'Mountain Pass':
			chance += 25.0
		elif self.cd_map_hex.terrain_type in ['Forest', 'Villages']:
			chance += 10.0
		elif self.cd_map_hex.terrain_type == 'Hills':
			chance += 15.0
		
		for position in COMMANDER_POSITIONS:
			crewman = self.player_unit.GetPersonnelByPosition(position)
			if crewman is None: continue
			modifier = crewman.GetSkillMod('Unique Opportunities', 20.0)
			if modifier is not None:
				chance -= modifier
				break
			
			modifier = crewman.GetSkillMod('Never Surprised', 20.0)
			if modifier is not None:
				chance -= modifier
				break
			
			modifier = crewman.GetSkillMod('Enemy Spotted!', 10.0)
			if modifier is not None:
				chance -= modifier
				break
		
		if self.player_unit.GetStat('recce') is not None:
			chance -= 5.0
		
		crew_exposed = False
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive or position.crewman.condition == 'Unconscious': continue
			if position.crewman.ce:
				crew_exposed = True
				break
		if crew_exposed:
			chance -= 10.0
		
		if chance < 3.0:
			chance = 3.0
		
		if GetPercentileRoll() <= chance:
			self.ambush = True
	
	
	# check for end of scenario and set flag if it has ended
	def CheckForEnd(self):
		all_enemies_dead = True
		for unit in self.units:
			if unit.owning_player == 1 and unit.alive:
				if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
				all_enemies_dead = False
				break
		if all_enemies_dead:
			ShowTutorialSlide('scenario_all_enemies_kia')
			ShowMessage('Victory! No enemy units remain in this area.', good_news=True)
			self.finished = True
			return
		
		# check for loss of player crew
		all_crew_dead = True
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if position.crewman.alive:
				all_crew_dead = False
				break
		if all_crew_dead:
			ShowMessage('Your crew is all dead.', good_news=False)
			scenario.player_unit.DestroyMe()
			return
		
		# check for end of campaign day, but don't end the scenario
		campaign_day.CheckForEndOfDay()
		
		# if campaign day has ended, chance that nightfall will end the scenario right away
		if campaign_day.ended:
			if campaign_day.day_clock['hour'] >= 23:
				chance = 100.0
			else:
				chance = float(campaign_day.day_clock['hour'] - campaign_day.end_of_day['hour'] + 1) * 8.0
			if GetPercentileRoll() <= chance:
				ShowMessage("The day's combat is over, and you withdraw from the battlefield safely.",
					longer_pause=True)
				self.finished = True
				return
	
	
	# check for triggering of a random event in a scenario
	def CheckForRandomEvent(self):
		
		if 'tutorial_campaign' in campaign.stats: return
		
		roll = GetPercentileRoll()
		if roll > self.random_event_chance:
			self.random_event_chance += 1.0
			return
		
		# check for special south pacific / SE Asia events
		if campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
			
			# friendly event
			roll = GetPercentileRoll()
			
			if campaign.player_unit.nation == 'Empire of Japan':
				if roll <= 5.0:
					unit = self.SpawnFriendlyReinforcements(unit_list=['SMG Squad', 'Flame Thrower Team', 'Combat Engineer Team'])
					if unit is not None:
						ShowMessage('A hidden friendly ' + unit.unit_id + ' has revealed themselves and joins the battle!',
							scenario_highlight=(unit.hx, unit.hy), good_news=True)
						return
			
			elif campaign.player_unit.nation == 'United Kingdom':
				if roll <= 5.0:
					unit = self.SpawnFriendlyReinforcements(unit_list=['OQF 25-Pounder'])
					if unit is not None:
						ShowMessage('A friendly ' + unit.unit_id + ' was nearby and joins the battle!',
							scenario_highlight=(unit.hx, unit.hy), good_news=True)
						return
			
			elif campaign.player_unit.nation == 'United States of America':
				if roll <= 5.0 and 'player_arty_support' in campaign.stats:
					self.DoArtilleryAttack(naval_only=True)
					return
			
			# enemy event
			roll = GetPercentileRoll()
			
			if 'Empire of Japan' in campaign.current_week['enemy_nations']:
				if roll <= 5.0:
					hex_list = GetHexRing(0, 0, 1)
					shuffle(hex_list)
					for (hx, hy) in hex_list:
						if len(self.hex_dict[(hx,hy)].unit_stack) > 0:
							if self.hex_dict[(hx,hy)].unit_stack[0].owning_player == 0:
								continue
						
						unit_id = choice(['SMG Squad', 'Flame Thrower Team', 'Combat Engineer Team', 'Combat Engineer Team'])
						unit = Unit(unit_id, owning_player=1)
						unit.nation = 'Empire of Japan'
						unit.ai = AI(unit)
						unit.ai.Reset()
						unit.GenerateNewPersonnel()
						unit.SpawnAt(hx, hy)
						unit.entrenched = True
						unit.spotted = True
						self.GenerateUnitLoS(unit)
						self.UpdateUnitCon()
						self.UpdateScenarioDisplay()
						ShowMessage('Enemy ' + unit_id + ' spotted at close range, entrenched in a cave mouth!',
							scenario_highlight=(hx, hy), good_news=False)
						return
			
			elif 'United Kingdom' in campaign.current_week['enemy_nations']:
				if roll <= 5.0:
					hex_list = GetHexRing(0, 0, 1)
					shuffle(hex_list)
					for (hx, hy) in hex_list:
						if len(self.hex_dict[(hx,hy)].unit_stack) > 0:
							if self.hex_dict[(hx,hy)].unit_stack[0].owning_player == 0:
								continue
						
						unit = Unit('OQF 25-Pounder', owning_player=1)
						unit.nation = 'United Kingdom'
						unit.ai = AI(unit)
						unit.ai.Reset()
						unit.GenerateNewPersonnel()
						unit.SpawnAt(hx, hy)
						unit.facing = GetDirectionToward(hx, hy, 0, 0)
						for weapon in unit.weapon_list:
							weapon.UpdateCoveredHexes()
						unit.entrenched = True
						unit.spotted = True
						self.GenerateUnitLoS(unit)
						self.UpdateUnitCon()
						self.UpdateScenarioDisplay()
						ShowMessage('Enemy ' + unit.unit_id + ' spotted at close range!',
							scenario_highlight=(hx, hy), good_news=False)
						return
			
			elif 'United States of America' in campaign.current_week['enemy_nations']:
				if roll <= 5.0:
					if 'enemy_arty_support' in campaign.stats:
						self.DoArtilleryAttack(player_target=True, naval_only=True)
						return
					
		
		# roll for type of event
		roll = GetPercentileRoll()
		
		# some day missions will force a reroll
		if campaign_day.mission == 'Amphibious Assault':
			if 60.0 < roll <= 65.0:
				roll = GetPercentileRoll()
			elif roll > 30.0:
				roll = GetPercentileRoll()
		
		# check for dedicated radio operator
		for position in campaign.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive or position.crewman.condition == 'Unconscious': continue
			if position.name == 'Radio Operator':
				if roll > 20.0:
					roll = GetPercentileRoll()
				break
		
		# friendly air attack
		if roll <= 10.0:
			if 'air_support_level' not in campaign.current_week: return
			if 'player_air_support' not in campaign.stats: return
			if campaign_day.weather['Cloud Cover'] == 'Overcast' or campaign_day.weather['Fog'] > 0 or campaign_day.weather['Precipitation'] == 'Sandstorm': return
			
			# possible friendly fire
			if roll <= 0.2:
				if campaign.player_unit.CrewmanHasSkill(['Radio Operator'], 'Good Comms'):
					if GetPercentileRoll() < 80.0: return
				self.DoAirAttack(friendly_fire=True)
			else:
				self.DoAirAttack()
			
		# friendly arty attack
		elif roll <= 20.0:
			if 'arty_support_level' not in campaign.current_week: return
			if 'player_arty_support' not in campaign.stats: return
			
			# possible friendly fire
			if roll <= 10.2:
				if campaign.player_unit.CrewmanHasSkill(['Radio Operator'], 'Good Comms'):
					if GetPercentileRoll() < 80.0: return
				self.DoArtilleryAttack(player_target=True, friendly_fire=True)
			else:
				self.DoArtilleryAttack()
		
		# enemy reinforcement
		elif roll <= 30.0:
			if self.enemy_reinforcements > 0:
				if GetPercentileRoll() <= (float(self.enemy_reinforcements) * 40.0):
					return
			self.enemy_reinforcements += 1
			if self.SpawnEnemyUnits(reinforcement=True):
				ShowMessage('Enemy reinforcements have arrived!', good_news=False)
		
		# sniper attack on player
		elif roll <= 40.0:
			
			# not possible in foggy conditions
			if campaign_day.weather['Fog'] > 0:
				return
			
			# less likely in north african terrain
			if campaign.stats['region'] == 'North Africa':
				if GetPercentileRoll() <= 80.0: return
			
			# check for vulnerable targets and select one if any
			crew_list = self.player_unit.VulnerableCrew()
			if len(crew_list) == 0: return
			crew_target = choice(crew_list)
			
			# do attack roll
			chance = BASE_SNIPER_TK_CHANCE
			
			# precipitation modifier
			if campaign_day.weather['Precipitation'] in ['Rain', 'Light Snow']:
				chance -= 5.0
			elif campaign_day.weather['Precipitation'] == ['Heavy Rain', 'Blizzard']:
				chance -= 15.0
			
			# target moving
			if self.player_unit.moving: chance -= 10.0
			
			# target terrain
			chance += self.player_unit.GetTEM()
			
			# large hatch
			if crew_target.current_position.large_hatch:
				chance += 15.0
			
			# odds too low
			if chance < 15.0: return
			
			#  get the sniper's origin and an indefinite article to refer to it with.
			if 'enemy_nation_odds' in campaign.stats:
				nation_roll = GetPercentileRoll()
				for k, value in campaign.stats['enemy_nation_odds'].items():
					# special: if enemy nation is not available this week, don't choose it
					if float(value) <= roll and k in campaign.current_week['enemy_nations']:
						sniper_nation = k
						break
					nation_roll -= float(value)
				else:
					sniper_nation = choice(campaign.current_week['enemy_nations'])
			else:
				sniper_nation = choice(campaign.current_week['enemy_nations'])

			# apparently it's actually more about the word's starting syllable than starting with a vowel but eh close enough for now.
			if session.nations[sniper_nation]['adjective'][0] in ['A','E','I','O','U']:
				sniper_prefix = 'an '
			else:
				sniper_prefix = 'a '
			
			# Get the sniper's unit portrait, if it exists.
			if not config['ArmCom2'].getboolean('fancy_portraits'):
				nation_suffix = 'basic'
			else:
				nation_suffix = session.nations[sniper_nation]['short_code'].lower()

			sniper_portrait = nation_suffix.join(['unit_sniper_team_', '.xp'])
			if sniper_portrait not in session.portrait_library:
				sniper_portrait = 'unit_sniper_team.xp'

			if crew_target.is_player_commander:
				crewman = None
				victim_name = 'you'
				victim_possessive = 'your'
			else:
				crewman = crew_target
				victim_name = 'your crewman'
				victim_possessive = "your crewman's"

			# do attack roll
			roll = GetPercentileRoll()

			# miss
			if roll > chance:
				PlaySound('ricochet')
				text = choice(["A", sniper_prefix.capitalize() + session.nations[sniper_nation]['adjective']])
				if libtcod.random_get_int(0, 0, 1):
					text += " sniper's bullet " + choice(["cracks over " + victim_possessive + " head!", "narrowly misses " + victim_name + choice([" and ricochets off your vehicle!", "!"])])
				else:
					text += " sniper " + choice(["fires at ", "narrowly misses "]) + victim_name + "!"
				ShowMessage(text, longer_pause=True, crewman=crewman, portrait=sniper_portrait)
				if crew_target.is_player_commander:
					session.ModifySteamStat('near_miss', 1)
					
			else:
				PlaySound('sniper_hit')
				sniper_desc = choice(["a", sniper_prefix + session.nations[sniper_nation]['adjective']])
				prefix = choice(["", "A gunshot " + choice(["rings out! ", "echoes! "])])				
				if crew_target.is_player_commander:
					text = 'You have been shot by ' + sniper_desc + ' sniper!'
				else:
					text = victim_name + ' has been shot by ' + sniper_desc + ' sniper!'
				ShowMessage(prefix + text, longer_pause=True, crewman=crewman, portrait=sniper_portrait, good_news=False)
				if crew_target.ResolveAttack({'sniper' : True}) is None:
					ShowMessage('Luckily, it was ' + choice(['a grazing hit.', 'only a graze.']), longer_pause=True, good_news=True)
		
		# random enemy tank is immobilized
		elif roll <= 50.0:
			unit_list = []
			for unit in self.units:
				if not unit.alive: continue
				if unit.owning_player == 0: continue
				if unit.GetStat('armour') is None: continue
				unit_list.append(unit)
			
			# no possible units to immobilize
			if len(unit_list) == 0:
				return
			
			unit = choice(unit_list)
			unit.ImmobilizeMe()
			if unit.spotted:
				ShowMessage(unit.GetName() + ' has been immobilized!',
					scenario_highlight=(unit.hx, unit.hy), good_news=True)
		
		# enemy air attack
		elif roll <= 55.0:
			if 'enemy_air_support' not in campaign.stats: return
			if campaign_day.weather['Cloud Cover'] == 'Overcast' or campaign_day.weather['Fog'] > 0 or campaign_day.weather['Precipitation'] == 'Sandstorm': return
			
			# friendly fire!
			if roll <= 50.5:
				self.DoAirAttack(player_target=True, friendly_fire=True)
			else:
				self.DoAirAttack(player_target=True)
		
		# enemy artillery attack on player
		elif roll <= 60.0:
			if 'enemy_arty_support' not in campaign.stats: return
			# friendly fire!
			if roll <= 55.5:
				self.DoArtilleryAttack(player_target=True, friendly_fire=True)
			else:
				self.DoArtilleryAttack(player_target=True)
		
		# friendly reinforcements
		elif roll <= 65.0:
			if 'player_unit_support' not in campaign.stats: return
			unit = self.SpawnFriendlyReinforcements()
			if unit is not None:
				ShowMessage('A friendly ' + unit.unit_id + ' arrives and joins the battle!',
					scenario_highlight=(unit.hx, unit.hy), good_news=True)
		
		# random squad member is immobilzed
		elif roll <= 65.5:
			if len(self.player_unit.squad) == 0: return
			unit = choice(self.player_unit.squad)
			if unit.immobilized: return
			
			if 'very_unreliable' in unit.stats:
				chance = 75.0
			elif 'unreliable' in unit.stats:
				chance = 50.0
			else:
				chance = 20.0
			if GetPercentileRoll() > chance: return
			
			ShowMessage('A ' + unit.unit_id + ' in your squad has broken down and is now immobilized!',
				scenario_highlight=(unit.hx, unit.hy), good_news=False)
			unit.ImmobilizeMe()
		
		# radio (if any) breaks down
		elif roll <= 70.0:
			if not self.player_unit.has_radio: return
			if self.player_unit.radio_damaged or self.player_unit.radio_destroyed: return
			ShowMessage('Your radio has broken down! It will need to be repaired.', good_news=False)
			self.player_unit.radio_damaged = True
			campaign_day.UpdateCommsStatus()
			self.UpdateCommsCon()
			self.UpdateScenarioDisplay()
		
		# radio (if any) is destroyed
		elif roll <= 71.0:
			if not self.player_unit.has_radio or self.player_unit.radio_destroyed: return
			ShowMessage('Your radio has completely broken down! It cannot be used for the rest of the day.',
				good_news=False)
			self.player_unit.radio_destroyed = True
			campaign_day.UpdateCommsStatus()
			self.UpdateCommsCon()
			self.UpdateScenarioDisplay()
		
		# harassing fire on player
		elif roll <= 95.0:
			
			# find active infantry/cavalry units
			unit_list = []
			for unit in self.units:
				if not unit.alive: continue
				if unit.owning_player == 0: continue
				if unit.routed: continue
				if unit.GetStat('category') not in ['Infantry', 'Cavalry']: continue
				if len(unit.weapon_list) == 0: continue
				if unit.weapon_list[0].GetStat('type') not in (['Small Arms'] + MG_WEAPONS): continue
				unit_list.append(unit)
			
			if len(unit_list) == 0:
				return
			
			shuffle(unit_list)
			for unit in unit_list:
				# make sure attack is possible
				if self.CheckAttack(unit, unit.weapon_list[0], self.player_unit) != '': continue
				
				unit.MoveToTopOfStack()
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				libtcod.console_flush()
				
				ShowMessage(unit.GetName() + ' fires harassing fire at you!', good_news=False)
				
				if unit.Attack(unit.weapon_list[0], self.player_unit):
					
					# won't cause AP hits
					self.player_unit.ap_hits_to_resolve = []
					self.player_unit.ResolveFP()
		
		else:
			return
		
		# an event was triggered, so reset random event chance
		self.random_event_chance = BASE_RANDOM_EVENT_CHANCE
	
	
	##################################################################################
	
	# Bail-out mini game
	# if abandoning_tank is true, no chance of a crew injury from the initial knock-out hit
	# if location is set, crew in hull/turret as appropriate will have a higher chance of injury
	def PlayerBailOut(self, location=None, weapon=None, abandoning_tank=False, force_explosion=False):
		
		# build the list of possible actions, and odds of success, for a crewman
		def BuildActionList(crewman):
			
			# clear any old actions
			crewman.action_list = [('None', 0.0, [])]
			
			# no other actions possible
			if not crewman.alive or crewman.condition == 'Unconscious':
				crewman.current_action = crewman.action_list[0]
				return
				
			# crewmen in safe location can only return to tank
			if crewman.current_position.location == 'Safe Location':
				crewman.action_list.append(('Return to Vehicle', 75.0, []))
			
			# crewmen on vehicle exterior
			elif crewman.current_position.location == 'Vehicle Exterior':
				crewman.action_list.append(('Move to Safe Location', 85.0, []))
				crewman.action_list.append(('Covering Fire', 100.0, []))
				
				# aid crewmen bailing out
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.crewman.condition == 'Unconscious': continue
					crewman.action_list.append(('Aid All Crewmen Bailing Out', 100.0, []))
					break
			
				# pull out an unconscious crewman
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.crewman.condition != 'Unconscious': continue
					if position.crewman.current_position.location in ['Vehicle Exterior', 'Safe Location']: continue
					
					# needs an open hatch anywhere in the same location
					has_exit = False
					for position2 in self.player_unit.positions_list:
						if position2.location != position.location: continue
						if position2.open_top or position2.crew_always_ce or position2.hatch_open:
							has_exit = True
							break
					if not has_exit:
						continue
					
					crewman.action_list.append(('Rescue Unconscious Crewman in ' + position.name + ' position', 60.0, []))
				
				# carry an unconscious crewman to safety
				for crewman2 in player_crew:
					if not crewman2.alive: continue
					if crewman2.condition != 'Unconscious': continue
					if crewman2.current_position.location != 'Vehicle Exterior': continue
					crewman.action_list.append(('Carry Unconscious Crewman to Safety', 35.0, []))
					break
			
			# crewman still inside tank
			else:
				
				# open a hatch
				if crewman.current_position.hatch and not crewman.current_position.hatch_open:
					crewman.action_list.append(('Open Hatch', 90.0, []))
				
				# open another hatch in the same location
				for position in self.player_unit.positions_list:
					if position == crewman.current_position: continue
					if position.location != crewman.current_position.location: continue
					if not position.hatch: continue
					if position.hatch_open: continue
					crewman.action_list.append(('Open ' + position.name + ' Hatch', 45.0, []))
				
				# throw a smoke grenade
				if crewman.current_position.name in COMMANDER_POSITIONS and campaign_day.smoke_grenades > 0:
					if crewman.ce:
						crewman.action_list.append(('Throw Smoke Grenade', 100.0, []))
				
				# move an unconscious crewman to an empty position in the tank
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.crewman.condition != 'Unconscious': continue
					if position.crewman.current_position.location in ['Vehicle Exterior', 'Safe Location']: continue
					
					# move an unconscious crewman to any empty position within the tank
					for position2 in self.player_unit.positions_list:
						if position2.crewman is None:
							crewman.action_list.append(('Move Crewman from ' + position.name + ' to ' + position2.name + ' Position' , 45.0, []))
				
				# push out an unconscious crewman in the same location
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.crewman.condition != 'Unconscious': continue
					if position.crewman.current_position.location != crewman.current_position.location: continue
					if position.crewman.current_position.location in ['Vehicle Exterior', 'Safe Location']: continue
					
					# needs an open hatch or open top anywhere in the same location
					has_exit = False
					for position2 in self.player_unit.positions_list:
						if position2.location != position.location: continue
						if position2.open_top or position2.crew_always_ce or position2.hatch_open:
							has_exit = True
							break
					if not has_exit:
						continue
					
					crewman.action_list.append(('Push Out Crewman in ' + position.name + ' position', 50.0, []))
				
				# swap positions with an unconscious or dead crewman
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not (not position.crewman.alive or position.crewman.condition == 'Unconscious'): continue
					if position.crewman.current_position.location in ['Vehicle Exterior', 'Safe Location']: continue
					if position.location == crewman.current_position.location:
						chance = 80.0
					else:
						chance = 50.0
					crewman.action_list.append(('Swap Positions with Crewman in ' + position.name + ' Position' , chance, []))
				
				# bail-out actions
				text = ''
				chance = 0.0
				
				# bail out while already exposed
				if crewman.current_position.open_top or crewman.current_position.crew_always_ce:
					text, chance = 'Bail Out', 95.0
				
				# bail out from an open turret rear
				elif 'open_rear_turret' in self.player_unit.stats and crewman.current_position.location == 'Turret':
					text, chance = 'Bail Out through Turret Rear', 90.0
				
				# bail out of open hatch in current location
				elif crewman.current_position.hatch_open:
					if crewman.current_position.large_hatch:
						text, chance = 'Bail Out through Large Hatch', 85.0
					else:
						text, chance = 'Bail Out through Hatch', 75.0
				
				# bail out of open hatch in nearby/other location
				else:
					# in nearby location
					for position in self.player_unit.positions_list:
						if position.location != crewman.current_position.location: continue
						if position.hatch_open:
							if position.large_hatch:
								text, chance = 'Bail Out through Nearby Large Hatch', 70.0
							else:
								text, chance = 'Bail Out through Nearby Hatch', 55.0
							break
					
					# in other location
					if text == '':
						for position in self.player_unit.positions_list:
							if position.location == crewman.current_position.location: continue
							if not position.hatch_open: continue
							
							if position.large_hatch:
								text, chance = 'Bail Out through Large ' + position.location + ' Hatch', 35.0
							else:
								text, chance = 'Bail Out through ' + position.location + ' Hatch', 20.0
							break
				
				if chance > 0.0:
					crewman.action_list.append((text, chance, []))
				
				# move to an empty position within the tank
				for position in self.player_unit.positions_list:
					if position == crewman.current_position: continue
					if position.crewman is not None: continue
					if position.location == crewman.current_position.location:
						chance = 85.0
					else:
						chance = 70.0
					crewman.action_list.append(('Go to ' + position.name + ' Position', chance, []))
				
				# help crewmen in same location / attempt to stabilize a critical injury
				aid_crewmen_added = False
				stabilize_crewmen_added = False
				for position in self.player_unit.positions_list:
					if position.location != crewman.current_position.location: continue
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.crewman == crewman: continue
					
					if not aid_crewmen_added:
						if position.crewman.condition != 'Good Order':
							crewman.action_list.append(('Aid Fellow Crewmen', 100.0, []))
							aid_crewmen_added = True
					
					if not stabilize_crewmen_added:
						for (k, v) in position.crewman.injury.items():
							(status, severity, scarring) = v
							if status is None and severity is None: continue
							if severity != 'Critical': continue
							crewman.action_list.append(('Stabilize Crewmen', 100.0, []))
							stabilize_crewmen_added = True
							break
				
				# covering fire
				if crewman.ce:
					crewman.action_list.append(('Covering Fire', 100.0, []))
			
			
			# run through list of actions and add any modifiers
			for i in range(len(crewman.action_list)):
				(text, chance, modifiers) = crewman.action_list[i]
				
				skill_mod = crewman.GetSkillMod('Gymnast', 10.0)
				if skill_mod is not None:
					if text[:26] == 'Rescue Unconscious Crewman' or 'Bail Out' in text:
						modifiers.append(('Gymnast', skill_mod))
				
				if on_fire:
					if text == 'Covering Fire':
						if crewman.current_position.location != 'Vehicle Exterior':
							modifiers.append(('Vehicle on Fire', -50.0))
					elif text[:4] == 'Open':
						modifiers.append(('Vehicle on Fire', -25.0))
					elif text == 'Push Unconscious Crewman Out':
						modifiers.append(('Vehicle on Fire', -30.0))
					elif text[:4] == 'Bail':
						modifiers.append(('Vehicle on Fire', -20.0))
				
				if smoke:
					if text == 'Covering Fire':
						if crewman.current_position.location != 'Vehicle Exterior':
							modifiers.append(('Smoke in Vehicle', -20.0))
					elif text[:4] == 'Open':
						modifiers.append(('Smoke in Vehicle', -25.0))
					elif text == 'Push Unconscious Crewman Out':
						modifiers.append(('Smoke in Vehicle', -20.0))
					elif text[:4] == 'Bail':
						modifiers.append(('Smoke in Vehicle', -10.0))
				
				if crewman.condition == 'Shaken':
					modifiers.append(('Shaken', -5.0))
				elif crewman.condition == 'Stunned':
					modifiers.append(('Stunned', -10.0))
				
				# injury modifiers here
				for (k, v) in crewman.injury.items():
					if v[1] is None: continue
					if v[1] not in ['Heavy', 'Serious', 'Critical']: continue
					if k in ['Right Leg & Foot', 'Left Leg & Foot']:
						if text in ['Return to Vehicle', 'Move to Safe Location']:
							modifiers.append(('Leg/Foot Injury', -10.0))
						elif text == 'Carry Unconscious Crewman to Safety':
							modifiers.append(('Leg/Foot Injury', -20.0))
						continue
					if k in ['Right Arm & Hand', 'Left Arm & Hand']:
						if text in ['Aid All Crewmen Bailing Out', 'Throw Smoke Grenade', 'Push Unconscious Crewman Out']:
							modifiers.append(('Arm/Hand Injury', -20.0))
						elif text[:26] == 'Rescue Unconscious Crewman':
							modifiers.append(('Arm/Hand Injury', -20.0))
						elif text[:4] == 'Open':
							modifiers.append(('Arm/Hand Injury', -10.0))
						elif text[:4] == 'Bail':
							modifiers.append(('Arm/Hand Injury', -15.0))
						continue
				
				# apply all modifiers to final chance
				for (text2, mod) in modifiers:
					chance += mod
				
				# round and restrict chance
				chance = round(chance, 1)
				if chance < 3.0:
					chance = 3.0
				elif chance > 97.0:
					chance = 97.0
				
				crewman.action_list[i] = (text, chance, modifiers)
			
			# if previous turn's action is still in list, select that one, even if odds/modifiers have changed
			for i in range(len(crewman.action_list)):
				if crewman.current_action[0] == crewman.action_list[i][0]:
					crewman.current_action = crewman.action_list[i]
					return
			
			# unable to find previous turn's action in current list, reset to default
			crewman.current_action = crewman.action_list[0]
		
		# display a positive or negative result for a crewman
		def DisplayResult(crewman, result_text, positive_result):
			
			# play sound effect if any
			if result_text == 'Success: Hatch now open':
				PlaySoundFor(crewman.current_position, 'hatch')
			elif result_text == 'Success: Threw a smoke grenade':
				PlaySoundFor(None, 'smoke')
			elif result_text in ['Success: Moved to a safe location', 'Success: Returned to the vehicle exterior']:
				PlaySound('infantry_moving')
			elif result_text == 'Success: Covering fire':
				PlaySoundFor(None, 'pistol_firing')
			
			y = 47
			if positive_result:
				libtcod.console_set_default_background(con, libtcod.light_blue)
			else:
				libtcod.console_set_default_background(con, libtcod.dark_red)	
			libtcod.console_rect(con, 63, y, 25, 5, True, libtcod.BKGND_SET)
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_set_default_background(con, libtcod.black)
			lines = wrap(result_text, 23)
			ys = 0
			for line in lines[:3]:
				libtcod.console_print(con, 64, y+1+ys, line)
				ys += 1
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			libtcod.console_flush()
			Wait(150, ignore_animations=True)
		
		# attempt to do the selected action for the crewman
		def DoBailoutAction(crewman):
			
			# check for recovery from negative condition
			if crewman.condition != 'Good Order':
				condition_change = False
				
				# check for crewmen in same location helping
				crewman_helping = False
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if position.location != crewman.current_position.location: continue
					if position.crewman == crewman: continue
					(text, odds, modifiers) = position.crewman.current_action
					if text == 'Aid Fellow Crewmen':
						crewman_helping = True
						break
				
				if crewman_helping:
					base_modifier = 20.0
				else:
					base_modifier = 40.0
				
				if crewman.condition == 'Shaken':
					if crewman.DoMoraleCheck(base_modifier):
						crewman.condition = 'Good Order'
						condition_change = True
				elif crewman.condition == 'Stunned':
					if crewman.DoMoraleCheck(base_modifier * 2):
						crewman.condition = 'Good Order'
						condition_change = True
				elif crewman.condition == 'Unconscious':
					if crewman.DoGritCheck(base_modifier * 3):
						crewman.condition = 'Stunned'
						condition_change = True
				
				if condition_change:
					if crewman.current_position.name in COMMANDER_POSITIONS:
						text = 'Your condition improves, you are now: ' + crewman.condition
						if crewman_helping:
							text += ' (Aid Fellow Crewmen bonus applied)'
						ShowSimpleMessage(text)
					else:
						text = "Your crewman's condition improves to " + crewman.condition + ':'
						if crewman_helping:
							text += ' (Aid Fellow Crewmen bonus applied)'
						ShowSimpleMessage(text, crewman=crewman)
			
			# check for critical injury stabilizing
			for (k, v) in crewman.injury.items():
				(status, severity, scarring) = v
				if status is None and severity is None: continue
				if severity != 'Critical' : continue
				
				# check for another crewman in same location helping
				crewman_helping = False
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if position.location != crewman.current_position.location: continue
					if position.crewman == crewman: continue
					(text, odds, modifiers) = position.crewman.current_action
					if text == 'Stabilize Crewmen':
						crewman_helping = True
						break
				
				if crewman_helping:
					chance = 10.0
				else:
					chance = 1.0
				
				if GetPercentileRoll() <= chance:
					severity = 'Serious'
					crewman.injury[k] = (status, severity, scarring)
					if crewman.is_player_commander:
						text = 'Your ' + k + ' injury has been stabilized.'
						if crewman_helping:
							text += ' (Stabilize Crewmen bonus applied)'
						ShowSimpleMessage(text)
					else:
						text = "Your crewman's " + k + ' injury has been stabilized.'
						if crewman_helping:
							text += ' (Stabilize Crewmen bonus applied)'
						ShowSimpleMessage(text, crewman=crewman)
			
			(text, odds, modifiers) = crewman.current_action
			
			# no action to do here
			if text in ['None']:
				return
			
			result_text = 'Failed: ' + text
			
			# do actual roll
			roll = GetPercentileRoll()
			
			# aid crewmen bailing out (automatic)
			if text == 'Aid All Crewmen Bailing Out':
				odds = 100.0
				result_text = 'Success: Aiding crewmen bailing out'
			
			# attempt to pull out a unconscious crewman still in the tank
			elif text[:26] == 'Rescue Unconscious Crewman':
				position_name = text[30:-9]
				for crewman in player_crew:
					if crewman.current_position.name != position_name: continue
					if crewman.condition != 'Unconscious': continue
					if roll <= odds:
						crewman.current_position.crewman = None
						crewman.current_position = tank_exterior_position
						result_text = 'Success: Pulled out crewman in ' + position_name + ' position'
					else:
						result_text = 'Unable to pull crewman out'
					break
			
			# move an unconscious crewman from one position to another empty position in the tank
			elif text[:12] == 'Move Crewman':
				rough_text = text[18:-9]
				[position1_name, position2_name] = rough_text.split(' to ')
				for crewman in player_crew:
					if crewman.current_position.name != position1_name: continue
					if crewman.condition != 'Unconscious': continue
					if roll <= odds:
						for position in self.player_unit.positions_list:
							if position.name == position2_name:
								crewman.current_position.crewman = None
								crewman.current_position = position
								position.crewman = crewman
								break
						result_text = 'Success: Moved crewman to a new position.'
					else:
						result_text = 'Unable to move crewman to a different position!'
			
			# push an unconscious crewman out of the tank
			elif text[:8] == 'Push Out':
				position_name = text[20:-9]
				for crewman in player_crew:
					if crewman.current_position.name != position_name: continue
					if crewman.condition != 'Unconscious': continue
					if roll <= odds:
						crewman.current_position.crewman = None
						crewman.current_position = tank_exterior_position
						result_text = 'Success: Pushed out crewman in ' + position_name + ' position'
					else:
						result_text = 'Unable to push out crewman'
					break
			
			# carry an unconscious crewman to safe location
			elif text == 'Carry Unconscious Crewman to Safety':
				rescue_list = []
				for crewman2 in player_crew:
					if not crewman2.alive: continue
					if crewman2.condition != 'Unconscious': continue
					if crewman2.current_position.location != 'Vehicle Exterior': continue
					rescue_list.append(crewman2)
				
				if len(rescue_list) == 0:
					if roll <= odds:
						crewman.current_position = safe_location_position
						result_text = 'No crewman to rescue, but moved to safe location.'
					else:
						result_text = 'No crewman to rescue; unable to move to a safe location!'
				else:
					if roll <= odds:
						crewman2 = choice(rescue_list)
						crewman2.current_position = safe_location_position
						crewman.current_position = safe_location_position
						result_text = 'Success: Brought a crewman to safe location.'
					else:
						result_text = 'Unable to bring crewman to safe location!'
			
			# swap positions with an unconscious or dead crewman
			elif text[:4] == 'Swap':
				position_name = text[31:-9]
				for position in self.player_unit.positions_list:
					if position.name == position_name:
						if position.crewman is None:
							odds = 0.0
							result_text = 'Crewman in target position no longer there!'
						elif position.crewman.alive and position.crewman.condition != 'Unconscious':
							odds = 0.0
							result_text = 'Crewman in target position has regained consciousness!'
						else:
							if roll <= odds:
								crewman.current_position.crewman = position.crewman
								position.crewman.current_position = crewman.current_position
								crewman.current_position = position
								position.crewman = crewman
								result_text = 'Success: Swapped positions.'
							else:
								result_text = 'Unable to swap positions!'
						break
			
			# attempt to open a hatch
			elif text == 'Open Hatch':
				# skip if hatch already open
				if crewman.current_position.hatch_open:
					odds = 0.0
					result_text = 'Hatch already open'
				else:
					if roll <= odds:
						if crewman.ToggleHatch():
							result_text = 'Success: Hatch now open'
						else:
							result_text = 'Unable to open hatch in this location'
			
			# attempt to open a nearby hatch
			elif text[:4] == 'Open':
				# strip the Open and Hatch parts to leave the position name
				text = text[5:-6]
				for position in self.player_unit.positions_list:
					if position.name == text:
						if position.hatch_open:
							odds = 0.0
							result_text = 'Hatch already open'
						else:
							if roll <= odds:	
								if position.TogglePositionHatch():
									result_text = 'Success: Hatch now open'
								else:
									result_text = 'Unable to open hatch in this location'
						break
			
			# throw a smoke grenade
			elif text == 'Throw Smoke Grenade':
				campaign_day.smoke_grenades -= 1
				if roll <= odds:
					self.player_unit.smoke += 1
					if self.player_unit.smoke > 2:
						self.player_unit.smoke = 2
					result_text = 'Success: Threw a smoke grenade'
				else:
					result_text = 'Could not throw a smoke grenade'
			
			# attempt to move to an empty position within the tank
			elif text[:6] == 'Go to ':
				text = text[6:-9]
				for position in self.player_unit.positions_list:
					if position.name == text:
						if position.crewman is not None:
							odds = 0.0
							result_text = 'Cannot move: Position is occupied.'
							break
						if roll <= odds:
							crewman.current_position.crewman = None
							crewman.current_position = position
							position.crewman = crewman
							result_text = 'Success: Moved to ' + text + ' position'
						break
			
			# move from tank exterior to safe location
			elif text == 'Move to Safe Location':
				if roll <= odds:
					crewman.current_position = safe_location_position
					result_text = 'Success: Moved to a safe location'
			
			# return to tank exterior from safe location
			elif text == 'Return to Vehicle':
				if roll <= odds:
					crewman.current_position = tank_exterior_position
					result_text = 'Success: Returned to the vehicle exterior'
			
			# suppressing fire
			elif text == 'Covering Fire':
				if roll <= odds:
					result_text = 'Success: Covering fire'
				else:
					crewman.current_action = ('None', 0.0, [])
			
			# aid fellow crewman in location
			elif text == 'Aid Fellow Crewmen':
				if roll <= odds:
					result_text = 'Success: Aiding other crewmen in location'
				else:
					result_text = 'Failed: Unable to aid fellow crewmen'
					crewman.current_action = ('None', 0.0, [])
			
			# help to stabilize fellow crewman in location
			elif text == 'Stabilize Crewmen':
				if roll <= odds:
					result_text = 'Success: Attempted to stabilize other crewmen in location'
				else:
					result_text = 'Failed: Unable to help fellow crewmen in location'
					crewman.current_action = ('None', 0.0, [])
			
			# bail out to tank exterior
			elif 'Bail Out' in text:
				crewman_helping = False
				
				# check for crewmen helping outside tank (multiple modifiers possible)
				for friendly_crewman in player_crew:
					if not friendly_crewman.alive: continue
					if friendly_crewman.current_position.location != 'Vehicle Exterior': continue
					(text, odds2, modifiers) = friendly_crewman.current_action
					if text == 'Aid All Crewmen Bailing Out':
						crewman_helping = True
						roll -= 15.0
				
				if roll < 0.0: roll = 0.0
				roll = round(roll, 1)
				if roll <= odds:
					crewman.current_position.crewman = None
					crewman.current_position = tank_exterior_position
					result_text = 'Success: Bailed out to tank exterior'
					if crewman_helping:
						result_text += ' (Aid Crewmen bonus applied)'
			
			# show rolls if outcome not automatic
			if odds != 0.0 and odds != 100.0:
				for i in range(3):
					libtcod.console_print(con, 64, 45, '      ')
					libtcod.console_print_ex(con, 68, 45, libtcod.BKGND_NONE,
						libtcod.RIGHT, str(GetPercentileRoll()))
					libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
					libtcod.console_flush()
					Wait(15, ignore_animations=True)
				libtcod.console_print(con, 64, 45, '      ')
				libtcod.console_print_ex(con, 68, 45, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(roll))
				libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
				libtcod.console_flush()
				Wait(15, ignore_animations=True)
			
			# display outcome
			DisplayResult(crewman, result_text, roll<=odds)
			
		# (re)draw the bail-out console and display on screen
		def UpdateBailOutConsole(no_highlight=False):
			
			libtcod.console_clear(con)
			
			# window title
			libtcod.console_set_default_background(con, libtcod.light_red)
			libtcod.console_rect(con, 0, 0, WINDOW_WIDTH, 3, True, libtcod.BKGND_SET)
			libtcod.console_set_default_foreground(con, libtcod.black)
			libtcod.console_print_ex(con, WINDOW_XM, 1, libtcod.BKGND_NONE,
				libtcod.CENTER, 'BAILING OUT')
			
			# display player unit
			libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
			libtcod.console_print(con, 1, 4, self.player_unit.unit_id)
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print(con, 1, 5, self.player_unit.GetStat('class'))
			
			libtcod.console_set_default_background(con, PORTRAIT_BG_COL)
			libtcod.console_rect(con, 1, 6, 25, 8, True, libtcod.BKGND_SET)
			DisplayUnitPortrait(con, 1, 6, self.player_unit, campaign.portrait_variant)
			
			libtcod.console_set_default_foreground(con, libtcod.white)
			if self.player_unit.unit_name != '':
				PrintExtended(con, 1, 6, self.player_unit.unit_name)
			
			# display tank status, nearby allies, visible enemies
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 27, 4, 'Status:')
			
			if abandoning_tank:
				libtcod.console_print(con, 28, 5, 'Abandoning')
			elif not self.player_unit.alive:
				libtcod.console_print(con, 28, 5, 'Knocked Out')
			
			if self.player_unit.smoke > 0:
				libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
				libtcod.console_print(con, 27, 6, 'Ext. Smoke: ' + str(self.player_unit.smoke))
			
			if smoke:
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				libtcod.console_print(con, 27, 7, 'Int. Smoke')
			
			if fire_chance > 0.0:
				libtcod.console_set_default_foreground(con, libtcod.light_red)
				if on_fire:
					libtcod.console_print(con, 27, 9, 'FIRE')
				else:
					libtcod.console_print(con, 27, 9, 'Fire Chance:')
					libtcod.console_print(con, 28, 10, str(int(fire_chance)) + '%')
			
			libtcod.console_set_default_foreground(con, ALLIED_UNIT_COL)
			libtcod.console_print(con, 41, 4, 'Nearby Allies:')
			y = 6
			for unit in nearby_allies:
				libtcod.console_print(con, 42, y, unit.GetName())
				y += 1
				if y == 15: break
			
			libtcod.console_set_default_foreground(con, ENEMY_UNIT_COL)
			libtcod.console_print(con, 65, 4, 'Enemies in Sight:')
			y = 6
			for (distance, unit) in enemies_in_los:
				libtcod.console_print(con, 64, y, distance)
				libtcod.console_print(con, 66, y, unit.GetName())
				y += 1
				if y == 12: break
			
			# display current time and round
			libtcod.console_set_default_foreground(con, libtcod.white)
			text = str(campaign_day.day_clock['hour']).zfill(2) + ':' + str(campaign_day.day_clock['minute']).zfill(2)
			libtcod.console_print(con, 27, 13, text)
			text = 'Round ' + str(current_round) + '/' + str(max_rounds)
			libtcod.console_print(con, 43, 13, text)
			
			# column headings
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_set_default_background(con, libtcod.darker_blue)
			libtcod.console_rect(con, 2, 15, 19, 1, False, libtcod.BKGND_SET)
			libtcod.console_print(con, 3, 15, 'Crewman & Status')
			libtcod.console_rect(con, 22, 15, 20, 1, False, libtcod.BKGND_SET)
			libtcod.console_print(con, 23, 15, 'Location')
			libtcod.console_rect(con, 43, 15, 19, 1, False, libtcod.BKGND_SET)
			libtcod.console_print(con, 44, 15, 'Action')
			libtcod.console_rect(con, 63, 15, 25, 1, False, libtcod.BKGND_SET)
			libtcod.console_print(con, 64, 15, 'Description/Action Roll')
			libtcod.console_set_default_background(con, libtcod.black)
			
			# row and column borders
			libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			DrawFrame(con, 1, 16, 88, 37)
			libtcod.console_vline(con, 21, 17, 36)
			libtcod.console_vline(con, 42, 17, 36)
			libtcod.console_vline(con, 62, 17, 36)
			
			for y in range(22, 51, 6):
				libtcod.console_hline(con, 2, y, 60)
			
			# list of crew
			y = 18
			libtcod.console_set_default_foreground(con, libtcod.white)
			for crewman in player_crew:
				
				# highlight if currently selected
				if selected_crewman == crewman and not no_highlight:
					libtcod.console_set_default_background(con, libtcod.darker_blue)
					libtcod.console_rect(con, 2, y-1, 60, 5, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
				
				# crewman name and current status
				PrintExtended(con, 2, y, crewman.GetCrewmanName(first_initial=True), nation=crewman.nation)
				
				if not crewman.alive:
					libtcod.console_set_default_foreground(con, libtcod.light_red)
					text = 'Dead'
				else:
					if crewman.condition != 'Good Order':
						libtcod.console_set_default_foreground(con, libtcod.light_red)
					else:
						libtcod.console_set_default_foreground(con, libtcod.light_green)
					text = crewman.condition
				libtcod.console_print(con, 2, y+2, text)
				
				# critical injury if any
				for (k, v) in crewman.injury.items():
					if v[1] != 'Critical': continue
					libtcod.console_set_default_foreground(con, libtcod.light_red)
					libtcod.console_print(con, 2, y+3, 'Critical Injury')
					break
				
				# location - could be in, on, or outside the tank
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 23, y, crewman.current_position.location)
				if crewman.current_position.name is not None:
					libtcod.console_print(con, 23, y+1, crewman.current_position.name)
					if on_fire:
						libtcod.console_set_default_foreground(con, libtcod.light_red)
						libtcod.console_print(con, 38, y, 'FIRE')
						libtcod.console_set_default_foreground(con, libtcod.white)
					
				if crewman.current_position.location in ['Turret', 'Hull']:
					if not crewman.current_position.hatch:
						libtcod.console_set_default_foreground(con, libtcod.red)
						text = 'No Hatch'
					elif crewman.current_position.hatch_open:
						libtcod.console_set_default_foreground(con, libtcod.light_green)
						text = 'Hatch Open'
					else:
						libtcod.console_set_default_foreground(con, libtcod.light_red)
						text = 'Hatch Shut'
					libtcod.console_print(con, 23, y+2, text)
				
				# display the crewman's currently selected action
				libtcod.console_set_default_foreground(con, libtcod.white)
				(text, odds, modifiers) = crewman.current_action
				lines = wrap(text, 18)
				
				# some actions may be quite long
				if len(lines) > 4:
					y1 = y-1
				else:
					y1 = y
				for line in lines[:4]:
					libtcod.console_print(con, 44, y1, line)
					y1+=1
				
				# add an additional line if no actions are available to the crewman
				if text == 'None' and len(crewman.action_list) == 1:
					libtcod.console_print(con, 43, y1+1, 'No possible actions')
				
				if selected_crewman == crewman and not no_highlight:
					
					# display total number of possible actions at top of column
					if crewman.current_action in crewman.action_list:
						text2 = str(crewman.action_list.index(crewman.current_action)+1) + '/' + str(len(crewman.action_list))
						libtcod.console_print(con, 51, 15, text2)
					
					libtcod.console_set_default_foreground(con, libtcod.white)
					libtcod.console_print(con, 64, 18, 'Action:')
					
					y1 = 19
					
					# description of action and current odds of success
					libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
					
					# modify for position-specific actions
					if text[:4] == 'Open':
						text = 'Open Hatch'
					elif text[:6] == 'Go to ':
						text = 'Go to Position'
					elif text[:4] == 'Move' and text[:7] != 'Move to':
						text = 'Move Crewman'
					elif text[:4] == 'Swap':
						text = 'Swap Positions'
					elif text[:6] == 'Rescue':
						text = 'Rescue Unconscious Crewman'
					
					if text in BAILOUT_ACTION_DESC:
						lines = wrap(BAILOUT_ACTION_DESC[text], 23)
						for line in lines:
							libtcod.console_print(con, 64, y1, line)
							y1+=1
					
					if text != 'None':
						# current modifiers to action
						libtcod.console_set_default_foreground(con, libtcod.white)
						libtcod.console_print(con, 64, 29, 'Active Modifiers:')
						libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
						if len(modifiers) == 0:
							libtcod.console_print(con, 64, 31, 'None')
						else:
							y1 = 31
							for (line, mod) in modifiers:
								libtcod.console_print(con, 64, y1, line)
								if mod > 0.0:
									text = '+' + str(mod)
								else:
									text = str(mod)
								libtcod.console_print_ex(con, 87, y1, libtcod.BKGND_NONE,
									libtcod.RIGHT, text + '%')
								y1 += 1
						
						# chance of success
						if odds > 0.0:
							libtcod.console_set_default_foreground(con, libtcod.white)
							libtcod.console_print(con, 64, 41, 'Chance of Success:')
							libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
							libtcod.console_print(con, 65, 43, str(odds) + '%')
				
				y += 6
				if y >= 54: break
			
			# display list of empty tank positions
			text = ''
			for position in self.player_unit.positions_list:
				if position.crewman is not None: continue
				if text != '': text += ', '
				text += position.name
			if text != '':
				libtcod.console_rect(con, 2, y-1, 60, 5, True, libtcod.BKGND_SET)
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 2, y, 'Empty Positions:')
				y1=y+1
				for line in wrap(text, 28):
					libtcod.console_print(con, 2, y1, line)
					y1+=1
					if y1 == 59: break
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 36, 54, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 36, 55, GAMEPADCHAR_DPAD_LR)
				DisplayButton(con, 36, 56, GAMEPADCHAR_BACK)
				DisplayButton(con, 36, 57, GAMEPADCHAR_X)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 32, 54, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 32, 55, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(con, 32, 56, 'End')
				libtcod.console_print(con, 32, 57, 'Space')
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print(con, 38, 54, 'Select Crewman')
			libtcod.console_print(con, 38, 55, 'Select Action')
			libtcod.console_print(con, 38, 56, 'End Bailout')
			libtcod.console_print(con, 38, 57, 'Proceed')
			
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			
		
		# set up initial round, max rounds
		current_round = 1
		max_rounds = 10
		
		# record each crewman's current position to return them there after bail-out is complete
		crew_positions = {}
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			crew_positions[position.crewman] = position
		
		# calculate fire chance per round
		if abandoning_tank:
			fire_chance = 0.0
		elif self.player_unit.GetStat('wet_stowage') is None:
			fire_chance = 5.0
		else:
			fire_chance = 2.0
		if weapon is not None:
			if weapon.GetStat('name') == 'Molotovs':
				fire_chance += 10.0
			elif weapon.GetStat('name') == 'Flame Thrower':
				fire_chance += 20.0
		
		# check for flamethrower fuel on board
		for weapon2 in self.player_unit.weapon_list:
			if weapon2.GetStat('type') != 'Flame Thrower': continue
			if weapon2.external_fuel: continue
			if weapon2.flame_ammo > 0:
				fire_chance += 25.0
		
		# flags: tank is on fire, smoke
		on_fire = False
		smoke = False
		
		# create a separate list of crew
		# include dead crewman still in their position
		player_crew = []
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			player_crew.append(position.crewman)
		
		# create two new Positions: tank exterior and safe location
		tank_exterior_position = Position(self.player_unit, {'name' : None,
			'location' : 'Vehicle Exterior'})
		safe_location_position = Position(self.player_unit, {'name' : None,
			'location' : 'Safe Location'})
		
		# build list of squadmates
		nearby_allies = []
		for unit in self.units:
			if not unit.alive: continue
			if unit.owning_player != 0: continue
			if unit.is_player: continue
			if GetHexDistance(0, 0, unit.hx, unit.hy) > 1: continue
			nearby_allies.append(unit)
		
		# build list of enemies in LoS
		enemies_in_los = []
		for unit in self.units:
			if not unit.alive: continue
			if unit.owning_player == 0: continue
			if not self.player_unit.los_table[unit]: continue
			distance = GetHexDistance(0, 0, unit.hx, unit.hy)
			if distance > 3: continue
			if distance == 1:
				text = 'C'
			elif distance == 2:
				text = 'M'
			else:
				text = 'L'
			enemies_in_los.append((text, unit))
		
		# generate initial list of crew bailout actions
		for crewman in player_crew:
			BuildActionList(crewman)
		
		selected_crewman = None
		
		# start bailout music if enabled
		if config['ArmCom2'].getboolean('music'):
			session.MusicHandler('bailout', True)
		
		# draw initial menu screen
		UpdateBailOutConsole(no_highlight=True)
		
		# if tank was knocked out, do initial injury checks on crew, explosion test
		if not abandoning_tank:
			
			if force_explosion:
				PlaySoundFor(self.player_unit, 'vehicle_explosion')
				ShowSimpleMessage('The explosion rips through your vehicle, destroying it from the inside out.')
				player_explosion = True
				smoke = True
				on_fire = True
			
			else:
				ShowSimpleMessage('Resolving effect of knock-out hit.')
				
				# roll for player tank explosion
				player_explosion = False
				if self.player_unit.DoExplosionRoll(location, weapon):
					PlaySoundFor(self.player_unit, 'vehicle_explosion')
					ShowSimpleMessage('The impact ignites an explosion in your vehicle, destroying it from the inside out.')
					player_explosion = True
					smoke = True
					on_fire = True
			
			crew_effect = False
			for crewman in player_crew:
				if not crewman.alive: continue
				result = crewman.ResolveAttack({'ko_hit':True, 'location':location,
					'weapon':weapon}, explosion=player_explosion,
					show_messages=False)
				
				# display result if any
				if result is not None:
					selected_crewman = crewman
					UpdateBailOutConsole()
					DisplayResult(crewman, 'Affected by KO Hit: ' + result, False)
					crew_effect = True
			if not crew_effect:
				ShowSimpleMessage('No effect on your crew.')
		
		# if all crew are now dead, skip bailout procedure
		all_dead = True
		for crewman in player_crew:
			if crewman.alive:
				all_dead = False
				break
		if all_dead:
			if player_explosion:
				session.ModifySteamStat('ko_all_kia', 1)
			ShowSimpleMessage('All your crew are dead.')
			session.MusicHandler('bailout', False)
			return
		
		# check for Player Commander death
		for crewman in player_crew:
			if not crewman.is_player_commander: continue
			if not crewman.alive:
				ShowSimpleMessage('You are dead.')
				session.MusicHandler('bailout', False)
				return
			break
		
		# do initial smoke roll
		if not abandoning_tank and not smoke:
			roll = GetPercentileRoll()
			if roll <= 25.0:
				smoke = True
				PlaySoundFor(None, 'smoke')
				ShowSimpleMessage('Your vehicle fills with smoke.')
		
		# generate final list of crew bailout actions
		for crewman in player_crew:
			BuildActionList(crewman)
		
		# select first crewman by default, final update of screen with selected crewman highlighted
		selected_crewman = player_crew[0]
		UpdateBailOutConsole()
		
		ShowSimpleMessage('Round ' + str(current_round) + '/' + str(max_rounds))
		
		exit_menu = False
		while not exit_menu:
			
			# quick exit for debugging
			if DEBUG:
				if key.vk == sdl2.SDLK_F11: sys.exit()
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# debug menu
			if key.vk == sdl2.SDLK_F10:
				if not DEBUG: continue
				ShowDebugMenu()
				continue
			
			# proceed to next round, or finish bail-out procedure
			elif key.vk in [sdl2.SDLK_SPACE, sdl2.SDLK_END] or session.gamepad_input in [2, 4]:
				
				if (key.vk == sdl2.SDLK_END or session.gamepad_input == 4) and current_round < max_rounds:
					if ShowNotification('End bailout after this round?', confirm=True):
						current_round = max_rounds
					else:
						UpdateBailOutConsole()
						continue
				
				# do crewmen actions
				for crewman in player_crew:
					selected_crewman = crewman
					UpdateBailOutConsole()
					DoBailoutAction(crewman)
				
				# update all crew ce statuses to reflect changes from action phase
				for crewman in player_crew:
					crewman.SetCEStatus()
				
				# if tank is on fire, check for explosion, then crewmen injuries
				if on_fire:
					
					if self.player_unit.DoExplosionRoll(None, None, fire=True):
						PlaySoundFor(self.player_unit, 'vehicle_explosion')
						ShowSimpleMessage('The fire ignites an explosion in your vehicle, destroying it from the inside out.')
						smoke = True
						
						crew_effect = False
						for crewman in player_crew:
							if not crewman.alive: continue
							if crewman.current_position.location == 'Safe Location':
								continue
							
							result = crewman.ResolveAttack({}, explosion=True, show_messages=False)
							
							# display result if any
							if result is not None:
								selected_crewman = crewman
								UpdateBailOutConsole()
								DisplayResult(crewman, 'Affected by explosion: ' + result, False)
								crew_effect = True
						if not crew_effect:
							ShowSimpleMessage('No effect on your crew.')
					
					ShowSimpleMessage('The fire in your tank continues to burn.')
					
					for crewman in player_crew:
						if crewman.current_position.location in ['Vehicle Exterior', 'Safe Location']:
							continue
						result = crewman.ResolveAttack({'burn_up' : True}, show_messages=False)
						
						# display result if any
						if result is not None:
							
							# check for Steam achivement
							if crewman.is_player_commander and not crewman.alive:
								session.ModifySteamStat('burn_kia', 1)
							
							selected_crewman = crewman
							UpdateBailOutConsole()
							DisplayResult(crewman, 'Affected by Fire: ' + result, False)
						
						# surviving unconscious crewmen wake up
						if crewman.alive and crewman.condition == 'Unconscious':
							crewman.condition = 'Stunned'
							if crewman.current_position.name in COMMANDER_POSITIONS:
								ShowSimpleMessage('You are awakened by the heat from the fire')
							else:
								ShowSimpleMessage('Your crewman is awakened by the heat from the fire:', crewman=crewman)
						
						BuildActionList(crewman)
						UpdateBailOutConsole(no_highlight=True)
				
				# otherwise, do fire roll
				else:
					roll = GetPercentileRoll()
					
					# check for crew skill effects
					for crewman in player_crew:
						if not crewman.alive: continue
						if crewman.current_position.location in ['Vehicle Exterior', 'Safe Location']:
							continue
						if crewman.condition == 'Unconscious': continue
						if 'Fire Fighter' in crewman.skills:
							roll += 1.0
					
					if roll <= fire_chance:
						on_fire = True
						PlaySound('flamethrower')
						UpdateBailOutConsole(no_highlight=True)
						ShowSimpleMessage('Your vehicle has caught on fire.')
				
				# do smoke roll
				if not abandoning_tank and not smoke:
					roll = GetPercentileRoll()
					if on_fire: roll -= 50.0
					if roll <= 5.0:
						smoke = True
						PlaySoundFor(None, 'smoke')
						ShowSimpleMessage('Your vehicle fills with smoke.')
				
				# check for enemies in LoS attacking player
				incoming_fp = 0
				for (distance, unit) in enemies_in_los:
					chance = 10.0
					
					# suppression by nearby allies
					if len(nearby_allies) >= 2:
						chance -= 3.0
					elif len(nearby_allies) == 1:
						chance -= 1.5
					
					# suppression by crewmen - close range only
					if distance == 'C':
						for crewman in player_crew:
							if crewman.current_action[0] == 'Covering Fire':
								if 'Spray and Pray' in crewman.skills:
									chance -= 8.0
								elif 'Gunslinger' in crewman.skills:
									chance -= 4.0
								else:
									chance -= 2.0
					
					# exterior smoke
					if self.player_unit.smoke > 0:
						chance -= (2.0 * self.player_unit.smoke)
					
					if chance < 1.0: chance = 1.0
					roll = GetPercentileRoll()
					
					if roll > chance: continue
					
					if distance == 'C':
						incoming_fp += 4
					elif distance == 'M':
						incoming_fp += 2
					else:
						incoming_fp += 1
					
				# apply any incoming firepower to exposed crewmen and crewmen on tank exterior
				if incoming_fp > 0:
					
					# play attacking sounds
					for i in range(4):
						if libtcod.random_get_int(0, 1, 5) == 1:
							PlaySound('lmg_firing_med')
						else:
							PlaySound('rifle_fire')
					
					ShowSimpleMessage('Enemy units fire at your tank, resolving ' +
						str(incoming_fp) + ' firepower.')
					fp_result = False
					for crewman in player_crew:
						if not crewman.alive: continue
						if crewman.current_position.location == 'Safe Location':
							continue
						if crewman.current_position.location != 'Vehicle Exterior' and not crewman.ce:
							continue
						result = crewman.ResolveAttack({'firepower' : incoming_fp}, show_messages=False)
						# display result if any
						if result is not None:
							selected_crewman = crewman
							UpdateBailOutConsole()
							DisplayResult(crewman, 'Hit by Firepower: ' + result, False)
							fp_result = True
							
					if not fp_result:
						ShowSimpleMessage('No effect.')
				
				# check for all crew dead, player commander dead, or all crew in safe location
				pc_dead = False
				all_dead = True
				all_safe = True
				for crewman in player_crew:
					if crewman.alive:
						all_dead = False
						if crewman.current_position.location != 'Safe Location':
							all_safe = False
					else:
						if crewman.is_player_commander:
							pc_dead = True
				
				if pc_dead:
					ShowSimpleMessage('You are dead.')
					exit_menu = True
					continue
				if all_dead:
					ShowSimpleMessage('All your crewmen are dead.')
					exit_menu = True
					continue
				if all_safe:
					ShowSimpleMessage('All your surviving crew are safe.')
					exit_menu = True
					continue
				
				# end of final round 
				if current_round == max_rounds:
					
					# do final rescue checks
					for crewman in player_crew:
						
						kill_crewman = False
						
						if not crewman.alive: continue
						if crewman.current_position.location == 'Safe Location':
							continue
						if crewman.current_position.location == 'Vehicle Exterior':
							
							if crewman.condition == 'Unconscious':
								result_text = 'Taken'
							else:
								result_text = 'Escaped'
							result_text += ' to safe location'
						else:
							if on_fire and crewman.condition == 'Unconscious':
								kill_crewman = True
								result_text = 'Burns to death in the tank.'
							else:
								
								# do fate roll
								roll = GetPercentileRoll()
								if roll <= 20.0:
									kill_crewman = True
									result_text = 'Was trapped in the tank and killed.'
								else:
								
									if crewman.condition == 'Unconscious':
										result_text = 'Taken'
									else:
										result_text = 'Escaped'
									result_text += ' to safe location'
						
						selected_crewman = crewman
						
						if kill_crewman:
							crewman.KIA()
						
						UpdateBailOutConsole()
						
						# move crewman to safe location
						if crewman.alive:
							crewman.current_position.crewman = None
							crewman.current_position = safe_location_position
						
						DisplayResult(crewman, result_text, crewman.alive)
					
					exit_menu = True
					continue
				
				# update possible actions for next turn
				for crewman in player_crew:
					BuildActionList(crewman)
				
				current_round += 1
				selected_crewman = player_crew[0]
				UpdateBailOutConsole()
				ShowSimpleMessage('Round ' + str(current_round) + '/' + str(max_rounds))
				continue	
			
			# key commands
			key_char = DeKey(chr(key.c).lower())
			
			# change selected crewman
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				i = player_crew.index(selected_crewman)
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if i == 0:
						i = len(player_crew) - 1
					else:
						i -= 1
				else:
					if i == len(player_crew) - 1:
						i = 0
					else:
						i += 1
				selected_crewman = player_crew[i]
				PlaySoundFor(None, 'menu_select')
				UpdateBailOutConsole()
				continue
			
			# change selected action
			elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
				if len(selected_crewman.action_list) <= 1: continue
				i = selected_crewman.action_list.index(selected_crewman.current_action)
				if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
					if i == 0:
						i = len(selected_crewman.action_list) - 1
					else:
						i -= 1
				else:
					if i == len(selected_crewman.action_list) - 1:
						i = 0
					else:
						i += 1
				selected_crewman.current_action = selected_crewman.action_list[i]
				PlaySoundFor(None, 'menu_select')
				UpdateBailOutConsole()
				continue
		
		# end of bail-out, return crewmen to original positions
		for position in self.player_unit.positions_list:
			for crewman in player_crew:
				if crewman not in crew_positions: continue
				if crew_positions[crewman] != position: continue
				position.crewman = crewman
				crewman.current_position = position
	
		# stop music
		session.MusicHandler('bailout', False)


	##################################################################################
	
	
	# spawn enemy units on the scenario layer
	# if reinforcement is True, only spawn one unit and add them to the LoS tables
	# if unit_id is set, don't randomly roll and use that one
	def SpawnEnemyUnits(self, reinforcement=False, nation=None, unit_id=None, location=None):
		
		enemy_unit_list = []
		
		# spawning one particular unit
		if nation is not None and unit_id is not None:
			enemy_unit_list.append((nation, unit_id))
		
		# enemy reinforcements arrive
		elif reinforcement:
			unit_list = []
			for unit in self.units:
				if unit.owning_player == 0: continue
				unit_list.append((unit.nation, unit.unit_id))
			
			# check adjacent zones too
			for direction in range(6):
				(hx, hy) = campaign_day.GetAdjacentCDHex(self.cd_map_hex.hx, self.cd_map_hex.hy, direction)
				# make sure this adjacent zone is on map
				if (hx, hy) not in CAMPAIGN_DAY_HEXES: continue
				if len(campaign_day.map_hexes[(hx, hy)].enemy_units) > 0:
					unit_list += campaign_day.map_hexes[(hx, hy)].enemy_units
				
			if len(unit_list) == 0: return False
			enemy_unit_list.append(choice(unit_list))
		
		else:
		
			# player is being attacked in own zone, generate enemy units for this zone
			if self.cd_map_hex.controlled_by == 0 and len(self.cd_map_hex.enemy_units) == 0:
				self.cd_map_hex.GenerateStrengthAndUnits(campaign_day.mission, player_attacked=True)
			
			for (nation, unit_id) in self.cd_map_hex.enemy_units:
				enemy_unit_list.append((nation, unit_id))
		
		# spawn one unit per unit id in the list
		for (nation, unit_id) in enemy_unit_list:
	
			# determine spawn location
			distance = libtcod.random_get_int(0, 1, 3)
			
			if distance == 1:
				if GetPercentileRoll() <= 65.0:
					distance += 1
			if session.unit_types[unit_id]['category'] == 'Infantry':
				if GetPercentileRoll() <= 75.0:
					distance -= 1
			elif session.unit_types[unit_id]['category'] in ['Cavalry', 'Vehicle']:
				if GetPercentileRoll() <= 60.0:
					distance += 1
			
			# check for commander skill
			if self.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Honed Senses'):
				if GetPercentileRoll() <= 20.0:
					distance += 2
				elif GetPercentileRoll() <= 70.0:
					distance += 1
			elif self.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Keen Senses'):
				if GetPercentileRoll() <= 5.0:
					distance += 2
				elif GetPercentileRoll() <= 50.0:
					distance += 1
			elif self.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Unique Opportunities'):
				if GetPercentileRoll() <= 5.0:
					distance += 2
				elif GetPercentileRoll() <= 50.0:
					distance += 1	
			
			if distance < 1:
				distance = 1
			elif distance > 3:
				distance = 3
			
			# reinforcements must spawn at least 2 hexes away
			if reinforcement and distance == 1:
				distance = 3
			
			hex_list = GetHexRing(0, 0, distance)
			shuffle(hex_list)
			
			if location is not None:
				(hx, hy) = location
			
			else:
			
				# choose a random hex in which to spawn
				for (hx, hy) in hex_list:
					
					# make sure no units from opposing force already here
					if len(self.hex_dict[(hx,hy)].unit_stack) > 0:
						if self.hex_dict[(hx,hy)].unit_stack[0].owning_player == 0:
							continue
					
					# if player spotted enemy units first, unlikely that they will spawn behind the player
					if not self.ambush:
						if GetDirectionToward(hx, hy, 0, 0) in [5, 0, 1]:
							if GetPercentileRoll() <= 85.0: continue
					break
			
			# create the enemy unit
			unit = Unit(unit_id, owning_player=1)
			unit.nation = nation
			unit.ai = AI(unit)
			unit.ai.Reset()
			unit.GenerateNewPersonnel()
			unit.SpawnAt(hx, hy)
			unit.CheckForTractorSpawn()
			
			# if player is being attacked, enemy units start moving
			if not self.player_attacking:
				unit.moving = True
			elif reinforcement:
				unit.moving = True
			else:
				unit.DeploymentCheck()	
			
			self.enemy_units_spawned += 1
			
			# if current campaign region is north africa, german and italian vehicles are all unreliable before Oct. 1941
			if campaign.stats['region'] == 'North Africa' and unit.GetStat('origin_nation') in ['Germany', 'Italy']:
				if campaign.today < '1941.10.01' and unit.GetStat('category') == 'Vehicle':
					unit.stats['unreliable'] = True
			
			# check for special weapon presence in unit
			if unit.GetStat('class') == 'Infantry Squad':
				
				added_sw = False
				
				# check for PF
				if not added_sw and nation == 'Germany' and campaign.today >= '1943.07.01':
					chance = 3
					if campaign.today <= '1943.09.30':
						chance -= 1
					elif campaign.today >= '1945.01.01':
						chance += 1
					if libtcod.random_get_int(0, 1, 10) <= chance:
						unit.weapon_list.append(Weapon(unit, PF_WEAPON))
						added_sw = True
				
				# check for captured PF
				if not added_sw and nation == 'Soviet Union' and campaign.today >= '1943.09.30':
					chance = 1
					if campaign.today >= '1944.01.01':
						chance += 2
					elif campaign.today >= '1945.01.01':
						chance += 3
					if libtcod.random_get_int(0, 1, 10) <= chance:
						unit.weapon_list.append(Weapon(unit, PF_WEAPON))
						added_sw = True
				
				# check for MOL
				if not added_sw:
					if campaign.today < '1940.01.01':
						if nation == 'Japan':
							chance = 3
						else:
							chance = 0
					else:
						if nation in ['Soviet Union', 'Finland', 'United States of America']:
							chance = 3
						else:
							chance = 1
					if libtcod.random_get_int(0, 1, 10) <= chance:
						unit.weapon_list.append(Weapon(unit, MOL_WEAPON))
						added_sw = True
				
				# check for DC
				if not added_sw:
					chance = 2
					if campaign.stats['region'] == 'South Pacific' and nation == 'Japan':
						chance = 6
					if libtcod.random_get_int(0, 1, 10) <= chance:
						unit.weapon_list.append(Weapon(unit, DC_WEAPON))
			
			# check for LMG/MMG presence in unit
			if unit.unit_id in ['Riflemen', 'Paratrooper Squad']:
				if campaign.today < '1940.01.01':
					chance = 5.0
				elif campaign.today < '1941.01.01':
					chance = 10.0
				elif campaign.today < '1942.01.01':
					chance = 15.0
				elif campaign.today < '1943.01.01':
					chance = 20.0
				elif campaign.today < '1944.01.01':
					chance = 25.0
				elif campaign.today < '1945.01.01':
					chance = 30.0
				else:
					chance = 35.0
				if unit.nation in ['Germany', 'United States of America']:
					chance += 10.0
				elif unit.nation in ['United Kingdom', 'Canada']:
					chance += 5.0
				
				roll = GetPercentileRoll()
				if roll <= (chance * 0.5):
					unit.weapon_list.append(Weapon(unit, MMG_WEAPON))
				elif roll <= chance:
					unit.weapon_list.append(Weapon(unit, LMG_WEAPON))
			
			# check for Type 89 Mortar
			if unit.unit_id == 'Riflemen' and nation == 'Japan':
				roll = GetPercentileRoll()
				if roll <= 30.0:
					unit.weapon_list.append(Weapon(unit, TYPE_89_MORTAR_WEAPON))
			
			# set facing
			if unit.GetStat('category') not in ['Infantry', 'Cavalry']:
				
				# ambush or player attacked in own zone
				if self.ambush or self.cd_map_hex.controlled_by == 0:
					# set facing toward player
					direction = GetDirectionToward(unit.hx, unit.hy, 0, 0)
				else:
					# random facing
					direction = libtcod.random_get_int(0, 0, 5)
				unit.facing = direction
				unit.PivotTurretToFace(direction)
				
				for weapon in unit.weapon_list:
					weapon.UpdateCoveredHexes()
				
				# check for HD if any
				unit.CheckForHD(spawn=True)
			
			# some units can be spawned dug-in, entrenched, or fortified
			if unit.GetStat('category') in ['Infantry', 'Gun'] and self.cd_map_hex.controlled_by == unit.owning_player and not reinforcement:
				
				if campaign_day.mission in ['Battle', 'Major Battle', 'Counterattack']:
					chance1 = 3.0
					chance2 = 10.0
					chance3 = 20.0
				elif campaign_day.mission == 'Amphibious Assault':
					chance1 = 70.0
					chance2 = 80.0
					chance3 = 100.0
				else:
					chance1 = 1.0
					chance2 = 5.0
					chance3 = 10.0
				
				# possible modifiers
				if scenario.cd_map_hex.terrain_type in ['Fortress', 'Fortification']:
					chance1 += 15.0
					chance2 += 20.0
					chance3 += 25.0
				elif campaign_day.mission in ['Urban Assault', 'Urban Defense']:
					chance1 += 10.0
					chance2 += 15.0
					chance3 += 20.0
				elif 'enemy_fortifications' in campaign.current_week:
					chance1 += 20.0
					chance2 += 35.0
					chance3 += 60.0
				
				roll = GetPercentileRoll()
				
				# packed-up guns cannot
				if unit.GetStat('category') == 'Gun' and not unit.deployed:
					roll = 100.0
				
				if roll <= chance1:
					unit.fortified = True
				elif roll <= chance2:
					unit.entrenched = True
				elif roll <= chance3:	
					unit.dug_in = True
			
			# reinforcements need to be added to the LoS table
			if reinforcement:
				self.GenerateUnitLoS(unit)
			
			# special: some units are spawned with non-combat companion units
			if unit_id == 'Light Artillery Car':
				
				# spawn an armoured or unarmoured locomotive
				if GetPercentileRoll() <= 15.0:
					unit2_id = 'Locomotive'
				else:
					unit2_id = 'Armoured Locomotive'
				unit2 = Unit(unit2_id, owning_player=1)
				unit2.nation = unit.nation
				unit2.ai = AI(unit2)
				unit2.ai.Reset()
				unit2.GenerateNewPersonnel()
				unit2.SpawnAt(hx, hy)
				unit2.facing = GetDirectionToward(unit2.hx, unit2.hy, 0, 0)
				for weapon in unit2.weapon_list:
					weapon.UpdateCoveredHexes()
				if reinforcement:
					self.GenerateUnitLoS(unit2)
				
				# chance to spawn an infantry car too
				# spawn an armoured or unarmoured locomotive
				if GetPercentileRoll() <= 40.0:
					unit2 = Unit('Infantry Car', owning_player=1)
					unit2.nation = unit.nation
					unit2.ai = AI(unit2)
					unit2.ai.Reset()
					unit2.GenerateNewPersonnel()
					unit2.SpawnAt(hx, hy)
					unit2.facing = GetDirectionToward(unit2.hx, unit2.hy, 0, 0)
					unit2.transport = 'Riflemen'
					if reinforcement:
						self.GenerateUnitLoS(unit2)
			
			# set up transported unit if any
			if 'enemy_transported_units' not in campaign.stats: continue
				
			# chance of no transported unit being present if enemy
			if unit.owning_player == 1:
				if GetPercentileRoll() <= 50.0:
					continue
			
			# low chance if Convoy Attack objective
			if self.cd_map_hex.objective is not None:
				if self.cd_map_hex.objective['type'] == 'Convoy Attack':
					if GetPercentileRoll() <= 80.0:
						continue
			
			transport_dict = campaign.stats['enemy_transported_units']
			if unit.nation not in transport_dict: continue
			if unit_id not in transport_dict[unit.nation]: continue
			transport_list = list(transport_dict[unit.nation][unit_id].items())
			shuffle(transport_list)
			for k, value in transport_list:
				if libtcod.random_get_int(0, 1, 100) <= value:
					# also check historical rarity here
					if not campaign.DoRarityCheck(k, nation=unit.nation):
						continue
					unit.transport = k
					break
			
			if unit.transport is not None: continue
			
			# if otherwise unable to select a transported unit, select the first possible one
			for k, value in transport_list:
				if campaign.DoRarityCheck(k, nation=unit.nation, get_rarity=True):
					unit.transport = k
					break
		
		return True			
	
	
	# given a combination of an attacker, weapon, and target, see if this would be a
	# valid attack; if not, return a text description of why not
	# if ignore_facing is true, we don't check whether weapon is facing correct direction
	def CheckAttack(self, attacker, weapon, target, ignore_facing=False):
		
		# check that proper crew command has been set if player is attacking
		if attacker == self.player_unit:
			
			position_list = weapon.GetStat('fired_by')
			if position_list is None:
				return 'No positions to fire this weapon'
			
			if weapon.GetStat('type') == 'Gun':
				command_req = 'Operate Gun'
			elif weapon.GetStat('type') == 'AAMG':
				command_req = 'Operate AAMG'
			elif weapon.GetStat('type') in MG_WEAPONS:
				command_req = 'Operate MG'
			elif weapon.GetStat('type') == 'Flame Thrower':
				command_req = 'Operate Flame Thrower'
			else:
				return 'Unknown weapon type!'
				
			crewman_found = False
			aamg_bu = False
			rst_restricted = False
			already_acted = False
			
			# check each crew position and try to find a crewman on the correct command to operate this weapon
			for position in self.player_unit.positions_list:
				
				if position.name not in position_list: continue
				if position.crewman is None: continue
				if position.crewman.current_cmd != command_req: continue
				
				# check that position is in same location as weapon mount if any
				if weapon.GetStat('mount') is not None:
					if position.location != weapon.GetStat('mount'):
						continue
				
				# crewman already acted this turn
				if position.crewman.acted:
					already_acted = True
					continue
				
				# if AAMG, crewman must normally be CE to operate
				if weapon.GetStat('type') == 'AAMG':
					if not position.crewman.ce and weapon.GetStat('bu_ok') is None:
						aamg_bu = True
						continue
				
				# crewmen in RST turret must be BU to operate weapons, unless the vehicle is OT
				if 'rst_ce_na' in session.crew_commands[position.crewman.current_cmd] and self.player_unit.GetStat('open_topped') is None:
					if self.player_unit.GetStat('turret') is not None:
						if position.location == 'Turret' and position.crewman.ce and self.player_unit.GetStat('turret') == 'RST' and not position.open_top:
							rst_restricted = True
							continue
				
				crewman_found = True
				break
			
			if not crewman_found:
				if aamg_bu:
					return 'Crewman must be CE to operate this weapon'
				elif rst_restricted:
					return 'Crewman must be BU to operate this weapon'
				elif already_acted:
					return 'Crewman has already acted this turn'
				else:
					return 'No crewman operating this weapon'
		
		# check that weapon isn't broken, isn't jammed, and hasn't already fired
		if weapon.broken:
			return 'Weapon is broken!'
		if weapon.jammed:
			return 'Weapon is jammed!'
		if weapon.fired:
			return 'Weapon has already fired this turn'
		
		# flame ammo
		if weapon.GetStat('type') == 'Flame Thrower':
			if weapon.flame_ammo == 0:
				return 'No flame thrower fuel remaining'
		
		# check that we're not firing on a friendly unit
		if target.owning_player == attacker.owning_player:
			if not (weapon.GetStat('type') == 'Gun' and weapon.ammo_type == 'Smoke'):
				return 'Can only fire Smoke at friendly units'
		
		# close combat attacks
		if weapon.GetStat('type') == 'Close Combat':
			if not target.spotted:
				return 'Target location unknown'
			if attacker.pinned:
				return 'Cannot initiate Close Combat when Pinned'
		
		# not a ballistic attack and no LoS
		elif weapon.GetStat('ballistic_attack') is None:
			if not attacker.los_table[target]:
				return 'No Line of Sight to Target'
		
		# if we're not ignoring facing,
		# check that target is in covered hexes and range
		if not ignore_facing:
			if (target.hx, target.hy) not in weapon.covered_hexes:
				return "Target not in weapon's covered arc"
		
		# check that current ammo is available and this ammo would affect the target
		if weapon.GetStat('type') == 'Gun':
			
			if weapon.ammo_type is None:
				return 'No ammo loaded'
			
			# check that at least one shell of required ammo is available
			ammo_avail = False
			if weapon.using_rr:
				if weapon.ready_rack[weapon.ammo_type] > 0:
					ammo_avail = True
			if weapon.ammo_stores[weapon.ammo_type] > 0:
				ammo_avail = True
			if not ammo_avail:
				return 'No more ammo of this type in this location'
			
			# canister/shrapnel ammo only effective at close range
			if weapon.ammo_type in ['C', 'SH'] and GetHexDistance(attacker.hx, attacker.hy, target.hx, target.hy) > 1:
				return (weapon.ammo_type + ' only effective at close range')
			
			# some HEAT ammo has a limited range
			if weapon.ammo_type == 'HEAT':
				if attacker.GetStat('heat_max_range') is not None:
					distance = int(attacker.GetStat('heat_max_range'))
					if GetHexDistance(attacker.hx, attacker.hy, target.hx, target.hy) > distance:
						return 'This HEAT has limited range'
		
		# check firing group restrictions
		for weapon2 in attacker.weapon_list:
			if weapon2 == weapon: continue
			if not weapon2.fired: continue
			if weapon2.GetStat('firing_group') == weapon.GetStat('firing_group'):
				return 'A weapon on this mount has already fired'
		
		# check for hull-mounted weapons blocked by HD status
		if len(attacker.hull_down) > 0:
			mount = weapon.GetStat('mount')
			if mount is not None:
				if mount == 'Hull':
					if weapon.GetStat('type') != 'TMG' and 'hd_ok' not in weapon.stats:
						if len(attacker.hull_down) == 6 or attacker.facing == attacker.hull_down[0]:
							return 'Weapon blocked by HD status'
		
		# check for deployment if required
		if attacker.GetStat('category') == 'Gun' or attacker.GetStat('deploy_to_fire') is not None:
			if not attacker.deployed:
				return 'Must be deployed to fire'
		
		# attack can proceed
		return ''
	
	
	# generate a profile for a given attack
	# if pivot or turret_rotate are set to True, will override actual attacker status
	def CalcAttack(self, attacker, weapon, target, pivot=False, turret_rotate=False, attempt_immobilize=False):
				
		profile = {}
		profile['attacker'] = attacker
		profile['weapon'] = weapon
		profile['ammo_type'] = weapon.ammo_type
		profile['target'] = target
		profile['modifier'] = ''	# placeholder for any final modifiers to attack result
		profile['result'] = ''		# placeholder for text rescription of result
		profile['immobilize'] = False
		
		# determine attack type
		weapon_type = weapon.GetStat('type')
		if weapon_type == 'Gun':
			profile['type'] = 'Point Fire'
		elif weapon_type == 'Small Arms' or weapon_type in MG_WEAPONS:
			profile['type'] = 'Area Fire'
			profile['effective_fp'] = 0		# placeholder for effective fp
		elif weapon_type == 'Close Combat':
			profile['type'] = 'Close Combat'
		elif weapon_type == 'Flame Thrower':
			profile['type'] = 'Flame Thrower'
			profile['effective_fp'] = 0
		else:
			print('ERROR: Weapon type not recognized: ' + weapon.stats['name'])
			return None
		
		# determine if ballistic attack/rocket
		profile['ballistic_attack'] = False
		profile['rocket'] = False
		if weapon.GetStat('ballistic_attack') is not None:
			profile['ballistic_attack'] = True
			if weapon.GetStat('rocket_launcher') is not None:
				profile['rocket'] = True
		
		# for player unit only:
		# determine crewman operating weapon:
		# need to find a match between positions that can fire the weapon,
		# and who is on the correct command
		profile['crewman'] = None
		if attacker.is_player:
			profile['crewman'] = weapon.GetOperatingCrewman()
			if profile['crewman'] is None: return None
		
		# calculate distance to target
		distance = GetHexDistance(attacker.hx, attacker.hy, target.hx, target.hy)
		profile['distance'] = distance
		
		# list of modifiers
		# [maximum displayable modifier description length is two lines of 17 and 16 characters]
		
		modifier_list = []
		
		# base critical hit chance
		profile['critical_hit'] = CRITICAL_HIT
		
		# immobilize attempt can't get critical hits
		if attempt_immobilize:
			profile['critical_hit'] = 0.0
		
		# Ballistic attacks much less likely to get a direct hit
		elif profile['ballistic_attack']:
			if profile['rocket']:
				profile['critical_hit'] = round(CRITICAL_HIT * 0.25, 1)
			else:
				profile['critical_hit'] = round(CRITICAL_HIT * 0.5, 1)
		
		# set flags for overrun attack or defensive fire attack
		profile['overrun'] = False
		profile['defensive_fire'] = False
		if attacker.overrun and target.spotted and target.hx == 0 and target.hy == -1:
			profile['overrun'] = True
		elif target.overrun and attacker.hx == 0 and attacker.hy == -1:
			profile['defensive_fire'] = True
		
		# point fire attacks (eg. guns)
		if profile['type'] == 'Point Fire':
			
			# calculate critical hit chance modifier
			if profile['crewman'] is not None:
				if weapon_type == 'Gun' and target.GetStat('armour') is not None:
					modifier = profile['crewman'].GetSkillMod('The Penetrator', 4.0)
					if modifier is not None:
						profile['critical_hit'] += modifier
					else:
						modifier = profile['crewman'].GetSkillMod('Knows Weak Spots', 2.0)
						if modifier is not None:
							profile['critical_hit'] += modifier
			
			# calculate base success chance
			
			# possible to fire HE at concealed targets
			if not target.spotted:
				# use infantry chance as base chance
				profile['base_chance'] = PF_BASE_CHANCE[distance][1]
			else:
				if target.GetStat('category') == 'Vehicle':
					profile['base_chance'] = PF_BASE_CHANCE[distance][0]
				else:
					profile['base_chance'] = PF_BASE_CHANCE[distance][1]
			
			# HE ammo has a higher base chance of hitting
			if profile['ammo_type'] == 'HE':
				profile['base_chance'] = round(profile['base_chance'] * 1.2, 1)
			
			# calculate modifiers and build list of descriptions
			
			# description max length is 19 chars
			
			# overrun attack or defensive fire
			if profile['overrun'] or profile['defensive_fire']:
				modifier_list.append(('Point Blank Range', 25.0))
			
			# attacker is moving
			if attacker.moving:
				
				mod = -50.0
				
				# check for gun gyro
				if attacker.is_player and 'gyro' in attacker.stats and weapon.GetStat('type') == 'Gun':
					if 'Advanced Gyro Use' in profile['crewman'].skills:
						mod = -20.0
					elif 'Basic Gyro Use' in profile['crewman'].skills:
						mod = -35.0
				
				# check for shoulder stabilizer
				elif weapon.GetStat('shoulder_stabilizer') is not None:
					mod = -40.0
				
				if profile['overrun']:
					mod = round(mod * 0.5, 1)
				
				modifier_list.append(('Attacker Moving', mod))
			
			# attacker pivoted
			elif pivot or attacker.facing != attacker.previous_facing:
				if weapon.GetStat('type') != 'AAMG' and weapon.GetStat('front_only') is None and weapon.GetStat('rear_facing') is None:
					if weapon.GetStat('turntable') is not None:
						modifier_list.append(('Attacker Pivoted', -15.0))
					else:
						modifier_list.append(('Attacker Pivoted', -35.0))
			
			# player or player squad member attacker pivoted
			elif self.player_pivot != 0 and (attacker == scenario.player_unit or attacker in scenario.player_unit.squad):
				if weapon.GetStat('type') != 'AAMG' and weapon.GetStat('front_only') is None and weapon.GetStat('rear_facing') is None:
					modifier_list.append(('Attacker Pivoted', -35.0))

			# weapon has turret rotated
			elif weapon.GetStat('mount') == 'Turret':
				if turret_rotate or attacker.turret_facing != attacker.previous_turret_facing:
					
					if weapon.GetStat('type') != 'AAMG' and weapon.GetStat('front_only') is None and weapon.GetStat('rear_facing') is None:
					
						# calculate modifier - assume that vehicle has a turret
						if attacker.GetStat('turret') == 'FT':
							mod = -10.0
						elif attacker.GetStat('turret') == 'VST':
							mod = -40.0
						else:
							mod = -20.0
						modifier_list.append(('Turret Rotated', mod))
			
			# attacker pinned or reduced
			if attacker.pinned:
				modifier_list.append(('Attacker Pinned', -60.0))
			elif attacker.reduced:
				modifier_list.append(('Attacker Reduced', -40.0))
			
			# attacker is packed-up gun
			if attacker.GetStat('category') == 'Gun' and not attacker.deployed and attacker.GetStat('size_class') in ['Very Small', 'Small']:
				modifier_list.append(('Attacker Packed-up', -30.0))
			
			# precipitation/sandstorm effects
			if campaign_day.weather['Precipitation'] == 'Rain' and campaign_day.weather['Fog'] == 0:
				modifier_list.append(('Rain', -5.0 * float(distance)))
			elif campaign_day.weather['Precipitation'] == 'Snow':
				modifier_list.append(('Snow', -10.0 * float(distance)))
			elif campaign_day.weather['Precipitation'] == 'Heavy Rain':
				modifier_list.append(('Heavy Rain', -15.0 * float(distance)))
			elif campaign_day.weather['Precipitation'] == 'Blizzard':
				modifier_list.append(('Blizzard', -20.0 * float(distance)))
			elif campaign_day.weather['Precipitation'] == 'Sandstorm':
				modifier_list.append(('Sandstorm', -20.0 * float(distance)))
			
			# fog, smoke, or dust concealment - only apply the one that will have the most effect
			vision_mod_text = ''
			vision_mod = 0.0
			
			if not (profile['overrun'] or profile['defensive_fire']):
			
				if campaign_day.weather['Fog'] > 0:
					if 4 - distance <= campaign_day.weather['Fog']:
						mod = round(-25.0 * distance, 1)
						if mod < vision_mod:
							vision_mod_text = 'Fog'
							vision_mod = mod
				
				effective_smoke = float(attacker.smoke + target.smoke)
				if effective_smoke > 0.0:
					mod = round(-25.0 * effective_smoke, 1)
					if mod < vision_mod:
						vision_mod_text = 'Smoke'
						vision_mod = mod
				
				effective_dust = float(attacker.dust + target.dust)
				if effective_dust > 0.0:
					mod = round(-15.0 * effective_dust, 1)
					if mod < vision_mod:
						vision_mod_text = 'Dust'
						vision_mod = mod
			
			if vision_mod < 0.0:
				modifier_list.append((vision_mod_text, vision_mod))
			
			
			# special gun stats
			if weapon_type == 'Gun':
				
				# inferior gun
				if weapon.GetStat('inferior_gun') is not None:
					modifier_list.append(('Inferior Gun', -15.0))
			
				# muzzle-mounted HEAT round
				if profile['ammo_type'] == 'HEAT' and attacker.GetStat('heat_penalty') is not None:
					modifier_list.append(('Low-Velocity HEAT', -20.0))
			
			# ballistic attack with no LoS
			if profile['ballistic_attack'] and not attacker.los_table[target]:
				modifier_list.append(('No LoS', -20.0))
			
			# artillery gun firing over open sights
			elif attacker.GetStat('class') == 'Artillery Gun':
				
				if int(weapon.stats['calibre']) > 40:
					if distance == 1:
						modifier_list.append(('Firing over Open Sights', -5.0))
					elif distance == 2:
						modifier_list.append(('Firing over Open Sights', -10.0))
					elif distance == 3:
						modifier_list.append(('Firing over Open Sights', -15.0))
					elif distance >= 4:
						modifier_list.append(('Firing over Open Sights', -20.0))
			
			# concealed target
			if not target.spotted:
				modifier_list.append(('Unspotted Target', -40.0))
			
			# spotted target
			else:
				
				# check to see if weapon has acquired target
				if weapon.acquired_target is not None:
					(ac_target, level) = weapon.acquired_target
					if ac_target == target:
						text = 'Acquired Target'
						if level == 1:
							text = 'Dialed In'
						mod = AC_BONUS[distance][level]
						if weapon.GetStat('ballistic_attack') is not None:
							mod = round(mod * 1.5, 1)
						modifier_list.append((text, mod))
				
				# target is moving (doesn't apply to defensive / point blank fire)
				if target.moving and not profile['defensive_fire']:
					if attacker.GetStat('category') == 'Vehicle':
						# fixed mount guns have a higher penalty
						if weapon.GetStat('mount') == 'Hull':
							mod = -45.0
						else:
							mod = -30.0
					elif attacker.GetStat('category') == 'Gun':
						if attacker.GetStat('turntable') is not None:
							mod = -15.0
						else:
							mod = -30.0
					else:
						mod = -30.0
					
					# modify by movement speed of target
					movement_class = target.GetStat('movement_class') 
					if movement_class is not None:
						if movement_class in ['Infantry', 'Slow Tank', 'Slow Wheeled']:
							mod = round(mod * 0.8, 1)
						elif movement_class in ['Half-Tracked', 'Fast Tank', 'Fast Wheeled']:
							mod = round(mod * 1.2, 1)
					
					if mod != 0.0:
						modifier_list.append(('Target Moving', mod))
				
				# target size
				size_class = target.GetStat('size_class')
				if size_class is not None:
					if size_class != 'Normal':
						text = size_class + ' Target'
						mod = PF_SIZE_MOD[size_class]
						
						# at close range, size modifiers are less
						if profile['distance'] <= 1:
							mod = round(mod / 2, 1)
						modifier_list.append((text, mod))
				
				# target is not being overrun
				if not profile['defensive_fire']:
				
					# target terrain
					tem = target.GetTEM()
					if tem != 0.0:
						if profile['ballistic_attack']:
							tem = round((tem * 0.5), 1)
						modifier_list.append(('Target in ' + target.terrain, tem))
			
			# long / short-barreled gun
			long_range = weapon.GetStat('long_range')
			if long_range is not None:
				if long_range == 'S' and distance > 1:
					modifier_list.append(('Short Gun', -12.0))
				
				elif long_range == 'L' and distance > 1:
					modifier_list.append(('Long Gun', 12.0))
				
				elif long_range == 'LL':
					if distance == 2:
						modifier_list.append(('Very Long Gun', 12.0))
					elif distance >= 3:
						modifier_list.append(('Very Long Gun', 24.0))
			
			if weapon_type == 'Gun' and not profile['ballistic_attack']:
				
				# APCR/APDS ammo
				if profile['ammo_type'] in ['APCR', 'APDS']:
					
					if 2 <= distance <= 3:
						modifier_list.append((profile['ammo_type'], -12.0))
					elif 4 <= distance <= 5:
						modifier_list.append((profile['ammo_type'], -24.0))
					elif distance >= 6:
						modifier_list.append((profile['ammo_type'], -36.0))
					
				# smaller-calibre gun at longer range
				calibre_mod = 0
				
				if weapon.stats['name'] == 'AT Rifle':
					calibre = 20
				else:
					calibre = int(weapon.stats['calibre'])
				
				if calibre <= 40 and distance >= 2:
					calibre_mod -= 1	
				
				if calibre <= 57:
					if distance == 2:
						calibre_mod -= 1
					elif distance == 3:
						calibre_mod -= 2
					elif distance >= 4:
						calibre_mod -= 3
				if calibre_mod < 0:
					modifier_list.append(('Small Calibre', (8.0 * calibre_mod)))
				
				# Smoke/WP Ammo
				if profile['ammo_type'] in ['Smoke', 'WP']:
					modifier_list.append(('Area Effect', 40.0))
				
				# overrun attack
				if profile['overrun']:
					if scenario.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Dakka Dakka!'):
						modifier_list.append(('Dakka Dakka!', 10.0))
					elif scenario.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Primo Victoria!'):
						modifier_list.append(('Primo Victoria!', 5.0))
			
			if attempt_immobilize:
				
				mod = -50.0
				
				# change based on movement class of target
				movement_class = target.GetStat('movement_class') 
				if movement_class is not None:
					if movement_class in ['Slow Wheeled', 'Wheeled', 'Fast Wheeled']:
						mod = -25.0
					elif movement_class == 'Half-Tracked':
						mod = -35.0
				
				modifier_list.append(('Immobilization Attempt', mod))
				if profile['crewman'] is not None:
					if 'The Immobilizer' in profile['crewman'].skills:
						modifier_list.append(('The Immobilizer', 25.0))
				profile['immobilize'] = True
			
			# guns that can't maintain RoF need to have loader(s) active or else suffer a to-hit penalty,
			# due to the gun operator having to spend time loading the slow-firing gun themselves
			# player unit only
			if weapon_type == 'Gun' and weapon.GetStat('rof_na') is not None and attacker.is_player:
				if weapon.GetStat('reloaded_by') is None:
					modifier_list.append(('Slow Firing Gun', -5.0))
				else:
					loaders_required = 1
					if weapon.GetStat('two_loaders') is not None:
						loaders_required = 2
					loaders_acting = 0
					
					for position_name in weapon.GetStat('reloaded_by'):
						for position in attacker.positions_list:
							if position.crewman is None: continue
							if position.name != position_name: continue
							if position.crewman.current_cmd == 'Reload':
								loaders_acting += 1
					
					if loaders_required - loaders_acting >= 2:
						modifier_list.append(('Slow Reloading', -20.0))
					elif loaders_required - loaders_acting == 1:
						modifier_list.append(('Slow Reloading', -10.0))
			
		
		# area fire
		elif profile['type'] == 'Area Fire':
			
			# calculate base FP
			fp = int(weapon.GetStat('fp'))
			
			# point blank range multiplier
			if distance == 0:
				fp = fp * 2
			
			profile['base_fp'] = fp
			
			# calculate base effect chance
			if target.GetStat('category') == 'Vehicle':
				base_chance = VEH_FP_BASE_CHANCE
			else:
				base_chance = INF_FP_BASE_CHANCE
			for i in range(2, fp + 1):
				base_chance += FP_CHANCE_STEP * (FP_CHANCE_STEP_MOD ** (i-1)) 
			profile['base_chance'] = round(base_chance, 1)
			
			# store the rounded base chance so we can use it later for modifiers
			base_chance = profile['base_chance']
			
			# calculate modifiers
			
			# overrun attack
			if profile['overrun']:
				modifier_list.append(('Overrun Attack', round(base_chance * 0.5, 1)))
				if scenario.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Dakka Dakka!'):
					modifier_list.append(('Dakka Dakka!', 20.0))
				elif scenario.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Primo Victoria!'):
					modifier_list.append(('Primo Victoria!', 10.0))
			
			else:
				
				# attacker moving/pivoted/turret rotated
				
				all_around_weapon = False
				if weapon.GetStat('type') == 'AAMG' and weapon.GetStat('front_only') is None:
					all_around_weapon = True
			
				# attacker moving
				if attacker.moving:
					if attacker.GetStat('category') == 'Vehicle':
						mod = round(base_chance / 2.5, 1)
					else:
						mod = round(base_chance / 2.0, 1)
					modifier_list.append(('Attacker Moving', 0.0 - mod))
				
				# attacker pivoted
				elif attacker.facing != attacker.previous_facing and not all_around_weapon:
					
					mod = round(base_chance / 3.0, 1)
					modifier_list.append(('Attacker Pivoted', 0.0 - mod))
	
				# player attacker pivoted - required because player unit facing is not updated until end of player turn
				elif attacker == scenario.player_unit and self.player_pivot != 0 and not all_around_weapon:
					mod = round(base_chance / 3.0, 1)
					modifier_list.append(('Attacker Pivoted', 0.0 - mod))
	
				# weapon turret rotated
				elif weapon.GetStat('mount') == 'Turret' and not all_around_weapon:
					if attacker.turret_facing != attacker.previous_turret_facing:
						mod = round(base_chance / 4.0, 1)
						modifier_list.append(('Turret Rotated', 0.0 - mod))
				
				# precipitation effects, only at higher ranges
				if distance >= 3:
					if campaign_day.weather['Precipitation'] == 'Rain' and campaign_day.weather['Fog'] == 0:
						mod = round(base_chance / 4.0, 1)
						modifier_list.append(('Rain', 0.0 - mod))
					elif campaign_day.weather['Precipitation'] == 'Snow':
						mod = round(base_chance / 4.0, 1)
						modifier_list.append(('Snow', 0.0 - mod))
					elif campaign_day.weather['Precipitation'] == 'Heavy Rain':
						mod = round(base_chance / 3.0, 1)
						modifier_list.append(('Heavy Rain', 0.0 - mod))
					elif campaign_day.weather['Precipitation'] == 'Blizzard':
						mod = round(base_chance / 3.0, 1)
						modifier_list.append(('Blizzard', 0.0 - mod))
					elif campaign_day.weather['Precipitation'] == 'Sandstorm':
						mod = round(base_chance / 2.0, 1)
						modifier_list.append(('Sandstorm', 0.0 - mod))
			
			# defensive fire attack
			if profile['defensive_fire']:
				modifier_list.append(('Point Blank Range', round(base_chance * 0.5, 1)))
			
			# attacker pinned or reduced
			if attacker.pinned:
				mod = round(base_chance / 2.0, 1)
				modifier_list.append(('Attacker Pinned', 0.0 - mod))
			elif attacker.reduced:
				mod = round(base_chance / 3.0, 1)
				modifier_list.append(('Attacker Reduced', 0.0 - mod))
			
			# Sandstorm
			if campaign_day.weather['Precipitation'] == 'Sandstorm':
				modifier_list.append(('Sandstorm', -10.0 * float(distance)))
			
			# fog, smoke, or dust concealment - only apply the one that will have the most effect
			vision_mod_text = ''
			vision_mod = 0.0
			
			if campaign_day.weather['Fog'] > 0 and not (profile['overrun'] or profile['defensive_fire']):
				if 4 - distance <= campaign_day.weather['Fog']:
					mod = round(base_chance * campaign_day.weather['Fog'] * 0.2, 1)
					if mod > vision_mod:
						vision_mod_text = 'Fog'
						vision_mod = mod
			
			effective_smoke = float(attacker.smoke + target.smoke)
			if effective_smoke > 0.0:
				mod = round(base_chance * effective_smoke * 0.2, 1)
				if mod > vision_mod:
					vision_mod_text = 'Smoke'
					vision_mod = mod
			
			effective_dust = float(attacker.dust + target.dust)
			if effective_dust > 0.0:
				mod = round(base_chance * effective_dust * 0.1, 1)
				if mod > vision_mod:
					vision_mod_text = 'Dust'
					vision_mod = mod
			
			if vision_mod > 0.0:
				modifier_list.append((vision_mod_text, 0.0 - vision_mod))
			
			
			if not target.spotted:
				modifier_list.append(('Unspotted Target', -15.0))
			else:
				
				# check to see if weapon has acquired target
				if weapon.acquired_target is not None:
					(ac_target, level) = weapon.acquired_target
					if ac_target == target:
						mod = round(15.0 + (float(level) * 15.0), 1)
						if distance == 3:
							mod = round(mod * 1.15, 1)
						text = 'Acquired Target'
						if level == 1:
							text = 'Dialed In'
						modifier_list.append((text, mod))
				
				# target is moving and weapon has restricted traverse
				if weapon.GetStat('restricted_traverse') is not None and target.moving:
					modifier_list.append(('Restricted Traverse', -15.0))
				
				# target is infantry or cavalry
				elif target.GetStat('category') in ['Infantry', 'Cavalry']:
					# and moving
					if target.moving:
						mod = round(base_chance / 2.0, 1)
						modifier_list.append(('Moving Infantry/Cavalry', mod))
					
					# is stationary support weapon team
					elif target.GetStat('class') == 'Support Weapon Team':
						modifier_list.append(('Target is Small Team', -20.0))
				
				# moving deployed gun
				elif target.GetStat('category') == 'Gun' and target.deployed and target.moving:
					mod = round(base_chance / 3.0, 1)
					modifier_list.append(('Moving Deployed Gun', mod))
				
				# target size
				size_class = target.GetStat('size_class')
				if size_class is not None:
					if size_class != 'Normal':
						text = size_class + ' Target'
						mod = PF_SIZE_MOD[size_class]
						# at close range, size modifiers are less
						if profile['distance'] <= 1:
							mod = round(mod / 2, 1)
						modifier_list.append((text, mod))
				
				# gun shield
				if not profile['overrun'] and target.GetStat('gun_shield') is not None:
					if GetFacing(attacker, target) == 'Front':
						modifier_list.append(('Gun Shield', -20.0))
			
				# fortified, entrenched, dug-in, or TEM modifier
				tem_mod = (None, 0.0)
				
				if target.fortified:
					tem_mod = ('Target Fortified', -50.0)
				elif target.entrenched:
					if profile['overrun']:
						tem_mod = ('Target Entrenched', -20.0)
					else:
						tem_mod = ('Target Entrenched', -30.0)
				elif target.dug_in:
					if profile['overrun']:
						tem_mod = ('Target Dug-in', -5.0)
					else:
						tem_mod = ('Target Dug-in', -15.0)
				
				# apply target terrain modifier if better
				tem = target.GetTEM()
				if tem < tem_mod[1]:
					tem_mod = ('Target in ' + target.terrain, tem)
				
				if tem_mod[0] != None:
					modifier_list.append(tem_mod)
		
		# flame thrower
		elif profile['type'] == 'Flame Thrower':
			
			# calculate base FP
			fp = int(weapon.GetStat('fp'))
			
			# crewman skill modifier
			if profile['crewman'] is not None:
				if "Light 'Em Up" in profile['crewman'].skills:
					fp += 2
			
			# point blank range multiplier
			if distance == 0:
				fp = fp * 2
			
			profile['base_fp'] = fp
			
			if target.GetStat('category') == 'Vehicle':
				base_chance = 60.0
			else:
				base_chance = 80.0
			profile['base_chance'] = base_chance
			
			
			# calculate modifiers
			
			# overrun attack
			if profile['overrun']:
				modifier_list.append(('Overrun Attack', round(base_chance * 0.5, 1)))
				if scenario.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Primo Victoria!'):
					modifier_list.append(('Primo Victoria!', 10.0))
			
			else:
				
				skip_movement_mods = False
				if profile['crewman'] is not None:
					if 'Conflagration' in profile['crewman'].skills:
						skip_movement_mods = True
				
				if not skip_movement_mods:
					# attacker moving
					if attacker.moving:
						if attacker.GetStat('category') == 'Vehicle':
							mod = round(base_chance / 3.0, 1)
						else:
							mod = round(base_chance / 2.0, 1)
						modifier_list.append(('Attacker Moving', 0.0 - mod))
					
					# attacker pivoted
					elif attacker.facing != attacker.previous_facing:
						mod = round(base_chance / 3.0, 1)
						modifier_list.append(('Attacker Pivoted', 0.0 - mod))
		
					# player attacker pivoted
					elif attacker == scenario.player_unit and self.player_pivot != 0:
						mod = round(base_chance / 3.0, 1)
						modifier_list.append(('Attacker Pivoted', 0.0 - mod))
		
					# weapon turret rotated
					elif weapon.GetStat('mount') == 'Turret':
						if attacker.turret_facing != attacker.previous_turret_facing:
							mod = round(base_chance / 4.0, 1)
							modifier_list.append(('Turret Rotated', 0.0 - mod))
				
				if not target.spotted:
					modifier_list.append(('Unspotted Target', -30.0))
				else:
					
					# fortified, entrenched, dug-in, or TEM modifier
					tem_mod = (None, 0.0)
					
					if target.fortified:
						tem_mod = ('Target Fortified', -30.0)
					elif target.entrenched:
						if profile['overrun']:
							tem_mod = ('Target Entrenched', -10.0)
						else:
							tem_mod = ('Target Entrenched', -15.0)
					elif target.dug_in:
						if profile['overrun']:
							tem_mod = ('Target Dug-in', -2.5)
						else:
							tem_mod = ('Target Dug-in', -6.5)
					
					if tem_mod[0] != None:
						modifier_list.append(tem_mod)
		
		# close combat attacks (eg. grenades, demo charges, etc.)
		elif profile['type'] == 'Close Combat':
			
			# determine base success chance
			if target.GetStat('category') == 'Vehicle':
				profile['base_chance'] = CC_BASE_CHANCE[0]
			else:
				profile['base_chance'] = CC_BASE_CHANCE[1]
			
			# firing a LATW
			if weapon.stats['name'] in AT_CC_WEAPONS:
				if weapon.stats['name'] in ['Panzerfaust', 'Panzerfaust Klein']:
					profile['base_chance'] = 35.0
				elif weapon.stats['name'] in ['Bazooka', 'Panzerschreck']:
					profile['base_chance'] = 50.0
				elif weapon.stats['name'] == 'PIAT':
					profile['base_chance'] = 30.0
				else:
					profile['base_chance'] = PF_BASE_CHANCE[distance][1]
			
			# placing a demo charge
			if weapon.GetStat('name') == 'Demolition Charge':
				profile['base_chance'] = 50.0
			
			# calculate modifiers
			
			# attacker has been reduced
			if attacker.reduced:
				modifier_list.append(('Attacker Reduced', -20.0))
			
			# attacker is infantry in a Rattenkrieg mission
			if campaign_day.rattenkrieg and attacker.GetStat('category') == 'Infantry':
				modifier_list.append(('Urban Attack', 20.0))
			
			# this is a defensive fire attack against an attempted overrun
			elif profile['defensive_fire']:
				modifier_list.append(('Defensive Attack', -10.0))
			
			# smoke or dust in target location - LATW weapons treated differently
			if weapon.stats['name'] not in AT_CC_WEAPONS:
				if target.smoke >= 2:
					modifier_list.append(('Smoke', 25.0))
				elif target.dust >= 2:
					modifier_list.append(('Dust', 20.0))
				elif target.smoke == 1:
					modifier_list.append(('Smoke', 10.0))
				elif target.dust == 1:
					modifier_list.append(('Dust', 5.0))
			else:
				if target.smoke >= 2:
					modifier_list.append(('Smoke', -25.0))
				elif target.dust >= 2:
					modifier_list.append(('Dust', -20.0))
				elif target.smoke == 1:
					modifier_list.append(('Smoke', -10.0))
				elif target.dust == 1:
					modifier_list.append(('Dust', -5.0))
			
			# target is a moving vehicle or cavalry
			if target.moving and target.GetStat('category') in ['Vehicle', 'Cavalry']:
				modifier_list.append(('Moving Target', -60.0))
			
			# target size
			size_class = target.GetStat('size_class')
			if size_class is not None:
				if size_class != 'Normal':
					text = size_class + ' Target'
					mod = PF_SIZE_MOD[size_class]
					modifier_list.append((text, mod))
			
			# target terrain
			tem = target.GetTEM()
			if tem != 0.0:
				
				# for placed/thrown weapons, improves odds of getting close enough for a good attack
				if weapon.GetStat('name') in ['Demolition Charge', 'Molotovs', 'Grenades']:
					modifier_list.append((target.terrain, abs(tem)))
				else:
					modifier_list.append((target.terrain, tem))
			
			if target.fortified:
				modifier_list.append(('Target Fortified', -20.0))
		
		# check for Commander directing fire
		for position in COMMANDER_POSITIONS:
			crewman = attacker.GetPersonnelByPosition(position)
			if crewman is None: continue
			if crewman.current_cmd == 'Direct Fire':
				
				crewman_mod_list = []
				
				# fire direction modifier
				modifier = crewman.GetActionMod(10.0)
				if not crewman.ce: modifier = round(modifier * 0.4, 1)
				crewman_mod_list.append(('Commander Fire Direction', modifier))
				
				# check for possible skill modifiers
				modifier = crewman.GetSkillMod('Fire Spotter', 10.0)
				if modifier is not None:
					crewman_mod_list.append(('Fire Spotter', modifier))
				if weapon_type in MG_WEAPONS:
					modifier = crewman.GetSkillMod('MG Spotter', 15.0)
					if modifier is not None:
						crewman_mod_list.append(('MG Spotter', modifier))
				elif weapon_type == 'Gun':
					modifier = crewman.GetSkillMod('Gun Spotter', 15.0)
					if modifier is not None:
						crewman_mod_list.append(('Gun Spotter', modifier))
				
				# sort list and add only the best modifier
				crewman_mod_list.sort(key = lambda x: x[1], reverse=True)
				modifier_list.append(crewman_mod_list[0])
					
				break
		
		# check for firing crew skills
		if profile['crewman'] is not None:
			
			# check for operating crewman in untrained position
			# MGs are excluded from this penalty
			if profile['crewman'].UntrainedPosition() and weapon_type not in MG_WEAPONS:
				modifier_list.append(('Untrained Crewman', -50.0))
			
			else:
				
				# following skills can stack except for upgraded versions of skills
				if weapon_type == 'Gun':
					
					modifier = profile['crewman'].GetSkillMod('Expert Shot', 8.0)
					if modifier is not None:
						modifier_list.append(('Expert Shot', modifier))
					else:
						modifier = profile['crewman'].GetSkillMod('Crack Shot', 3.0)
						if modifier is not None:
							modifier_list.append(('Crack Shot', modifier))	
					
					if target.moving:
						modifier = profile['crewman'].GetSkillMod('Target Tracker', 7.0)
						if modifier is not None:
							modifier_list.append(('Target Tracker', modifier))
					
					if distance == 3:
						modifier = profile['crewman'].GetSkillMod('Sniper', 7.0)
						if modifier is not None:
							modifier_list.append(('Sniper', modifier))
					
					# skill for firing in precepitation
					if campaign_day.weather['Precipitation'] in ['Rain', 'Snow', 'Heavy Rain', 'Blizzard']:
						modifier = profile['crewman'].GetSkillMod('Target Focus', 8.0)
						if modifier is not None:
							for (text, mod) in modifier_list:
								if text in ['Rain', 'Snow', 'Heavy Rain', 'Blizzard']:
									break
							if modifier > abs(mod):
								modifier = abs(mod)
							modifier_list.append(('Target Focus', modifier))
				
				elif weapon_type in MG_WEAPONS:
					if attacker.moving and attacker.GetStat('category') == 'Vehicle':
						modifier = profile['crewman'].GetSkillMod('Steady Hands', round(profile['base_chance'] / 6.0, 1))
						if modifier is not None:
							modifier_list.append(('Steady Hands', modifier))
			
			# check for target specialist skills
			if target.spotted:
				if target.GetStat('category') in ['Infantry', 'Cavalry']:
					modifier = profile['crewman'].GetSkillMod('Infantry Specialist', 5.0)
					if modifier is not None:
						modifier_list.append(('Infantry Specialist', modifier))
				
				elif target.GetStat('category') == 'Gun':
					modifier = profile['crewman'].GetSkillMod('Gun Specialist', 5.0)
					if modifier is not None:
						modifier_list.append(('Gun Specialist', modifier))
				
				elif target.GetStat('category') == 'Vehicle':
					modifier = profile['crewman'].GetSkillMod('Vehicle Specialist', 5.0)
					if modifier is not None:
						modifier_list.append(('Vehicle Specialist', modifier))
			
			# check for injury modifiers
			for (k, v) in profile['crewman'].injury.items():
				if k not in ['Right Arm & Hand', 'Left Arm & Hand']: continue
				if v[1] is None: continue
				if v[1] == 'Light':
					modifier_list.append(('Arm/Hand Injury', -5.0))
				elif v[1] == 'Heavy':
					modifier_list.append(('Arm/Hand Injury', -15.0))
				else:
					modifier_list.append(('Arm/Hand Injury', -25.0))
		
		# operating crewman fatigue
		if profile['crewman'] is not None:
			if profile['crewman'].fatigue > 0:
				modifier_list.append(('Crewman Fatigue', 0.0 - float(profile['crewman'].fatigue)))
		
		# prune out zero modifiers
		for (text, mod) in reversed(modifier_list):
			if mod == 0.0:
				modifier_list.remove((text, mod))
		
		# save the list of modifiers
		profile['modifier_list'] = modifier_list[:]
		
		# calculate total modifier
		total_modifier = 0.0
		for (desc, mod) in modifier_list:
			total_modifier += mod
		
		# calculate final chance of success
		# can range from 0.5 to 99.5
		profile['final_chance'] = RestrictChanceNew(profile['base_chance'] + total_modifier)
		
		# HD save modifier is added last, and scales to final to-hit/to-effect chance
		hd_save_chance = scenario.GetHullDownSaveChance(profile)
		if hd_save_chance > 0.0:
			mod = round(profile['final_chance'] * (hd_save_chance/100), 1)
			profile['modifier_list'].append(('Target HD', -mod))
			profile['final_chance'] = RestrictChanceNew(profile['final_chance'] - mod)
			profile['hd_mod'] = mod
		
		# calculate additional outcomes for Area Fire and Flame Thrower
		if profile['type'] in ['Area Fire', 'Flame Thrower']:
			profile['full_effect'] = RestrictChanceNew(profile['final_chance'] * FP_FULL_EFFECT)
			profile['critical_effect'] = RestrictChanceNew(profile['final_chance'] * FP_CRIT_EFFECT)
		
		# calculate full and partial effect odds for HE
		elif profile['ammo_type'] == 'HE':
			profile['full_effect'] = RestrictChanceNew(profile['final_chance'] * HE_PARTIAL_EFFECT)
			profile['critical_effect'] = profile['critical_hit']
		
		return profile
	
	
	# takes an attack profile and generates a profile for an armour penetration attempt
	# uses a slightly different system from to-hit
	def CalcAP(self, profile, air_attack=False):
		
		profile['type'] = 'ap'
		profile['modifier'] = ''			# clear any final modifier from the attack
		modifier_list = []
		
		# create local pointers for convenience
		attacker = profile['attacker']
		weapon = profile['weapon']
		target = profile['target']
		
		# flag for top armour hit (side armour value plus a modifier)
		top_armour = False
		if profile['ballistic_attack'] and profile['result'] == 'CRITICAL HIT':
			top_armour = True
		
		# check for good MOL/DC placement
		if weapon.stats['name'] == 'Demolition Charge':
			if libtcod.random_get_int(0, 1, 6) == 1:
				top_armour = True
		elif weapon.stats['name'] == 'Molotovs':
			if libtcod.random_get_int(0, 1, 4) == 1:
				top_armour = True
		
		# get location hit on target
		location = profile['location']
		
		# hull hit or target does not have rotatable turret
		if location == 'Hull' or target.turret_facing is None:
			turret_facing = False
		else:
			turret_facing = True
		
		if air_attack:
			facing = 'Side'
		
		# overrun attacks always hit side or rear armour
		elif profile['overrun']:
			facing = GetFacing(attacker, target, turret_facing=turret_facing)
			if facing == 'Front':
				facing = 'Side'
			else:
				facing = 'Rear'
		
		# contact close combat weapons use side armour
		elif weapon.stats['name'] in ['Demolition Charge', 'Flame Thrower', 'Molotovs'] and weapon.stats['type'] == 'Close Combat':
			facing = 'Side'
		
		# all others depend on facing toward attacker
		else:
			facing = GetFacing(attacker, target, turret_facing=turret_facing)
		
		# set rear facing flag if applicable
		rear_facing = False
		if facing == 'Rear':
			rear_facing = True
			facing = 'Side'
		
		hit_location = (location + '_' + facing).lower()
		
		# generate a text description of location hit
		if top_armour:
			profile['location_desc'] = 'Top'
		else:
			if location == 'Turret' and target.turret_facing is None:
				location = 'Upper Hull'
			profile['location_desc'] = location + ' '
			if rear_facing:
				profile['location_desc'] += 'Rear'
			else:
				profile['location_desc'] += facing
		
		# check for armour rating in hit location
		armour = target.GetStat('armour')
		unarmoured_location = True
		if armour is not None:
			if top_armour and target.GetStat('open_topped') is not None:
				unarmoured_location = True
			elif target.GetStat('open_rear_turret') is not None and profile['location_desc'] in ['Turret Rear', 'Upper Hull Rear']:
				unarmoured_location = True
			else:
				if armour[hit_location] != '-':
					unarmoured_location = False
		
		# look up base AP score required
		base_score = None
		
		if 'custom_ap' in weapon.stats:
			base_score = int(weapon.GetStat('custom_ap'))
		
		elif weapon.GetStat('type') in MG_WEAPONS:
			calibre = weapon.GetStat('calibre')
			if calibre is None:
				base_score = 4
			elif calibre in ['13', '14', '15']:
				base_score = 5
			else:
				base_score = 4
			
		elif weapon.GetStat('name') == 'Rifles':
			base_score = 2
			
		elif weapon.GetStat('name') == 'AT Rifle':
			if attacker.nation in ['Soviet Union', 'Finland', 'Japan']:
				base_score = 6
			else:
				base_score = 5
		
		# vehicle flame thrower
		elif weapon.GetStat('type') == 'Flame Thrower':
			base_score = 8
		
		elif weapon.GetStat('type') == 'Close Combat':
			
			name = weapon.GetStat('name')
			
			# SMGs have no chance to penetrate armour
			if name == 'Submachine Guns':
				profile['base_chance'] = 0
				profile['modifier_list'] = []
				profile['final_score'] = 0
				profile['final_chance'] = 0.0
				return profile
			
			# HEAT close combat weapons
			if name in AT_CC_WEAPONS:
				
				if unarmoured_location:
					base_score = 11
				else:
					if name == 'Bazooka':
						if campaign.today < '1944.01.01':
							base_score = 10
						else:
							base_score = 13
					elif name == 'PIAT':
						base_score = 15
					elif name == 'Panzerfaust Klein':
						base_score = 22
					elif name == 'Panzerschreck':
						base_score = 26
					elif name == 'Panzerfaust':
						base_score = 31
			
			# HE / Flame close combat weapons
			else:
				if name == 'Grenades':
					if unarmoured_location:
						base_score = 4
					else:
						base_score = 2
				if name == 'Demolition Charge':
					if unarmoured_location:
						base_score = 8
					else:
						base_score = 10
				elif name == 'Flame Thrower':
					if unarmoured_location:
						base_score = 8
					else:
						base_score = 6
				elif name == 'Molotovs':
					if unarmoured_location:
						base_score = 6
					else:
						base_score = 4

		else:
			calibre = weapon.GetStat('calibre')
			
			# C/SH ammo
			if profile['ammo_type'] in ['C', 'SH']:
				base_score = 0
			
			# AP ammo
			elif profile['ammo_type'] == 'AP':
				
				# unarmoured location
				if unarmoured_location:
					calibre = int(calibre)
					if calibre <= 28:
						base_score = 7
					elif calibre <= 57:
						base_score = 8
					elif calibre <= 77:
						base_score = 9
					elif calibre <= 95:
						base_score = 10
					else:
						base_score = 11
				
				# armoured location
				else:
					origin_nation = None
					if 'origin_nation' in weapon.unit.stats:
						origin_nation = weapon.unit.stats['origin_nation']
					
					if weapon.GetStat('long_range') is not None:
						calibre += weapon.GetStat('long_range')
					
					# modded weapons
					if 'custom_ammo_ap' in weapon.stats:
						if 'AP' in weapon.stats['custom_ammo_ap']:
							base_score = int(weapon.stats['custom_ammo_ap']['AP'])
					
					# special cases first
					if base_score is None and calibre == '75' and ('Lee' in weapon.unit.unit_id or 'Grant' in weapon.unit.unit_id or 'M3S' in weapon.unit.unit_id):
						base_score = 13
					
					if base_score is None and origin_nation is not None:
						if calibre == '75S' and origin_nation == 'Empire of Japan':
							base_score = 12
						elif calibre == '76L' and origin_nation == 'Soviet Union':
							base_score = 13
						elif calibre == '76LL' and origin_nation == 'Soviet Union':
							base_score = 16
						elif calibre == '90L' and origin_nation == 'Italy':
							base_score = 20
						
					# all other cases
					if base_score is None:
						if weapon.GetStat('name') == 'AT Rifle':
							base_score = 5
						elif calibre in ['15', '20']:
							base_score = 5
						elif calibre in ['20L']:
							base_score = 6
						elif calibre in ['20LL', '25LL', '37S', '30']:
							base_score = 7
						elif calibre in ['37', '40', '47S', '57S', '70S']:
							base_score = 8
						elif calibre in ['37L', '57', '65S', '76S']:
							base_score = 9
						elif calibre in ['40L', '45L', '47', '75S']:
							base_score = 10
						elif calibre in ['37LL', '45LL', '47L', '50']:
							base_score = 11
						elif calibre in ['76', '84S']:
							base_score = 12
						elif calibre in ['50L', '88', '120S']:
							base_score = 13
						elif calibre in ['75', '105']:
							base_score = 14
						elif calibre in ['57L', '57LL']:
							base_score = 15
						elif calibre in ['75L', '76L', '85L', '150S', '152S']:
							base_score = 17
						elif calibre in ['80L']:
							base_score = 18
						elif calibre in ['77L', '200L']:
							base_score = 19
						elif calibre in ['88L']:
							base_score = 20
						elif calibre in ['90L', '105L', '150', '152', '155']:
							base_score = 21
						elif calibre in ['75LL', '76LL']:
							base_score = 23
						elif calibre in ['122L']:
							base_score = 25
						elif calibre in ['88LL', '100L', '120L']:
							base_score = 27
						elif calibre in ['150L', '155L']:
							base_score = 28
						elif calibre in ['140L']:
							base_score = 32
						elif calibre in ['128L', '170L']:
							base_score = 33
			
			# APCR/APDS ammo
			elif profile['ammo_type'] in ['APCR', 'APDS']:
				
				# unarmoured location
				if unarmoured_location:
					calibre = int(calibre)
					if calibre <= 28:
						base_score = 7
					elif calibre <= 57:
						base_score = 8
					elif calibre <= 77:
						base_score = 9
					elif calibre <= 95:
						base_score = 10
					else:
						base_score = 11
				
				# armoured location
				else:
					
					if weapon.GetStat('long_range') is not None:
						calibre += weapon.GetStat('long_range')
					
					origin_nation = None
					if 'origin_nation' in weapon.unit.stats:
						origin_nation = weapon.unit.stats['origin_nation']
					
					if profile['ammo_type'] == 'APDS':
						
						# modded weapons
						if 'custom_ammo_ap' in weapon.stats:
							if 'APDS' in weapon.stats['custom_ammo_ap']:
								base_score = int(weapon.stats['custom_ammo_ap']['APDS'])
						
						if base_score is None:
							if calibre in ['57L', '57LL']:
								base_score = 18
							elif calibre == '77L':
								base_score = 19
							elif calibre == '76LL':	
								if origin_nation is None:
									base_score = 25
								else:
									if origin_nation == 'Soviet Union':
										base_score = 18
									else:
										base_score = 25
					else:
						
						# modded weapons
						if 'custom_ammo_ap' in weapon.stats:
							if 'APCR' in weapon.stats['custom_ammo_ap']:
								base_score = int(weapon.stats['custom_ammo_ap']['APCR'])
						
						if base_score is None:
							if calibre == '37L':
								base_score = 10
							elif calibre in ['28LL', '45L']:
								base_score = 12
							elif calibre in ['45LL', '47L']:
								base_score = 13
							elif calibre in ['40LL', '50']:
								base_score = 14
							elif calibre == '76L':	
								if origin_nation is None:
									base_score = 20
								else:
									if origin_nation == 'Soviet Union':
										base_score = 14
									elif origin_nation == 'United States of America':
										base_score = 22
									else:
										base_score = 20
							elif calibre == '50L':
								base_score = 17
							elif calibre == '57LL':
								base_score = 18
							elif calibre in ['75', '85L']:
								base_score = 19
							elif calibre == '75L':
								base_score = 20
							elif calibre == '88L':
								base_score = 23
							elif calibre == '90L':
								base_score = 27
			
			# HEAT ammo
			elif profile['ammo_type'] == 'HEAT':
				
				# unarmoured location
				if unarmoured_location:
					base_score = 11
				
				# armoured location
				else:
					
					# modded weapons
					if 'custom_ammo_ap' in weapon.stats:
						if 'HEAT' in weapon.stats['custom_ammo_ap']:
							base_score = int(weapon.stats['custom_ammo_ap']['HEAT'])
					
					if base_score is None:
						if calibre in ['57', '65', '94']:
							base_score = 11
						elif calibre == '70':
							base_score = 12
						elif calibre in ['75', '76', '88']:
							base_score = 13
						elif calibre == '100':
							base_score = 14
						elif calibre in ['105', '114']:
							base_score = 15
						elif calibre == '95':
							base_score = 16
						elif calibre == '122':
							base_score = 17
						elif calibre == '150':
							base_score = 21
						elif calibre in ['37', '47']:
							base_score = 26
						elif calibre == '380':		# Sturmtiger launcher
							base_score = 30
			
			# HE hit
			elif profile['ammo_type'] == 'HE':
				
				calibre = int(calibre)
				
				if unarmoured_location:
					if calibre <= 20:
						base_score = 6
					elif calibre <= 30:
						base_score = 8
					elif calibre <= 40:
						base_score = 9
					elif calibre <= 50:
						base_score = 10
					elif calibre <= 70:
						base_score = 12
					elif calibre <= 80:
						base_score = 14
					elif calibre <= 100:
						base_score = 16
					elif calibre <= 120:
						base_score = 18
					else:
						base_score = 20
				
				# armoured location
				else:
					
					if calibre <= 20:
						base_score = 3
					elif calibre <= 30:
						base_score = 4
					elif calibre <= 40:
						base_score = 5
					elif calibre <= 50:
						base_score = 6
					elif calibre <= 70:
						base_score = 7
					elif calibre <= 80:
						base_score = 8
					elif calibre <= 100:
						base_score = 10
					elif calibre <= 120:
						base_score = 12
					else:
						base_score = 16
		
		if base_score is None:
			print('ERROR: not able to find base AP score for: ' + weapon.GetStat('name'))
			base_score = 2
		
		profile['base_chance'] = base_score
		
		if not top_armour and base_score > 0:
		
			# rear facing and critical hit modifiers
			if rear_facing:
				modifier_list.append(('Rear Facing', 1))
			
			if profile['result'] == 'CRITICAL HIT':
				
				# MG critical hits do not apply as large a modifier
				if weapon.GetStat('type') in MG_WEAPONS:
					critical_modifier = int(ceil(base_score / 2))
				else:
					critical_modifier = base_score
				modifier_list.append(('Critical Hit', critical_modifier))
			
			# range/calibre modifier
			distance = GetHexDistance(attacker.hx, attacker.hy, target.hx, target.hy)
			if weapon.GetStat('name') == 'AT Rifle':
				if distance <= 1:
					modifier_list.append(('Close Range', 2))
				else:
					modifier_list.append(('Long Range', -2))
			
			elif profile['ammo_type'] == 'AP' and weapon.GetStat('calibre') is not None and not unarmoured_location:
				calibre = int(weapon.GetStat('calibre'))
				if calibre <= 25:
					if distance <= 1:
						modifier_list.append(('Close Range', 1))
					elif distance <= 3:
						modifier_list.append(('Long Range', -1))
					else:
						modifier_list.append(('Very Long Range', -2))
				else:
					if distance <= 1:
						modifier_list.append(('Close Range', 1))
					elif distance >= 4:
						modifier_list.append(('Very Long Range', -1))
			
			elif profile['ammo_type'] == 'APCR' and weapon.GetStat('calibre') is not None and not unarmoured_location:
				
				calibre = int(weapon.GetStat('calibre'))
				
				if calibre <= 57:
					if distance <= 1:
						modifier_list.append(('Close Range', 2))
					elif 3 <= distance <= 4:
						modifier_list.append(('Long Range', -2))
					elif distance >= 5:
						modifier_list.append(('Very Long Range', -4))
				else:
					if distance <= 1:
						modifier_list.append(('Close Range', 2))
					elif 3 <= distance <= 4:
						modifier_list.append(('Long Range', -1))
					elif distance >= 5:
						modifier_list.append(('Very Long Range', -3))
			
			elif profile['ammo_type'] == 'APDS' and not unarmoured_location:
			
				if distance <= 1:
					modifier_list.append(('Close Range', 1))
		
		# armoured location modifier; armour NA if flame attack
		if not unarmoured_location and weapon.GetStat('name') not in ['Flame Thrower', 'Molotovs']:
			if top_armour:
				target_armour = int(ceil(float(armour['hull_side']) * 0.5))
			else:
				target_armour = int(armour[hit_location])
			if target_armour > 0:
				modifier_list.append(('Armour', 0 - target_armour))
					
		# save the list of modifiers
		profile['modifier_list'] = modifier_list[:]
		
		# calculate total modifer
		total_modifier = 0
		for (desc, mod) in modifier_list:
			total_modifier += mod
		
		# calculate final chance of success
		# possible to be impossible or for penetration to be automatic
		final_score = base_score + total_modifier
		
		profile['final_score'] = final_score
		
		if final_score < 2:
			profile['final_chance'] = 0.0
		elif final_score >= 12:
			profile['final_chance'] = 100.0
		else:
			profile['final_chance'] = Get2D6Odds(final_score)
		
		return profile
	

	# Returns the chance of an attack being blocked from a target's HD status. Factors in the odds of hitting
	# the hull or turret
	def GetHullDownSaveChance(self, profile):
		
		if len(profile['target'].hull_down) == 0:
			return 0.0
		
		# Can't go HD against an attack from above and Smoke/WP aren't affected by HD.
		if profile['type'] not in ['Area Fire', 'Point Fire'] or profile['ballistic_attack'] or profile['ammo_type'] in ['Smoke', 'WP']:
			return 0.0
		
		# Emplacements are HD all around and can't be flanked.
		if len(profile['target'].hull_down) == 6:
			return 95.0

		direction = GetDirectionToward(profile['target'].hx, profile['target'].hy, profile['attacker'].hx, profile['attacker'].hy)
		if direction not in profile['target'].hull_down:
			return 0.0
	
		if profile['target'].hull_down[0] == direction:
			chance = 95.0
		else:
			chance = 80.0
		
		# factor in chance of hitting hull/turret
		hull_hit_chance = profile['target'].GetHullHitChance(profile['ballistic_attack'])
		chance = round(chance * (hull_hit_chance/100), 1)
		
		# HD is less effective if being overrun.
		if profile['overrun']:
			chance = round(chance * 0.5, 1)

		return chance


	# generate an attack console to display an attack, AP profile, or HE resolution to the screen and prompt to proceed
	def DisplayAttack(self, profile):
		
		libtcod.console_clear(attack_con)
		
		# display the background outline
		libtcod.console_blit(session.attack_bkg, 0, 0, 0, 0, attack_con, 0, 0)
		
		# window title
		libtcod.console_set_default_background(attack_con, libtcod.darker_blue)
		libtcod.console_rect(attack_con, 1, 1, 25, 1, False, libtcod.BKGND_SET)
		libtcod.console_set_default_background(attack_con, libtcod.black)
		
		# set flags on whether attacker/target is spotted
		attacker_spotted = True
		if profile['attacker'].owning_player == 1 and not profile['attacker'].spotted:
			attacker_spotted = False
		target_spotted = True
		if profile['target'].owning_player == 1 and not profile['target'].spotted:
			target_spotted = False
		
		if profile['type'] == 'ap':
			text = 'Armour Penetration'
		elif profile['type'] == 'he':
			text = 'HE Hit Resolution'
		elif profile['type'] == 'Close Combat':
			text = 'Close Combat'
		else:
			text = 'Ranged Attack'
		libtcod.console_print_ex(attack_con, 13, 1, libtcod.BKGND_NONE, libtcod.CENTER, text)
		
		# display attacker portrait if any
		if profile['type'] in ['Point Fire', 'Area Fire', 'Close Combat', 'Flame Thrower']:
			libtcod.console_set_default_background(attack_con, PORTRAIT_BG_COL)
			libtcod.console_rect(attack_con, 1, 2, 25, 8, False, libtcod.BKGND_SET)
			if attacker_spotted:
				DisplayUnitPortrait(attack_con, 1, 2, profile['attacker'], campaign.portrait_variant)
			else:
				libtcod.console_blit(LoadXP('unit_unknown.xp'), 0, 0, 0, 0, attack_con, 1, 2)
		
		# attack description
		if profile['type'] in ['ap', 'he']:
			text1 = profile['target'].GetName()
			if attacker_spotted:
				text2 = 'hit by ' + profile['weapon'].GetStat('name')
			else:
				text2 = 'hit'
			if profile['ammo_type'] is not None:
				text2 += ' (' + profile['ammo_type'] + ')'
			if profile['type'] == 'ap':
				text3 = 'in'
				text4 = profile['location_desc']
			else:
				text3 = ''
				text4 = ''
		else:
			text1 = profile['attacker'].GetName()
			if attacker_spotted:
				text2 = 'attacking with'
				text3 = profile['weapon'].GetStat('name')
				if profile['weapon'].ammo_type is not None:
					text3 += ' ' + profile['weapon'].ammo_type
			else:
				text2 = 'attacking'
			text4 = profile['target'].GetName()
			
		libtcod.console_print_ex(attack_con, 13, 10, libtcod.BKGND_NONE, libtcod.CENTER, text1)
		libtcod.console_print_ex(attack_con, 13, 11, libtcod.BKGND_NONE, libtcod.CENTER, text2)
		libtcod.console_print_ex(attack_con, 13, 12, libtcod.BKGND_NONE, libtcod.CENTER, text3)
		libtcod.console_print_ex(attack_con, 13, 13, libtcod.BKGND_NONE, libtcod.CENTER, text4)
		
		# display target portrait if any
		libtcod.console_set_default_background(attack_con, PORTRAIT_BG_COL)
		libtcod.console_rect(attack_con, 1, 14, 25, 8, False, libtcod.BKGND_SET)
		
		if target_spotted:
			DisplayUnitPortrait(attack_con, 1, 14, profile['target'], campaign.portrait_variant)
		else:
			libtcod.console_blit(LoadXP('unit_unknown.xp'), 0, 0, 0, 0, attack_con, 1, 14)
		
		# base chance
		text = 'Base '
		if profile['type'] == 'ap':
			text += 'Score to Penetrate:'
		elif profile['type'] == 'he':
			text += 'Score to Destroy:'
		elif profile['type'] in ['Area Fire', 'Flame Thrower'] or profile['ammo_type'] == 'HE':
			text += 'Chance of Effect:'
		else:
			text += 'Chance to Hit:'
		libtcod.console_print_ex(attack_con, 13, 23, libtcod.BKGND_NONE, libtcod.CENTER, text)
		text = str(profile['base_chance'])
		if profile['type'] not in ['ap', 'he']:
			text += '%'
		libtcod.console_print_ex(attack_con, 13, 24, libtcod.BKGND_NONE, libtcod.CENTER, text)
		
		# list of modifiers
		libtcod.console_set_default_background(attack_con, libtcod.darker_blue)
		libtcod.console_rect(attack_con, 1, 27, 25, 1, False, libtcod.BKGND_SET)
		libtcod.console_set_default_background(attack_con, libtcod.black)
		libtcod.console_print_ex(attack_con, 13, 27, libtcod.BKGND_NONE, libtcod.CENTER,
			'Modifiers')
		y = 29
		if len(profile['modifier_list']) == 0:
			libtcod.console_print_ex(attack_con, 13, y, libtcod.BKGND_NONE, libtcod.CENTER,
				'None')
		else:
			for (desc, mod) in profile['modifier_list']:
				
				# description: max displayable width is 17 chars
				lines = wrap(desc, 17, subsequent_indent = ' ')
				for line in lines:
					libtcod.console_print(attack_con, 2, y, line)
					y += 1
				
				y -= 1
				
				# amount
				if mod > 0.0:
					col = libtcod.green
					text = '+'
				else:
					col = libtcod.red
					text = ''
				
				libtcod.console_set_default_foreground(attack_con, col)
				libtcod.console_print_ex(attack_con, 24, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, text + str(mod))
				libtcod.console_set_default_foreground(attack_con, libtcod.white)
				
				y += 1
				if y == 39: break
		
		# display final score required for AP/HE rolls
		if profile['type'] in ['ap', 'he']:
			libtcod.console_print_ex(attack_con, 13, 40, libtcod.BKGND_NONE, libtcod.CENTER,
				'Score required:')
			libtcod.console_print_ex(attack_con, 13, 41, libtcod.BKGND_NONE, libtcod.CENTER,
				str(profile['final_score']))
		
		# display final modified chance
		libtcod.console_set_default_background(attack_con, libtcod.darker_blue)
		libtcod.console_rect(attack_con, 1, 43, 25, 1, False, libtcod.BKGND_SET)
		libtcod.console_set_default_background(attack_con, libtcod.black)
		libtcod.console_print_ex(attack_con, 13, 43, libtcod.BKGND_NONE, libtcod.CENTER,
			'Modified Chance')
		
		# display chance bar graph
		
		# base miss/no effect bar
		DrawOddsBar(attack_con, 1, 44, 25, 100, libtcod.red, False)
		
		if profile['type'] in ['Area Fire', 'Flame Thrower'] or (profile['ammo_type'] == 'HE' and profile['type'] not in ['ap', 'he']):
			# area fire / FTR / HE have partial, full, and critical outcomes possible
			# partial effect
			DrawOddsBar(attack_con, 1, 44, 25, profile['final_chance'], libtcod.darker_green, True)
			
			if profile['final_chance'] > profile['full_effect']:
				libtcod.console_print_ex(attack_con, 24, 45, libtcod.BKGND_NONE,
					libtcod.RIGHT, 'PART')
				text = str(profile['final_chance']) + '%'
				libtcod.console_print_ex(attack_con, 24, 46, libtcod.BKGND_NONE,
					libtcod.RIGHT, text)
			
			# full effect
			DrawOddsBar(attack_con, 1, 44, 25, profile['full_effect'], libtcod.dark_green, True)
			
			crit_possible = False
			if profile['final_chance'] > 3.0:
				crit_possible = True
			
			if profile['full_effect'] > profile['critical_effect'] or not crit_possible:
				libtcod.console_print_ex(attack_con, 13, 45, libtcod.BKGND_NONE,
					libtcod.CENTER, 'FULL')
				text = str(profile['full_effect']) + '%'
				libtcod.console_print_ex(attack_con, 13, 46, libtcod.BKGND_NONE,
					libtcod.CENTER, text)
			
			# critical effect - N/A if original odds were <= 3% or FTR
			if crit_possible and profile['type'] != 'Flame Thrower':
				DrawOddsBar(attack_con, 1, 44, 25, profile['critical_effect'], libtcod.blue, False)
				libtcod.console_print(attack_con, 2, 45, 'CRIT')
				text = str(profile['critical_effect']) + '%'
				libtcod.console_print(attack_con, 2, 46, text)
			
		# point fire, close combat, or ap/he resolution
		else:
			# hit
			if profile['type'] in ['ap', 'he']:
				DrawOddsBar(attack_con, 1, 44, 25, profile['final_chance'], libtcod.dark_green, False)
			
			# if not AP or HE impact resolution, there can never be a 100% chance of an outcome.
			else:
				DrawOddsBar(attack_con, 1, 44, 25, profile['final_chance'], libtcod.dark_green, True)

				# critical hit band. no critical hit possible if original odds were <= 3% and crit chance is capped by hit chance.
				if profile['final_chance'] > 3.0 and profile['ammo_type'] not in ['Smoke', 'WP']:
					DrawOddsBar(attack_con, 1, 44, 25, min(profile['critical_hit'], profile['final_chance']), libtcod.blue, False)
			
			text = str(profile['final_chance']) + '%'
			
			# AP/HE checks may be automatic or impossible
			if profile['type'] in ['ap', 'he']:
				if profile['final_chance'] == 0.0:
					text = 'Impossible'
				elif profile['final_chance'] == 100.0:
					text = 'Automatic'
			libtcod.console_print_ex(attack_con, 13, 45, libtcod.BKGND_NONE,
				libtcod.CENTER, text)
		
		# add a HD save band in sepia if there is one in the attack
		if profile['type'] not in ['ap', 'he'] and 'hd_mod' in profile:
			x_start = int(ceil(25 * profile['final_chance'] / 100.0))
			DrawOddsBar(attack_con, x_start, 44, 25, profile['hd_mod'], libtcod.sepia, False, skip_left_cap=True)
		
		# set this now
		profile['fate_point_allowed'] = False
		
		# return now if RoF attack
		if profile['weapon'].maintained_rof: return
		
		# check for display of fate point or cancel prompt
		display_cancel = False
		display_fate_point = False
		if profile['attacker'] == self.player_unit and profile['type'] not in ['ap', 'he']:
			display_cancel = True
		
		if not display_cancel:
			if profile['type'] not in ['ap', 'he'] and profile['target'] == self.player_unit and campaign_day.fate_points > 0 and profile['final_chance'] not in [0.0, 100.0]:
				display_fate_point = True
				profile['fate_point_allowed'] = True
		
		# display remaining fate points allowed to use
		if display_fate_point:
			libtcod.console_set_default_foreground(attack_con, libtcod.darker_purple)
			libtcod.console_print_ex(attack_con, 25, 14, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(campaign_day.fate_points))
		
		# display inputs
		if gamepad is not None:
			if display_cancel:
				DisplayButton(attack_con, 10, 56, GAMEPADCHAR_B)
			elif display_fate_point:
				DisplayButton(attack_con, 10, 56, GAMEPADCHAR_Y)
			DisplayButton(attack_con, 10, 57, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(attack_con, ACTION_KEY_COL)
			if display_cancel:
				libtcod.console_print(attack_con, 6, 56, 'Esc')
			elif display_fate_point:
				libtcod.console_print(attack_con, 6, 56, 'F')
			libtcod.console_print(attack_con, 6, 57, 'Tab')
		
		libtcod.console_set_default_foreground(attack_con, libtcod.white)
		if display_cancel:
			libtcod.console_print(attack_con, 12, 56, 'Cancel')
		elif display_fate_point:
			libtcod.console_print(attack_con, 12, 56, 'Fate Point')
		libtcod.console_print(attack_con, 12, 57, 'Continue')
		
		
	
	# do a roll, animate the attack console, and display the results
	# returns an modified attack profile
	def DoAttackRoll(self, profile):
		
		# clear prompts from attack console - clear background as well
		libtcod.console_set_default_background(attack_con, libtcod.black)
		libtcod.console_rect(attack_con, 6, 56, 18, 2, True, libtcod.BKGND_SET)
		
		result_text = ''
		
		# if AP roll, may not need to roll
		if profile['type'] == 'ap':
			if profile['final_chance'] == 0.0:
				result_text = 'NO PENETRATION'
			elif profile['final_chance'] == 100.0:
				result_text = 'PENETRATED'
		
		# if HE roll, may not need to roll
		elif profile['type'] == 'he':
			if profile['final_chance'] == 0.0:
				result_text = 'NO EFFECT'
			elif profile['final_chance'] == 100.0:
				result_text = 'DESTROYED'
		
		# only roll if outcome not yet determined
		if result_text == '':
		
			# don't animate percentage rolls if player is not involved
			if profile['attacker'] != scenario.player_unit and profile['target'] != scenario.player_unit:
				roll = GetPercentileRoll()
			else:
				for i in range(6):
					roll = GetPercentileRoll()
					
					# check for debug flag - force a hit or penetration
					if i == 5:
						if DEBUG:
							if profile['attacker'] == scenario.player_unit and session.debug['Player Always Hits']:
								while roll >= profile['final_chance']:
									roll = GetPercentileRoll()
							elif profile['target'] == scenario.player_unit and profile['type'] in ['ap', 'he'] and session.debug['Player Always Penetrated']:
								while roll >= profile['final_chance']:
									roll = GetPercentileRoll()
							elif profile['target'] == scenario.player_unit and profile['type'] not in ['ap', 'he'] and session.debug['AI Hates Player']:	
								while roll >= profile['final_chance']:
									roll = GetPercentileRoll()
					
					# clear any previous text
					libtcod.console_print_ex(attack_con, 13, 48, libtcod.BKGND_NONE,
						libtcod.CENTER, '           ')
					
					text = 'Roll: ' + str(roll)
					libtcod.console_print_ex(attack_con, 13, 48, libtcod.BKGND_NONE,
						libtcod.CENTER, text)
					
					scenario.UpdateScenarioDisplay()
					
					# don't animate if fast mode debug flag is set
					if DEBUG and session.debug['Fast Mode']:
						continue
					
					# pause between rolls
					Wait(15)
			
			# wait for attack animation to end if still active
			# compatibility check for <= 1.1.3
			if 'attack_animation_active' in scenario.animation:
				while scenario.animation['attack_animation_active']:
					libtcod.console_flush()
					CheckForAnimationUpdate()
			
			# record the final roll in the attack profile
			profile['roll'] = roll
			
			# if player is attacker, check for Steam achievement
			if profile['attacker'] == scenario.player_unit and profile['type'] != 'he':
				if 0.0 <= profile['final_chance'] - roll <= 0.5:
					session.ModifySteamStat('close_pass', 1)
				elif 0.0 < roll - profile['final_chance'] <= 0.5:
					session.ModifySteamStat('close_miss', 1)
			
			# determine location hit on target (not always used). Don't reroll this if doing an AP or HE kill roll.
			if 'location' not in profile:
				if GetPercentileRoll() <= profile['target'].GetHullHitChance(profile['ballistic_attack']):
					profile['location'] = 'Hull'
				else:
					profile['location'] = 'Turret'
			
			profile['effective_fp'] = 0
			
			# armour penetration roll
			if profile['type'] == 'ap':
				if roll >= CRITICAL_MISS:
					result_text = 'NO PENETRATION'
				elif roll <= CRITICAL_HIT:
					result_text = 'PENETRATED'
				elif roll <= profile['final_chance']:
					result_text = 'PENETRATED'
				else:
					result_text = 'NO PENETRATION'
				
				# modify message for unarmoured targets
				if result_text == 'NO PENETRATION' and profile['target'].GetStat('armour') is None:
					result_text = 'MINOR DAMAGE'
			
			# HE destruction roll
			elif profile['type'] == 'he':
				if roll <= profile['final_chance']:
					result_text = 'DESTROYED'
				else:
					
					# should be an unarmoured vehicle, but just make sure
					if profile['target'].GetStat('armour') is not None:
						result_text = 'NO EFFECT'
					else:
						
						# player target
						if profile['target'].ai is None:
							if not profile['target'].immobilized:
								result_text = 'IMMOBILIZED'
							else:
								result_text = 'NO EFFECT'
						
						# AI target
						else:
							
							if GetPercentileRoll() <= 50.0:
								if not profile['target'].immobilized:
									result_text = 'IMMOBILIZED'
								else:
									result_text = 'NO EFFECT'
							else:
								if profile['target'].ai.state != 'Stunned':
									result_text = 'STUNNED'	
								else:
									result_text = 'NO EFFECT'							
			
			# area fire attack
			elif profile['type'] == 'Area Fire':
				if roll <= profile['critical_effect']:
					
					# no critical effect possible if original odds were <= 3%
					if profile['final_chance'] <= 3.0:
						result_text = 'FULL EFFECT'
						profile['effective_fp'] = profile['base_fp']
					else:
						result_text = 'CRITICAL EFFECT'
						profile['effective_fp'] = profile['base_fp'] * 2
				elif roll <= profile['full_effect']:
					result_text = 'FULL EFFECT'
					profile['effective_fp'] = profile['base_fp']
				elif roll <= profile['final_chance']:
					result_text = 'PARTIAL EFFECT'
					profile['effective_fp'] = int(floor(profile['base_fp'] / 2))
					if profile['effective_fp'] < 1:
						profile['effective_fp'] = 1
				else:
					result_text = 'NO EFFECT'
				
				# overrun attacks get bonus FP
				if profile['overrun']:
					profile['effective_fp'] = profile['effective_fp'] * 2
				
				# unspotted targets take half FP rounded up
				if not profile['target'].spotted:
					profile['effective_fp'] = ceil(profile['effective_fp'] * 0.5)
				
				# might be converted into an AP MG hit
				if result_text in ['FULL EFFECT', 'CRITICAL EFFECT'] and profile['target'].GetStat('armour') is not None:
					if profile['weapon'].GetStat('type') in MG_WEAPONS:
						if result_text == 'FULL EFFECT':
							result_text = 'HIT'
						else:
							result_text = 'CRITICAL HIT'
					
					# rifle weapons can result in an AP check if within 1 hex from target; compatibility check here for 1.2.13
					elif profile['weapon'].GetStat('type') in RIFLE_WEAPONS and 'distance' in profile:
						if distance <= 1:
							if result_text == 'FULL EFFECT':
								result_text = 'HIT'
							else:
								result_text = 'CRITICAL HIT'
			
			# vehicle flame thrower attack
			elif profile['type'] == 'Flame Thrower':
				if roll <= profile['full_effect']:
					result_text = 'FULL EFFECT'
					profile['effective_fp'] = profile['base_fp']
				elif roll <= profile['final_chance']:
					result_text = 'PARTIAL EFFECT'
					profile['effective_fp'] = int(floor(profile['base_fp'] / 2))
					if profile['effective_fp'] < 1:
						profile['effective_fp'] = 1
				else:
					result_text = 'NO EFFECT'
				
				# overrun attacks get bonus FP
				if profile['overrun']:
					profile['effective_fp'] = profile['effective_fp'] * 2
				
				# unspotted targets take half FP rounded up
				if not profile['target'].spotted:
					profile['effective_fp'] = ceil(profile['effective_fp'] * 0.5)
				
				# might be converted into an AP hit
				if result_text in ['FULL EFFECT', 'CRITICAL EFFECT']:
					if profile['target'].GetStat('armour') is not None:
						if result_text == 'FULL EFFECT':
							result_text = 'HIT'
	
			# point fire or close combat attack
			else:
				
				if roll >= CRITICAL_MISS:
					result_text = 'MISS'
				
				elif roll <= profile['critical_hit'] and profile['ammo_type'] not in ['Smoke', 'WP']:
					
					# make sure that original roll was a success
					if roll > profile['final_chance']:
						result_text = 'MISS'
					else:
						# no critical hit possible if original odds were <= 3%
						if profile['final_chance'] <= 3.0:
							result_text = 'HIT'
						else:
							result_text = 'CRITICAL HIT'
				
				elif profile['ammo_type'] == 'HE':
					if roll <= profile['full_effect']:
						result_text = 'HIT'
					elif roll <= profile['final_chance']:
						result_text = 'PARTIAL HIT'
					else:
						result_text = 'MISS'
				
				elif roll <= profile['final_chance']:
					result_text = 'HIT'
				else:
					result_text = 'MISS'
				
				# calculate effective FP
				if result_text in ['HIT', 'CRITICAL HIT', 'PARTIAL HIT']:
					
					if profile['type'] == 'Close Combat':
						profile['effective_fp'] = int(profile['weapon'].GetStat('fp'))
						if result_text == 'CRITICAL HIT':
							profile['effective_fp'] = profile['effective_fp'] * 2
					
					elif profile['type'] == 'Point Fire':
						if profile['ammo_type'] == 'WP':
							profile['effective_fp'] = WP_FP
						elif profile['ammo_type'] in ['C', 'SH']:
							calibre = int(profile['weapon'].GetStat('calibre'))
							if calibre <= 37:
								profile['effective_fp'] = 12
							elif calibre <= 75:
								profile['effective_fp'] = 20
							else:
								profile['effective_fp'] = 24
						elif profile['target'].GetStat('category') in ['Infantry', 'Cavalry', 'Gun']:
							if profile['ammo_type'] in ['HE', 'HEAT']:
								# set the result now so that the HE FP is calculated correctly
								profile['result'] = result_text
								profile = profile['attacker'].CalcHEEffectiveFP(profile)
							elif profile['ammo_type'] in AP_AMMO_TYPES:
								profile['effective_fp'] = 1
						else:
							if profile['ammo_type'] in ['HE', 'HEAT']:
								profile['result'] = result_text
								profile = profile['attacker'].CalcHEEffectiveFP(profile)
					
					# unspotted targets take half FP rounded up
					if not profile['target'].spotted:
						profile['effective_fp'] = ceil(profile['effective_fp'] * 0.5)
			
			# checks for HD target
			if 'hd_mod' in profile:
				
				# if final roll failed and was within the HD save modifier, change message to reflect that it was a HD save
				if result_text == 'MISS':
					if 'full_effect' in profile:
						if roll + profile['hd_mod'] >= profile['full_effect']: 
							result_text = 'HULL DOWN SAVED'
					elif 'final_chance' in profile:
						if roll + profile['hd_mod'] >= profile['final_chance']:
							result_text = 'HULL DOWN SAVED'
				
				# if final roll passed and target was HD, roll to see if hit location is changed to turret
				elif result_text in ['HIT', 'CRITICAL HIT'] and profile['location'] == 'Hull':
					if GetPercentileRoll() >= profile['hd_mod']:
						profile['location'] = 'Turret'
		
		profile['result'] = result_text
		
		# check for RoF
		profile['weapon'].maintained_rof = False
		player_rof = False
		if profile['type'] not in ['ap', 'he'] and not profile['immobilize'] and not profile['defensive_fire']:
			
			chance = profile['weapon'].GetRoFChance()
			if chance > 0.0:
				if GetPercentileRoll() <= chance:
					profile['weapon'].maintained_rof = True
					profile['weapon'].rof_shots += 1
			
			# player is involved and maintained RoF
			if (profile['attacker'] == scenario.player_unit or profile['target'] == scenario.player_unit) and profile['weapon'].maintained_rof:
				libtcod.console_print_ex(attack_con, 13, 54, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Maintained Rate of Fire')
				
				# RoF attack
				if profile['attacker'] == scenario.player_unit:
					
					player_rof = True
					
					# display inputs
					if gamepad is not None:
						DisplayButton(attack_con, 10, 56, GAMEPADCHAR_A)
						DisplayButton(attack_con, 10, 57, GAMEPADCHAR_B)
					else:
						libtcod.console_set_default_foreground(attack_con, ACTION_KEY_COL)
						libtcod.console_print(attack_con, 6, 56, EnKey('f').upper() + '/Tab')
						libtcod.console_print(attack_con, 6, 57, 'Esc')
					libtcod.console_set_default_foreground(attack_con, libtcod.white)
					libtcod.console_print(attack_con, 12, 56, 'Fire Again')
					libtcod.console_print(attack_con, 12, 57, 'End Attack')
		
		# play sound effect for HD save
		if profile['result'] == 'HULL DOWN SAVED':
			PlaySoundFor(None, 'hull_down_save')
		
		# if player is not involved, return now
		if profile['attacker'] != scenario.player_unit and profile['target'] != scenario.player_unit:
			return profile
		
		# display result on screen
		libtcod.console_print_ex(attack_con, 13, 51, libtcod.BKGND_NONE,
			libtcod.CENTER, result_text)
		
		# display effective FP if any 
		if profile['effective_fp'] > 0 and profile['result'] not in ['MISS - HULL DOWN', 'MISS - NO TURRET']:
			libtcod.console_print_ex(attack_con, 13, 52, libtcod.BKGND_NONE,
				libtcod.CENTER, str(profile['effective_fp']) + ' FP')
		
		# display final effect modifier if any
		if profile['modifier'] != '':
			libtcod.console_print_ex(attack_con, 13, 53, libtcod.BKGND_NONE,
				libtcod.CENTER, profile['modifier'])
		
		# display prompt if not player RoF
		if not player_rof:
			if gamepad is not None:
				DisplayButton(attack_con, 10, 57, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(attack_con, ACTION_KEY_COL)
				libtcod.console_print(attack_con, 6, 57, 'Tab')
			libtcod.console_set_default_foreground(attack_con, libtcod.white)
			libtcod.console_print(attack_con, 12, 57, 'Continue')
		
		return profile
	
	
	# selecte a different weapon (or a different ammo type for the current weapon) on the player unit
	def SelectWeapon(self, forward):
		
		if self.selected_weapon is None:
			self.selected_weapon = scenario.player_unit.weapon_list[0]
			self.UpdatePlayerInfoCon()
			self.UpdateCrewInfoCon()
			return
		
		# if weapon is not broken/jammed and is gun, see if can select a different ammo type instead
		if not self.selected_weapon.broken and not self.selected_weapon.jammed:
			crewman = self.selected_weapon.GetOperatingCrewman()
			if crewman is not None and not crewman.acted and self.selected_weapon.SelectAmmoType(forward):
				return
		
		if forward:
			m = 1
		else:
			m = -1
		
		i = scenario.player_unit.weapon_list.index(self.selected_weapon) + m
		
		if i < 0:
			self.selected_weapon = scenario.player_unit.weapon_list[-1]
		elif i > len(scenario.player_unit.weapon_list) - 1:
			self.selected_weapon = scenario.player_unit.weapon_list[0]
		else:
			self.selected_weapon = scenario.player_unit.weapon_list[i]
		self.UpdatePlayerInfoCon()
		self.UpdateCrewInfoCon()
		
		# select proper ammo type if gun
		if self.selected_weapon.GetStat('ammo_type_list') is None: return
		
		if forward:
			i = 0
		else:
			i = -1
		self.selected_weapon.ammo_type = self.selected_weapon.stats['ammo_type_list'][i]
	
	
	# (re)build a sorted list of possible player targets
	def BuildTargetList(self):
		
		self.target_list = []
		temp_target_list = []
		
		# build a temporary list of enemy and friendly targets (for smoke)
		for unit in self.units:
			if not unit.alive: continue
			if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
			# don't allow targeting allies in same hex, messes up hex stack order
			if unit.hx == 0 and unit.hy == 0: continue
			if unit.owning_player == 0:
				if unit == self.player_unit: continue
				if unit in self.player_unit.squad: continue
			temp_target_list.append(unit)
		
		# build final target list, sorted by distance and hextant
		for (hx, hy) in SCENARIO_HEXES:
			for unit in reversed(temp_target_list):
				if unit.hx != hx or unit.hy != hy: continue
				self.target_list.append(unit)
				temp_target_list.remove(unit)

		# build individual weapon target lists, restricted to targets in covered hexes
		for weapon in self.player_unit.weapon_list:
			weapon.BuildTargetList()


	# build an array of player crew positions and gun-type weapons whose ammunition crewmen in that position can manage
	# this function exists for centralising calculations and ease of remembering which weapon was last selected while scrolling in case of crewmen opearting multiple weapons
	def BuildRRManagementArray(self):
		self.rack_management_array = {}
		for weapon in self.player_unit.weapon_list:
			if weapon.GetStat('type') != 'Gun':
				continue
			gunners = weapon.GetStat('fired_by')
			loaders = weapon.GetStat('reloaded_by')
			if gunners is None: gunners = []
			if loaders is None: loaders = []
			
			for position in self.player_unit.positions_list:
				# check that position is in same location as weapon mount if any
				if weapon.GetStat('mount') is not None and weapon.GetStat('mount') != position.location:
					continue
				# check that position is able to fire or load the weapon
				if position.name in gunners or position.name in loaders:
					if position in self.rack_management_array:
						self.rack_management_array[position].append(weapon)
					else:
						self.rack_management_array[position] = [weapon]


	# cycle selected target for player weapon
	def CycleTarget(self, forward):
		
		# no weapon selected
		if self.selected_weapon is None: return

		# no targets to select from
		if len(self.selected_weapon.weapon_target_list) == 0: return

		# no target selected yet. Shouldn't normally happen.
		if self.selected_weapon.selected_target is None:
			self.selected_weapon.selected_target = self.selected_weapon.weapon_target_list[0]
			PlaySoundFor(None, 'menu_select')
		
		# only one target to select.
		elif len(self.selected_weapon.weapon_target_list) == 1:
			self.selected_weapon.selected_target = self.selected_weapon.weapon_target_list[0]

		else:
			i = self.selected_weapon.weapon_target_list.index(self.selected_weapon.selected_target)

			if forward:
				i += 1
			else:
				i -= 1

			if i < 0:
				self.selected_weapon.selected_target = self.selected_weapon.weapon_target_list[-1]
			elif i > len(self.selected_weapon.weapon_target_list) - 1:
				self.selected_weapon.selected_target = self.selected_weapon.weapon_target_list[0]
			else:
				self.selected_weapon.selected_target = self.selected_weapon.weapon_target_list[i]
			PlaySoundFor(None, 'menu_select')
			
		self.selected_weapon.selected_target.MoveToTopOfStack()
		self.UpdateUnitCon()
		self.UpdateUnitInfoCon()
	
	
	# roll to see if air and/or arty support requests were granted, and trigger attacks if so
	# also checks for enemy air/artillery attacks if player was attacked in own zone
	def ResolveSupportRequests(self):
		
		# do and display the roll and result for a given support request
		def DoSupportRoll(support_type, chance):
			
			# build a list of modifiers and the total roll modifier
			modifiers = []
			final_modifier = 0
			
			# campaign skill modifiers
			if support_type == 'Air':
				if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Combined Operations'):
					modifiers.append(('Combined Operations', 5))
			
			elif support_type == 'Artillery':
				if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Centralized Fire'):
					modifiers.append(('Centralized Fire', 10))
				elif campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Combined Operations'):
					modifiers.append(('Combined Operations', 5))
			
			elif support_type == 'Unit':
				if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Combined Operations'):
					modifiers.append(('Combined Operations', 5))
			
			# no radio link
			if not campaign_day.hq_radio_comms:
				modifiers.append(('No Radio Link', -25))
			else:
				# dedicated radio operator
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.name == 'Radio Operator':
						modifiers.append(('Radio Operator', 10))
						break
			
			for (text, mod) in modifiers:
				final_modifier += mod
			
			chance = chance + float(final_modifier)
			if chance < 5.0:
				chance = 5.0
			if chance > 100.0:
				chance = 100.0
			
			# create a local copy of the current screen to re-draw when we're done
			temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
			libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
			
			# set up message console and screen location
			session.msg_con = NewConsole(31, 20, libtcod.darkest_grey, libtcod.white)
			session.msg_location = (WINDOW_XM + 1 - 9 + window_x, WINDOW_YM - 14 - window_y)
			
			DrawFrame(session.msg_con, 0, 0, 31, 20)
			libtcod.console_set_default_foreground(session.msg_con, libtcod.white)
			libtcod.console_print_ex(session.msg_con, 15, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Resolving ' + support_type)
			libtcod.console_print_ex(session.msg_con, 15, 3, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Support Request')
			
			# display list of modifiers here
			y = 5
			libtcod.console_set_default_foreground(session.msg_con, libtcod.lighter_grey)
			for (text, mod) in modifiers:
				libtcod.console_print(session.msg_con, 2, y, text)
				mod_text = str(mod) + '%'
				if mod > 0:
					mod_text = '+' + mod_text
				libtcod.console_print_ex(session.msg_con, 27, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, mod_text)
				y += 1
				
			libtcod.console_set_default_foreground(session.msg_con, libtcod.white)
			libtcod.console_print_ex(session.msg_con, 15, 13, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Chance: ' + str(chance) + '%')
			
			FlushKeyboardEvents()
			Wait(120)
			
			for i in range(6):
				roll = GetPercentileRoll()
				if DEBUG:
					if session.debug['Support Requests Always Granted']:
						roll = 0.0
				
				libtcod.console_print_ex(session.msg_con, 15, 15, libtcod.BKGND_NONE,
					libtcod.CENTER, '           ')
				libtcod.console_print_ex(session.msg_con, 15, 15, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Roll: ' + str(roll))
				Wait(20)
			
			if roll <= chance:
				libtcod.console_print_ex(session.msg_con, 15, 17, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Success!')
			else:
				libtcod.console_print_ex(session.msg_con, 15, 17, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Attempt Failed')
			Wait(1)
			
			if config['ArmCom2'].getboolean('message_prompt'):
				libtcod.console_print_ex(session.msg_con, 15, 18, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Tab to Continue')
			
			if config['ArmCom2'].getboolean('message_prompt'):
				WaitForContinue()
			else:
				FlushKeyboardEvents()
				# allow the message to be read by the player
				Wait(180 * config['ArmCom2'].getint('message_pause'),
					allow_skip=True, ignore_animations=True)
			
			FlushKeyboardEvents()
			
			# erase console and re-draw screen
			session.msg_con = None
			session.msg_location = None
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			libtcod.console_flush()
			
			if roll <= chance:
				return True
			return False
		
		# track number of units destroyed for Steam stats
		active_enemy_units = 0
		for unit in self.units:
			if unit.owning_player == 1:
				active_enemy_units += 1
		
		# check for air attack first - not in friendly zone
		if campaign_day.air_support_request and not self.cd_map_hex.controlled_by == 0:
			
			air_support_na = False
			if campaign_day.weather['Cloud Cover'] == 'Overcast':
				ShowMessage('Cannot offer air attack support - cloud cover too heavy.', good_news=False)
				air_support_na = True
			elif campaign_day.weather['Fog'] > 0:
				ShowMessage('Cannot offer air attack support - fog is too thick.', good_news=False)
				air_support_na = True
			elif campaign_day.weather['Precipitation'] == 'Sandstorm':
				ShowMessage('Cannot offer air attack support - sandstorm in progress.', good_news=False)
				air_support_na = True
			
			if not air_support_na:
				if DoSupportRoll('Air', campaign_day.air_support_level):
					campaign_day.air_support_level -= float(libtcod.random_get_int(0, 1, 3)) * 5.0
					if campaign_day.air_support_level < 0.0:
						campaign_day.air_support_level = 0.0
					self.DoAirAttack(requested_attack=True)
		
		# check for artillery attack, also not in friendly zone
		if campaign_day.arty_support_request and not self.cd_map_hex.controlled_by == 0:
			if DoSupportRoll('Artillery', campaign_day.arty_support_level):
				campaign_day.arty_support_level -= float(libtcod.random_get_int(0, 1, 3)) * 5.0
				if campaign_day.arty_support_level < 0.0:
					campaign_day.arty_support_level = 0.0
				self.DoArtilleryAttack()
		
		# check for Steam achivement
		surviving_enemy_units = 0
		for unit in self.units:
			if unit.owning_player == 1:
				surviving_enemy_units += 1
		
		if active_enemy_units - surviving_enemy_units >= 3:
			session.ModifySteamStat('destroyed_three_targets', 1)
		
		# if player didn't request unit support and is being attacked in own zone, may have some support units for free
		free_unit_support = False
		if not campaign_day.unit_support_request and self.cd_map_hex.controlled_by == 0 and 'unit_support_level' in campaign.current_week:
			if GetPercentileRoll() <= 33.3:
				campaign_day.unit_support_request = True
				campaign_day.unit_support_type = choice(list(campaign.stats['player_unit_support']))
				free_unit_support = True
		
		# in Major Battle missions, player may get extra support for free
		elif not campaign_day.unit_support_request and 'unit_support_level' in campaign.current_week and campaign_day.mission == 'Major Battle':
			if GetPercentileRoll() <= 15.0:
				campaign_day.unit_support_request = True
				campaign_day.unit_support_type = choice(list(campaign.stats['player_unit_support']))
				free_unit_support = True
		
		# check for unit support request
		unit_support_arrived = False
		
		if campaign_day.unit_support_request and campaign_day.unit_support_type is not None:
			
			result = False
			if free_unit_support:
				if GetPercentileRoll() <= campaign_day.unit_support_level:
					result = True
			else:
				result = DoSupportRoll('Unit', campaign_day.unit_support_level)
				
			if result:
				if not free_unit_support:
					campaign_day.unit_support_level -= float(libtcod.random_get_int(0, 1, 3)) * 5.0
					if campaign_day.unit_support_level < 0.0:
						campaign_day.unit_support_level = 0.0
				
				# spawn units - determine number of units
				roll = libtcod.random_get_int(0, 1, 10)
				if roll <= 3:
					num_units = 1
				elif roll <= 8:
					num_units = 2
				else:
					num_units = 3
				
				# Major Battle support will be higher
				if campaign_day.mission == 'Major Battle' and not free_unit_support:
					num_units += 1
				
				# armoured support will be fewer units
				if campaign_day.unit_support_type == 'Armoured':
					num_units -= 1
					if num_units < 1: num_units = 1
				
				# possible spawn locations
				ring_list = []
				for r in range(1, 4):
					hex_ring = []
					for (hx, hy) in GetHexRing(0, 0, r):
						if len(self.hex_dict[(hx,hy)].unit_stack) > 0:
							if self.hex_dict[(hx,hy)].unit_stack[0].owning_player == 1:
								continue
						hex_ring.append((hx, hy))
					ring_list.append(hex_ring)
				
				text = ''
				
				for tries in range(300):
					
					unit_id = choice(campaign.stats['player_unit_support'][campaign_day.unit_support_type])
					
					# check historical availability of unit
					if not campaign.DoRarityCheck(unit_id, nation=campaign.stats['player_nation']):
						continue
					
					# determine spawn location
					found_location = False
					for hex_ring in ring_list:
						shuffle(hex_ring)
						for (hx, hy) in hex_ring:
							# less likely to spawn in front of player if not ambushed
							if not self.ambush:
								if GetDirectionToward(hx, hy, 0, 0) in [2, 3, 4]:
									if GetPercentileRoll() <= 95.0: continue
							found_location = True
							break
						if found_location: break
					
					unit = Unit(unit_id)
					unit.nation = campaign.player_unit.nation
					unit.ai = AI(unit)
					unit.ai.Reset()
					unit.GenerateNewPersonnel()
					unit.SpawnAt(hx, hy)
					unit.CheckForTractorSpawn()
					unit.DeploymentCheck()
					unit.facing = 0
					unit.CheckForHD(spawn=True)
					if 'turret' in unit.stats:
						unit.turret_facing = 0
					if not unit.deployed:
						unit.moving = True
					self.GenerateUnitLoS(unit)
					
					# set up additional passenger unit if any
					if 'friendly_transported_units' in campaign.stats:
						transport_dict = campaign.stats['friendly_transported_units']
						if unit_id in transport_dict:
							transport_list = list(transport_dict[unit_id].items())
							shuffle(transport_list)
							for k, value in transport_list:
								if libtcod.random_get_int(0, 1, 100) <= value:
									unit.transport = k
									break
					
					if text != '':
						text += ', '
					text += unit_id
					
					num_units -= 1
					if num_units == 0: break
				
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				
				if free_unit_support:
					msg_text = campaign_day.unit_support_type + ' support unit'
					if num_units == 1:
						msg_text += ' was'
					else:
						msg_text += 's were'
					msg_text += ' nearby and join the battle: ' + text
				else:
				
					msg_text = campaign_day.unit_support_type + ' support unit'
					if num_units == 1:
						msg_text += ' has'
					else:
						msg_text += 's have'
					msg_text += ' arrived: ' + text
				ShowMessage(msg_text, good_news=True)
				
				unit_support_arrived = True
		
		# if recon support arrived, set the recon spotting flag
		if unit_support_arrived:
			if campaign_day.unit_support_type == 'Recon':
				self.recon_spotting = True
		
		# reset flags
		campaign_day.air_support_request = False
		campaign_day.arty_support_request = False
		campaign_day.unit_support_request = False
		campaign_day.unit_support_type = None
		
		# update GUI console
		self.UpdateGuiCon()
		
		# check for enemy air/artillery attacks
		if self.cd_map_hex.controlled_by != 1:
			
			# possible enemy air attack
			if 'enemy_air_support' in campaign.stats and campaign_day.weather['Cloud Cover'] != 'Overcast' and campaign_day.weather['Fog'] == 0 and campaign_day.weather['Precipitation'] != 'Sandstorm':
				
				# chance is based on current player air support level
				if 'air_support_level' not in campaign.current_week or 'player_air_support' not in campaign.stats:
					chance = 40.0
				else:
					chance = 100.0 - (campaign_day.air_support_level * 1.5)
					if chance > 30.0:
						chance = 30.0
					elif chance < 0.0:
						chance = 0.0
				
				if GetPercentileRoll() <= chance:
					ShowMessage('Attacking enemy forces have brought air support!', good_news=False)
					self.DoAirAttack(player_target=True)
			
			# possible enemy artillery attack
			if 'enemy_arty_support' in campaign.stats:
				
				# chance is based on nearby enemy strength
				(player_hx, player_hy) = campaign_day.player_unit_location
				enemy_strength = 0
				for direction in range(6):
					(hx2, hy2) = campaign_day.GetAdjacentCDHex(player_hx, player_hy, direction)
					if (hx2, hy2) not in campaign_day.map_hexes:
						continue
					enemy_strength += campaign_day.map_hexes[(hx2,hy2)].enemy_strength
				
				if enemy_strength <= 3:
					chance = 3.0
				else:
					chance = float(enemy_strength) * 0.5
					if chance > 30.0:
						chance = 30.0
				
				if GetPercentileRoll() <= chance:
					ShowMessage('Attacking enemy forces have brought artillery support!', good_news=False)
					self.DoArtilleryAttack(player_target=True)
	
	
	# resolve an air support attack
	# if player_target is true, the player squad is the target of an enemy attack
	def DoAirAttack(self, requested_attack=False, player_target=False, friendly_fire=False):
		
		# determine air unit(s) to spawn
		unit_list = []
		
		if player_target:
			friendly_player = 1
			if friendly_fire:
				target_player = 1
			else:
				target_player = 0
			
			nation_list = list(campaign.stats['enemy_air_support'])
			shuffle(nation_list)
			for nation in nation_list:
				if nation in campaign.current_week['enemy_nations']:
					unit_list = campaign.stats['enemy_air_support'][nation]
					break
			
			# could not find an appropriate list of air units to spawn
			if len(unit_list) == 0:
				return
		else:
			friendly_player = 0
			if friendly_fire:
				target_player = 0
			else:
				target_player = 1
			unit_list = campaign.stats['player_air_support']
		
		# take out any fighter planes from list if this is a requested attack
		if requested_attack:
			for unit_type in reversed(unit_list):
				if session.unit_types[unit_type]['class'] == 'Fighter':
					unit_list.remove(unit_type)
		
		# no available aircraft
		if len(unit_list) == 0: return
		
		# if player is the target, crewmen roll against Perception to button up or hunker down
		if player_target:
			self.player_unit.CrewButtonUpCheck()
		
		# choose a random unit type, roll for rarity
		plane_id = None
		shuffle(unit_list)
		for unit_type in unit_list:
			if not campaign.DoRarityCheck(unit_type): continue
			plane_id = unit_type
			break
		if plane_id is None:
			plane_id = choice(unit_list)
		
		# spawn a spotter plane
		unit = Unit(plane_id, owning_player=friendly_player)
		
		PlaySoundFor(unit, 'plane_incoming')
		
		if friendly_fire:
			if player_target:
				ShowMessage('Enemy air forces launch an attack, but they have mistaken their own forces for ours!',
					good_news=True)
			else:
				ShowMessage('Air support attack inbound, but they have mistaken you for the enemy!',
					good_news=False)
		else:
			if player_target:
				ShowMessage('Enemy air forces launch an attack! Trying to spot targets.',
					good_news=False)
			else:
				ShowMessage('Air support attack inbound! Trying to spot targets.')
		
		# calculate base spotting chance and add weather modifiers
		chance = 85.0
			
		if campaign_day.weather['Cloud Cover'] == 'Scattered':
			chance -= 5.0
		elif campaign_day.weather['Cloud Cover'] == 'Heavy':
			chance -= 10.0
		if campaign_day.weather['Precipitation'] in ['Rain', 'Snow']:
			chance -= 10.0
		elif campaign_day.weather['Precipitation'] in ['Heavy Rain', 'Blizzard']:
			chance -= 20.0
		
		if campaign_day.weather['Fog'] > 0:
			chance -= 5.0 * float(campaign_day.weather['Fog'])
		
		# check each hex with 1+ target units present, skip outermost ring though
		target_hex_list = []
		for map_hex in self.map_hexes:
			if len(map_hex.unit_stack) == 0: continue
			if map_hex.unit_stack[0].owning_player != target_player: continue
			if GetHexDistance(0, 0, map_hex.hx, map_hex.hy) > 3: continue
			
			# roll to spot each enemy unit in hex
			for unit in map_hex.unit_stack:
				
				if not unit.alive: continue
				
				modifier = 0.0
					
				if unit.smoke > 0:
					modifier -= 5.0
				elif unit.dust > 0:
					modifier += 5.0
				
				size_class = unit.GetStat('size_class')
				if size_class is not None:
					if size_class == 'Small':
						modifier -= 7.0
					elif size_class == 'Very Small':
						modifier -= 18.0
					elif size_class == 'Large':
						modifier += 7.0
					elif size_class == 'Very Large':
						modifier += 18.0
					elif size_class == 'Extra Large':
						modifier += 25.0
				
				if unit.moving:
					modifier += 10.0
				
				modifier += unit.GetTEM()
				
				roll = GetPercentileRoll()
				if friendly_fire:
					roll -= 20.0
				
				# not spotted
				if roll > RestrictChance(chance + round(modifier * 0.25, 2)):
					continue
				
				# spotted, add this hex to targets and don't check any other units present in this hex
				target_hex_list.append(map_hex)
				break
		
		if len(target_hex_list) == 0:
			ShowMessage('No targets spotted, ending attack.')
			return
		
		# possible that friendly spotting plane reports unit identity to player
		if not player_target and not friendly_fire:
			for map_hex in target_hex_list:
				for unit2 in map_hex.unit_stack:
					if unit2.spotted: continue
					if campaign_day.hq_radio_comms:
						if libtcod.random_get_int(0, 1, 5) == 1: continue
					else:
						if libtcod.random_get_int(0, 1, 3) == 1: continue
					unit2.SpotMe()
					scenario.UpdateUnitCon()
					scenario.UpdateScenarioDisplay()
					ShowMessage(unit2.GetName() + ' spotted by air support!',
						portrait=unit2, scenario_highlight=(unit2.hx, unit2.hy))
		
		# roll for number of planes
		roll = libtcod.random_get_int(0, 1, 10)
		if roll <= 6:
			num_planes = 1
		elif roll <= 9:
			num_planes = 2
		else:
			num_planes = 3
		
		# create plane units
		plane_unit_list = []
		for i in range(num_planes):
			plane_unit_list.append(Unit(plane_id, owning_player=friendly_player))
		
		# display message
		text = str(num_planes) + ' ' + plane_id + ' arrive'
		if num_planes == 1: text += 's'
		text += ' for an attack.'
		ShowMessage(text, portrait=plane_unit_list[0].GetStat('portrait'))
		
		# get number of AA weapons in scenario
		aa_weapons = 0
		for unit in self.units:
			if not unit.alive: continue
			if unit.ai is None: continue
			if unit.owning_player != target_player: continue
			
			if unit.ai.state == 'Lax':
				if GetPercentileRoll() <= 80.0: continue
			
			for weapon in unit.weapon_list:
				if weapon.broken: continue
				if weapon.jammed: continue
				if weapon.GetStat('type') == 'AAMG' or unit.stats['class'] in AA_CLASSES:
					aa_weapons += 1
		
		results = False
		
		# do each plane attack seperately, select and resolve each attack
		for unit in plane_unit_list:
			
			# seems to help with spinning wheel of death
			libtcod.console_flush()
			FlushKeyboardEvents()
			
			continue_attack_mod = 0.0
			
			attack_finished = False
			while not attack_finished:
				
				libtcod.console_flush()
				FlushKeyboardEvents()
			
				# choose a random target hex
				map_hex = choice(target_hex_list)
				
				# no targets left in his hex
				if len(map_hex.unit_stack) == 0:
					if GetPercentileRoll() - continue_attack_mod <= 55.0:
						attack_finished = True
					continue
				
				# choose a random target within the hex and move to top of stack
				target = choice(map_hex.unit_stack)
				target.MoveToTopOfStack()
				scenario.UpdateUnitCon()
				scenario.UpdateScenarioDisplay()
				
				# choose a random weapon system to use for this attack
				weapon = choice(unit.weapon_list)
				
				(x2, y2) = self.PlotHex(map_hex.hx, map_hex.hy)
				
				# animation from below
				if y2 <= 30:
					y = y2 + 12
					if y > 51: y = 51
					y2 += 1
					direction = -1
				
				# animation from above
				else:
					y = y2 - 12
					if y < 9: y = 9
					y2 -= 1
					direction = 1
				
				# determine attack direction and attack position
				(x2, y2) = self.PlotHex(map_hex.hx, map_hex.hy - direction)
				
				# create air attack animation and let animation run
				self.animation['air_attack'] = GeneratePlaneCon(direction)
				self.animation['air_attack_line'] = GetLine(x2, y, x2, y2)
				PlaySoundFor(unit, 'plane_incoming')
				while not self.animation['air_attack_arrived']:
					libtcod.console_flush()
					CheckForAnimationUpdate()
				
				# check for AA attacks if any
				if aa_weapons > 0:
					chance = float(aa_weapons) * 1.0
					roll = GetPercentileRoll()
					
					if roll <= chance:
						PlaySound('lmg_firing_high')
						ShowMessage('The attacking aircraft was driven off by AA fire!')
						
						# clear airplane depiction and end attack
						self.animation['air_attack'] = None
						self.animation['air_attack_arrived'] = False
						libtcod.console_flush()
						CheckForAnimationUpdate()
						attack_finished = True
						continue
				
				# set new animation locations on map
				(x, y) = self.PlotHex(map_hex.hx, map_hex.hy - direction)
				(x2, y2) = self.PlotHex(map_hex.hx, map_hex.hy)
				
				# do attack sounds and animations
				if weapon.stats['type'] == 'Ordinance':
					PlaySoundFor(None, 'stuka_divebomb')
					self.animation['bomb_effect'] = (x2, y2)
					self.animation['bomb_effect_lifetime'] = 10
					while self.animation['bomb_effect'] is not None:
						libtcod.console_flush()
						CheckForAnimationUpdate()
				
				elif weapon.stats['type'] == 'MG':
					PlaySoundFor(weapon, 'fire')
					scenario.animation['small_arms_fire_action'] = True
					scenario.animation['small_arms_fire_line'] = GetLine(x,y,x2,y2)
					scenario.animation['small_arms_lifetime'] = 12
					while scenario.animation['small_arms_fire_action']:
						libtcod.console_flush()
						CheckForAnimationUpdate()
				
				elif weapon.stats['type'] == 'Rockets':
					PlaySoundFor(weapon, 'fire')
					scenario.animation['canister_fire'] = GetLine(x,y,x2,y2)[0]
					scenario.animation['canister_fire_lifetime'] = 11
					while scenario.animation['canister_fire']:
						libtcod.console_flush()
						CheckForAnimationUpdate()
					PlaySoundFor(weapon, 'he_explosion')
					scenario.animation['bomb_effect'] = (x2, y2)
					scenario.animation['bomb_effect_lifetime'] = 7
					while scenario.animation['bomb_effect']:
						libtcod.console_flush()
						CheckForAnimationUpdate()
					
				elif weapon.stats['type'] == 'Cannon':
					PlaySoundFor(weapon, 'fire')
					scenario.animation['gun_fire_active'] = True
					scenario.animation['gun_fire_line'] = GetLine(x,y,x2,y2)
					while scenario.animation['gun_fire_active']:
						libtcod.console_flush()
						CheckForAnimationUpdate()
					PlaySoundFor(weapon, 'he_explosion')
					scenario.animation['bomb_effect'] = (x2, y2)
					scenario.animation['bomb_effect_lifetime'] = 7
					while scenario.animation['bomb_effect']:
						libtcod.console_flush()
						CheckForAnimationUpdate()
				
				else:
					print('ERROR: Air unit weapon not recognized: ' + weapon.stats['type'])
					attack_finished = True
					continue
				
				# do attack roll
				if weapon.stats['type'] == 'MG':
					
					# calculate base FP and base effect chance
					fp = int(weapon.GetStat('fp'))
					
					if target.GetStat('category') == 'Vehicle':
						chance = VEH_FP_BASE_CHANCE
					else:
						chance = INF_FP_BASE_CHANCE
					for i in range(2, fp + 1):
						chance += FP_CHANCE_STEP * (FP_CHANCE_STEP_MOD ** (i-1)) 
					chance = round(chance, 1)
					
					if not target.spotted:
						chance -= 30.0
					if target.GetStat('category') == 'Infantry' and target.moving:
						chance += chance * 1.5
					if target.fortified:
						chance -= 50.0
					elif target.entrenched:
						chance -= 20.0
					elif target.dug_in:
						chance -= 10.0
					
					chance = round(chance, 1)
					roll = GetPercentileRoll()
					if roll <= 3.0:
						results = True
						target.fp_to_resolve += (fp * 2)
						target.hit_by_fp = True
						target.ResolveFP()
						continue_attack_mod += 15.0
					elif roll <= chance:
						results = True
						target.fp_to_resolve += fp
						target.hit_by_fp = True
						target.ResolveFP()
						continue_attack_mod += 5.0
					else:
						target.PinTest(4)
				
				# bombs, rockets, or cannon
				else:
					
					if weapon.GetStat('type') == 'Cannon':
						calibre = int(weapon.GetStat('calibre'))
						if calibre <= 30:
							effective_fp = 8
						elif calibre <= 75:
							effective_fp = 12
						else:
							effective_fp = 16
					else:
					
						# determine effective fp
						for (calibre, effective_fp) in HE_FP_EFFECT:
							if calibre <= int(weapon.stats['calibre']):
								break
					
					# calculate basic to-hit score required
					if not target.spotted:
						chance = PF_BASE_CHANCE[0][1]
					else:
						if target.GetStat('category') == 'Vehicle':
							chance = PF_BASE_CHANCE[0][0]
						else:
							chance = PF_BASE_CHANCE[0][1]
				
					# target size modifier
					size_class = target.GetStat('size_class')
					if size_class is not None:
						if size_class != 'Normal':
							chance += PF_SIZE_MOD[size_class]
					
					# smoke or dust modifier
					if target.smoke >= 2:
						chance -= 30.0
					elif target.dust >= 2:
						chance -= 20.0
					elif target.smoke == 1:
						chance -= 15.0
					elif target.dust == 1:
						chance -= 10.0
					
					# bombs are less accurate
					if weapon.stats['type'] == 'Ordinance':
						chance = round(chance * 0.5, 1)
					chance = RestrictChance(chance)
					roll = GetPercentileRoll()
					
					# chance that a miss will still reveal a concealed unit
					if roll > chance:
						target.PinTest(8)
						if GetPercentileRoll() <= MISSED_FP_REVEAL_CHANCE:
							target.hit_by_fp = True
					else:
						
						# hit
						results = True
						
						# roll for direct hit / near miss
						direct_hit = False
						chance = DIRECT_HIT_CHANCE
						if weapon.stats['type'] in ['Rockets', 'Cannon']:
							chance += 15.0
						roll = GetPercentileRoll()
						if roll <= chance:
							direct_hit = True
						else:
							effective_fp = int(effective_fp / 2)
						
						# infantry, cavalry, or gun target
						if target.GetStat('category') in ['Infantry', 'Cavalry', 'Gun']:
							
							# direct hit: destroyed
							if direct_hit:
								if target == scenario.player_unit:
									text = 'You were'
								else:
									text = target.GetName() + ' was'
								text += ' destroyed by a direct hit from the air attack!'
								ShowMessage(text, scenario_highlight=(target.hx, target.hy))
								target.DestroyMe()
								continue_attack_mod += 15.0
							
							# near miss
							else:
							
								target.fp_to_resolve += effective_fp
								target.hit_by_fp = True
								if target == scenario.player_unit:
									text = 'You were'
								else:
									text = target.GetName() + ' was'
								text += ' hit by the air attack.'
								ShowMessage(text, scenario_highlight=(target.hx, target.hy))
								target.ResolveFP()
								continue_attack_mod += 10.0
						
						# vehicle target
						elif target.GetStat('category') == 'Vehicle':
							
							# near miss - only applies FP if not a bomb or a rocket
							if not direct_hit and weapon.stats['type'] not in ['Ordinance', 'Rockets']:
								target.fp_to_resolve += effective_fp
								target.hit_by_fp = True
								if target == scenario.player_unit:
									text = 'You were'
								else:
									text = target.GetName() + ' was'
								text += ' hit by the air attack.'
								ShowMessage(text, scenario_highlight=(target.hx, target.hy))
								target.ResolveFP()
								continue_attack_mod += 10.0
							
							# direct hit: unarmoured and open topped vehicles destroyed
							elif direct_hit and (target.GetStat('armour') is None or target.GetStat('open_topped') is not None):
								if target == scenario.player_unit:
									text = 'You were'
								else:
									text = target.GetName() + ' was'
								text += ' destroyed by a direct hit from the air attack.'
								ShowMessage(text, scenario_highlight=(target.hx, target.hy))
								target.DestroyMe()
								continue_attack_mod += 20.0
							
							else:
							
								# armoured vehicle target
								# create an attack profile for the AP calculation
								profile = {}
								profile['attacker'] = unit
								profile['weapon'] = weapon
								profile['overrun'] = False
								if weapon.stats['name'] in ['Bombs', 'Rockets']:
									profile['ammo_type'] = 'HE'
								else:
									profile['ammo_type'] = weapon.stats['ammo_type_list'][0]	
								profile['target'] = target
								
								if direct_hit:
									profile['result'] = 'CRITICAL HIT'
								else:
									profile['result'] = 'HIT'
								
								profile['ballistic_attack'] = False
								if weapon.stats['name'] == 'Bombs':
									profile['ballistic_attack'] = True
								
								# determine location hit
								if profile['ballistic_attack']:
									chance = 30.0
								else:
									chance = 50.0
								if GetPercentileRoll() <= chance:
									profile['location'] = 'Hull'
								else:
									profile['location'] = 'Turret'
								
								profile = self.CalcAP(profile, air_attack=True)
								
								# do AP roll
								if GetPercentileRoll() > profile['final_chance']:
									if target == scenario.player_unit:
										text = 'You were'
									else:
										text = target.GetName() + ' was'
									text += ' unaffected by the air attack'
									ShowMessage(text, scenario_highlight=(target.hx, target.hy))
								else:
								
									# penetrated
									if target == scenario.player_unit:
										text = 'Your vehicle was'
									else:
										text = target.GetName() + ' was'
									text += ' knocked out by the air attack.'
									ShowMessage(text, scenario_highlight=(target.hx, target.hy))
									target.DestroyMe()
									continue_attack_mod += 20.0
				
				# increase Steam stat if appropriate
				if not player_target and not friendly_fire and not target.alive:
					session.ModifySteamStat('dest_air_arty', 1)
					
				# clear airplane depiction
				self.animation['air_attack'] = None
				self.animation['air_attack_arrived'] = False
				libtcod.console_flush()
				CheckForAnimationUpdate()
				
				# roll to see if attack ends here
				if friendly_fire:
					continue_attack_mod += 10.0
				
				roll = GetPercentileRoll() - continue_attack_mod
				if roll <= 55.0:
					attack_finished = True
				else:
					continue_attack_mod += 5.0
		
		if not results:
			ShowMessage('Air attack had no effect.')
		
		# clean up
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		libtcod.console_flush()
		

	# resolve an artillery attack
	# if player_target is true, the player squad is the target of an enemy attack
	# if friendly_fire is true, attack is against target's own forces
	# if naval_only is true, attack will be aborted if a ship unit is randomly selected
	def DoArtilleryAttack(self, player_target=False, friendly_fire=False, naval_only=False):
		
		# determine artillery unit(s) to spawn
		unit_list = None
		if player_target:
			if friendly_fire:
				target_player = 1
			else:
				target_player = 0
			
			nation_list = list(campaign.stats['enemy_arty_support'])
			shuffle(nation_list)
			for nation in nation_list:
				if nation in campaign.current_week['enemy_nations']:
					unit_list = campaign.stats['enemy_arty_support'][nation]
					break
			
			# could not find an appropriate artillery list
			if unit_list is None:
				return
		else:
			if friendly_fire:
				target_player = 0
			else:
				target_player = 1
			unit_list = campaign.stats['player_arty_support']
		
		# select the gun unit
		unit_id = None
		for tries in range(300):
			possible_id = choice(unit_list)
			if naval_only:
				if session.unit_types[possible_id]['class'] != 'Ship':
					continue
			if not campaign.DoRarityCheck(possible_id):
				continue
			unit_id = possible_id
			break
		
		# unable to find a suitable unit
		if unit_id is None: return
		
		if friendly_fire:
			if player_target:
				friendly_player = 0
			else:
				friendly_player = 1
		else:
			if player_target:
				friendly_player = 1
			else:
				friendly_player = 0
		
		# spawn gun unit and determine effective FP
		gun_unit = Unit(unit_id, owning_player=friendly_player)
		gun_calibre = int(gun_unit.weapon_list[0].GetStat('calibre'))
		naval_attack = False
		if gun_unit.GetStat('class') == 'Ship':
			naval_attack = True
		
		if friendly_fire:
			if player_target:
				ShowMessage('Enemy artillery forces fire a bombardment, but they have been given incorrect coordinates and fire on their own forces!',
					good_news=True)
			else:
				ShowMessage('Artillery support attack inbound, but they have been given incorrect coordinates and fire on your location!',
					good_news=False)
		else:
			if player_target:
				ShowMessage('Enemy artillery forces fire a bombardment!',
					good_news=False)
			else:
				ShowMessage('Artillery support attack inbound! Firing spotting rounds.')
		
		# if player is the target, crewmen roll against Perception to button up or hunker down
		if player_target:
			self.player_unit.CrewButtonUpCheck()
		
		# try to do an attack on every hex with a target unit in it, skip outermost ring though
		target_hex_list = []
		for map_hex in self.map_hexes:
			if len(map_hex.unit_stack) == 0: continue
			if map_hex.unit_stack[0].owning_player != target_player: continue
			if GetHexDistance(0, 0, map_hex.hx, map_hex.hy) > 3: continue
			
			# display spotting round animation
			(x, y) = self.PlotHex(map_hex.hx, map_hex.hy)
			for i in range(libtcod.random_get_int(0, 1, 2)):
				libtcod.console_flush()
				FlushKeyboardEvents()
				xm = 3 - libtcod.random_get_int(0, 0, 6)
				ym = 3 - libtcod.random_get_int(0, 0, 6)
				PlaySoundFor(gun_unit, 'he_explosion')
				self.animation['bomb_effect'] = (x+xm, y+ym)
				self.animation['bomb_effect_lifetime'] = 2
				while self.animation['bomb_effect'] is not None:
					libtcod.console_flush()
					CheckForAnimationUpdate()
			
			# calculate base spotting chance and add weather modifiers
			chance = 95.0
			if campaign_day.weather['Precipitation'] in ['Rain', 'Snow']:
				chance -= 15.0
			elif campaign_day.weather['Precipitation'] in ['Heavy Rain', 'Blizzard']:
				chance -= 30.0
			if campaign_day.weather['Fog'] > 0:
				chance -= 10.0
			
			if friendly_fire:
				chance += 20.0
			if naval_attack:
				chance += 10.0
			
			if GetPercentileRoll() > chance: continue
			
			target_hex_list.append(map_hex)
		
		# no possible targets
		if len(target_hex_list) == 0:
			ShowMessage('No targets spotted, ending attack.')
			return
		
		# spotter may report unit identity to player
		if not player_target and not friendly_fire:
			for map_hex in target_hex_list:
				for unit2 in map_hex.unit_stack:
					if unit2.spotted: continue
					if campaign_day.hq_radio_comms:
						if libtcod.random_get_int(0, 1, 5) == 1: continue
					else:
						if libtcod.random_get_int(0, 1, 3) == 1: continue
					unit2.SpotMe()
					scenario.UpdateUnitCon()
					scenario.UpdateScenarioDisplay()
					ShowMessage(unit2.GetName() + ' spotted by artillery support spotters!',
						portrait=unit2, scenario_highlight=(unit2.hx, unit2.hy))
		
		ShowMessage('Targets spotted, ' + unit_id + ' guns firing for effect.', 
			portrait=gun_unit.GetStat('portrait'))
		
		# display bombardment animation
		for map_hex in target_hex_list:
			libtcod.console_flush()
			# seems to help with spinning wheel of death
			FlushKeyboardEvents()
			(x, y) = self.PlotHex(map_hex.hx, map_hex.hy)
			
			if naval_attack:
				effect_num = libtcod.random_get_int(0, 3, 4)
			else:
				effect_num = libtcod.random_get_int(0, 2, 3)
			for i in range(effect_num):
				libtcod.console_flush()
				xm = 3 - libtcod.random_get_int(0, 0, 6)
				ym = 3 - libtcod.random_get_int(0, 0, 6)
				PlaySoundFor(gun_unit, 'he_explosion')
				self.animation['bomb_effect'] = (x+xm, y+ym)
				self.animation['bomb_effect_lifetime'] = 2
				while self.animation['bomb_effect'] is not None:
					libtcod.console_flush()
					CheckForAnimationUpdate()
		
		# determine effective fp for weapon
		for (calibre, effective_fp) in HE_FP_EFFECT:
			if calibre <= gun_calibre:
				break
		effective_fp = int(effective_fp / 2)
		
		# determine campaign skill modifier if any
		skill_mod = 0
		soft_target_mod = 0
		if not player_target:
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Centralized Fire'):
				skill_mod = 15.0
			if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Combined Bombardment'):
				soft_target_mod = 25.0
		
		# roll for possible hit against each unit in each target hex
		results = False
		for map_hex in target_hex_list:
			for target in map_hex.unit_stack:
				if not target.alive: continue
				
				# calculate base effect chance
				if target.GetStat('category') == 'Vehicle':
					chance = VEH_FP_BASE_CHANCE
				else:
					chance = INF_FP_BASE_CHANCE
				for i in range(2, effective_fp + 1):
					chance += FP_CHANCE_STEP * (FP_CHANCE_STEP_MOD ** (i-1)) 
				
				chance = RestrictChance(round(chance * 0.5, 1))
				
				# apply campaign skill modifiers if any
				chance += skill_mod
				if target.GetStat('category') in ['Infantry', 'Cavalry', 'Gun']:
					chance += soft_target_mod
				
				roll = GetPercentileRoll()
				
				# naval bombardment allows a re-roll
				if roll > chance and naval_attack:
					roll = GetPercentileRoll()
				
				# no effect
				if roll > chance:
					# chance that a miss will still reveal a concealed unit
					if GetPercentileRoll() <= MISSED_FP_REVEAL_CHANCE:
						target.hit_by_fp = True
					continue
				
				results = True
				
				# move target unit to top of hex stack and update screen
				target.MoveToTopOfStack()
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				
				# set artillery location on map
				gun_unit.hx = target.hx
				gun_unit.hy = target.hy+4
				
				# roll for direct hit / near miss
				direct_hit = False
				if GetPercentileRoll() <= DIRECT_HIT_CHANCE:
					direct_hit = True
				
				# infantry, cavalry, or gun target hit
				if target.GetStat('category') in ['Infantry', 'Cavalry', 'Gun']:
					
					# direct hit: destroyed
					if direct_hit:
						if target == scenario.player_unit:
							text = 'You were'
						else:
							text = target.GetName() + ' was'
						text += ' destroyed by a direct hit from the artillery attack.'
						ShowMessage(text, scenario_highlight=(target.hx, target.hy))
						target.DestroyMe()
						continue
					
					# near miss
					target.fp_to_resolve += effective_fp
					target.hit_by_fp = True
					
					if target == scenario.player_unit:
						text = 'You were'
					else:
						text = target.GetName() + ' was'
					text += ' hit by artillery attack.'
					ShowMessage(text, scenario_highlight=(target.hx, target.hy))
					
					target.ResolveFP()
				
				# vehicle hit
				elif target.GetStat('category') == 'Vehicle':
					
					# near miss - only applies FP
					if not direct_hit:
						
						target.fp_to_resolve += effective_fp
						target.hit_by_fp = True
						
						if target == scenario.player_unit:
							text = 'You were'
						else:
							text = target.GetName() + ' was'
						text += ' nearly hit by the artillery attack.'
						ShowMessage(text, scenario_highlight=(target.hx, target.hy))
						
						target.ResolveFP()
						
						# player crewmen might be shaken by attack
						if target == scenario.player_unit:
							for position in target.positions_list:
								if position.crewman is None: continue
								if position.crewman.condition != 'Good Order': continue
								if position.crewman.DoMoraleCheck(-10): continue
								position.crewman.condition = 'Shaken'
								ShowMessage('The nearby explosion has shaken your crewman:',
									crewman=position.crewman, good_news=False)
						
						continue
					
					# direct hit
					
					# unarmoured and open topped vehicles destroyed
					if target.GetStat('armour') is None or target.GetStat('open_topped') is not None:
						if target == scenario.player_unit:
							text = 'You were'
						else:
							text = target.GetName() + ' was'
						text += ' destroyed by a direct hit from the artillery attack.'
						ShowMessage(text, scenario_highlight=(target.hx, target.hy))
						target.DestroyMe()
						continue
					
					# otherwise, calculate an AP hit on the top armour
					# create an attack profile for the AP calculation
					profile = {}
					profile['attacker'] = gun_unit
					profile['weapon'] = gun_unit.weapon_list[0]
					profile['ammo_type'] = 'HE'
					profile['target'] = target
					profile['result'] = 'CRITICAL HIT'
					profile['ballistic_attack'] = True
					profile['overrun'] = False
					
					# determine location hit
					if GetPercentileRoll() <= 50.0:
						profile['location'] = 'Hull'
					else:
						profile['location'] = 'Turret'
					
					profile = self.CalcAP(profile)
												
					# do AP roll
					roll = GetPercentileRoll()
					
					# no penetration
					if roll > profile['final_chance']:
						if target == scenario.player_unit:
							text = 'You were hit by the artillery attack but your tank was not damaged.'
						else:
							text = target.GetName() + ' was hit by the artillery attack but remains unharmed.'
						ShowMessage(text, scenario_highlight=(target.hx, target.hy))
						
						# calculate and apply effective FP
						profile = gun_unit.CalcHEEffectiveFP(profile)
						target.fp_to_resolve += profile['effective_fp']
						target.hit_by_fp = True
						target.ResolveFP()
						
						# player crew may get shaken by the impact
						if target == scenario.player_unit:
							for position in target.positions_list:
								if position.crewman is None: continue
								if position.crewman.condition != 'Good Order': continue
								if position.crewman.DoMoraleCheck(-50): continue
								position.crewman.condition = 'Shaken'
								ShowMessage('The impact has shaken your crewman:',
									crewman=position.crewman, good_news=False)
						
						continue
					
					# penetrated
					if target == scenario.player_unit:
						text = 'You were'
					else:
						text = target.GetName() + ' was'
					text += ' destroyed by artillery attack'
					ShowMessage(text, scenario_highlight=(target.hx, target.hy))
					target.DestroyMe()
				
				if not target.alive:
					session.ModifySteamStat('dest_air_arty', 1)
		
		if not results:
			ShowMessage('Artillery attack had no effect.')
	
	
	# execute a player move forward/backward, repositioning other units on the hex map as needed
	def MovePlayer(self, forward, reposition=False):
		
		target_terrain = None
		
		if reposition:
			if not self.player_unit.overrun:
				target_terrain = self.ShowRepositionMenu()
				if target_terrain == ('Cancel', 0.0): return
		
		else:
		
			# check for double bog check 
			if 'Double Bog Check' in SCENARIO_TERRAIN_EFFECTS[self.player_unit.terrain]:
				# FUTURE: check for squad units too
				for unit in self.units:
					if unit != self.player_unit: continue
					unit.DoBogCheck(forward)
			
			# notify player and update consoles if player bogged
			if self.player_unit.bogged:
				ShowMessage('Your vehicle has become bogged down.', good_news=False)
				self.UpdatePlayerInfoCon()
				self.UpdateUnitCon()
				self.advance_phase = True
				return
		
		# do sound effect
		PlaySoundFor(self.player_unit, 'movement')
		
		# set statuses and reset facing for squadmates
		self.player_unit.moving = True
		
		for unit in scenario.player_unit.squad:
			unit.moving = True
			if unit.facing is not None:
				unit.facing = 0
				for weapon in unit.weapon_list:
					weapon.UpdateCoveredHexes()
			unit.DoLandmineCheck()
		
		# player landmine check
		if self.player_unit.DoLandmineCheck():
			self.UpdatePlayerInfoCon()
			self.advance_phase = True
			return
		
		# move may be cancelled by breakdown
		self.player_unit.BreakdownCheck(reposition=reposition)
		if self.player_unit.immobilized:
			self.UpdatePlayerInfoCon()
			ShowMessage('Your vehicle has completely broken down - it is now immobilized.',
				longer_pause=True, good_news=False)
			self.advance_phase = True
			return
		if self.player_unit.broken_down:
			self.UpdatePlayerInfoCon()
			ShowMessage('Your vehicle has broken down - it will be immobile for the remainder of the battle.',
				longer_pause=True, good_news=False)
			self.advance_phase = True
			return
		
		if not reposition:
		
			# do move success roll
			if forward:
				chance = scenario.player_unit.forward_move_chance
			else:
				chance = scenario.player_unit.reverse_move_chance
			roll = GetPercentileRoll()
			
			# check for crew action modifier
			for position in COMMANDER_POSITIONS:
				crewman = self.player_unit.GetPersonnelByPosition(position)
				if crewman is None: continue
				if crewman.current_cmd == 'Direct Movement':
					
					mod_applied = False
					
					# check for skill modifiers
					modifier = crewman.GetSkillMod('Forward!', 7.0)
					if forward and modifier is not None:
						chance += modifier
						mod_applied = True
					
					modifier = crewman.GetSkillMod('Driver Direction', 5.0)
					if not mod_applied and modifier is not None:
						chance += modifier
						mod_applied = True
					
					if not mod_applied:					
						modifier = crewman.GetActionMod(3.0)
						if not crewman.ce: modifier = modifier * 0.5
						chance += modifier
				break
			
			# check for driver / rear driver skill
			if not forward and self.player_unit.GetPersonnelByPosition('Rear Driver') is not None:
				crewman = self.player_unit.GetPersonnelByPosition('Rear Driver')
			else:
				crewman = self.player_unit.GetPersonnelByPosition('Driver')
			if crewman is not None:
				modifier = crewman.GetSkillMod('Lightning Shifter', 15.0)
				if modifier is not None:
					chance += modifier
				else:
					modifier = crewman.GetSkillMod('Quick Shifter', 5.0)
					if modifier is not None:
						chance += modifier
				
				# check for driver being CE
				if crewman.ce:
					chance += 10.0
			
			# check for debug flag
			if DEBUG:
				if session.debug['Player Always Moves']:
					roll = 1.0
		
			# move was not successful
			if roll > chance:
				
				# if player pivoted, reset move bonus
				if self.player_pivot != 0:
					if forward:
						self.player_unit.reverse_move_bonus = 0.0
						self.player_unit.forward_move_bonus = BASE_MOVE_BONUS
					else:
						self.player_unit.forward_move_bonus = 0.0
						self.player_unit.reverse_move_bonus = BASE_MOVE_BONUS
				
				# clear any alternative bonus and apply bonus for future moves
				else:
					if forward:
						self.player_unit.reverse_move_bonus = 0.0
						self.player_unit.forward_move_bonus += BASE_MOVE_BONUS
					else:
						self.player_unit.forward_move_bonus = 0.0
						self.player_unit.reverse_move_bonus += BASE_MOVE_BONUS
				
				# show pop-up message to player
				ShowMessage('You move but not far enough to enter a new map hex')
				
				# set new terrain and LoS for player and squad
				for unit in self.units:
					if unit != self.player_unit and unit not in self.player_unit.squad: continue
					unit.GenerateTerrain()
					self.GenerateUnitLoS(unit)
					unit.CheckForHD()
				
				# clear acquired targets
				self.player_unit.ClearAcquiredTargets(movement=True)
				for unit in scenario.player_unit.squad:
					unit.ClearAcquiredTargets()
				
				self.advance_phase = True
				return
		
			# move was successful, clear all bonuses
			self.player_unit.forward_move_bonus = 0.0
			self.player_unit.reverse_move_bonus = 0.0
			self.player_unit.hd_attempt_bonus = 0.0
			
			# calculate new hex positions for each unit in play
			if forward:
				direction = 3
			else:
				direction = 0
			
			# run through list of non-player squad units and plot their ideal move
			# player movement will not normally move a unit into ring 4 nor off board
			# if this would prevent another unit from moving, however, the game will do so
			for unit in self.units:
				if unit == self.player_unit: continue
				if unit in self.player_unit.squad: continue
				if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
				
				(new_hx, new_hy) = GetAdjacentHex(unit.hx, unit.hy, direction)
				
				# special case: enemy units jump over player hex 0,0
				jump = False
				if new_hx == 0 and new_hy == 0 and unit.owning_player == 1:
					(new_hx, new_hy) = GetAdjacentHex(0, 0, direction)
					jump = True
				
				# set destination hex
				unit.dest_hex = (new_hx, new_hy)
				
				# calculate animation locations
				(x1, y1) = self.PlotHex(unit.hx, unit.hy)
				(x2, y2) = self.PlotHex(new_hx, new_hy)
				unit.animation_cells = GetLine(x1, y1, x2, y2)
				
				# special case: unit is jumping over 0,0
				if jump:
					for i in range(12, 0, -2):
						unit.animation_cells.pop(i)
			
			# units that would be moved into ring 4 or off board will avoid doing so if possible
			for unit in self.units:
				if unit == self.player_unit: continue
				if unit in self.player_unit.squad: continue
				if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
				
				(new_hx, new_hy) = unit.dest_hex
				if GetHexDistance(0, 0, new_hx, new_hy) <= 3: continue
					
				(hx2, hy2) = GetAdjacentHex(unit.hx, unit.hy, ConstrainDir(direction + 3))
				
				# no units that would need to move into this hex; cancel move
				if len(self.hex_dict[(hx2,hy2)].unit_stack) == 0:
					unit.dest_hex = None
					unit.animation_cells = []
					continue
				
				# units that need to move into this hex are friendly; cancel move
				if self.hex_dict[(hx2,hy2)].unit_stack[0].owning_player == unit.owning_player:
					unit.dest_hex = None
					unit.animation_cells = []
					continue
			
			# special case: possible for enemy unit(s) in 0,-1 or 0,1 to jump over 0,0 and end up in same hex
			# as a friendly unit that was in 0,0 and has now moved to 0,-1 or 0,1. In these cases,
			# don't move the friendly unit (essentially it moves with the player)
			for unit in self.units:
				if unit.hx != 0 and unit.hy not in [-1, 1]: continue
				if unit.owning_player != 1: continue
				if unit.dest_hex is None: continue
				if unit.dest_hex not in [(0,-1), (0,1)]: continue
				
				for unit2 in self.units:
					if unit2.owning_player != 0: continue
					if unit2.dest_hex is None: continue
					
					# unit2 is going to move into same hex as this unit, cancel unit2 move
					if unit2.dest_hex == unit.dest_hex:
						unit2.dest_hex = None
						unit2.animation_cells = []
			
			# animate movement
			for i in range(6):
				for unit in self.units:
					if unit == self.player_unit: continue
					if unit in self.player_unit.squad: continue
					if unit.dest_hex is None: continue
					if len(unit.animation_cells) > 0:
						unit.animation_cells.pop(0)
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				Wait(15)
			
			# set new hex location for each moving unit and move into new hex stack
			for unit in self.units:
				if unit.dest_hex is None: continue
				
				# sanity check
				if unit in self.hex_dict[(unit.hx, unit.hy)].unit_stack:
					self.hex_dict[(unit.hx, unit.hy)].unit_stack.remove(unit)
				
				(unit.hx, unit.hy) = unit.dest_hex
				
				# unit is still on map (or in invisible extra ring)
				if GetHexDistance(0, 0, unit.hx, unit.hy) <= 4:
					self.hex_dict[(unit.hx, unit.hy)].unit_stack.append(unit)
				
				# clear destination hex and animation data
				unit.dest_hex = None
				unit.animation_cells = []
				
				# update unit's weapons' covered hexes (mainly for defensive fire attacks)
				for weapon in unit.weapon_list:
					weapon.UpdateCoveredHexes()
		
		# if Drive Into Terrain command is active, allow player to choose target terrain type after a move
		if not reposition and not self.player_unit.overrun:
			if not forward and self.player_unit.GetPersonnelByPosition('Rear Driver') is not None:
				crewman = self.player_unit.GetPersonnelByPosition('Rear Driver')
			else:
				crewman = self.player_unit.GetPersonnelByPosition('Driver')
			if crewman is not None:
				if crewman.current_cmd == 'Drive Into Terrain':
					target_terrain = self.ShowRepositionMenu(allow_cancel=False)
		
		# set new terrain, generate new LoS for player and squad
		for unit in self.units:
			if unit != self.player_unit and unit not in self.player_unit.squad: continue
			unit.GenerateTerrain(target_terrain=target_terrain)
			self.GenerateUnitLoS(unit)
			unit.CheckForHD()
			unit.SetSmokeDustLevel()
		
		# clear acquired targets
		self.player_unit.ClearAcquiredTargets(movement=True)
		for unit in scenario.player_unit.squad:
			unit.ClearAcquiredTargets()
		
		# show message if player repositioned and is not going on an overrun attack
		if reposition and not self.player_unit.overrun:
			text = 'You move to a new location within the same hex.'
			if self.player_unit.terrain is not None:
				text += ' New terrain: ' + self.player_unit.terrain
			ShowMessage(text, longer_pause=True)
		
		self.UpdatePlayerInfoCon()
		self.UpdateUnitInfoCon()
		self.UpdateUnitCon()
		
		# recalculate move chances and do bog check in new location
		for unit in self.units:
			if unit != self.player_unit: continue
			unit.CalculateMoveChances()
			unit.DoBogCheck(forward, reposition=reposition)
		
		# notify player and update consoles if player bogged
		if self.player_unit.bogged:
			ShowMessage('Your vehicle has become bogged down.', good_news=False)
			self.UpdatePlayerInfoCon()
			self.UpdateUnitCon()
			self.advance_phase = True
			return
		
		# check for extra move
		if self.player_unit.ExtraMoveCheck(forward=forward):
			ShowMessage('You have moved swiftly enough to take another move action.',
				good_news=True)
			return
		self.advance_phase = True
	
	
	# display a list of possible target terrain types for Reposition action
	def ShowRepositionMenu(self, allow_cancel=True):
		
		def DrawMenu():
			libtcod.console_clear(menu_con)
			libtcod.console_set_default_foreground(menu_con, libtcod.grey)
			DrawFrame(menu_con, 0, 0, 43, 36)
			libtcod.console_set_default_foreground(menu_con, TITLE_COL)
			libtcod.console_print_ex(menu_con, 22, 2, libtcod.BKGND_NONE, libtcod.CENTER,
				'Target Terrain')
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			libtcod.console_print(menu_con, 3, 5, 'Terrain Type')
			libtcod.console_print(menu_con, 27, 5, 'TEM')
			libtcod.console_print(menu_con, 32, 5, 'Chance')
			
			y = 8
			n = 0
			libtcod.console_set_default_foreground(menu_con, libtcod.white)
			for (terrain, odds) in terrain_list:
				libtcod.console_print(menu_con, 3, y, terrain)
				
				text = '0.0'
				if 'TEM' in SCENARIO_TERRAIN_EFFECTS[terrain]:
					if 'All' in SCENARIO_TERRAIN_EFFECTS[terrain]['TEM']:
						text = str(SCENARIO_TERRAIN_EFFECTS[terrain]['TEM']['All'])
					elif 'Vehicle' in SCENARIO_TERRAIN_EFFECTS[terrain]['TEM']:
						text = str(SCENARIO_TERRAIN_EFFECTS[terrain]['TEM']['Vehicle'])
				libtcod.console_print_ex(menu_con, 30, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, text + '%')
				libtcod.console_print_ex(menu_con, 37, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(odds) + '%')
				
				if n == selected_choice:
					libtcod.console_set_default_background(menu_con, HIGHLIGHT_MENU_COL)
					libtcod.console_rect(menu_con, 3, y, 35, 1, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(menu_con, libtcod.black)
				y += 1
				n += 1
			
			# display inputs
			if gamepad is not None:
				DisplayButton(menu_con, 12, 31, GAMEPADCHAR_DPAD_UD)
				DisplayButton(menu_con, 12, 32, GAMEPADCHAR_A)
				if allow_cancel:
					DisplayButton(menu_con, 12, 33, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(menu_con, ACTION_KEY_COL)
				libtcod.console_print(menu_con, 9, 31, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(menu_con, 9, 32, 'Tab')
				if allow_cancel:
					libtcod.console_print(menu_con, 9, 33, 'Esc')
			
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			libtcod.console_print(menu_con, 14, 31, 'Select Target Terrain')
			libtcod.console_print(menu_con, 14, 32, 'Proceed')
			if allow_cancel:
				libtcod.console_print(menu_con, 14, 33, 'Cancel Reposition')
			
			libtcod.console_blit(menu_con, 0, 0, 0, 0, con, 24, 12)
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# build list of possible terrain types and odds of getting each
		terrain_list = []
		odds_dict = CD_TERRAIN_TYPES[scenario.cd_map_hex.terrain_type]['scenario_terrain_odds']
		for k, v in odds_dict.items():
			
			# don't allow repositioning into impossible terrain
			if campaign.stats['region'] == 'North Africa':
				if k in ['Woods', 'Wooden Buildings', 'Fields', 'Marsh']: continue
			
			odds = v * 2.0
			
			# apply skill modifiers here
			if self.player_unit.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Instinct for Terrain'):
				odds += 25.0
			elif self.player_unit.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Eye for Terrain'):
				odds += 15.0
			
			# apply highest commander skill modifier
			for position in COMMANDER_POSITIONS:
				crewman = self.player_unit.GetPersonnelByPosition(position)
				if crewman is None: continue
				modifier = crewman.GetSkillMod('Prepared Positions', 20.0)
				if modifier is not None:
					odds += modifier 
				elif crewman.current_cmd == 'Direct Movement':
					modifier = crewman.GetActionMod(10.0)
					if modifier > 0.0:
						odds += modifier
				break
			
			if odds > 97.0:
				odds = 97.0
			
			terrain_list.append((k, odds))
		
		# create a local copy of the current screen to re-draw when we're done
		temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
		libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
		
		# darken background 
		libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.5)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# create display console
		menu_con = NewConsole(43, 36, libtcod.black, libtcod.white)
		
		selected_choice = 0
		result = None
		
		# draw menu for first time
		DrawMenu()
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# cancel reposition
			if allow_cancel and (key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1):
				result = ('Cancel', 0.0)
				exit_menu = True
				PlaySoundFor(None, 'menu_select')
				continue
			
			# proceed
			elif key.vk in [sdl2.SDLK_TAB, sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
				result = terrain_list[selected_choice]
				exit_menu = True
				PlaySoundFor(None, 'menu_select')
				continue
			
			key_char = DeKey(chr(key.c).lower())
			
			# change selected terrain
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if selected_choice == 0:
						selected_choice = len(terrain_list) - 1
					else:
						selected_choice -= 1
				else:
					if selected_choice == len(terrain_list) - 1:
						selected_choice = 0
					else:
						selected_choice += 1
				
				DrawMenu()
				PlaySoundFor(None, 'menu_select')
				continue
		
		libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
		return result
	
	
	# pivot the hull of the player unit, rotating all other units around them
	def PivotPlayer(self, clockwise):
		
		if clockwise:
			r = 5
			f = -1
		else:
			r = 1
			f = 1
		
		# calculate new hex positions of units
		for unit in self.units:
			if unit == self.player_unit: continue
			if unit in self.player_unit.squad: continue
			unit.dest_hex = RotateHex(unit.hx, unit.hy, r)
		
		PlaySoundFor(None, 'player_pivot')
		
		# set new hex location for each unit outside of 0,0 and move into new hex stack
		for map_hex in self.map_hexes:
			if map_hex.hx == 0 and map_hex.hy == 0: continue
			if len(map_hex.unit_stack) == 0: continue
			for unit in reversed(map_hex.unit_stack):
				
				# already moved
				if unit.dest_hex is None: continue
				
				# set new location then clear their destination
				self.hex_dict[(unit.hx, unit.hy)].unit_stack.remove(unit)
				(unit.hx, unit.hy) = unit.dest_hex
				self.hex_dict[(unit.hx, unit.hy)].unit_stack.insert(0, unit)
				unit.dest_hex = None
			
				# pivot unit facings if any
				if unit.facing is not None:
					unit.facing = ConstrainDir(unit.facing + f)
				if unit.turret_facing is not None:
					unit.PivotTurretToFace(ConstrainDir(unit.turret_facing + f)) 
				
				# pivot unit HD if any
				if 0 < len(unit.hull_down) < 6:
					for i in range(3):
						unit.hull_down[i] = ConstrainDir(unit.hull_down[i] + f)
				
				# update unit's weapons' covered hexes (mainly for defensive fire attacks)
				for weapon in unit.weapon_list:
					weapon.UpdateCoveredHexes()
		
		# record player pivot
		self.player_pivot = ConstrainDir(self.player_pivot + f)
		
		# recalculate player move chances
		self.player_unit.CalculateMoveChances()
		
		self.UpdatePlayerInfoCon()
		self.UpdateContextCon()
		self.UpdateGuiCon()
		self.UpdateUnitCon()
		
		# pivot player HD if any
		if len(self.player_unit.hull_down) > 0:
			for i in range(3):
				self.player_unit.hull_down[i] = ConstrainDir(self.player_unit.hull_down[i] + f)
		
	
	# rotate turret of player unit
	def RotatePlayerTurret(self, clockwise):
		turret = self.player_unit.GetStat('turret')
		if turret is None: return
		if turret in ['FIXED', 'FXT']: return
		
		# no crewman on the correct order
		no_crewman_operating = True
		for position in self.player_unit.positions_list:
			if position.crewman is None: continue
			if position.location != 'Turret': continue
			if position.crewman.current_cmd in ['Operate Gun', 'Operate MG', 'Operate Flame Thrower']:
				no_crewman_operating = False
				break
		
		if no_crewman_operating:
			return
		
		# weapon on turret has already fired
		for weapon in self.player_unit.weapon_list:
			if not weapon.fired: continue
			mount = weapon.GetStat('mount')
			if mount is None: continue
			if mount != 'Turret': continue
			if weapon.GetStat('type') == 'AAMG' and weapon.GetStat('front_only') is None and weapon.GetStat('rear_facing') is None: continue
			
			# already fired, can't rotate turret again this turn
			return
		
		if clockwise:
			f = 1
		else:
			f = -1
		scenario.player_unit.turret_facing = ConstrainDir(scenario.player_unit.turret_facing + f)
		
		PlaySoundFor(None, 'player_turret')
		
		# update covered hexes for any turret-mounted weapons
		for weapon in scenario.player_unit.weapon_list:
			if weapon.GetStat('mount') != 'Turret': continue
			weapon.UpdateCoveredHexes()
			weapon.BuildTargetList()

		# move current target of current weapon to top of unit stack if required
		if scenario.selected_weapon is not None:
			if scenario.selected_weapon.GetStat('mount') == 'Turret' and scenario.selected_weapon.selected_target is not None:
				scenario.selected_weapon.selected_target.MoveToTopOfStack()

		self.UpdateUnitCon()
		self.UpdateGuiCon()
	
	
	# attempt to conceal oneself from or reveal oneself to an enemy unit
	def ConcealOrRevealPlayer(self):
		
		# update the console display and GUI overlay
		def UpdateScreen():
			
			libtcod.console_clear(attack_con)
			libtcod.console_blit(session.attack_bkg, 0, 0, 0, 0, attack_con, 0, 0)
			
			# menu title
			libtcod.console_set_default_background(attack_con, libtcod.darker_blue)
			libtcod.console_rect(attack_con, 1, 1, 25, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(attack_con, libtcod.black)
			libtcod.console_set_default_foreground(attack_con, libtcod.yellow)
			libtcod.console_print(attack_con, 4, 2, 'Conceal/Reveal Self')
			
			libtcod.console_set_default_foreground(attack_con, libtcod.white)
			libtcod.console_hline(attack_con, 1, 4, 25)
			
			# display info on target
			target_spotted = True
			if selected_unit.owning_player == 1 and not selected_unit.spotted:
				target_spotted = False
			
			if target_spotted:
				DisplayUnitInfo(attack_con, 1, 5, selected_unit.unit_id, selected_unit)
			else:
				libtcod.console_print(attack_con, 1, 5, 'Unspotted Enemy Unit')
				libtcod.console_set_default_background(attack_con, PORTRAIT_BG_COL)
				libtcod.console_rect(attack_con, 1, 7, 25, 8, False, libtcod.BKGND_SET)
				libtcod.console_blit(LoadXP('unit_unknown.xp'), 0, 0, 0, 0, attack_con, 1, 7)
			
			libtcod.console_set_default_foreground(attack_con, libtcod.white)
			libtcod.console_hline(attack_con, 1, 24, 25)
			
			libtcod.console_print(attack_con, 2, 26, 'Current Status:')
			if self.player_unit.los_table[selected_unit]:
				text = 'Line of Sight'
				action_type = 'Conceal'
			else:
				text = 'Line of Sight Blocked'
				action_type = 'Reveal'
			libtcod.console_print(attack_con, 4, 27, text)
			
			# display action and odds of success
			libtcod.console_print(attack_con, 2, 29, 'Chance to ' + action_type + ' self:')
			libtcod.console_print(attack_con, 4, 30, str(chance) + '%')
			
			# display bog chance
			libtcod.console_print(attack_con, 2, 32, 'Chance of bogging down:')
			libtcod.console_print(attack_con, 4, 33, str(self.player_unit.bog_chance) + '%')
			
			# display inputs
			if gamepad is not None:
				DisplayButton(attack_con, 9, 55, GAMEPADCHAR_DPAD_LR)
				DisplayButton(attack_con, 9, 56, GAMEPADCHAR_B)
				DisplayButton(attack_con, 9, 57, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(attack_con, ACTION_KEY_COL)
				libtcod.console_print(attack_con, 5, 55, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(attack_con, 5, 56, 'Esc')
				libtcod.console_print(attack_con, 5, 57, 'Tab')
			
			libtcod.console_set_default_foreground(attack_con, libtcod.white)
			libtcod.console_print(attack_con, 11, 55, 'Select Target')
			libtcod.console_print(attack_con, 11, 56, 'Cancel')
			libtcod.console_print(attack_con, 11, 57, 'Proceed')
		
		# calculate the chance of revealing self to / concealing self from selected unit
		def CalculateChance():
			base_chance = self.DoLoSRoll(self.player_unit, selected_unit, chance_only=True)
			
			# modify based on conceal or reveal action
			if self.player_unit.los_table[selected_unit]:
				base_chance = round(base_chance * 0.50, 1)
			else:
				base_chance = round(base_chance * 0.75, 1)
			return base_chance
			
		
		unit = self.player_unit
		
		# build a list of enemy units
		unit_list = []
		for unit in self.units:
			if not unit.alive: continue
			if unit.owning_player == 0: continue
			if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
			unit_list.append(unit)
		
		# shouldn't happen, but just check
		if len(unit_list) == 0: return
		
		# select first unit by default
		selected_unit = unit_list[0]
		
		# calculate initial success chance
		chance = CalculateChance()
		
		# activate the attack console, which we use for target info display and menu commands
		self.attack_con_active = True
		
		# update screen for first time
		UpdateScreen()
		self.UpdateGuiCon(los_highlight=(self.player_unit, selected_unit))  
		self.UpdateScenarioDisplay()
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			
			# cancel action
			if key.vk in [sdl2.SDLK_BACKSPACE, sdl2.SDLK_ESCAPE] or session.gamepad_input == 1:
				exit_menu = True
				continue
			
			# proceed
			elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				
				# set statuses
				self.player_unit.moving = True
				self.player_unit.ClearAcquiredTargets()
				for unit in scenario.player_unit.squad:
					unit.moving = True
					unit.ClearAcquiredTargets()
				
				# landmine check
				if self.player_unit.DoLandmineCheck():
					self.UpdatePlayerInfoCon()
					self.advance_phase = True
					exit_menu = True
					continue
				
				# do the roll
				roll = GetPercentileRoll()
				
				# check for crew action modifier
				for position in COMMANDER_POSITIONS:
					crewman = self.player_unit.GetPersonnelByPosition(position)
					if crewman is None: continue
					if crewman.current_cmd == 'Direct Movement':
						modifier = crewman.GetSkillMod('Driver Direction', 5.0)
						if modifier is not None:
							chance += modifier
						else:
							modifier = crewman.GetActionMod(3.0)
							if not crewman.ce: modifier = modifier * 0.5
							chance += modifier
					break
				
				# do sound effect
				PlaySoundFor(self.player_unit, 'movement')
				
				# not successful
				if roll > chance:
					if self.player_unit.los_table[selected_unit]:
						ShowMessage('You were not able to move into a position where you are concealed from the target.',
							good_news=False)
					else:
						ShowMessage('You were not able to move into a position where you are revealed to the target.',
							good_news=False)
				
				# roll was successful
				else:
					if self.player_unit.los_table[selected_unit]:
						ShowMessage('You were able to move into a position where you are concealed from the target.',
							good_news=True)
						self.player_unit.los_table[selected_unit] = False
						selected_unit.los_table[self.player_unit] = False
					else:
						ShowMessage('You were able to move into a position where you are revealed to the target.',
							good_news=True)
						self.player_unit.los_table[selected_unit] = True
						selected_unit.los_table[self.player_unit] = True
				
					# check for HD for player and squad
					for unit in self.units:
						if unit != self.player_unit and unit not in self.player_unit.squad: continue
						unit.CheckForHD()
				
				# check for bog
				if self.player_unit.DoBogCheck(True):
					ShowMessage('Your vehicle has become bogged down.',
						good_news=False)
					self.UpdatePlayerInfoCon()
					self.UpdateUnitCon()
				
				self.advance_phase = True
				exit_menu = True
				continue
			
			key_char = DeKey(chr(key.c).lower())
			
			# change selected target
			if key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
				i = unit_list.index(selected_unit)
				if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
					if i == 0:
						i = len(unit_list) - 1
					else:
						i -= 1
				else:
					if i == len(unit_list) - 1:
						i = 0
					else:
						i += 1
				selected_unit = unit_list[i]
				chance = CalculateChance()
				UpdateScreen()
				self.UpdateGuiCon(los_highlight=(self.player_unit, selected_unit))
				self.UpdateScenarioDisplay()
				continue
		
		# turn off attack console and clear the LoS display on the GUI console
		self.attack_con_active = False
		self.UpdateGuiCon()
		self.UpdateScenarioDisplay()
		
	
	# display a pop-up window with info on a particular unit
	def ShowUnitInfoWindow(self, unit):
		
		# create a local copy of the current screen to re-draw when we're done
		temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
		libtcod.console_blit(0, 0, 0, 0, 0, temp_con, 0, 0)
	
		# darken screen background
		libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
		
		# create window and draw frame
		window_con = libtcod.console_new(27, 44)
		libtcod.console_set_default_background(window_con, libtcod.black)
		libtcod.console_set_default_foreground(window_con, libtcod.white)
		DrawFrame(window_con, 0, 0, 27, 44)
		
		# draw unit info, description, and command instructions
		DisplayUnitInfo(window_con, 1, 1, unit.unit_id, unit)
		
		text = ''
		for t in unit.GetStat('description'):
			text += t
		lines = wrap(text, 25)
		y = 21
		libtcod.console_set_default_foreground(window_con, libtcod.light_grey)
		for line in lines[:20]:
			libtcod.console_print(window_con, 1, y, line)
			y+=1
		
		# display inputs
		if gamepad is not None:
			DisplayButton(window_con, 10, 42, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(window_con, ACTION_KEY_COL)
			libtcod.console_print(window_con, 7, 42, 'ESC')
		libtcod.console_set_default_foreground(window_con, libtcod.lighter_grey)
		libtcod.console_print(window_con, 12, 42, 'Return')
		
		# blit window to screen
		libtcod.console_blit(window_con, 0, 0, 0, 0, con, WINDOW_XM-13, 7)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		# wait for player to exit view
		exit = False
		while not exit:
			libtcod.console_flush()
			keypress = GetInputEvent()
			if mouse.rbutton_pressed or mouse.lbutton_pressed:
				mouse.rbutton_pressed = False
				mouse.lbutton_pressed = False
				exit = True
			if not keypress: continue
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 0:
				exit = True
		
		# re-draw original view
		libtcod.console_blit(temp_con, 0, 0, 0, 0, 0, 0, 0)
		del temp_con
	
	
	# advance to next phase/turn and do automatic events
	def AdvanceToNextPhase(self):
		
		# do end of phase actions for player
		
		# end of player turn, switching to enemy turn
		if self.phase == PHASE_ALLIED_ACTION:
			
			# resolve fp on units first
			for unit in reversed(self.units):
				if not unit.alive: continue
				unit.ResolveFP()
				libtcod.console_flush()
			
			self.phase = PHASE_ENEMY_ACTION
			self.active_player = 1
		
		# end of enemy activation, player's turn
		elif self.phase == PHASE_ENEMY_ACTION:
			
			# resolve fp on units first
			for unit in reversed(self.units):
				if not unit.alive: continue
				unit.ResolveFP()
				libtcod.console_flush()
			
			# if units are on overrun, reset their overrun statuses, etc.
			for unit in self.units:
				if unit != self.player_unit and unit not in self.player_unit.squad: continue
				if not unit.overrun: continue
				unit.overrun = False
				unit.GenerateTerrain()
				unit.CheckForHD()
				unit.SetSmokeDustLevel()
			self.UpdateUnitCon()
			
			# advance clock
			campaign_day.AdvanceClock(0, TURN_LENGTH)
			
			# check for end of scenario
			self.CheckForEnd()
			if self.finished: return
			
			self.phase = PHASE_RANDOM_EVENT
			
			# update the displays
			DisplayTimeInfo(scen_time_con)
			self.UpdateUnitCon()
			self.UpdateScenarioDisplay()
			libtcod.console_flush()
			
			# check for random event
			self.CheckForRandomEvent()
			
			# player did not survive random event
			if not self.player_unit.alive:
				campaign_day.ended = True
				return
			
			# check for all enemies dead as result of random event
			self.CheckForEnd()
			if self.finished: return
			
			self.active_player = 0
			self.phase = PHASE_COMMAND
			
			# reset player unit and squadmates
			for unit in self.units:
				if not unit.alive: continue
				if unit.owning_player != 0: continue
				if not unit.is_player and unit not in self.player_unit.squad: continue
				unit.ResetForNewTurn()
				unit.DoRecoveryRoll()
				unit.CalculateMoveChances()
			
			self.UpdatePlayerInfoCon()
			self.player_unit.MoveToTopOfStack()
			
			ShowTutorialSlide('scenario_new_player_turn')
		
		# still player turn, advance phase
		else:
			
			# end of command phase
			if self.phase == PHASE_COMMAND:
				
				# make sure no conflicting commands are active
				driver_on_command = False
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.name not in ['Driver', 'Co-Driver', 'Rear Driver']: continue
					if position.crewman.current_cmd not in ['Drive', 'Drive Into Terrain', 'Withdraw']: continue
					if not driver_on_command:
						driver_on_command = True
						continue
					
					# 2+ drivers on drive command
					ShowMessage('Only one driver may be on a Drive command in any one turn.')
					return
			
			# end of crew action phase
			elif self.phase == PHASE_CREW_ACTION:
				
				# check to see if friendly unit orders are updated
				for unit in self.units:
					if not unit.alive: continue
					if unit.owning_player == 1: continue
					if unit.is_player: continue
					if unit.ai is None: continue
					
					# command already set
					if unit.ai.leader_command == self.battlegroup_command: continue
					
					# if no battlegroup radio connection, roll here to see if sent to friendly units properly
					if not campaign_day.bg_radio_comms:
						distance = float(GetHexDistance(unit.hx, unit.hy, 0, 0))
						if distance == 0:
							chance = 97.0
						elif distance == 1:
							chance = 90.0
						else:
							chance = 80.0
						roll = GetPercentileRoll()
						if roll > chance: continue
							
					unit.ai.leader_command = self.battlegroup_command
				
				self.UpdateCommsCon()
							
			# end of movement phase
			elif self.phase == PHASE_MOVEMENT:
				
				self.UpdatePlayerInfoCon()
				
				# player pivoted during movement phase
				if self.player_pivot != 0:
					self.player_unit.ClearAcquiredTargets(no_enemy=True)
					
					# clear move chances if did not move
					if not self.player_unit.moving:
						self.player_unit.forward_move_bonus = 0.0
						self.player_unit.reverse_move_bonus = 0.0
					
					# do bog check for pivot
					if not self.player_unit.bogged:
						self.player_unit.DoBogCheck(False, pivot=True)
						if self.player_unit.bogged:
							ShowMessage('Your vehicle has become bogged down.',
								good_news=False)
							self.UpdatePlayerInfoCon()
							self.UpdateUnitCon()
			
			# end of shooting phase
			elif self.phase == PHASE_SHOOTING:
				
				# clear GUI console and refresh screen
				libtcod.console_clear(gui_con)
				self.UpdateScenarioDisplay()
				libtcod.console_flush()
				
				# resolve hits on units
				for unit in reversed(self.units):
					if not unit.alive: continue
					unit.ResolveAPHits()
					unit.ResolveHEHits()
				
				# do concealment check for player
				self.player_unit.DoConcealmentCheck()
			
			self.phase += 1
		
		# update the displays
		DisplayTimeInfo(scen_time_con)
		self.UpdateCmdCon()
		self.UpdateUnitCon()
		self.UpdateScenarioDisplay()
		libtcod.console_flush()
		
		# do automatic actions at start of phase
		
		# command phase: rebuild lists of commands
		if self.phase == PHASE_COMMAND:
			self.player_unit.BuildCmdLists()
		
		# spotting phase: do spotting then automatically advance
		elif self.phase == PHASE_SPOTTING:
			
			# first check for swap position, since this may change current command
			# for crewmen who swap
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if position.crewman.current_cmd == 'Swap Position':
					ShowSwapPositionMenu(spotting_phase=True)
					self.UpdateCrewInfoCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
					break
			
			ShowTutorialSlide('scenario_spotting_phase')
			
			self.player_unit.DoSpotChecks()
			self.advance_phase = True
		
		# crew action phase:
		elif self.phase == PHASE_CREW_ACTION:
			
			ShowTutorialSlide('scenario_action_phase')
			
			input_command = False
			
			# run through each position, checking for crew actions in order of importance
			
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				
				# check for withdrawing
				if position.crewman.current_cmd == 'Withdraw':
					if ShowNotification('Attempt to withdraw from this battle?', confirm=True):
						
						PlaySoundFor(self.player_unit, 'movement')
						self.player_unit.moving = True
						self.player_unit.ClearAcquiredTargets()
						self.player_unit.GenerateTerrain()
						self.GenerateUnitLoS(self.player_unit)
						self.player_unit.CheckForHD()
						for unit in self.player_unit.squad:
							unit.moving = True
							unit.ClearAcquiredTargets()
							unit.GenerateTerrain()
							self.GenerateUnitLoS(unit)
							unit.CheckForHD()
						
						if self.AttemptWithdraw():
							ShowMessage('You successfully withdraw from the battle.',
								good_news=True)
							campaign_day.player_withdrew = True
							self.finished = True
							return
						else:
							ShowMessage('You were unable to withdraw from the battle!',
								good_news=False)
				
				# check for abandoning vehicle
				# 'Abandon Tank' included for compatibilty pre 1.1.0
				elif position.crewman.current_cmd in ['Abandon Tank', 'Abandon Vehicle']:
					if ShowNotification('Abandon your vehicle?', confirm=True):
						campaign.player_unit.alive = False
						ShowMessage('You abandon your vehicle.')
						campaign.AddJournal('Abandoned vehicle')
						self.player_unit.alive = False
						self.PlayerBailOut(abandoning_tank=True)
						campaign_day.ended = True
						campaign_day.abandoned_tank = True
						self.finished = True
						return
			
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
			
				# check for radio repair attempt
				if position.crewman.current_cmd == 'Repair Radio':
					if not self.player_unit.has_radio or self.player_unit.radio_destroyed: continue
					if not self.player_unit.radio_damaged: continue
					
					chance = 50.0
					if position.name == 'Radio Operator':
						chance += 25.0
					
					roll = GetPercentileRoll()
					if position.crewman.condition in ['Shaken', 'Stunned']:
						roll += 20.0
					
					if roll <= chance:
						ShowMessage('Your radio is now repaired and operational again.',
							good_news=True)
						self.player_unit.radio_damaged = False
						campaign_day.UpdateCommsStatus()
						self.UpdateCommsCon()
						self.UpdateScenarioDisplay()
					else:
						ShowMessage('Your radio is still damaged and inoperative.',
							good_news=False)
			
			# check for automatic actions or commands that require further input
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
			
				# check for smoke grenade
				if position.crewman.current_cmd == 'Smoke Grenade' and position.crewman.ce:
					self.player_unit.smoke += 1
					if self.player_unit.smoke > 2:
						self.player_unit.smoke = 2
					campaign_day.smoke_grenades -= 1
					PlaySoundFor(None, 'smoke')
					ShowMessage('You throw a smoke grenade.')
					self.UpdatePlayerInfoCon()
					self.UpdateUnitCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
				
				# check for smoke mortar
				elif position.crewman.current_cmd == 'Fire Smoke Mortar':
					self.player_unit.smoke = 2
					campaign_day.smoke_mortar_rounds -= 1
					PlaySoundFor(None, 'smoke')
					ShowMessage('The ' + position.name + ' fires off a smoke mortar round.')
					self.UpdatePlayerInfoCon()
					self.UpdateUnitCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
				
				# check for action that needs input in this phase
				elif not input_command and position.crewman.current_cmd in CREW_ACTION_INPUT_COMMANDS:
					input_command = True
					self.selected_position = self.player_unit.positions_list.index(position)
					# update unit info pane to possibly highlight a weapon that's having its ready rack mananged
					self.UpdatePlayerInfoCon()
			
			if not input_command:
				self.advance_phase = True
		
		# movement phase
		elif self.phase == PHASE_MOVEMENT:
			# update unit info pane to remove any weapon highlights from crew command phases
			self.UpdatePlayerInfoCon()
			
			ShowTutorialSlide('scenario_movement_phase')
			
			# reset player pivot
			self.player_pivot = 0
			
			# don't wait for player input phase if no crewman in position on correct order
			driver_active = False
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if not position.crewman.alive: continue
				if position.name not in ['Driver', 'Co-Driver', 'Rear Driver']: continue
				if position.crewman.current_cmd not in ['Drive', 'Drive Into Terrain']: continue
				driver_active = True
				break
			
			if driver_active:
				scenario.player_unit.CalculateMoveChances()
			else:
				self.advance_phase = True
			
		# shooting phase
		elif self.phase == PHASE_SHOOTING:
			
			# small arms attacks first if any
			sa_targets = []
			for unit in self.units:
				if not unit.alive: continue
				if unit.owning_player == 0: continue
				if not unit.spotted: continue
				if unit.GetStat('category') not in ['Infantry', 'Cavalry', 'Gun']: continue
				if not scenario.player_unit.los_table[unit]: continue
				if GetHexDistance(unit.hx, unit.hy, 0, 0) > 1: continue
				sa_targets.append(unit)
			
			if len(sa_targets) > 0:
			
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					
					if position.crewman.current_cmd == 'Fire Small Arms' and position.crewman.ce:
						if position.crewman.is_player_commander:
							text = 'You fire at nearby targets with your '
						else:
							text = 'Your ' + position.name + ' fires at nearby targets with their '
						if 'Spray and Pray' in position.crewman.skills:
							text += 'SMG.'
						else:
							text += 'pistol.'
						ShowMessage(text)
						
						if 'Spray and Pray' in position.crewman.skills:
							PlaySoundFor(None, 'smg_firing')
						else:
							PlaySoundFor(None, 'pistol_firing')
						attack_effect = False
						
						for unit in sa_targets:
							roll = GetPercentileRoll()
							chance = 40.0
							if self.player_unit.overrun:
								chance += 10.0
							elif self.player_unit.moving:
								chance -= 15.0
							
							if campaign_day.weather['Precipitation'] == 'Sandstorm':
								chance -= 10.0
							elif campaign_day.weather['Fog'] >= 3:
								chance -= 10.0
							
							if unit.fortified or unit.entrenched or unit.dug_in:
								chance -= 25.0
							
							if roll > chance: continue
							ShowMessage(unit.GetName() + ' was hit by the attack.', scenario_highlight=(unit.hx, unit.hy))
							unit.fp_to_resolve += choice([1, 1, 2])
							
							if 'Spray and Pray' in position.crewman.skills:
								unit.fp_to_resolve += 2
							elif 'Gunslinger' in position.crewman.skills:
								unit.fp_to_resolve += 1
							
							unit.hit_by_fp = True
							
							# make this unit alert if lax
							if unit.ai is not None:
								unit.ai.state = 'Alert'
							
							attack_effect = True
						
						if not attack_effect:
							ShowMessage('No effect.')
						
						# change squadmates' AI orders if required
						for unit in campaign_day.player_squad:
							if not unit.alive: continue
							if unit.ai is None: continue
							if unit.ai.leader_command == 'On my Mark':
								unit.ai.leader_command = 'Fire at Will'
						
			
			# check that 1+ crew are on correct order to input in shooting phase
			skip_phase = True
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				if position.crewman.current_cmd in ['Operate Gun', 'Operate MG', 'Operate AAMG', 'Operate Flame Thrower']:
					skip_phase = False
					break
			
			if skip_phase:
				self.advance_phase = True
			else:
				ShowTutorialSlide('scenario_shooting_phase')
				self.BuildTargetList()
				
				# set gun RR use for player unit
				self.player_unit.SetGunRRUse()

				# select the first manned weapon and update the unit info pane to highlight it and its operators.
				for weapon in self.player_unit.weapon_list:
					if weapon.GetOperatingCrewman():
						self.selected_weapon = weapon
						break
				self.UpdatePlayerInfoCon()
				
				# move current target of current weapon to top of unit stack if required
				if self.selected_weapon is not None:
					if self.selected_weapon.selected_target is not None:
						self.selected_weapon.selected_target.MoveToTopOfStack()
				
				self.UpdateUnitCon()
				self.UpdateGuiCon()
		
		# allied action phase
		elif self.phase == PHASE_ALLIED_ACTION:
			
			# clear context console and weapon & weapon operator highlights
			self.UpdateContextCon()
			self.UpdatePlayerInfoCon()
			self.UpdateCrewInfoCon()
			self.UpdateScenarioDisplay()
			libtcod.console_flush()
			
			ShowTutorialSlide('scenario_allied_phase')
			
			self.DoAISpotChecks(0)
			
			# player squad and allies act
			unit_list = []
			for unit in self.player_unit.squad:
				unit_list.append(unit)
			for unit in self.units:
				if not unit.alive: continue
				if unit.owning_player != 0: continue
				if unit.is_player: continue
				if unit in self.player_unit.squad: continue
				unit_list.append(unit)
			
			# move any gun tractors to end of list
			unit_list.sort(key=lambda x: x.GetStat('class') == 'Tractor')
			
			for unit in unit_list:
				unit.MoveToTopOfStack()
				if unit not in self.player_unit.squad:
					unit.ResetForNewTurn()
				unit.DoRecoveryRoll()
				unit.CalculateMoveChances()
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				libtcod.console_flush()
				unit.ai.DoActivation()
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				libtcod.console_flush()
				
				# resolve any hits caused by this unit
				for unit2 in self.units:
					if not unit2.alive: continue
					unit2.ResolveAPHits()
					unit2.ResolveHEHits()
				
				# do concealment check for this unit
				unit.DoConcealmentCheck()
				libtcod.console_flush()
			
			self.advance_phase = True
		
		# enemy action
		elif self.phase == PHASE_ENEMY_ACTION:
			
			ShowTutorialSlide('scenario_enemy_phase')
			
			self.DoAISpotChecks(1)
			
			# build list of enemy units to activate
			unit_list = []
			for unit in self.units:
				if unit.owning_player != 1: continue
				if not unit.alive: continue
				unit_list.append(unit)
			
			# move any gun tractors to end of list
			unit_list.sort(key=lambda x: x.GetStat('class') == 'Tractor')
			
			for unit in unit_list:
				
				# if player has been destroyed, don't keep attacking
				if not self.player_unit.alive:
					break
				
				unit.MoveToTopOfStack()
				self.UpdateUnitCon()
				self.UpdateScenarioDisplay()
				libtcod.console_flush()
				unit.ResetForNewTurn()
				unit.DoRecoveryRoll()
				unit.CalculateMoveChances()
				unit.ai.DoActivation()
				scenario.UpdateUnitCon()
				scenario.UpdateScenarioDisplay()
				libtcod.console_flush()
				
				# resolve any hits caused by this unit
				for unit2 in self.units:
					if not unit2.alive: continue
					unit2.ResolveAPHits()
					unit2.ResolveHEHits()

				unit.DoConcealmentCheck()
				libtcod.console_flush()
			
			# clear scenario ambush flag if any
			self.ambush = False
			
			self.advance_phase = True
		
		self.UpdateCrewInfoCon()
		self.UpdateUnitInfoCon()
		self.UpdateCmdCon()
		self.UpdateContextCon()
		self.UpdateGuiCon()
		self.UpdateScenarioDisplay()
		libtcod.console_flush()
	
	
	# update contextual info console
	# 18x12
	def UpdateContextCon(self):
		libtcod.console_clear(context_con)
		
		# if we're advancing to next phase automatically, don't display anything here
		if self.advance_phase: return
		
		# Command Phase: display info about current crew command
		if self.phase == PHASE_COMMAND:
			position = scenario.player_unit.positions_list[self.selected_position]
			
			if position.crewman is None: return
			if not position.crewman.alive:
				libtcod.console_set_default_foreground(context_con, libtcod.light_grey)
				libtcod.console_print(context_con, 0, 0, 'Crewman is dead')
				return
			
			libtcod.console_set_default_foreground(context_con, SCEN_PHASE_COL[self.phase])
			
			# if command is too long, shorten
			text = position.crewman.current_cmd
			if len(text) > 18:
				text = text[:15] + '...'
			libtcod.console_print(context_con, 0, 0, text)
			
			# display warning if command not currently possible
			rst_restricted = False
			if 'rst_ce_na' in session.crew_commands[position.crewman.current_cmd] and scenario.player_unit.GetStat('open_topped') is None:
				if scenario.player_unit.GetStat('turret') is not None:
					if position.location == 'Turret' and position.crewman.ce and scenario.player_unit.GetStat('turret') == 'RST':
						rst_restricted = True
			
			# some commands not possible when buttoned up
			bu_na = False
			if not position.crewman.ce:
				if position.crewman.current_cmd in ['Smoke Grenade', 'Fire Small Arms']:
					bu_na = True
				
				if position.crewman.current_cmd == 'Operate AAMG':
					
					# determine whether crewman could operate an AAMG from this position while BU
					bu_na = True
					for weapon in scenario.player_unit.weapon_list:
						if weapon.GetStat('mount') is None: continue
						if weapon.GetStat('mount') != position.location: continue
						if weapon.GetStat('type') != 'AAMG': continue
						if weapon.GetStat('bu_ok') is not None:
							bu_na = False
							break
			
			# some commands have no effect when buttoned up
			bu_ne = False
			if not position.crewman.ce:
				if position.crewman.current_cmd == 'Hunker Down':
					bu_ne = True
			
			if rst_restricted:
				libtcod.console_set_default_foreground(context_con, libtcod.light_red)
				libtcod.console_print(context_con, 0, 2, 'Command N/A while')
				libtcod.console_print(context_con, 0, 3, 'CE in a restricted')
				libtcod.console_print(context_con, 0, 4, 'turret!')
			
			elif bu_na:
				libtcod.console_set_default_foreground(context_con, libtcod.light_red)
				libtcod.console_print(context_con, 0, 2, 'Command N/A while')
				libtcod.console_print(context_con, 0, 3, 'BU!')
			
			elif bu_ne:
				libtcod.console_set_default_foreground(context_con, libtcod.light_red)
				libtcod.console_print(context_con, 0, 2, 'Command has no')
				libtcod.console_print(context_con, 0, 3, 'effect while BU!')
			
			else:
			
				libtcod.console_set_default_foreground(context_con, libtcod.light_grey)
				lines = wrap(session.crew_commands[position.crewman.current_cmd]['desc'], 18)
				y = 2
				for line in lines:
					libtcod.console_print(context_con, 0, y, line)
					y += 1
				
				# display gun ammo if viewing Manage Ready Rack command
				if position.crewman.current_cmd == 'Manage Ready Rack':
					y += 1
					weapon = scenario.rack_management_array[position][0]
					libtcod.console_set_default_foreground(context_con, libtcod.white)
					libtcod.console_print(context_con, 1, y, weapon.stats['name'])
					weapon.DisplayAmmo(context_con, 1, y)
		
				# display smoke grenades or mortar rounds remaining if on these commands
				elif position.crewman.current_cmd == 'Smoke Grenade':
					y += 1
					text = 'Smoke Grenades: ' + str(campaign_day.smoke_grenades)
					libtcod.console_print(context_con, 0, y, text)
				
				elif position.crewman.current_cmd == 'Fire Smoke Mortar':
					y += 1
					text = 'Smoke Rounds: ' + str(campaign_day.smoke_mortar_rounds)
					libtcod.console_print(context_con, 0, y, text)
				
				# display FT fuel remaining
				elif position.crewman.current_cmd == 'Operate Flame Thrower':
					y += 1
					for weapon in scenario.player_unit.weapon_list:
						if weapon.GetStat('type') != 'Flame Thrower': continue
						if weapon.GetStat('mount') is None: continue
						if weapon.GetStat('mount') != position.location: continue
						text = 'Fuel: ' + str(weapon.flame_ammo) + '/' + str(weapon.flame_ammo_max)
						libtcod.console_print(context_con, 0, y, text)
						break
				
				# display withdraw chance
				elif position.crewman.current_cmd == 'Withdraw':
					libtcod.console_set_default_foreground(context_con, libtcod.white)
					libtcod.console_print(context_con, 0, y+1, 'Current Chance:')
					libtcod.console_print(context_con, 0, y+2, str(self.GetWithdrawChance()) + '%')
		
		# Movement Phase
		elif self.phase == PHASE_MOVEMENT:
			
			libtcod.console_set_default_foreground(context_con, libtcod.white)
			
			# if player is already bogged down, only display unbog chance
			if self.player_unit.bogged:
				libtcod.console_print(context_con, 0, 0, 'Chance to Unbog:')
				libtcod.console_set_default_foreground(context_con, libtcod.light_grey)
				text = str(self.player_unit.GetUnbogChance()) + '%'
				libtcod.console_print(context_con, 0, 2, text)
				return
			
			libtcod.console_print(context_con, 5, 0, 'Success')
			libtcod.console_print(context_con, 14, 0, 'Bog')
			
			libtcod.console_print(context_con, 0, 2, 'Fwd')
			libtcod.console_print(context_con, 0, 4, 'Rev')
			libtcod.console_print(context_con, 0, 6, 'Pivot')
			libtcod.console_print(context_con, 0, 8, 'HD')			
			
			libtcod.console_set_default_foreground(context_con, libtcod.light_grey)
			
			# forward move
			text = str(self.player_unit.forward_move_chance) + '%'
			libtcod.console_print_ex(context_con, 10, 2, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			text = str(self.player_unit.bog_chance) + '%'
			libtcod.console_print_ex(context_con, 16, 2, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			
			# reverse move
			text = str(self.player_unit.reverse_move_chance) + '%'
			libtcod.console_print_ex(context_con, 10, 4, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			text = str(round(self.player_unit.bog_chance * 1.5, 1)) + '%'
			libtcod.console_print_ex(context_con, 16, 4, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			
			# pivot
			libtcod.console_print_ex(context_con, 10, 6, libtcod.BKGND_NONE,
				libtcod.RIGHT, '100%')
			text = str(round(self.player_unit.bog_chance * 0.25, 1)) + '%'
			libtcod.console_print_ex(context_con, 16, 6, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			
			# Hull Down
			text = str(self.player_unit.GetHDChance(driver_attempt=True)) + '%'
			libtcod.console_print_ex(context_con, 10, 8, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			libtcod.console_print_ex(context_con, 16, 8, libtcod.BKGND_NONE,
				libtcod.RIGHT, '0%')
			
		# crew action phase
		elif self.phase == PHASE_CREW_ACTION:
			position = self.player_unit.positions_list[self.selected_position]
			if position.crewman is None: return
			
			if position.crewman.current_cmd == 'Manage Ready Rack':
				rr_weapon = scenario.rack_management_array[position][0]
				libtcod.console_set_default_foreground(context_con, libtcod.white)
				libtcod.console_set_default_background(context_con, libtcod.darkest_red)
				libtcod.console_rect(context_con, 0, 0, 18, 1, True, libtcod.BKGND_SET)
				libtcod.console_set_default_background(context_con, libtcod.black)
				libtcod.console_print(context_con, 0, 0, rr_weapon.stats['name'])
				rr_weapon.DisplayAmmo(context_con, 0, 1)
			
		# Shooting Phase
		elif self.phase == PHASE_SHOOTING:
			
			weapon = self.selected_weapon
			if weapon is None:
				return
			
			libtcod.console_set_default_foreground(context_con, libtcod.white)
			libtcod.console_set_default_background(context_con, libtcod.darkest_red)
			libtcod.console_rect(context_con, 0, 0, 18, 1, True, libtcod.BKGND_SET)
			libtcod.console_print(context_con, 0, 0, weapon.stats['name'])
			libtcod.console_set_default_background(context_con, libtcod.darkest_grey)
			
			if weapon.GetStat('mount') is not None:
				libtcod.console_set_default_foreground(context_con, libtcod.light_grey)
				libtcod.console_print_ex(context_con, 17, 0, libtcod.BKGND_NONE,
					libtcod.RIGHT, weapon.stats['mount'])
			
			if weapon.broken:
				libtcod.console_set_default_foreground(context_con, libtcod.light_red)
				libtcod.console_print(context_con, 0, 1, 'BROKEN')
				return
			elif weapon.jammed:
				libtcod.console_set_default_foreground(context_con, libtcod.light_red)
				libtcod.console_print(context_con, 0, 1, 'JAMMED')
				return
			
			libtcod.console_set_default_foreground(context_con, libtcod.white)
			# if weapon is a gun, display ammo info here
			if weapon.GetStat('type') == 'Gun':
				weapon.DisplayAmmo(context_con, 0, 1, no_extra=True)
			# otherwise, can display fp rating
			elif weapon.GetStat('fp') is not None:
				libtcod.console_print(context_con, 0, 1, weapon.GetStat('fp') + ' FP')
			
			# display FT fuel remaining
			if weapon.GetStat('type') == 'Flame Thrower':	
				text = 'Fuel: ' + str(weapon.flame_ammo) + '/' + str(weapon.flame_ammo_max)
				libtcod.console_print(context_con, 0, 3, text)
			
			# display target and acquired target status if any
			if weapon.selected_target is not None and weapon.acquired_target is not None:
				(ac_target, level) = weapon.acquired_target
				if ac_target == weapon.selected_target:
					text = 'Acquired Target'
					if level == 1:
						text = 'Dialed In'
					libtcod.console_set_default_foreground(context_con, libtcod.light_blue)
					libtcod.console_print(context_con, 0, 8, text)
					libtcod.console_set_default_foreground(context_con, libtcod.white)
			
			# if weapon has fired, don't display any other info
			if weapon.fired:
				libtcod.console_set_default_foreground(context_con, libtcod.red)
				libtcod.console_print(context_con, 0, 10, 'Fired')
				return
			
			# display RoF chance if any
			libtcod.console_set_default_foreground(context_con, libtcod.white)
			libtcod.console_print_ex(context_con, 17, 1, libtcod.BKGND_NONE,
				libtcod.RIGHT, 'RoF')
			
			libtcod.console_set_default_foreground(context_con, libtcod.light_grey)
			chance = weapon.GetRoFChance()
			if chance > 0.0:
				text = str(chance) + '%'
			else:
				text = 'N/A'
			libtcod.console_print_ex(context_con, 17, 2, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			
			if weapon.selected_target is None:
				libtcod.console_set_default_foreground(context_con, libtcod.red)
				libtcod.console_print(context_con, 0, 8, 'No target selected')
			
			# display info about current target if any
			else:
				result = self.CheckAttack(scenario.player_unit, weapon, weapon.selected_target)
				
				# attack is fine
				if result == '':
					libtcod.console_set_default_foreground(context_con, libtcod.light_blue)
					libtcod.console_print(context_con, 0, 9, 'Ready to fire!')
				# attack is not fine
				else:
					lines = wrap(result, 18)
					y = 9
					libtcod.console_set_default_foreground(context_con, libtcod.red)
					for line in lines:
						libtcod.console_print(context_con, 0, y, line)
						y += 1
						if y == 12: break
	
	
	# update zone info console, 18x5
	def UpdateZoneInfoCon(self):
		libtcod.console_clear(zone_info_con)
		libtcod.console_set_default_foreground(zone_info_con, libtcod.light_grey)
		libtcod.console_print_ex(zone_info_con, 9, 0, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Current Zone:')
		libtcod.console_set_default_foreground(zone_info_con, libtcod.white)
		map_zone = campaign_day.map_hexes[campaign_day.player_unit_location]
		libtcod.console_print_ex(zone_info_con, 9, 1, libtcod.BKGND_NONE,
			libtcod.CENTER, map_zone.terrain_type)
		if map_zone.landmines:
			libtcod.console_set_default_foreground(zone_info_con, libtcod.light_red)
			libtcod.console_print_ex(zone_info_con, 9, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Landmines')
		if map_zone.objective is not None:
			libtcod.console_set_default_foreground(zone_info_con, libtcod.light_blue)
			libtcod.console_print_ex(zone_info_con, 9, 3, libtcod.BKGND_NONE,
				libtcod.CENTER, map_zone.objective['type'])
	
	
	# update comms info console, 18x5
	def UpdateCommsCon(self):
		libtcod.console_clear(comms_con)
		libtcod.console_set_default_foreground(comms_con, libtcod.yellow)
		libtcod.console_print(comms_con, 4, 0, 'Radio Comms')
		
		libtcod.console_set_default_foreground(comms_con, libtcod.light_grey)
		text = 'Battlegroup '
		if campaign_day.bg_radio_comms:
			text += chr(251)
		else:
			text += 'x'
		libtcod.console_print(comms_con, 0, 1, text)
		
		text = 'HQ '
		if campaign_day.hq_radio_comms:
			text += chr(251)
		else:
			text += 'x'
		libtcod.console_print(comms_con, 0, 2, text)
		
		if not self.player_unit.has_radio:
			libtcod.console_set_default_foreground(comms_con, libtcod.light_grey)
			libtcod.console_print(comms_con, 5, 3, 'No Radio')
		else:
			libtcod.console_set_default_foreground(comms_con, libtcod.lighter_grey)
			text = 'Radio '
			if self.player_unit.radio_destroyed:
				text += 'Destroyed'
			elif self.player_unit.radio_damaged:
				text += 'Damaged'
			else:
				text += 'Operational'
			libtcod.console_print(comms_con, 0, 3, text)
			
		libtcod.console_set_default_foreground(comms_con, libtcod.light_purple)
		libtcod.console_print_ex(comms_con, 9, 4, libtcod.BKGND_NONE,
			libtcod.CENTER, self.battlegroup_command)
	
	
	# update player unit info console
	# During shooting phase, highlight the active weapon. During command phases, highlight weapons operated by the selected position. During ready rack management, highlight current selected weapon.
	def UpdatePlayerInfoCon(self):
		libtcod.console_clear(player_info_con)
		weapon = None
		position = None
		if scenario.phase == PHASE_SHOOTING:
			weapon = scenario.selected_weapon
		elif scenario.phase in [PHASE_COMMAND, PHASE_SPOTTING, PHASE_CREW_ACTION]:
			if scenario.phase == PHASE_CREW_ACTION:
				crew_position = scenario.player_unit.positions_list[scenario.selected_position]
				if crew_position.crewman and crew_position.crewman.current_cmd == 'Manage Ready Rack':
					weapon = scenario.rack_management_array[crew_position][0]
			position = scenario.selected_position
		DisplayUnitInfo(player_info_con, 0, 0, scenario.player_unit.unit_id, scenario.player_unit, weapon_highlight=weapon, position_highlight=position)
	
	
	# update the player crew info console
	def UpdateCrewInfoCon(self):
		libtcod.console_clear(crew_con)
		
		y = 0
		i = 0

		for position in scenario.player_unit.positions_list:

			# during shooting phase, highlight positions & commands connected to the selected weapon
			if scenario.phase == PHASE_SHOOTING:
				weapon = scenario.selected_weapon
				if weapon.GetStat('mount') is None or position.location == weapon.GetStat('mount'):
					if weapon.GetStat('fired_by') is not None and position.name in weapon.GetStat('fired_by'):
						libtcod.console_set_default_background(crew_con, libtcod.darker_blue)
						libtcod.console_rect(crew_con, 0, y, 25, 3, True, libtcod.BKGND_SET)
						if position.crewman and position.crewman == weapon.GetOperatingCrewman():
							libtcod.console_set_default_background(crew_con, libtcod.dark_blue)
							libtcod.console_rect(crew_con, 0, y+2, 25, 1, True, libtcod.BKGND_SET)
						libtcod.console_set_default_background(crew_con, libtcod.black)
					elif weapon.GetStat('reloaded_by') is not None and position.name in weapon.GetStat('reloaded_by'):
						libtcod.console_set_default_background(crew_con, libtcod.darkest_orange)
						libtcod.console_rect(crew_con, 0, y, 25, 3, True, libtcod.BKGND_SET)
						if position.crewman and position.crewman.current_cmd == 'Reload':
							libtcod.console_set_default_background(crew_con, libtcod.darker_orange)
							libtcod.console_rect(crew_con, 0, y+2, 25, 1, True, libtcod.BKGND_SET)
						libtcod.console_set_default_background(crew_con, libtcod.black)

			# otherwise, highlight if the phase is the command phase and the position is selected
			# if the latter, also highlight any weapons fired or reloaded by this position.
			elif i == scenario.selected_position and scenario.phase in [PHASE_COMMAND, PHASE_SPOTTING, PHASE_CREW_ACTION]:
				libtcod.console_set_default_background(crew_con, libtcod.darker_blue)
				libtcod.console_rect(crew_con, 0, y, 25, 3, True, libtcod.BKGND_SET)
				libtcod.console_set_default_background(crew_con, libtcod.black)
			
			# display position name and location in vehicle (eg. turret/hull)
			# if crewman is untrained in this position, highlight this
			libtcod.console_set_default_foreground(crew_con, libtcod.light_blue)
			if position.crewman is not None:
				if position.crewman.UntrainedPosition():
					libtcod.console_set_default_foreground(crew_con, libtcod.light_red)
			libtcod.console_print(crew_con, 0, y, position.name)
			libtcod.console_set_default_foreground(crew_con, libtcod.white)
			libtcod.console_print_ex(crew_con, 0+24, y, libtcod.BKGND_NONE, 
				libtcod.RIGHT, position.location)
			
			# display name of crewman and buttoned up / exposed status if any
			if position.crewman is None:
				libtcod.console_print(crew_con, 0, y+1, 'Empty')
			else:
				
				if position.crewman.is_player_commander:
					libtcod.console_set_default_foreground(crew_con, PC_COL)
				# use nickname if any
				if position.crewman.nickname != '':
					PrintExtended(crew_con, 0, y+1, '"' + position.crewman.nickname + '"')
				else:
					PrintExtended(crew_con, 0, y+1, position.crewman.GetCrewmanName(first_initial=True), nation=position.crewman.nation)
					
				libtcod.console_set_default_foreground(crew_con, libtcod.white)
				if position.open_top or position.crew_always_ce:
					libtcod.console_set_default_foreground(crew_con, libtcod.light_blue)
					text = 'CE'
				elif not position.hatch:
					text = '--'
				elif position.crewman.ce:
					text = 'CE'
					if position.large_hatch: text += '+L'
					# highlight if crewman is especially vunerable
					if position.crewman.alive and position.crewman.condition != 'Unconscious' and session.crew_commands[position.crewman.current_cmd]['spotting_allowed']:
						libtcod.console_set_default_foreground(crew_con, libtcod.light_yellow)
				else:
					text = 'BU'
				libtcod.console_print_ex(crew_con, 24, y+1, libtcod.BKGND_NONE, libtcod.RIGHT, text)
			
				# display if crewman is dead
				if not position.crewman.alive:
					libtcod.console_set_default_foreground(crew_con, libtcod.dark_grey)
					libtcod.console_print(crew_con, 0, y+2, 'Dead')
				
				else:
					
					# display current command
					libtcod.console_set_default_foreground(crew_con, libtcod.dark_yellow)
					libtcod.console_print(crew_con, 0, y+2, position.crewman.current_cmd)
					
					# highlight command if in Action Phase and on a command that needs input in this phase
					if self.phase == PHASE_CREW_ACTION:
						if position.crewman.current_cmd in CREW_ACTION_INPUT_COMMANDS:
							libtcod.console_set_default_background(crew_con, libtcod.dark_blue)
							libtcod.console_rect(crew_con, 0, y+2, 25, 1, False, libtcod.BKGND_SET)
							libtcod.console_set_default_background(crew_con, libtcod.black)
			
					# display condition and warning if crewman has 1+ critical injuries
					libtcod.console_set_default_foreground(crew_con, libtcod.light_grey)
					if position.crewman.condition == 'Unconscious':
						text = 'Uncn'
					elif position.crewman.condition == 'Stunned':
						text = 'Stun'
					elif position.crewman.condition == 'Shaken':
						text = 'Shkn'
					else:
						text = ''
					libtcod.console_print_ex(crew_con, 24, y+2, libtcod.BKGND_NONE, libtcod.RIGHT, 
						text)
					
					fresh_injury = False
					critical_injury = False
					for (k, v) in position.crewman.injury.items():
						if v[1] is None: continue
						if v[0] == 'Fresh':
							fresh_injury = True
						if v[1] == 'Critical':
							critical_injury = True
					
					if critical_injury:
						libtcod.console_set_default_foreground(crew_con, libtcod.light_red)
						libtcod.console_print_ex(crew_con, 19, y+2, libtcod.BKGND_NONE,
							libtcod.RIGHT, 'CRIT')
					elif fresh_injury:
						libtcod.console_set_default_foreground(crew_con, libtcod.light_red)
						libtcod.console_print_ex(crew_con, 19, y+2, libtcod.BKGND_NONE,
							libtcod.RIGHT, 'I')
			
			libtcod.console_set_default_foreground(crew_con, libtcod.darker_grey)
			for x in range(25):
				libtcod.console_print(crew_con, x, y+3, '-')
			
			libtcod.console_set_default_foreground(crew_con, libtcod.white)
			y += 4
			i += 1
	
	
	# update player command console 25x12
	def UpdateCmdCon(self):
		libtcod.console_clear(cmd_menu_con)
		
		# view mode active
		if session.scen_view_mode:
			
			if session.scen_view_hex is None: return
			
			libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_green)
			libtcod.console_print_ex(cmd_menu_con, 12, 0, libtcod.BKGND_NONE, libtcod.CENTER, 
				'Map Hex View Mode')
			
			# key commands
			libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
			if gamepad is not None:
				DisplayButton(cmd_menu_con, 3, 2, GAMEPADCHAR_LS)
				DisplayButton(cmd_menu_con, 3, 3, GAMEPADCHAR_LS)
				DisplayButton(cmd_menu_con, 3, 4, GAMEPADCHAR_Y)
				DisplayButton(cmd_menu_con, 3, 5, GAMEPADCHAR_A)
				DisplayButton(cmd_menu_con, 3, 11, GAMEPADCHAR_LSB)
			else:
				libtcod.console_print(cmd_menu_con, 1, 2, EnKey('q').upper() + '/' + EnKey('w').upper()+ '/' + EnKey('e').upper())
				libtcod.console_print(cmd_menu_con, 1, 3, EnKey('z').upper() + '/' + EnKey('x').upper()+ '/' + EnKey('c').upper())
				libtcod.console_print(cmd_menu_con, 1, 4, EnKey('s').upper())
				libtcod.console_print(cmd_menu_con, 1, 5, EnKey('f').upper())
				libtcod.console_print(cmd_menu_con, 1, 11, EnKey('v').upper())
			
			libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
			libtcod.console_print(cmd_menu_con, 8, 2, 'Move Highlight')
			libtcod.console_print(cmd_menu_con, 8, 3, 'Move Highlight')
			libtcod.console_print(cmd_menu_con, 8, 4, 'Cycle Unit Stack')
			libtcod.console_print(cmd_menu_con, 8, 5, 'Show Unit Info')
			libtcod.console_print(cmd_menu_con, 8, 11, 'Exit View Mode')
			return
		
		# current phase
		libtcod.console_set_default_foreground(cmd_menu_con, SCEN_PHASE_COL[self.phase])
		libtcod.console_print_ex(cmd_menu_con, 12, 0, libtcod.BKGND_NONE, libtcod.CENTER, 
			SCEN_PHASE_NAMES[self.phase] + ' Phase')
		
		# player not active
		if scenario.active_player == 1: return
		# advancing to next phase automatically
		if self.advance_phase: return
		
		# Command phase
		if self.phase == PHASE_COMMAND:
			
			# display inputs
			if gamepad is not None:
				DisplayButton(cmd_menu_con, 3, 1, GAMEPADCHAR_DPAD_UD)
				DisplayButton(cmd_menu_con, 3, 2, GAMEPADCHAR_DPAD_LR)
				DisplayButton(cmd_menu_con, 3, 4, GAMEPADCHAR_Y)
				DisplayButton(cmd_menu_con, 3, 5, GAMEPADCHAR_B)
				DisplayButton(cmd_menu_con, 3, 6, GAMEPADCHAR_BACK)
				DisplayButton(cmd_menu_con, 3, 7, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
				libtcod.console_print(cmd_menu_con, 1, 1, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(cmd_menu_con, 1, 2, EnKey('a').upper() + '/' + EnKey('d').upper())
				libtcod.console_print(cmd_menu_con, 1, 3, '1-0')
				libtcod.console_print(cmd_menu_con, 1, 4, 'H')
				libtcod.console_print(cmd_menu_con, 1, 5, EnKey('b').upper())
				libtcod.console_print(cmd_menu_con, 1, 6, EnKey('x').upper())
				libtcod.console_print(cmd_menu_con, 1, 7, EnKey('e').upper())
				
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 7, 3, 'Command Hotkeys')
			
			libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
			libtcod.console_print(cmd_menu_con, 7, 1, 'Select Position')
			libtcod.console_print(cmd_menu_con, 7, 2, 'Select Command')
			libtcod.console_print(cmd_menu_con, 7, 4, 'Open/Shut Hatch')
			libtcod.console_print(cmd_menu_con, 7, 5, 'Button/Open Up!')
			libtcod.console_print(cmd_menu_con, 7, 6, 'Set Default')
			libtcod.console_print(cmd_menu_con, 7, 7, 'Crewman Menu')
		
		# Crew action phase
		elif self.phase == PHASE_CREW_ACTION:
			if gamepad is not None:
				DisplayButton(cmd_menu_con, 1, 1, GAMEPADCHAR_DPAD_UD)
			else:
				libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
				libtcod.console_print(cmd_menu_con, 1, 1, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
			libtcod.console_print(cmd_menu_con, 5, 1, 'Select Position')
			
			# crew command specific actions
			if self.selected_position is None: return
			position = self.player_unit.positions_list[self.selected_position]
			if position.crewman is None: return
			
			if position.crewman.current_cmd == 'Manage Ready Rack':
				
				# Overwrite a bit of the up/down button prompt
				libtcod.console_print(cmd_menu_con, 20, 1, '/Ammo')

				rr_weapon = scenario.rack_management_array[position][0]

				# Generate modified saved & default ready rack templates, in case there's not enough ammo to fill them.
				possible_saved_rr = rr_weapon.CheckLoadoutTemplate(rr_weapon.default_ready_rack)[0]
				possible_default_rr = rr_weapon.CheckLoadoutTemplate(rr_weapon.GenerateDefaultLoadout(True)[1])[0]
				
				if gamepad is not None:
					DisplayButton(cmd_menu_con, 1, 2, GAMEPADCHAR_DPAD_LR)
					DisplayButton(cmd_menu_con, 1, 3, GAMEPADCHAR_RS)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, 2, EnKey('a').upper() + '/' + EnKey('d').upper())
					libtcod.console_print(cmd_menu_con, 1, 3, EnKey('c').upper())
				
				HOTKEYS = ['t', 'g', 'b']
				y = 4
				for i in range(min(3, len(rr_weapon.stats['ammo_type_list']))):
					ammotype = rr_weapon.stats['ammo_type_list'][i]
					if rr_weapon.ready_rack[ammotype] == rr_weapon.rr_size or rr_weapon.ammo_stores[ammotype] == 0:
						libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
					else:
						libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, y, EnKey(HOTKEYS[i]).upper())
					y += 1

				if len(rr_weapon.default_ready_rack) == 0 or possible_saved_rr == rr_weapon.ready_rack:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
				libtcod.console_print(cmd_menu_con, 1, y, EnKey('f').upper()) # saved rr

				if possible_default_rr != rr_weapon.ready_rack:
					if gamepad is not None:
						DisplayButton(cmd_menu_con, 1, y+1, GAMEPADCHAR_Y)
					else:
						libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
						libtcod.console_print(cmd_menu_con, 1, y+1, EnKey('x').upper()) # default rr
				
				if len(scenario.rack_management_array[position]) == 1:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, 3, 'Cycle Selected Gun')
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, 2, 'Remove/Add Round')
				y = 4
				for i in range(min(3, len(rr_weapon.stats['ammo_type_list']))):
					ammotype = rr_weapon.stats['ammo_type_list'][i]
					if rr_weapon.ready_rack[ammotype] == rr_weapon.rr_size or rr_weapon.ammo_stores[ammotype] == 0:
						libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
					else:
						libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
					libtcod.console_print(cmd_menu_con, 5, y, 'Fill RR with ' + ammotype)
					y += 1

				if len(rr_weapon.default_ready_rack) == 0 or possible_saved_rr == rr_weapon.ready_rack:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, y, 'Apply Saved RR') # f

				if possible_default_rr == rr_weapon.ready_rack:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, y+1, 'Apply Default RR') # x

			elif position.crewman.current_cmd == 'Command Battlegroup':
				
				allied_units = False
				for unit in self.units:
					if not unit.alive: continue
					if unit.owning_player == 1: continue
					if unit.is_player: continue
					allied_units = True
					break
				
				# no units to order
				if not allied_units: return
					
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_purple)
				libtcod.console_print_ex(cmd_menu_con, 12, 3, libtcod.BKGND_NONE,
					libtcod.CENTER, self.battlegroup_command)
				
				# display inputs
				if gamepad is not None:
					DisplayButton(cmd_menu_con, 1, 5, GAMEPADCHAR_A)
					DisplayButton(cmd_menu_con, 1, 6, GAMEPADCHAR_B)
					DisplayButton(cmd_menu_con, 1, 7, GAMEPADCHAR_BACK)
					DisplayButton(cmd_menu_con, 1, 8, GAMEPADCHAR_Y)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, 5, EnKey('q').upper())
					libtcod.console_print(cmd_menu_con, 1, 6, EnKey('a').upper())
					libtcod.console_print(cmd_menu_con, 1, 7, EnKey('z').upper())
					libtcod.console_print(cmd_menu_con, 1, 8, EnKey('x').upper())
				
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, 5, 'Fire at Will')
				libtcod.console_print(cmd_menu_con, 5, 6, 'Attack my Target')
				libtcod.console_print(cmd_menu_con, 5, 7, 'Hold Fire')
				libtcod.console_print(cmd_menu_con, 5, 8, 'On my Mark')
			
			elif position.crewman.current_cmd == 'First Aid':
				
				if position.crewman.first_aid_action_taken:
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
					libtcod.console_print(cmd_menu_con, 7, 3, 'Already Acted')
				else:
					if gamepad is not None:
						DisplayButton(cmd_menu_con, 1, 3, GAMEPADCHAR_A)
					else:
						libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
						libtcod.console_print(cmd_menu_con, 1, 3, EnKey('f').upper())
					libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
					libtcod.console_print(cmd_menu_con, 5, 3, 'Attempt First Aid')
				
		# Movement phase
		elif self.phase == PHASE_MOVEMENT:
			
			# unbogging only
			if self.player_unit.bogged:
				if gamepad is not None:
					DisplayButton(cmd_menu_con, 3, 1, GAMEPADCHAR_A)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, 1, EnKey('u').upper())
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, 1, 'Attempt Unbog')
			
			# normal commands
			else:
				
				if gamepad is not None:
					DisplayButton(cmd_menu_con, 3, 1, GAMEPADCHAR_DPAD_UD)
					DisplayButton(cmd_menu_con, 3, 2, GAMEPADCHAR_DPAD_LR)
					DisplayButton(cmd_menu_con, 3, 3, GAMEPADCHAR_A)
					DisplayButton(cmd_menu_con, 3, 5, GAMEPADCHAR_BACK)
					DisplayButton(cmd_menu_con, 3, 6, GAMEPADCHAR_Y)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, 1, EnKey('w').upper() + '/' + EnKey('s').upper())
					libtcod.console_print(cmd_menu_con, 1, 2, EnKey('a').upper() + '/' + EnKey('d').upper())
					libtcod.console_print(cmd_menu_con, 1, 3, EnKey('o').upper())
					libtcod.console_print(cmd_menu_con, 1, 5, EnKey('r').upper())
					libtcod.console_print(cmd_menu_con, 1, 6, EnKey('c').upper())
				
				# Attempt Hull down - may not be active
				hd_ok = True
				if len(self.player_unit.hull_down) > 0:
					if self.player_unit.hull_down[0] == self.player_unit.facing:
						hd_ok = False
				if hd_ok:
					if gamepad is not None:
						DisplayButton(cmd_menu_con, 3, 4, GAMEPADCHAR_B)
					else:
						libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
						libtcod.console_print(cmd_menu_con, 1, 4, EnKey('h').upper())
				
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 5, 1, 'Forward/Reverse')
				libtcod.console_print(cmd_menu_con, 5, 2, 'Pivot Hull')
				libtcod.console_print(cmd_menu_con, 5, 3, 'Overrun Attack')
				libtcod.console_print(cmd_menu_con, 5, 5, 'Reposition')
				libtcod.console_print(cmd_menu_con, 5, 6, 'Conceal/Reveal Self')
				if len(self.player_unit.hull_down) > 0:
					if self.player_unit.hull_down[0] == self.player_unit.facing:
						libtcod.console_set_default_foreground(cmd_menu_con, libtcod.dark_grey)
				libtcod.console_print(cmd_menu_con, 5, 4, 'Attempt Hull Down')
				
		
		# Shooting phase
		elif self.phase == PHASE_SHOOTING:
			
			immobilize_allowed = False
			if self.selected_weapon is not None:
				immobilize_allowed = self.CanImmobilize(self.player_unit, self.selected_weapon, self.selected_weapon.selected_target)
			
			if gamepad is not None:
				DisplayButton(cmd_menu_con, 3, 1, GAMEPADCHAR_DPAD_UD)
				DisplayButton(cmd_menu_con, 3, 2, GAMEPADCHAR_DPAD_LR)
				if 'turret' in self.player_unit.stats:
					if self.player_unit.stats['turret'] not in ['FIXED', 'FXT']:
						DisplayButton(cmd_menu_con, 2, 3, GAMEPADCHAR_LB)
						DisplayButton(cmd_menu_con, 3, 3, GAMEPADCHAR_RB)
				if self.selected_weapon.rr_size > 0:
					DisplayButton(cmd_menu_con, 3, 4, GAMEPADCHAR_BACK)
			else:
				libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
				libtcod.console_print(cmd_menu_con, 1, 1, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(cmd_menu_con, 1, 2, EnKey('a').upper() + '/' + EnKey('d').upper())
				if 'turret' in self.player_unit.stats:
					if self.player_unit.stats['turret'] not in ['FIXED', 'FXT']:
						libtcod.console_print(cmd_menu_con, 1, 3, EnKey('q').upper() + '/' + EnKey('e').upper())
				if self.selected_weapon.rr_size > 0:
					libtcod.console_print(cmd_menu_con, 1, 4, EnKey('r').upper())
			
			libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
			libtcod.console_print(cmd_menu_con, 7, 1, 'Select Weapon/Ammo')
			libtcod.console_print(cmd_menu_con, 7, 2, 'Select Target')
			if 'turret' in self.player_unit.stats:
				if self.player_unit.stats['turret'] not in ['FIXED', 'FXT']:
					libtcod.console_print(cmd_menu_con, 7, 3, 'Rotate Turret')
			if self.selected_weapon.rr_size > 0:
				libtcod.console_print(cmd_menu_con, 7, 4, 'Toggle RR Use')
			
			# broken weapon
			if self.selected_weapon.broken:
				pass
			
			# jammed weapon
			elif self.selected_weapon.jammed:
				if gamepad is not None:
					DisplayButton(cmd_menu_con, 3, 6, GAMEPADCHAR_Y)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, 6, EnKey('u').upper())
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 7, 6, 'Unjam Weapon')
			
			else:
				if gamepad is not None:
					DisplayButton(cmd_menu_con, 3, 6, GAMEPADCHAR_A)
					if immobilize_allowed:
						DisplayButton(cmd_menu_con, 3, 7, GAMEPADCHAR_B)
				else:
					libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
					libtcod.console_print(cmd_menu_con, 1, 6, EnKey('f').upper())
					if immobilize_allowed:
						libtcod.console_print(cmd_menu_con, 1, 7, EnKey('i').upper())
			
				libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
				libtcod.console_print(cmd_menu_con, 7, 6, 'Fire at Target')
				if immobilize_allowed:
					libtcod.console_print(cmd_menu_con, 7, 7, 'Attempt Immobilize')
		
		else:
			return
		
		# display inputs
		libtcod.console_set_default_foreground(cmd_menu_con, ACTION_KEY_COL)
		if gamepad is not None:
			DisplayButton(cmd_menu_con, 3, 10, GAMEPADCHAR_X)
			DisplayButton(cmd_menu_con, 3, 11, GAMEPADCHAR_LSB)
		else:
			libtcod.console_print(cmd_menu_con, 1, 10, 'Space')
			libtcod.console_print(cmd_menu_con, 1, 11, EnKey('v').upper())
		
		libtcod.console_set_default_foreground(cmd_menu_con, libtcod.light_grey)
		libtcod.console_print(cmd_menu_con, 7, 10, 'End Phase')
		libtcod.console_print(cmd_menu_con, 7, 11, 'Enter View Mode')
	
	
	# plot the center of a given in-game hex on the scenario hex map console
	# 0,0 appears in centre of console
	def PlotHex(self, hx, hy):
		x = (hx*7) + 26
		y = (hy*6) + (hx*3) + 21
		return (x,y)
	
	
	# build a dictionary of console locations and their corresponding map hexes
	# only called once when Scenario is created
	def BuildHexmapDict(self):
		for map_hex in self.map_hexes:
			# stop when outer hex ring is reached
			if GetHexDistance(0, 0, map_hex.hx, map_hex.hy) > 3: return
			(x,y) = self.PlotHex(map_hex.hx, map_hex.hy)
			
			# record console positions to dictionary
			for x1 in range(x-2, x+3):
				self.hex_map_index[(x1, y-2)] = map_hex
				self.hex_map_index[(x1, y+2)] = map_hex
			for x1 in range(x-3, x+4):
				self.hex_map_index[(x1, y-1)] = map_hex
				self.hex_map_index[(x1, y+1)] = map_hex
			for x1 in range(x-4, x+5):
				self.hex_map_index[(x1, y)] = map_hex
	
	
	# update hexmap console 53x43
	def UpdateHexmapCon(self):
		
		libtcod.console_clear(hexmap_con)
		
		# select base hex console image to use
		if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
			scen_hex = LoadXP('scen_hex_snow.xp')
		elif self.cd_map_hex.terrain_type == 'Beach':
			scen_hex = LoadXP('scen_hex_beach.xp')
		elif campaign_day.rattenkrieg:
			scen_hex = LoadXP('scen_hex_urban.xp')
		elif campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
			scen_hex = LoadXP('scen_hex_sp.xp')
		elif campaign.stats['region'] == 'North Africa':
			scen_hex = LoadXP('scen_hex_desert.xp')
		elif campaign_day.weather['Season'] == 'Winter':
			scen_hex = LoadXP('scen_hex_winter.xp')
		else:
			scen_hex = LoadXP('scen_hex.xp')
		libtcod.console_set_key_color(scen_hex, KEY_COLOR)
		
		# draw hexes to hex map console
		for map_hex in self.map_hexes:
			if GetHexDistance(0, 0, map_hex.hx, map_hex.hy) > 3: break
			(x,y) = self.PlotHex(map_hex.hx, map_hex.hy)
			libtcod.console_blit(scen_hex, 0, 0, 0, 0, hexmap_con, x-5, y-3)
		
		# draw fog/sandstorm depiction overtop
		if campaign_day.weather['Fog'] > 0:
			scen_hex = LoadXP('scen_hex_fog.xp')
			libtcod.console_set_key_color(scen_hex, KEY_COLOR)
			for distance in range(3, 3 - campaign_day.weather['Fog'], -1):
				for (hx, hy) in GetHexRing(0, 0, distance):
					(x,y) = self.PlotHex(hx, hy)
					libtcod.console_blit(scen_hex, 0, 0, 0, 0, hexmap_con, x-5, y-3)
		
		del scen_hex
	
	
	# update unit layer console
	def UpdateUnitCon(self):
		
		libtcod.console_set_default_background(unit_con, KEY_COLOR)
		libtcod.console_clear(unit_con)
		for map_hex in self.map_hexes:
			
			distance = GetHexDistance(0, 0, map_hex.hx, map_hex.hy)
			
			# too far away
			if distance > 3: continue
			
			# no units in hex
			if len(map_hex.unit_stack) == 0: continue
			
			# draw up to two other units in stack
			if config.getboolean('ArmCom2', 'unit_stack_display'):
				if len(map_hex.unit_stack) > 1:
					map_hex.unit_stack[1].DrawMe(-2, 0)
				if len(map_hex.unit_stack) > 2:
					map_hex.unit_stack[2].DrawMe(2, 0)
			
			# draw top unit in stack
			map_hex.unit_stack[0].DrawMe(0, 0)
			
			# draw stack number indicator if any
			if len(map_hex.unit_stack) == 1: continue
			
			# don't draw stack number if top unit is moving
			if len(map_hex.unit_stack[0].animation_cells) > 0: continue
			
			# don't draw stack number if all units already displayed
			if config['ArmCom2'].getboolean('unit_stack_display') and len(map_hex.unit_stack) <= 3: continue
			
			if 4 - distance <= campaign_day.weather['Fog']:
				bg_col = libtcod.Color(128,128,128)
			elif scenario.cd_map_hex.terrain_type == 'Beach':
				bg_col = libtcod.Color(102,102,0)
			elif campaign_day.rattenkrieg:
				bg_col = libtcod.Color(77,77,77)
			elif campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
				bg_col = libtcod.Color(0,102,0)
			elif campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
				bg_col = libtcod.Color(191,191,191)
			elif campaign.stats['region'] == 'North Africa':
				bg_col = libtcod.Color(102,82,51)
			elif campaign_day.weather['Season'] == 'Winter':
				bg_col = libtcod.Color(51,41,26)
			else:
				bg_col = libtcod.Color(0,64,0)
			if map_hex.unit_stack[0].turret_facing is not None:
				facing = map_hex.unit_stack[0].turret_facing
			elif map_hex.unit_stack[0].facing is not None:
				facing = map_hex.unit_stack[0].facing
			else:
				facing = 3
			if facing in [5,0,1]:
				y_mod = 1
			else:
				y_mod = -1
			
			# exception: unit is unspotted enemy
			if not map_hex.unit_stack[0].spotted and map_hex.unit_stack[0].owning_player == 1:
				y_mod = -1
			
			# top unit is on overrun
			if map_hex.unit_stack[0].overrun:
				y_mod -= 1
			
			(x,y) = scenario.PlotHex(map_hex.unit_stack[0].hx, map_hex.unit_stack[0].hy)
			text = str(len(map_hex.unit_stack))
			
			if 4 - distance <= campaign_day.weather['Fog']:
				libtcod.console_set_default_foreground(unit_con, libtcod.black)
			else:
				libtcod.console_set_default_foreground(unit_con, libtcod.grey)
			libtcod.console_set_default_background(unit_con, bg_col)
			libtcod.console_print_ex(unit_con, x, y+y_mod, libtcod.BKGND_SET, libtcod.CENTER,
				text)
		
	
	# update GUI console
	def UpdateGuiCon(self, los_highlight=None, hide_los=False, highlight_covered_hexes=None):
		
		libtcod.console_clear(gui_con)
		
		# map hex view mode active
		if session.scen_view_mode:
			
			if session.scen_view_hex is None: return
			(hx, hy) = session.scen_view_hex
			(x,y) = scenario.PlotHex(hx, hy)
			libtcod.console_blit(session.scen_hex_fov, 0, 0, 0, 0, gui_con,
				x-5, y-3)
			return
				
		# display field of view if in command phase
		# but not if there's a support attack still to resolve
		if self.phase == PHASE_COMMAND and not (campaign_day.air_support_request or campaign_day.arty_support_request):
			position = scenario.player_unit.positions_list[scenario.selected_position]
			for (hx, hy) in position.visible_hexes:
				(x,y) = scenario.PlotHex(hx, hy)
				libtcod.console_blit(session.scen_hex_fov, 0, 0, 0, 0, gui_con,
					x-5, y-3)
		
		# shooting phase
		elif self.phase == PHASE_SHOOTING:
			
			# display covered hexes if a weapon is selected
			if self.selected_weapon is not None:
				for (hx, hy) in self.selected_weapon.covered_hexes:
					(x,y) = self.PlotHex(hx, hy)
					libtcod.console_blit(session.scen_hex_fov, 0, 0, 0, 0, gui_con,
						x-5, y-3)
			
				# display target recticle if a weapon target is selected
				if self.selected_weapon.selected_target is not None and not hide_los:
					
					if not self.player_unit.los_table[self.selected_weapon.selected_target]:
						
						# depending on scenario hex base colour, change highlight colour to be more visible
						if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow'] or campaign_day.rattenkrieg:
							col = libtcod.black
						else:
							col = libtcod.light_grey
					else:
						col = libtcod.red
					
					# display firing line
					(x1,y1) = self.player_unit.GetScreenLocation()
					(x2,y2) = self.PlotHex(self.selected_weapon.selected_target.hx, self.selected_weapon.selected_target.hy)
					line = GetLine(x1, y1, x2, y2)
					for (x,y) in line[2:-1]:
						libtcod.console_put_char_ex(gui_con, x, y, 250, col, libtcod.black)
		
		# for AISpy
		if highlight_covered_hexes is not None:
			for (hx, hy) in highlight_covered_hexes:
				if GetHexDistance(0, 0, hx, hy) > 3: continue
				(x,y) = self.PlotHex(hx, hy)
				libtcod.console_blit(session.scen_hex_fov, 0, 0, 0, 0, gui_con,
					x-5, y-3)
		
		if los_highlight is None: return
		
		(unit1, unit2) = los_highlight
		(x1,y1) = self.PlotHex(unit1.hx, unit1.hy)
		if unit1.overrun: y1 -= 1
		(x2,y2) = self.PlotHex(unit2.hx, unit2.hy)
		if unit2.overrun: y2 -= 1
		line = GetLine(x1, y1, x2, y2)
		for (x,y) in line[2:-1]:
			libtcod.console_put_char_ex(gui_con, x, y, 250, libtcod.red, libtcod.black)
			
	
	# update unit info console, which displays basic information about a unit under
	# the mouse cursor
	# 61x5
	def UpdateUnitInfoCon(self):
		libtcod.console_clear(unit_info_con)
		
		unit = None
		
		# view mode active
		if session.scen_view_mode:
			
			if session.scen_view_hex is None: return
			(hx, hy) = session.scen_view_hex
			map_hex = self.hex_dict[(hx,hy)]
		
		else:
		
			# check that cursor is in map area and on a map hex
			x = mouse.cx - 32 - window_x
			y = mouse.cy - 9 - window_y
			if (x,y) not in self.hex_map_index:
				
				# a unit might be targeted by the player
				if self.phase == PHASE_SHOOTING and self.selected_weapon is not None:
					if self.selected_weapon.selected_target is not None:
						unit = self.selected_weapon.selected_target
				
				if unit is None:
					libtcod.console_set_default_foreground(unit_info_con, libtcod.dark_grey)
					if gamepad is None:
						libtcod.console_print(unit_info_con, 18, 1, 'Mouseover a hex for details')
						libtcod.console_print(unit_info_con, 10, 2, 'Use the mouse wheel to cycle units in a hex')
						libtcod.console_print(unit_info_con, 8, 3, 'Right click on a hex for more info on that unit')
					else:
						libtcod.console_print(unit_info_con, 18, 1, 'Use View mode to inspect hexes')
					return
				else:
					map_hex = self.hex_dict[(unit.hx,unit.hy)]
			else:
				map_hex = self.hex_map_index[(x,y)]
		
		# distance from player in right column
		distance = GetHexDistance(0, 0, map_hex.hx, map_hex.hy)
		if distance == 0:
			text = '0-120m'
		elif distance == 1:
			text = '120-480m'
		elif distance == 2:
			text = '480-960m'
		else:
			text = '960-1440m'
		libtcod.console_set_default_foreground(unit_info_con, libtcod.light_grey)
		libtcod.console_print_ex(unit_info_con, 60, 0, libtcod.BKGND_NONE,
			libtcod.RIGHT, 'Range: ' + text)
		
		# fog effect if any
		if campaign_day.weather['Fog'] > 0:
			if 4 - distance <= campaign_day.weather['Fog']:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.lighter_grey)
				libtcod.console_print_ex(unit_info_con, 60, 1, libtcod.BKGND_NONE,
					libtcod.RIGHT, 'Fog')
		
		# no unit targeted
		if unit is None:
			
			# no units in stack
			if len(map_hex.unit_stack) == 0:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.dark_grey)
				libtcod.console_print(unit_info_con, 23, 2, 'No units present')
				return
			
			# if using mouse control, get the unit near the mouse.
			if not session.scen_view_mode:
				unit = map_hex.GetMouseUnit(x)
			# otherwise, get the top unit in the stack.
			else:
				unit = map_hex.unit_stack[0]
		
		if unit is None:
			return
		# display smoke and/or dust levels
		text = ''
		if unit.smoke > 0:
			text += 'Smoke: ' + str(unit.smoke)
		if unit.dust > 0:
			if unit.smoke > 0:
				text += ' '
			text += 'Dust: ' + str(unit.dust)
		if text != '':
			libtcod.console_set_default_foreground(unit_info_con, libtcod.grey)
			libtcod.console_print_ex(unit_info_con, 60, 2, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
		
		# LoS blocked
		if not self.player_unit.los_table[unit]:
			libtcod.console_set_default_background(unit_info_con, libtcod.grey)
			libtcod.console_rect(unit_info_con, 25, 0, 11, 1, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(unit_info_con, libtcod.darkest_grey)
			libtcod.console_set_default_foreground(unit_info_con, libtcod.black)
			libtcod.console_print(unit_info_con, 25, 0, 'LoS Blocked')
			
			if unit.owning_player == 1:
				ShowTutorialSlide('scenario_los_blocked')
		
		if unit.owning_player == 1 and not unit.spotted:
			libtcod.console_set_default_foreground(unit_info_con, UNKNOWN_UNIT_COL)
			libtcod.console_print(unit_info_con, 0, 0, 'Unspotted Enemy')
			
		else:
			
			if unit == scenario.player_unit:
				col = libtcod.white
			elif unit.owning_player == 0:
				col = ALLIED_UNIT_COL
			else:
				col = ENEMY_UNIT_COL
	
			libtcod.console_set_default_foreground(unit_info_con, col)
			libtcod.console_print(unit_info_con, 0, 0, unit.unit_id)
			
			libtcod.console_set_default_foreground(unit_info_con, libtcod.light_grey)
			
			# display commander surname if player squadmate
			if unit.owning_player == 0 and unit.hx == 0 and unit.hy == 0 and not unit.is_player:
				PrintExtended(unit_info_con, 30, 0, unit.positions_list[0].crewman.last_name, center=True)
			
			libtcod.console_print(unit_info_con, 0, 1, session.nations[unit.nation]['adjective'])
			libtcod.console_print(unit_info_con, 0, 2, unit.GetStat('class'))
			
			# statuses
			if unit.immobilized:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.darker_red)
				libtcod.console_print(unit_info_con, 0, 3, 'Immobilized')
			elif unit.pinned:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.dark_red)
				libtcod.console_print(unit_info_con, 0, 3, 'Pinned')
			elif unit.moving:
				libtcod.console_print(unit_info_con, 0, 3, 'Moving')
			
			if unit.routed:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.light_red)
				libtcod.console_print(unit_info_con, 0, 4, 'Routed')
			
			if unit.fired:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.red)
				libtcod.console_print(unit_info_con, 12, 3, 'Fired')
			
			if unit.towing is not None:
				libtcod.console_print(unit_info_con, 10, 4, 'Towing: ' + unit.towing.unit_id)
			
			if unit.GetStat('category') == 'Gun' or unit.GetStat('deploy_to_fire') is not None:
				if unit.deployed:
					libtcod.console_print(unit_info_con, 12, 4, 'Deployed')
				else:
					libtcod.console_print(unit_info_con, 12, 4, 'Packed-Up')
					if unit.towed_by is not None:
						libtcod.console_print(unit_info_con, 22, 4, 'Towed')
			
			# middle column
			
			# current terrain
			if unit.terrain is not None:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.dark_green)
				libtcod.console_print_ex(unit_info_con, 30, 1, libtcod.BKGND_NONE,
					libtcod.CENTER, unit.terrain)
			
			# TEM if any
			unit_tem = unit.GetTEM()
			if unit_tem != 0.0:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.darker_green)
				libtcod.console_print_ex(unit_info_con, 30, 2, libtcod.BKGND_NONE,
					libtcod.CENTER, 'TEM: ' + str(unit_tem) + '%')
			
			# for units not in player's own hex
			if not (unit.hx == 0 and unit.hy == 0):
			
				# hull facing if any
				if unit.facing is not None and unit.GetStat('category') not in ['Infantry', 'Cavalry']:
					libtcod.console_put_char_ex(unit_info_con, 27, 3, 'H',
						libtcod.light_grey, libtcod.darkest_grey)
					libtcod.console_put_char_ex(unit_info_con, 28, 3,
						GetDirectionalArrow(unit.facing), libtcod.light_grey,
						libtcod.darkest_grey)
					text = GetFacing(scenario.player_unit, unit)
					libtcod.console_set_default_foreground(unit_info_con, libtcod.light_grey)
					libtcod.console_print(unit_info_con, 30, 3, text)
				
				if unit.turret_facing is not None:
					libtcod.console_put_char_ex(unit_info_con, 27, 4, 'T',
						libtcod.light_grey, libtcod.darkest_grey)
					libtcod.console_put_char_ex(unit_info_con, 28, 4,
						GetDirectionalArrow(unit.turret_facing), libtcod.light_grey,
						libtcod.darkest_grey)
					text = GetFacing(scenario.player_unit, unit, turret_facing=True)
					libtcod.console_set_default_foreground(unit_info_con, libtcod.light_grey)
					libtcod.console_print(unit_info_con, 30, 4, text)
			
			# HD status if any
			if len(unit.hull_down) > 0:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.sepia)
				libtcod.console_print(unit_info_con, 36, 3, 'HD')
				
				# emplacements have HD all around
				if len(unit.hull_down) == 6:
					libtcod.console_put_char_ex(unit_info_con, 38, 3,
						250, libtcod.sepia, libtcod.darkest_grey)
				else:
					libtcod.console_put_char_ex(unit_info_con, 38, 3,
						GetDirectionalArrow(unit.hull_down[0]), libtcod.sepia,
						libtcod.darkest_grey)
			
			# right column
			
			# dug-in, entrenched, or fortified status
			text = ''
			if unit.dug_in:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.sepia)
				text = 'Dug-in'
			elif unit.entrenched:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.light_sepia)
				text = 'Entrenched'
			elif unit.fortified:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.light_grey)
				text = 'Fortified'
			if text != '':
				libtcod.console_print_ex(unit_info_con, 60, 3, libtcod.BKGND_NONE,
					libtcod.RIGHT, text)
			
			# AI statuses
			if unit.ai is None: return
			if unit in scenario.player_unit.squad:
				libtcod.console_set_default_foreground(unit_info_con, libtcod.light_purple)
				libtcod.console_print_ex(unit_info_con, 60, 4, libtcod.BKGND_NONE,
					libtcod.RIGHT, unit.ai.leader_command)
				return
			
			text = unit.ai.attitude + chr(250) + unit.ai.state
			libtcod.console_set_default_foreground(unit_info_con, libtcod.light_purple)
			libtcod.console_print_ex(unit_info_con, 60, 4, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
	
	
	# starts or re-starts looping animations based on weather conditions
	# this is for the Scenario interface
	def InitAnimations(self):
		
		# reset animations
		self.animation['rain_active'] = False
		self.animation['rain_drops'] = []
		self.animation['snow_active'] = False
		self.animation['snowflakes'] = []
		self.animation['sandstorm_active'] = False
		self.animation['sand'] = []
		self.animation['hex_highlight'] = False
		self.animation['hex_flash'] = 0
		
		# check for rain/snow/sandstorm animation
		if campaign_day.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
			self.animation['rain_active'] = True
		elif campaign_day.weather['Precipitation'] in ['Light Snow', 'Snow', 'Blizzard']:
			self.animation['snow_active'] = True
		elif campaign_day.weather['Precipitation'] == 'Sandstorm':
			self.animation['sandstorm_active'] = True
		
		# set up rain if any
		if self.animation['rain_active']:
			num = 4
			if campaign_day.weather['Precipitation'] == 'Heavy Rain':
				num = 8
			for i in range(num):
				x = libtcod.random_get_int(0, 4, 50)
				y = libtcod.random_get_int(0, 0, 38)
				lifespan = libtcod.random_get_int(0, 1, 5)
				self.animation['rain_drops'].append((x, y, 4))
		
		# set up snow if any
		if self.animation['snow_active']:
			if campaign_day.weather['Precipitation'] == 'Light Snow':
				num = 4
			elif campaign_day.weather['Precipitation'] == 'Snow':
				num = 8
			else:
				num = 16
			for i in range(num):
				x = libtcod.random_get_int(0, 4, 50)
				y = libtcod.random_get_int(0, 0, 37)
				lifespan = libtcod.random_get_int(0, 4, 10)
				self.animation['snowflakes'].append((x, y, lifespan))
		
		# set up sandstorm if any
		if self.animation['sandstorm_active']:
			for i in range(32):
				x = libtcod.random_get_int(0, 4, 50)
				y = libtcod.random_get_int(0, 0, 37)
				lifespan = libtcod.random_get_int(0, 4, 10)
				self.animation['sand'].append((x, y, lifespan))
	
	
	# update the scenario animation frame and console 53x43
	def UpdateAnimCon(self, weather=False):
		
		libtcod.console_clear(anim_con)
		
		# update either weather animations or single-shot ones
		
		# weather/looping animations
		if weather:
		
			# check for storm lightning effect
			if campaign_day.weather['Storm']:
				if libtcod.random_get_int(0, 0, 200) == 1:
					x = libtcod.random_get_int(0, 32, 85)
					for y in range(window_y, WINDOW_HEIGHT):
						libtcod.console_set_char_background(0, x, y,
							libtcod.yellow, libtcod.BKGND_SET)
						roll = libtcod.random_get_int(0, 1, 10)
						if roll <= 2:
							x -= 1
						elif roll >= 9:
							x += 1
						
						if x < 33:
							x = 30
						elif x > 85:
							x = 85
					
					for i in range(3):
						libtcod.console_flush()
					libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
					libtcod.console_flush()
					PlaySoundFor(None, 'thunder')
			
			if self.animation['rain_active']:
				
				# update location of each rain drop, spawn new ones if required
				for i in range(len(self.animation['rain_drops'])):
					(x, y, lifespan) = self.animation['rain_drops'][i]
					
					# respawn if finished
					if lifespan == 0:
						x = libtcod.random_get_int(0, 4, 50)
						y = libtcod.random_get_int(0, 0, 37)
						lifespan = libtcod.random_get_int(0, 1, 5)
					else:
						y += 2
						lifespan -= 1
					
					self.animation['rain_drops'][i] = (x, y, lifespan)
						
			if self.animation['snow_active']:
				
				# update location of each snowflake
				for i in range(len(self.animation['snowflakes'])):
					(x, y, lifespan) = self.animation['snowflakes'][i]
					
					# respawn if finished
					if lifespan == 0:
						x = libtcod.random_get_int(0, 4, 50)
						y = libtcod.random_get_int(0, 0, 37)
						lifespan = libtcod.random_get_int(0, 4, 10)
					else:
						x += choice([-1, 0, 1])
						y += 1
						lifespan -= 1
					
					self.animation['snowflakes'][i] = (x, y, lifespan)
				
			
			# update sandstorm
			if self.animation['sandstorm_active']:
				
				# update sand location
				for i in range(len(self.animation['sand'])):
					(x, y, lifespan) = self.animation['sand'][i]
					
					# respawn if finished or off screen
					if lifespan == 0 or x > 50:
						x = libtcod.random_get_int(0, 4, 48)
						y = libtcod.random_get_int(0, 0, 37)
						lifespan = libtcod.random_get_int(0, 4, 10)
					else:
						x += 1
						lifespan -= 1
					
					self.animation['sand'][i] = (x, y, lifespan)

			
			# reset update timer
			session.weather_anim_timer = time.time()

		# single-shot animations
		else:

			# update airplane animation if any
			if self.animation['air_attack'] is not None:
				# stop if reached end, but don't clear the airplane console yet
				if len(self.animation['air_attack_line']) == 1:
					self.animation['air_attack_arrived'] = True
				else:
					# update draw location and draw
					self.animation['air_attack_line'].pop(0)
				
			# update gun fire animation if any
			if self.animation['gun_fire_active']:
				self.animation['gun_fire_line'].pop(0)
				if len(self.animation['gun_fire_line']) > 0:
					self.animation['gun_fire_line'].pop(0)
				
				if len(self.animation['gun_fire_line']) == 0:
					self.animation['gun_fire_active'] = False
					self.animation['attack_animation_active'] = False
			
			# update small arms fire if any
			if self.animation['small_arms_fire_action'] is not None:
				if self.animation['small_arms_lifetime'] == 0:
					self.animation['small_arms_fire_action'] = None
					self.animation['attack_animation_active'] = False
				else:
					self.animation['small_arms_lifetime'] -= 1
					
			# update bomb/explosion animation if any
			if self.animation['bomb_effect'] is not None:
				if self.animation['bomb_effect_lifetime'] == 0:
					self.animation['bomb_effect'] = None
					self.animation['attack_animation_active'] = False
				else:
					self.animation['bomb_effect_lifetime'] -= 1
					
			# update grenade effect if any
			if self.animation['grenade_effect'] is not None:
				if self.animation['grenade_effect_lifetime'] == 0:
					self.animation['grenade_effect'] = None
					self.animation['attack_animation_active'] = False
				else:
					self.animation['grenade_effect_lifetime'] -= 1
					
			# update flamethrower effect if any
			if self.animation['ft_effect'] is not None:
				if self.animation['ft_effect_lifetime'] == 0:
					self.animation['ft_effect'] = None
					self.animation['attack_animation_active'] = False
				else:
					self.animation['ft_effect_lifetime'] -= 1
			
			# update Panzerschreck firing effect if any
			if self.animation['psk_fire_action']:
				self.animation['psk_fire_line'].pop(0)
				if len(self.animation['psk_fire_line']) == 0:
					self.animation['psk_fire_action'] = False
					self.animation['attack_animation_active'] = False
			
			# update canister fire effect if any
			if self.animation['canister_fire']:
				if self.animation['canister_fire_lifetime'] == 0:
					self.animation['canister_fire'] = False
					self.animation['attack_animation_active'] = False
				else:
					self.animation['canister_fire_lifetime'] -= 1
			
			# update canister hit effect if any
			if self.animation['canister_hit']:
				if self.animation['canister_hit_lifetime'] == 0:
					self.animation['canister_hit'] = False
					self.animation['attack_animation_active'] = False
				else:
					self.animation['canister_hit_lifetime'] -= 1
			
			# update smoke effect if any
			if self.animation['smoke_effect']:
				if self.animation['smoke_effect_lifetime'] == 0:
					self.animation['smoke_effect'] = 0
					self.animation['attack_animation_active'] = False
				else:
					self.animation['smoke_effect_lifetime'] -= 1
			
			# update hex highlight if any
			if self.animation['hex_highlight']:
				if self.animation['hex_flash'] == 1:
					self.animation['hex_flash'] = 0
				else:
					self.animation['hex_flash'] = 1
			
			# reset update timer
			session.anim_timer = time.time()
		
		# draw all active animations to animation console
		if self.animation['rain_active']:
			for (x, y, lifespan) in self.animation['rain_drops']:
				if x < 0 or y > 50: continue
				if lifespan == 0:
					char = 111
				else:
					char = 124
				libtcod.console_put_char_ex(anim_con, x, y, char, libtcod.light_blue,
					libtcod.black)
		if self.animation['snow_active']:
			for (x, y, lifespan) in self.animation['snowflakes']:
				if x < 0 or y > 50: continue
				libtcod.console_put_char_ex(anim_con, x, y, 249, libtcod.white,
					libtcod.black)
		if self.animation['sandstorm_active']:
			for (x, y, lifespan) in self.animation['sand']:
				if x < 0 or y > 50: continue
				libtcod.console_put_char_ex(anim_con, x, y, 177, libtcod.light_sepia,
					libtcod.darker_sepia)
		
		if self.animation['air_attack'] is not None:
			(x,y) = self.animation['air_attack_line'][0]
			libtcod.console_blit(self.animation['air_attack'], 0, 0, 0, 0, anim_con, x-1, y)
		
		if self.animation['gun_fire_active']:
			if len(self.animation['gun_fire_line']) > 0:
				(x,y) = self.animation['gun_fire_line'][0]
				libtcod.console_put_char_ex(anim_con, x, y, 250, libtcod.white,
					libtcod.black)
		
		if self.animation['small_arms_fire_action'] is not None:
			(x,y) = choice(self.animation['small_arms_fire_line'][1:])
			libtcod.console_put_char_ex(anim_con, x, y, 250, libtcod.yellow,
				libtcod.black)
		
		if self.animation['bomb_effect'] is not None:
			(x,y) = self.animation['bomb_effect']
			if 3 & self.animation['bomb_effect_lifetime'] == 0:
				col = libtcod.red
			elif 2 & self.animation['bomb_effect_lifetime'] == 0:
				col = libtcod.yellow
			else:
				col = libtcod.black
			libtcod.console_put_char_ex(anim_con, x, y, 42, col,
				libtcod.black)
		
		if self.animation['grenade_effect'] is not None:
			(x,y) = self.animation['grenade_effect']
			x += libtcod.random_get_int(0, -1, 1)
			y += libtcod.random_get_int(0, -1, 1)
			col = choice([libtcod.red, libtcod.yellow, libtcod.black])
			libtcod.console_put_char_ex(anim_con, x, y, 250, col,
				libtcod.black)
		
		if self.animation['ft_effect'] is not None:
			(x,y) = self.animation['ft_effect']
			x += libtcod.random_get_int(0, -1, 1)
			y += libtcod.random_get_int(0, -1, 1)
			fg_col = choice([libtcod.light_red, libtcod.light_yellow, libtcod.grey])
			bg_col = choice([libtcod.red, libtcod.yellow, libtcod.black])
			libtcod.console_put_char_ex(anim_con, x, y, 177, fg_col,
				bg_col)
		
		if self.animation['psk_fire_action']:
			if len(self.animation['psk_fire_line']) > 0:
				(x,y) = self.animation['psk_fire_line'][0]
				libtcod.console_put_char_ex(anim_con, x, y, 250, libtcod.green,
					libtcod.black)
		
		if self.animation['canister_fire']:
			if self.animation['canister_fire_lifetime'] > 4:
				(x,y) = self.animation['canister_fire']
				if 3 & self.animation['canister_fire_lifetime'] == 0:
					col = libtcod.red
				elif 2 & self.animation['canister_fire_lifetime'] == 0:
					col = libtcod.yellow
				else:
					col = libtcod.black
				libtcod.console_put_char_ex(anim_con, x, y, 42, col,
					libtcod.black)
		
		if self.animation['canister_hit']:
			for i in range(4):
				(x,y) = self.animation['canister_hit']
				x += libtcod.random_get_int(0, -2, 2)
				y += libtcod.random_get_int(0, -2, 2)
				libtcod.console_put_char_ex(anim_con, x, y, 250, libtcod.silver,
					libtcod.black)
		
		if self.animation['smoke_effect']:
			for i in range(6):
				(x,y) = self.animation['smoke_effect']
				x += libtcod.random_get_int(0, -2, 2)
				y += libtcod.random_get_int(0, -2, 2)
				libtcod.console_put_char_ex(anim_con, x, y, 177, libtcod.dark_grey,
					libtcod.black)
		
		if self.animation['hex_highlight']:
			(hx, hy) = self.animation['hex_highlight']
			(x,y) = self.PlotHex(hx, hy)
			if self.animation['hex_flash'] == 1:
				char = 250
			else:
				char = 249
			for direction in range(6):
				for (xm,ym) in HEX_EDGE_CELLS[direction]:
					libtcod.console_put_char_ex(anim_con, x+xm, y+ym,
						char, libtcod.light_blue, libtcod.black)

	
	# draw all scenario consoles to the screen
	def UpdateScenarioDisplay(self, skip_blit=False):
		libtcod.console_clear(con)
		
		# left column
		if self.attack_con_active:
			libtcod.console_blit(attack_con, 0, 0, 0, 0, con, 0, 0)
		else:
			libtcod.console_blit(bkg_console, 0, 0, 0, 0, con, 0, 0)
			libtcod.console_blit(player_info_con, 0, 0, 0, 0, con, 1, 1)
			libtcod.console_blit(crew_con, 0, 0, 0, 0, con, 1, 21)
			libtcod.console_blit(cmd_menu_con, 0, 0, 0, 0, con, 1, 47)
		
		# border around main map display
		libtcod.console_set_default_foreground(con, libtcod.darkest_grey)
		DrawFrame(con, 27, 0, 63, 60)
		
		# main map display
		libtcod.console_blit(hexmap_con, 0, 0, 0, 0, con, 32, 9)
		libtcod.console_blit(unit_con, 0, 0, 0, 0, con, 32, 9)
		libtcod.console_blit(gui_con, 0, 0, 0, 0, con, 32, 9, 1.0, 0.0)
		libtcod.console_blit(anim_con, 0, 0, 0, 0, con, 32, 9, 1.0, 0.0)
		
		# consoles around the edge of map
		libtcod.console_blit(context_con, 0, 0, 0, 0, con, 28, 1)
		libtcod.console_blit(zone_info_con, 0, 0, 0, 0, con, 28, 48)
		libtcod.console_blit(comms_con, 0, 0, 0, 0, con, 71, 48)
		libtcod.console_blit(scen_time_con, 0, 0, 0, 0, con, 48, 1)
		libtcod.console_blit(scen_weather_con, 0, 0, 0, 0, con, 71, 1)
		libtcod.console_blit(unit_info_con, 0, 0, 0, 0, con, 28, 54)
		
		if skip_blit == True: return
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	
	# main input loop for scenarios
	def DoScenarioLoop(self):
		
		# set up and load scenario consoles
		global bkg_console, crew_con, cmd_menu_con, scen_weather_con
		global player_info_con, context_con, scen_time_con, hexmap_con, unit_con, gui_con
		global anim_con, attack_con, unit_info_con, zone_info_con, comms_con
		
		# background outline console for left column
		bkg_console = LoadXP('bkg.xp')
		
		player_info_con = NewConsole(25, 18, libtcod.black, libtcod.white)
		crew_con = NewConsole(25, 24, libtcod.black, libtcod.white)
		cmd_menu_con = NewConsole(25, 12, libtcod.black, libtcod.white)
		context_con = NewConsole(18, 12, libtcod.darkest_grey, libtcod.white)
		scen_time_con = NewConsole(21, 6, libtcod.darkest_grey, libtcod.white)
		scen_weather_con = NewConsole(18, 12, libtcod.darkest_grey, libtcod.white)
		unit_info_con = NewConsole(61, 5, libtcod.darkest_grey, libtcod.white)
		zone_info_con = NewConsole(18, 5, libtcod.darkest_grey, libtcod.white)
		comms_con = NewConsole(18, 5, libtcod.darkest_grey, libtcod.white)
		hexmap_con = NewConsole(53, 43, libtcod.black, libtcod.black)
		unit_con = NewConsole(53, 43, KEY_COLOR, libtcod.white, key_colour=True)
		gui_con = NewConsole(53, 43, KEY_COLOR, libtcod.white, key_colour=True)
		anim_con = NewConsole(53, 43, KEY_COLOR, libtcod.white, key_colour=True)
		attack_con = NewConsole(27, 60, libtcod.black, libtcod.white)
		
		pin_list = []
		
		# we're starting a new scenario
		if not self.init_complete:
			
			# set up player unit
			self.player_unit = campaign.player_unit
			self.player_unit.ResetMe()
			self.player_unit.facing = 0
			if 'turret' in self.player_unit.stats:
				self.player_unit.turret_facing = 0
			self.player_unit.squad = []
			self.player_unit.SpawnAt(0,0)
			self.player_unit.CheckForHD(spawn=True)
			self.BuildRRManagementArray()
			
			# reset player crewman actions
			for position in self.player_unit.positions_list:
				if position.crewman is None: continue
				position.crewman.current_cmd = 'Spot'
				position.crewman.acted = False
			
			# copy over rest of player squad
			for unit in campaign_day.player_squad:
				unit.ResetMe()
				unit.facing = 0
				if 'turret' in unit.stats:
					unit.turret_facing = 0
				unit.SpawnAt(0,0)
				unit.CheckForHD(spawn=True)
				self.player_unit.squad.append(unit)
			
			# try and generate enemy units
			no_units_here = False
			if not self.SpawnEnemyUnits():
				no_units_here = True
			
			# generate Rescue units if any
			rescue_unit = None
			if self.cd_map_hex.objective is not None:
				if self.cd_map_hex.objective['type'] == 'Rescue':
					rescue_unit = self.SpawnFriendlyReinforcements(rescue_spawn=True)
			
			# apply effects from advancing fire if any
			if self.cd_map_hex.controlled_by != 0 and self.advancing_fire:
				for unit in self.units:
					if unit.owning_player == 0: continue
					unit.hit_by_fp = True
					unit.PinTest(10)
					if unit.pinned:
						pin_list.append(unit)
			
			# do initial LoS generation
			self.GenerateLoS()
			
			# set up player unit and squad for first activation
			self.player_unit.ResetForNewTurn(skip_smoke=True)
			for unit in self.player_unit.squad:
				unit.ResetForNewTurn(skip_smoke=True)
			
			# start player forces moving if they moved into this zone
			if self.player_attacking:
				self.player_unit.moving = True
				for unit in self.player_unit.squad:
					unit.moving = True
			
			# roll for possible ambush if not friendly-controlled
			if self.cd_map_hex.controlled_by != 0:
				self.DoAmbushRoll()
			
			# if player was ambushed, player squad starts spotted,
			# and enemy units are set to alert and activate first
			if self.ambush:
				for unit in self.units:
					if unit.owning_player == 0:
						unit.SpotMe()
					elif unit.owning_player == 1:
						if unit.ai is not None:
							unit.ai.state = 'Alert'
				self.phase = PHASE_ALLIED_ACTION
				self.advance_phase = True
		
		# reset animation timers
		session.anim_timer = time.time()
		session.weather_anim_timer = time.time()
		
		# init looping animations
		self.InitAnimations()
		
		# generate consoles and draw scenario screen for first time
		self.UpdateContextCon()
		self.UpdateZoneInfoCon()
		self.UpdateCommsCon()
		DisplayTimeInfo(scen_time_con)
		DisplayWeatherInfo(scen_weather_con)
		self.UpdatePlayerInfoCon()
		self.UpdateCrewInfoCon()
		self.UpdateCmdCon()
		self.UpdateUnitCon()
		self.UpdateGuiCon()
		self.UpdateAnimCon()
		self.UpdateHexmapCon()
		
		# draw the final display, but skip blitting to screen if we're still setting up the scenario
		self.UpdateScenarioDisplay(skip_blit=not self.init_complete)
		
		# finish up init actions if needed
		if not self.init_complete:
			
			self.init_complete = True
			
			PlaySoundFor(None, 'scenario_start')
			
			# display transition animation between the root console and the new double buffer console
			(hx, hy) = campaign_day.player_unit_location
			(x1, y1) = campaign_day.PlotCDHex(hx, hy)
			x1 = float(x1) + 26.0		# upper right corner
			y1 = float(y1) + 3.0
			x2 = x1 + 6.0		# lower right coner
			y2 = y1 + 8.0
			
			x1_step = x1 / 20.0
			y1_step = y1 / 20.0
			x2_step = (float(WINDOW_WIDTH) - x2) / 20.0
			y2_step = (float(WINDOW_HEIGHT) - y2) / 20.0
			
			for i in range(20):
				
				x1 -= x1_step
				y1 -= y1_step
				x2 += x2_step
				y2 += y2_step
				
				# copy the window over to the root console
				libtcod.console_blit(con, int(x1), int(y1), int(x2-x1), int(y2-y1),
					0, window_x+int(x1), window_y+int(y1))
				DrawFrame(0, window_x+int(x1), window_y+int(y1), int(x2-x1),
					int(y2-y1))
				Wait(3, ignore_animations=True)
			
			# clear the root console
			libtcod.console_clear(0)
			
			self.UpdateScenarioDisplay()
			libtcod.console_flush()
			
			ShowTutorialSlide('scenario_base')
			
			# notify player about rescue unit if any
			if rescue_unit is not None:
				ShowMessage('A friendly ' + rescue_unit.unit_id + ' is pinned down nearby!',
					scenario_highlight=(rescue_unit.hx, rescue_unit.hy))
			
			# check for no enemy units here
			if no_units_here:
				ShowMessage('No enemy forces seem to be here - must have been a false report.')
				self.finished = True
			
			else:
		
				# check for support request(s) and resolve if any
				self.ResolveSupportRequests()
					
				# player or all enemy units may have been destroyed
				self.CheckForEnd()
			
			# only check for enemies pinned by advancing fire if the scenario hasn't already ended
			if not self.finished:
			
				# pin messages
				for unit in pin_list:
					if not unit.alive: continue
					if not (unit.owning_player == 1 and not unit.spotted):
						ShowMessage(unit.GetName() + ' was pinned by your Advancing Fire', scenario_highlight=(unit.hx, unit.hy))
				pin_list = []
				
				if self.ambush:
					ShowMessage('You have been ambushed by enemy forces! They have a chance to attack first.',
						good_news=False)
					if GetPercentileRoll() <= 2.0:
						ShowCrewChatter('ambushed', None)
				
				DisplayTimeInfo(scen_time_con)
				
			# record scenario play
			session.ModifySteamStat('scenarios_fought', 1)
			
			# support units get a chance to spot
			if self.recon_spotting:
				ShowMessage('Your recon support has a chance to spot any concealed enemy units.')
				self.DoAISpotChecks(owning_player=0, support_only=True)
				self.recon_spotting = False
			
			# build player crew command lists
			if not self.finished:
				self.player_unit.BuildCmdLists()
				
				# try to set crewmen default command & hatch status if any
				for position in self.player_unit.positions_list:
					if position.crewman is None: continue
					if position.crewman.default_start is None: continue
					(ce, cmd) = position.crewman.default_start
					if position.crewman.ce != ce:
						position.crewman.ToggleHatch()
					if cmd != position.crewman.current_cmd and cmd in position.crewman.cmd_list:
						position.crewman.current_cmd = cmd
					position.UpdateVisibleHexes()
				
				self.UpdateCrewInfoCon()
				
				# update these in case our first crewman is on a different default command
				self.UpdateContextCon()
				self.UpdateGuiCon()
				self.UpdateScenarioDisplay()
			
				ShowTutorialSlide('scenario_command_phase')
			
			else:
				ShowTutorialSlide('scenario_all_dead')
			
			SaveGame()
		
		# record mouse cursor position to check when it has moved
		mouse_x = -1
		mouse_y = -1
		
		# start music for first time
		session.MusicHandler('scen_music', True)
		
		exit_scenario = False
		while not exit_scenario:
			
			# check for exiting game
			if session.exiting:
				return
			
			# check for scenario finished, return to campaign day map
			if self.finished:
				# copy the scenario unit over to the campaign version
				campaign.player_unit = self.player_unit
				campaign_day.BuildPlayerGunList()
				
				# copy the squad over too
				campaign_day.player_squad = []
				for unit in self.player_unit.squad:
					campaign_day.player_squad.append(unit)
				
				exit_scenario = True
				continue
			
			libtcod.console_flush()
			
			# check to see if music track has finished and music needs to be restarted
			if session.music is not None:
				if mixer.Mix_PlayingMusic() == 0:
					session.MusicHandler('scen_music', True)
			
			# trigger advance to next phase
			if self.advance_phase:
				self.advance_phase = False
				self.AdvanceToNextPhase()
				
				# only save if we're about to go back to player input
				if not self.advance_phase:
					SaveGame()
				continue
			
			CheckForAnimationUpdate()
			libtcod.console_flush()
			input_event = GetInputEvent()
			
			##### Mouse Commands #####
			
			# only check if hex view mode is not active
			if not session.scen_view_mode:
			
				# check to see if mouse cursor has moved
				if mouse.cx != mouse_x or mouse.cy != mouse_y:
					mouse_x = mouse.cx
					mouse_y = mouse.cy
					self.UpdateUnitInfoCon()
					self.UpdateScenarioDisplay()
				
				if mouse.wheel_up or mouse.wheel_down or mouse.lbutton_pressed or mouse.rbutton_pressed:
					# see if cursor is over a hex with 1+ units in it
					x = mouse.cx - 32 - window_x
					y = mouse.cy - 9 - window_y
					if (x,y) in self.hex_map_index:
						map_hex = self.hex_map_index[(x,y)]
						if len(map_hex.unit_stack) > 0:
							if mouse.rbutton_pressed:
								mouse.rbutton_pressed = False
								unit = map_hex.GetMouseUnit(x)
								if not (unit.owning_player == 1 and not unit.spotted):
									PlaySoundFor(None, 'menu_select')
									self.ShowUnitInfoWindow(unit)
								else:
									PlaySoundFor(None, 'command_select')
								continue

							elif mouse.wheel_up or mouse.wheel_down and len(map_hex.unit_stack) > 1:
								if mouse.wheel_up:
									map_hex.unit_stack[:] = map_hex.unit_stack[1:] + [map_hex.unit_stack[0]]
								else:
									map_hex.unit_stack.insert(0, map_hex.unit_stack.pop(-1))
								mouse.wheel_up = False
								mouse.wheel_down = False
								
								self.UpdateUnitCon()
								self.UpdateUnitInfoCon()

								if self.selected_weapon is not None and self.selected_weapon.selected_target is not None:
									if self.selected_weapon.selected_target in map_hex.unit_stack and map_hex.unit_stack[0] in self.selected_weapon.weapon_target_list:
										self.selected_weapon.selected_target = map_hex.unit_stack[0]
										self.UpdateGuiCon()
										self.UpdateCmdCon()
										self.UpdateContextCon()

								self.UpdateScenarioDisplay()
								continue
							
							elif mouse.lbutton_pressed and scenario.phase == PHASE_SHOOTING:
								mouse.lbutton_pressed = False
								unit = map_hex.GetMouseUnit(x)
								if self.selected_weapon is not None and unit in	self.selected_weapon.weapon_target_list:
									PlaySoundFor(None, 'menu_select')
									self.selected_weapon.selected_target = unit
									unit.MoveToTopOfStack()
									self.UpdateUnitCon()
									self.UpdateUnitInfoCon()
									self.UpdateGuiCon()
									self.UpdateCmdCon()
									self.UpdateContextCon()
									self.UpdateScenarioDisplay()
								else:
									PlaySoundFor(None, 'command_select')
								continue
			
			if not input_event: continue
			
			##### Controller and Keyboard Commands #####
			
			# open game menus
			if key.vk in [sdl2.SDLK_ESCAPE, sdl2.SDLK_F1, sdl2.SDLK_F2, sdl2.SDLK_F3, sdl2.SDLK_F4] or session.gamepad_input == 6:
				if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 6:
					session.active_menu_tab = 0
				elif key.vk == sdl2.SDLK_F1:
					session.active_menu_tab = 1
				elif key.vk == sdl2.SDLK_F2:
					session.active_menu_tab = 2
				elif key.vk == sdl2.SDLK_F3:
					session.active_menu_tab = 3
				elif key.vk == sdl2.SDLK_F4:
					session.active_menu_tab = 4
				ShowGameMenu()
				continue
			
			# debug menu
			elif key.vk == sdl2.SDLK_F10:
				if not DEBUG: continue
				ShowDebugMenu()
				continue
			
			# player not active
			if scenario.active_player == 1: continue
			
			key_char = DeKey(chr(key.c).lower())
			
			# Any Phase
			
			# advance to next phase
			if key.vk == sdl2.SDLK_SPACE or session.gamepad_input == 2:
				self.advance_phase = True
				session.scen_view_mode = False
				session.scen_view_hex = None
				continue
			
			# toggle hex view mode
			if key_char == 'v' or session.gamepad_input == 7:
				
				# start/end hex view mode
				if not session.scen_view_mode:
					session.scen_view_mode = True
					session.scen_view_hex = (0,0)
				else:
					session.scen_view_mode = False
					session.scen_view_hex = None
				
				# update consoles
				self.UpdateCmdCon()
				self.UpdateGuiCon()
				self.UpdateUnitInfoCon()
				self.UpdateScenarioDisplay()
				continue
			
			# hex view mode active
			if session.scen_view_mode:
				
				if session.scen_view_hex is None: continue
				
				# get currently highlighted hex
				(hx, hy) = session.scen_view_hex
				map_hex = self.hex_dict[(hx,hy)]
				
				# select a direction - can use keyboard input or controller left stick
				direction = None
				if key_char in VIEW_MODE_DIR_KEYS:
					direction = VIEW_MODE_DIR_KEYS.index(key_char)
				elif session.left_stick_direction is not None:
					direction = session.left_stick_direction
					session.left_stick_hold_repeat = True
				
				# try and move highlighted hex
				if direction is not None:
					(hx, hy) = GetAdjacentHex(hx, hy, direction)
					if GetHexDistance(0, 0, hx, hy) <= 3:
						session.scen_view_hex = (hx, hy)
						self.UpdateGuiCon()
						self.UpdateUnitInfoCon()
						self.UpdateScenarioDisplay()
				
				# cycle unit stack of highlighted hex
				elif key_char == 's' or session.gamepad_input == 3:
					if len(map_hex.unit_stack) < 2: continue
					map_hex.unit_stack.insert(0, map_hex.unit_stack.pop(-1))
					self.UpdateUnitCon()
					self.UpdateUnitInfoCon()
					self.UpdateScenarioDisplay()
				
				# display unit info
				elif key_char == 'f' or session.gamepad_input == 0:
					if len(map_hex.unit_stack) == 0: continue
					unit = map_hex.unit_stack[0]
					if not (unit.owning_player == 1 and not unit.spotted):
						self.ShowUnitInfoWindow(unit)
				
				continue
			
			# Command Phase only
			if self.phase == PHASE_COMMAND:
				# change selected crew position
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
						self.selected_position -= 1
						if self.selected_position < 0:
							self.selected_position = len(self.player_unit.positions_list) - 1
					else:
						self.selected_position += 1
						if self.selected_position == len(self.player_unit.positions_list):
							self.selected_position = 0
					self.UpdateContextCon()
					self.UpdatePlayerInfoCon()
					self.UpdateCrewInfoCon()
					self.UpdateCmdCon()
					self.UpdateGuiCon()
					self.UpdateScenarioDisplay()
					continue
				
				# change current command for selected crewman
				elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
					
					# no crewman in selected position
					crewman = self.player_unit.positions_list[self.selected_position].crewman
					if crewman is None:
						continue
					
					PlaySoundFor(None, 'command_select')
					crewman.SelectCommand(key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13)
					self.player_unit.positions_list[self.selected_position].UpdateVisibleHexes()
					
					self.UpdateContextCon()
					self.UpdatePlayerInfoCon()
					self.UpdateCrewInfoCon()
					self.UpdateGuiCon()
					self.UpdateScenarioDisplay()
					continue
				
				# quick-select a command
				elif key_char in ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']:
					
					if key_char not in QUICK_COMMANDS: continue
					
					crewman = self.player_unit.positions_list[self.selected_position].crewman
					if crewman is None:
						continue
					
					if QUICK_COMMANDS[key_char] not in crewman.cmd_list: continue
					crewman.current_cmd = QUICK_COMMANDS[key_char]
					self.player_unit.positions_list[self.selected_position].UpdateVisibleHexes()
					self.UpdateContextCon()
					self.UpdatePlayerInfoCon()
					self.UpdateCrewInfoCon()
					self.UpdateGuiCon()
					self.UpdateScenarioDisplay()
					continue
				
				# toggle hatch for selected crewman (not mapped)
				elif chr(key.c).lower() == 'h' or session.gamepad_input == 3:
					
					# no crewman in selected position
					crewman = self.player_unit.positions_list[self.selected_position].crewman
					if crewman is None: continue
					
					if crewman.ToggleHatch():
						PlaySoundFor(crewman.current_position, 'hatch')
						self.UpdateContextCon()
						self.UpdatePlayerInfoCon()
						self.UpdateCrewInfoCon()
						self.UpdateGuiCon()
						self.UpdateScenarioDisplay()
						continue
				
				# button or open up all hatches
				elif key_char == 'b' or session.gamepad_input == 1:
					close_all = False
					for position in self.player_unit.positions_list:
						if position.crewman is None: continue
						if not position.crewman.alive: continue
						if position.crewman.condition == 'Unconscious': continue
						if not position.hatch: continue
						if position.crewman.ce:
							close_all = True
							break
					
					for position in self.player_unit.positions_list:
						if position.crewman is None: continue
						if not position.crewman.alive: continue
						
						if close_all and not position.crewman.ce: continue
						if not close_all and position.crewman.ce: continue
						
						if position.crewman.ToggleHatch():
							PlaySoundFor(position, 'hatch')
							position.UpdateVisibleHexes()

					self.UpdateContextCon()
					self.UpdatePlayerInfoCon()
					self.UpdateCrewInfoCon()
					self.UpdateGuiCon()
					self.UpdateScenarioDisplay()
					continue
				
				# set default hatch status and command
				elif key_char == 'x' or session.gamepad_input == 4:
					# no crewman in selected position
					crewman = self.player_unit.positions_list[self.selected_position].crewman
					if crewman is None: continue
					
					# crewman is KIA
					if not crewman.alive: continue
					
					PlaySoundFor(None, 'menu_select')
					crewman.default_start = (crewman.ce, crewman.current_cmd)
					ShowMessage('Default hatch status and command set for this crewman.')
					continue
				
				# open crewman menu
				elif key_char == 'e' or session.gamepad_input == 0:
					crewman = self.player_unit.positions_list[self.selected_position].crewman
					if crewman is None: continue
					PlaySoundFor(None, 'menu_select')
					crewman.ShowCrewmanMenu()
					self.UpdateCrewInfoCon()
					self.UpdateScenarioDisplay()
					continue
			
			# crew action phase only
			elif self.phase == PHASE_CREW_ACTION:

				position = self.player_unit.positions_list[self.selected_position]

				# change selected crew position or ammo type
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
						forwards = False
					else:
						forwards = True
					
					# possibly change selected ammo type
					if position.crewman.current_cmd == 'Manage Ready Rack' and scenario.rack_management_array[position][0].SelectAmmoType(forwards, wrap=False):
						self.UpdateContextCon()
						self.UpdateScenarioDisplay()
					else:
						# During this phase we only select crewmen with commands that take inputs
						selectable_positions = []
						for position2 in self.player_unit.positions_list:
							if position2.crewman is None or position2.crewman.current_cmd not in CREW_ACTION_INPUT_COMMANDS: continue
							selectable_positions.append(self.player_unit.positions_list.index(position2))

						if forwards:
							ammo_index = 0
							if self.selected_position == selectable_positions[-1]:
								self.selected_position = selectable_positions[0]
							else:
								self.selected_position = selectable_positions[selectable_positions.index(self.selected_position) + 1]
						else:
							ammo_index = -1
							if self.selected_position == selectable_positions[0]:
								self.selected_position = selectable_positions[-1]
							else:
								self.selected_position = selectable_positions[selectable_positions.index(self.selected_position) - 1]
						
						# if the new position is managing a ready rack, select the proper ammo type in the appropriate scroll direction
						position = self.player_unit.positions_list[self.selected_position]
						if position.crewman.current_cmd == 'Manage Ready Rack':
							weapon = scenario.rack_management_array[position][0]
							if weapon.GetStat('ammo_type_list') is None: return
							weapon.ammo_type = weapon.stats['ammo_type_list'][ammo_index]

						self.UpdateContextCon()
						self.UpdatePlayerInfoCon()
						self.UpdateCrewInfoCon()
						self.UpdateCmdCon()
						self.UpdateGuiCon()
						self.UpdateScenarioDisplay()
					continue
				
				# ready rack commands
				if position.crewman.current_cmd == 'Manage Ready Rack':

					rr_weapon = scenario.rack_management_array[position][0]

					# switch currently managed weapon
					if key_char == 'c' or session.gamepad_input == 8:
						managed_gun_list = scenario.rack_management_array[position]
						if len(managed_gun_list) == 1: continue
						managed_gun_list.append(managed_gun_list.pop(0))
						PlaySoundFor(None, 'menu_select')
						self.UpdatePlayerInfoCon()
						self.UpdateContextCon()
						self.UpdateScenarioDisplay()
						continue

					# try to move a shell into or out of Ready Rack
					elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
						if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
							add_num = -1
						else:
							add_num = 1
						if rr_weapon.ManageRR(add_num):
							self.UpdateContextCon()
							self.UpdateCmdCon()
							self.UpdateScenarioDisplay()
						continue
					
					# hotkeys: fill RR with a given ammo type
					elif key_char in ['t', 'g', 'b']:
						i = ['t', 'g', 'b'].index(key_char)
						if i > len(rr_weapon.stats['ammo_type_list']) - 1: continue
						ammotype = rr_weapon.stats['ammo_type_list'][i]
						if rr_weapon.ready_rack[ammotype] == rr_weapon.rr_size or rr_weapon.ammo_stores[ammotype] == 0:
							continue

						# Empty current rack.
						rr_weapon.DumpReadyRackToStores()

						# save current ammo type so we can switch back
						old_ammo_type = rr_weapon.ammo_type
						rr_weapon.ammo_type = ammotype
						rr_weapon.ManageRR(rr_weapon.rr_size)
						rr_weapon.ammo_type = old_ammo_type	
						self.UpdateContextCon()
						self.UpdateCmdCon()
						self.UpdateScenarioDisplay()
						continue

					# fill rack with default or saved load
					elif key_char in ['x', 'f'] or session.gamepad_input == 3:
						if key_char == 'x' or session.gamepad_input == 3:
							target_rack = rr_weapon.GenerateDefaultLoadout(True)[1]
						elif len(rr_weapon.default_ready_rack) == 0:
							continue # Can't fill with no template saved.
						else:
							target_rack = rr_weapon.default_ready_rack

						(target_rack, inadequate_ammo) = rr_weapon.CheckLoadoutTemplate(target_rack)[::2]

						if rr_weapon.ready_rack == target_rack: continue

						# Empty current rack.
						rr_weapon.DumpReadyRackToStores()

						# fill it per the template
						rr_weapon.FillReadyRackFromStores(target_rack)
						
						PlaySoundFor(None, 'shell_move_10')
						self.UpdateContextCon()
						self.UpdateCmdCon()
						self.UpdateScenarioDisplay()

						# message if there's too little ammo.
						if len(inadequate_ammo):
							ShowMessage("There are not enough " + GenerateEnglishList(inadequate_ammo) + " rounds to fill the ready rack!")
						continue

				# command battlegroup
				elif position.crewman.current_cmd == 'Command Battlegroup':
					if key_char in ['q', 'a', 'z', 'x'] or session.gamepad_input in [0, 1, 3, 4]:
						PlaySoundFor(None, 'menu_select')
						if key_char == 'q' or session.gamepad_input == 0:
							self.battlegroup_command = 'Fire at Will'
						elif key_char == 'a' or session.gamepad_input == 1:
							self.battlegroup_command = 'Attack my Target'
						elif key_char == 'z' or session.gamepad_input == 4:
							self.battlegroup_command = 'Hold Fire'
						elif key_char == 'x' or session.gamepad_input == 3:
							self.battlegroup_command = 'On my Mark'
						self.UpdateCmdCon()
						self.UpdateUnitInfoCon()
						self.UpdateCommsCon()
						self.UpdateScenarioDisplay()
						continue
				
				# first aid
				elif position.crewman.current_cmd == 'First Aid':
					
					# open first aid menu
					if key_char == 'f' or session.gamepad_input == 0:
						if position.crewman.first_aid_action_taken: continue
						PlaySoundFor(None, 'menu_select')
						self.ShowFirstAidMenu(position.crewman)
						self.UpdateCrewInfoCon()
						self.UpdateCmdCon()
						self.UpdateScenarioDisplay()
						continue
			
			# Movement phase only
			elif scenario.phase == PHASE_MOVEMENT:
				
				# player unit is bogged
				if self.player_unit.bogged:
					if key_char == 'u' or session.gamepad_input == 0:
						PlaySoundFor(campaign.player_unit, 'movement')
						if self.player_unit.DoUnbogCheck():
							ShowMessage('Your vehicle is no longer bogged down.',
								good_news=True)
							self.UpdatePlayerInfoCon()
						else:
							ShowMessage('Your vehicle remains bogged down.',
								good_news=False)
						self.UpdateScenarioDisplay()
						libtcod.console_flush()
						self.advance_phase = True
					
					continue
				
				# move forward/backward (may also end the phase)
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					self.MovePlayer(key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11)
					self.UpdateContextCon()
					self.UpdateUnitInfoCon()
					self.UpdateScenarioDisplay()
					continue
				
				# pivot hull
				elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
					self.PivotPlayer(key_char == 'd' or key.vk == sdl2.SDLK_RIGHT or session.gamepad_input == 14)
					self.UpdatePlayerInfoCon()
					self.UpdateContextCon()
					self.UpdateUnitInfoCon()
					self.UpdateScenarioDisplay()
					continue
				
				# overrun attack
				elif key_char == 'o' or session.gamepad_input == 0:
					if self.player_unit.bogged or self.player_unit.immobilized or self.player_unit.broken_down: continue
					defending_units = False
					for unit in self.hex_dict[(0,-1)].unit_stack:
						if unit.owning_player != 1: continue
						if not unit.spotted: continue
						defending_units = True
						break
					if not defending_units:
						ShowMessage('No spotted enemy units in overrun attack range.')
						continue
					
					ShowMessage('You attempt to move into position for an Overrun attack.')
					self.advance_phase = True
					self.player_unit.overrun = True
					self.MovePlayer(False, reposition=True)
					
					# check for bogging, etc. cancelling overrun attack
					if self.player_unit.bogged or self.player_unit.immobilized or self.player_unit.broken_down:
						self.player_unit.overrun = False
						self.UpdateUnitCon()
						self.UpdateScenarioDisplay()
						libtcod.console_flush()
						continue
					
					target_list = [self.player_unit]
					for unit in self.player_unit.squad:
						if not unit.alive: continue
						unit.overrun = True
						unit.moving = True
						if unit.facing is not None:
							unit.facing = 0
						if 'turret' in unit.stats:
							unit.turret_facing = 0
						self.GenerateUnitLoS(unit)
						target_list.append(unit)
					self.UpdateUnitCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
					
					# enemy gets a chance to do a defensive fire attack (cannot use ballistic-fire weapons)
					for unit in self.units:
						
						if DEBUG:
							if session.debug['No Enemy AI Actions']:
								continue
						
						if not unit.alive: continue
						if unit.owning_player != 1: continue
						if unit.routed: continue
						if unit.hx != 0 or unit.hy != -1: continue
						if unit.ai is None: continue
						
						# no weapons on unit
						if len(unit.weapon_list) == 0: continue
						
						roll = GetPercentileRoll()
						
						# modify roll by AI difficulty setting
						roll -= float(campaign.options['ai_difficulty']) * 10.0
						
						# modify roll by unit status and stats
						if unit.pinned:
							roll += 40.0
						elif unit.ai.state == 'Lax':
							roll += 25.0
						if 'elite' in unit.stats:
							roll -= 25.0
						
						roll = round(roll, 1)
						if roll > 60.0: continue
						
						unit.ai.state = 'Alert'
						# reset weapons so that unit has a chance to fire again this turn
						for weapon in unit.weapon_list:
							weapon.ResetMe()
						
						ShowMessage(unit.GetName() + ' attempts to engage in defensive fire!')
						
						unit.ai.DoActivation(defensive_fire=True)
					
					# resolve any hits from defensive fire
					for unit in target_list:
						unit.ResolveFP()
						unit.ResolveAPHits()
						unit.ResolveHEHits()
					
					# return player to top of unit stack if needed
					self.player_unit.MoveToTopOfStack()
					
					continue
				
				# attempt HD
				elif key_char == 'h' or session.gamepad_input == 1:
					
					# already in HD position
					if len(self.player_unit.hull_down) > 0:
						if self.player_unit.hull_down[0] == self.player_unit.facing:
							ShowMessage('You are already Hull Down in this direction.')
							continue
					
					# set statuses and play sound
					self.player_unit.moving = True
					self.player_unit.ClearAcquiredTargets()
					PlaySoundFor(self.player_unit, 'movement')
					
					# squadmates also attempt if possible
					for unit in self.player_unit.squad:
						if unit.immobilized or unit.broken_down: continue
						
						# don't re-check if already HD in a similar direction
						if len(unit.hull_down) > 0:
							if self.player_unit.facing in unit.hull_down:
								continue
						
						unit.moving = True
						unit.ClearAcquiredTargets()
						unit.CheckForHD(driver_attempt=True)
					
					# breakdown
					self.player_unit.BreakdownCheck(reposition=True)
					if self.player_unit.immobilized:
						ShowMessage('Your vehicle has completely broken down - it is now immobilized.',
							longer_pause=True, good_news=False)
						self.advance_phase = True
						continue
					if self.player_unit.broken_down:
						ShowMessage('Your vehicle has broken down - it will be immobile for the remainder of the battle.',
							longer_pause=True, good_news=False)
						self.advance_phase = True
						continue
						
					result = self.player_unit.CheckForHD(driver_attempt=True)
					if result:
						ShowMessage('You move into a Hull Down position.',
							good_news=True)
						if GetPercentileRoll() <= 1.5:
							ShowCrewChatter('hull_down_get', None)
					else:
						ShowMessage('You were unable to move into a Hull Down position.',
							good_news=False)
					self.UpdatePlayerInfoCon()
					self.UpdateUnitInfoCon()
					self.UpdateScenarioDisplay()
					
					# check for extra move if not successful
					if not result and self.player_unit.ExtraMoveCheck():
						ShowMessage('You have moved swiftly enough to take another move action.',
							good_news=True)
						continue
					
					self.advance_phase = True
					continue
				
				# reposition
				elif key_char == 'r' or session.gamepad_input == 4:
					self.MovePlayer(False, reposition=True)
					self.UpdateUnitCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
					continue
				
				# conceal/reveal self
				elif key_char == 'c' or session.gamepad_input == 3:
					self.ConcealOrRevealPlayer()
					self.UpdateUnitCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
					continue
				
			# Shooting phase
			elif scenario.phase == PHASE_SHOOTING:
				
				# select player weapon or ammo type
				if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					self.SelectWeapon(key_char == 's' or key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12)
					
					# move selected target to top of stack if needed
					if self.selected_weapon.selected_target is not None:
						self.selected_weapon.selected_target.MoveToTopOfStack()
						self.UpdateUnitCon()
						self.UpdateUnitInfoCon()
					
					self.UpdateGuiCon()
					self.UpdateCmdCon()
					self.UpdateContextCon()
					self.UpdateScenarioDisplay()
					continue
				
				# cycle player target
				elif key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
					self.CycleTarget(key_char == 'd' or key.vk == sdl2.SDLK_RIGHT or session.gamepad_input == 13)
					self.UpdateGuiCon()
					self.UpdateCmdCon()
					self.UpdateContextCon()
					self.UpdateScenarioDisplay()
					continue
				
				# rotate turret
				elif key_char in ['q', 'e'] or session.gamepad_input in [9, 10]:
					self.RotatePlayerTurret(key_char == 'e' or session.gamepad_input == 10)
					self.UpdateGuiCon()
					self.UpdateCmdCon()
					self.UpdateContextCon()
					self.UpdateScenarioDisplay()
					continue
				
				# toggle ready rack use
				elif key_char == 'r' or session.gamepad_input == 4:
					if self.selected_weapon.rr_size == 0: continue
					self.selected_weapon.using_rr = not self.selected_weapon.using_rr
					self.UpdateContextCon()
					self.UpdateScenarioDisplay()
					PlaySoundFor(None, 'menu_select')
					continue
				
				# attempt unjam
				elif key_char == 'u' or session.gamepad_input == 3:
					if not self.selected_weapon.jammed: continue
					
					# find operating crewman
					crewman = self.selected_weapon.GetOperatingCrewman()
					if crewman is None: continue
					
					# check for BU restrictions
					if self.selected_weapon.GetStat('type') == 'AAMG' and not crewman.ce:
						ShowMessage('Crewmen must be CE to attempt to unjam an AAMG.')
						continue
					
					if crewman.acted:
						ShowMessage('Operating crewman has already acted this turn.')
						continue
					
					crewman.acted = True
					
					if self.selected_weapon.AttemptUnjam(crewman):
						ShowMessage(self.selected_weapon.GetStat('name') + ' is no longer jammed.')
						self.UpdatePlayerInfoCon()
						self.UpdateCmdCon()
						self.UpdateContextCon()
					else:
						ShowMessage('Crewman was unable to unjam ' + self.selected_weapon.GetStat('name') + '.',
							good_news=False)
					
					self.UpdateUnitCon()
					self.UpdateScenarioDisplay()
					libtcod.console_flush()
				
				# fire active weapon at selected target / attempt to immobilize an armoured target
				elif key_char in ['f', 'i'] or session.gamepad_input in [0, 1]:
					
					if self.selected_weapon.jammed or self.selected_weapon.broken: continue
					
					attempt_immobilize = False
					if key_char == 'i' or session.gamepad_input == 1:
						attempt_immobilize = True
					result = scenario.player_unit.Attack(scenario.selected_weapon,
						scenario.selected_weapon.selected_target,
						attempt_immobilize=attempt_immobilize)
					if result:
						self.UpdatePlayerInfoCon()
						self.UpdateUnitInfoCon()
						self.UpdateCmdCon()
						self.UpdateContextCon()
						self.UpdateScenarioDisplay()
					continue

		# exiting layer, reset flags
		session.scen_view_mode = False
		session.scen_view_hex = None
		
		# stop music if any
		session.MusicHandler('', False)


# Session: stores data that is generated for each game session and not stored in the saved game
class Session:
	def __init__(self):
				
		# set up home, mod, and log folders
		self.home_path = HOMEPATH
		self.mod_path = MODPATH
		self.log_path = LOGPATH
		
		# selected main menu item
		self.mm_item = 0
		# main menu options screen active
		self.mm_options = False
		# selected options menu item
		self.options_item = 0
		
		# active game menu tab
		self.active_menu_tab = 0
		# last selected unit suport class
		self.unit_support_selection = None
		# missing sound effect wanring has been displayed
		self.missing_sound_displayed = False
		
		# glossary of game terms
		try:
			with open(DATAPATH + 'glossary.json', encoding='utf8') as data_file:
				self.glossary = json.load(data_file)
		except:
			traceback.print_exc()
			self.glossary = None
		self.glossary_entry = 0
		
		# dictionary for game's local copy of current user stats
		self.user_stats = {}
		
		# flag for when player is exiting from game
		self.exiting = False
		
		# flag: the last time the keyboard was polled, a key was pressed
		self.key_down = False
		
		# stores number of controllers currently active (0 means just keyboard and mouse)
		self.num_controllers = 0
		
		# stores current gamepad input (-2 : no input or no controller)
		self.gamepad_input = -2
		self.gamepad_button_down = False
		
		# left stick and trigger input info
		self.left_stick_x = 0
		self.left_stick_y = 0
		self.left_stick_direction = None	# hex direction that left stick is currently being held in, 0-5
		self.left_stick_hold_repeat = False	# left stick input has already been processed, and needs to return to 0 before next input
		
		self.trigger_active = False		# either trigger is being pulled
		
		# ID of the current SDL display window, will be set by UpdateDisplaySize
		self.window_id = 0
		
		# record current window display size and cell size
		self.UpdateDisplaySize()
		
		# keyboard encodings/decodings
		self.keyboard_decode = {}
		self.keyboard_encode = {}
		
		# load debug flags if in debug mode
		self.debug = {}
		if DEBUG:
			with open(DATAPATH + 'debug.json', encoding='utf8') as data_file:
				self.debug = json.load(data_file)	
		
		# store tutorial slide text
		with open(DATAPATH + 'tutorial_slides.json', encoding='utf8') as data_file:
			self.tutorial_slides = json.load(data_file)
		
		# store player crew command definitions
		with open(DATAPATH + 'crew_command_defs.json', encoding='utf8') as data_file:
			self.crew_commands = json.load(data_file)
		
		# load and store nation definition info
		with open(DATAPATH + 'nation_defs.json', encoding='utf8') as data_file:
			self.nations = json.load(data_file)
		
		# load and store region definition info
		with open(DATAPATH + 'region_defs.json', encoding='utf8') as data_file:
			self.regions = json.load(data_file)
		
		# load and store skills info
		with open(DATAPATH + 'skill_defs.json', encoding='utf8') as data_file:
			self.skills = json.load(data_file)
		
		if DEBUG:
			for skill in self.skills.keys():
				if len(skill) > MAX_SKILL_NAME_LENGTH:
					print('Warning: Skill name too long: ' + skill)
		
		# load background for attack console
		self.attack_bkg = LoadXP('attack_bkg.xp')
		
		# load background for tutorial slides
		self.training_bkg = LoadXP('training_bkg.xp')
		
		# field of view highlight on scenario hex map
		self.scen_hex_fov = LoadXP('scen_hex_fov.xp')
		libtcod.console_set_key_color(self.scen_hex_fov, KEY_COLOR)
		
		# animation timers, used by both the campaign day and the scenario object
		self.anim_timer = 0.0
		self.weather_anim_timer = 0.0
		
		# pop-up message console
		self.msg_con = None
		self.msg_location = None
		
		# build list of mod directories and prepare a list of active mods
		mod_directories = []
		self.active_mods = []
		self.failed_mods = []
		for directory in os.listdir(self.mod_path):	
			if not os.path.isdir(self.mod_path + directory): continue
			# skip example mod directory and any outdated mod folders
			if directory in ['example_mod', 'sounds', 'units', 'campaigns']: continue
			mod_directories.append(directory)
		
		
		# check for modded region definitions
		for directory in mod_directories:
			filename = self.mod_path + directory + os.sep + 'region_defs.json'
			if not os.path.exists(filename): continue
			try:
				with open(filename, encoding='utf8') as data_file:
					modded_data = json.load(data_file)
				for (k, v) in modded_data.items():
					self.regions[k] = v
				if directory not in self.active_mods:
					self.active_mods.append(directory)
			except Exception as e:
				print('Error: Unable to parse modded file ' + filename + ': ' + str(e) + '\n\n')
		
		# check for modded nation definitions, and record the mod that is currently 'controlling' the given nation, meaning its flag/ribbon xp files will be used
		self.modded_nations = {}
		for directory in mod_directories:
			filename = self.mod_path + directory + os.sep + 'nation_defs.json'
			if not os.path.exists(filename): continue
			try:
				with open(filename, encoding='utf8') as data_file:
					modded_data = json.load(data_file)
				for (k, v) in modded_data.items():
					self.nations[k] = v
					self.modded_nations[k] = directory
				if directory not in self.active_mods:
					self.active_mods.append(directory)
			except Exception as e:
				print('Error: Unable to parse modded file ' + filename + ': ' + str(e) + '\n\n')
		
		# run through nations and load national flag images
		self.flags = {}
		for nation_name, data in self.nations.items():
			
			# if a nation definition is modded, check for a modded flag image first
			found_flag = False
			if nation_name in self.modded_nations:
				filename = self.mod_path + self.modded_nations[k] + os.sep + data['flag_image']
				if os.path.exists(filename):
					self.flags[nation_name] = LoadXP(filename)
					found_flag = True
			
			# otherwise, try to load the stock image
			if not found_flag:
				self.flags[nation_name] = LoadXP(data['flag_image'])
			
			# some nations inherit data from others
			if 'inherit' in data:
				for (k, v) in data['inherit'].items():
					for field_name in v:
						if field_name in self.nations[k]:
							data[field_name] = self.nations[k][field_name]
		
		# build list of stock and custom campaigns, replacing any stock campaigns with modded version
		self.campaign_list = []
		self.modded_campaign_list = []
		for filename in os.listdir(CAMPAIGNPATH):
			if not filename.endswith('.json'): continue
			self.campaign_list.append(CAMPAIGNPATH + filename)
		
		for directory in mod_directories:
			file_path = self.mod_path + directory + os.sep + 'campaigns' + os.sep
			
			# no custom campaigns in this mod
			if not os.path.exists(file_path): continue
			for filename in os.listdir(file_path):
				if not filename.endswith('.json'): continue
				
				# make sure that the modded campaign will load
				try:
					with open(file_path + filename, encoding='utf8') as data_file:
						campaign_data = json.load(data_file)
				except Exception as e:
					print('Error: Unable to parse campaign file ' + filename + ': ' +
						str(e) + '\n\n')
					self.failed_mods.append(directory + ': ' + filename)
					continue
				
				if CAMPAIGNPATH + filename in self.campaign_list:
					self.campaign_list.remove(CAMPAIGNPATH + filename)
				self.campaign_list.append(file_path + filename)
				self.modded_campaign_list.append(file_path + filename)
				if directory not in self.active_mods:
					self.active_mods.append(directory)
		
		# load stock and modded unit types
		with open(DATAPATH + 'unit_type_defs.json', encoding='utf8') as data_file:
			self.unit_types = json.load(data_file)
		for directory in mod_directories:
			file_path = self.mod_path + directory + os.sep + 'units' + os.sep
			# no custom units in this mod
			if not os.path.exists(file_path): continue
			for filename in os.listdir(file_path):
				if not filename.endswith('.json'): continue
				try:
					# try to load and add the modded units to the master list
					# replacing any older definitions with the same unit ID
					with open(file_path + filename, encoding='utf8') as data_file:
						mod_data = json.load(data_file)
						for k, v in mod_data.items():
							self.unit_types[k] = v
						if directory not in self.active_mods:
							self.active_mods.append(directory)
				
				except Exception as e:
					print('Error: Unable to parse modded unit file ' + filename + ': ' +
						str(e) + '\n\n')
					self.failed_mods.append(directory + ': ' + filename)
					continue

		# build dictionary of portrait filepaths for each variant category including Standard.
		# Note that this is case-sensitive and unit portrait IDs can't be assumed to be consistent with filenames;
		# for safety, we lowercase them when accessing or assigning keys.
		# returns True if it found any portraits in the given directory, for active mod detection.
		def LoadPortraits(file_path, modfolder = None):
			if not os.path.exists(file_path):
				return False
			found_portraits = False

			# add standard portraits
			for filename in os.listdir(file_path):
				if filename.endswith('.xp'):
					if filename.lower() in self.portrait_library:
						self.portrait_library[filename.lower()]['STD'] = file_path + filename
					else:
						self.portrait_library[filename.lower()] = {'STD' : file_path + filename}
					found_portraits = True
					# Record modded portraits and conflicts
					if modfolder is not None:
						if filename.lower() in self.modded_portraits:
							if 'STD' in self.modded_portraits[filename.lower()]: # mod conflict
								self.modded_portraits[filename.lower()]['STD'].append(modfolder)
							else:
								self.modded_portraits[filename.lower()]['STD'] = [modfolder]
						else:
							self.modded_portraits[filename.lower()] = {'STD' : [modfolder]}

			# check variant subdirectories
			for variant in PORTRAIT_VARIANTS:
				variant_path = file_path + variant + os.sep
				if not os.path.exists(variant_path):
					continue
				for filename in os.listdir(variant_path):
					if filename.endswith('.xp'):
						if filename.lower() in self.portrait_library:
							self.portrait_library[filename.lower()][variant] = variant_path + filename
						else:
							self.portrait_library[filename.lower()] = {variant : variant_path + filename}
						found_portraits = True
						# Record modded variants and conflicts
						if modfolder is not None:
							if filename.lower() in self.modded_portraits:
								if variant in self.modded_portraits[filename.lower()]: # mod conflict
									self.modded_portraits[filename.lower()][variant].append(modfolder)
								else:
									self.modded_portraits[filename.lower()][variant] = [modfolder]
							else:
								self.modded_portraits[filename.lower()] = {variant : [modfolder]}

			return found_portraits

		self.portrait_library = {}
		self.modded_portraits = {} # array for debugging mod files
		self.missing_variants = {} # array of generic variants to make it clear in unit viewer which portrait variants are unique.

		# add base-game portraits
		LoadPortraits(PORTRAITPATH)
		# save a copy of this for comparing to mod files.
		self.base_game_portraits = {key:value.copy() for key,value in self.portrait_library.items()}
		self.base_game_missing_variants = {}

		# add modded portraits, overwriting any base-game ones or previous mods
		for directory in mod_directories:
			if LoadPortraits(self.mod_path + directory + os.sep + 'unit_portraits' + os.sep, directory) and directory not in self.active_mods:
				self.active_mods.append(directory)

		# check if any portrait variants are missing, and assign the first available portrait in their place if they are.
		# ex. if there's a STD portrait but no DES variant, assign STD to DES.
		# If there's a WIN variant but no STD or DES, assign WIN to STD and DES.
		def FillPortraitLibraryGaps(debug = False):
			if debug:
				library = self.base_game_portraits
				missing_vars = self.base_game_missing_variants
			else:
				library = self.portrait_library
				missing_vars = self.missing_variants

			for portrait_key in library:
				missing_vars[portrait_key] = []
				for v1 in PORTRAIT_VARIANTS:
					if v1 in library[portrait_key]:
						first_available_variant = library[portrait_key][v1]
						break

				for v2 in PORTRAIT_VARIANTS:
					if v2 not in library[portrait_key]:
						library[portrait_key][v2] = first_available_variant
						missing_vars[portrait_key].append(v2)

		FillPortraitLibraryGaps(False) # Fill missing variants in gameplay portrait library with copies of existing variants.
		FillPortraitLibraryGaps(True) # Ditto for the comparison library which doesn't include mod portraits.

		# Setup fancy infantry/cavalry portrait keys. These work the same way as the main library but have an additional key for the unit's nation.
		# unmodifiedportraitname.xp = generic unit
		# portraitname_nationcode.xp = nation-specific variant
		# portraitname_basic.xp = old generic portrait
		self.infantry_portrait_library = {}
		for unit_name, unit_stats in self.unit_types.items():
			if unit_stats['category'] not in ['Infantry', 'Cavalry']:
				continue
			if 'portrait' not in unit_stats:
				continue
			unit_portrait = unit_stats['portrait'].lower()
			if unit_portrait in self.infantry_portrait_library:
				continue

			# Check for a basic/old-style generic portrait, use the default if it doesn't exist. Note lowercase due to portrait library de-capping.
			basic_portrait = unit_portrait[:-3] + '_basic.xp'
			if basic_portrait not in self.portrait_library:
				basic_portrait = unit_portrait

			# If there's no default portrait to be found, try to find a usable variant, preferably not the stickman `_basic.xp` one.
			if unit_portrait not in self.portrait_library:
				search_term = unit_portrait[:-3] + '_'
				for library_portrait in self.portrait_library:
					if search_term in library_portrait and library_portrait != basic_portrait:
						self.portrait_library[unit_portrait] = self.portrait_library[library_portrait]
						break
				else:
					if basic_portrait in self.portrait_library:
						self.portrait_library[unit_portrait] = self.portrait_library[basic_portrait]
					else:
						continue

			self.infantry_portrait_library[unit_portrait] = {}

			# Create variant subdictionaries and record the corresponding default and old-style portraits.
			for variant in PORTRAIT_VARIANTS:
				self.infantry_portrait_library[unit_portrait][variant] = {None : self.portrait_library[unit_portrait][variant], 'BASIC' : self.portrait_library[basic_portrait][variant]}

			# Check for national basic subvariants, use the corresponding default if they don't exist.
			for portrait_nation in [self.nations[i]['short_code'] for i in self.nations]:
				national_filename = unit_portrait[:-3] + '_' + portrait_nation.lower() + '.xp'
				if national_filename not in self.portrait_library:
					national_filename = unit_portrait
				for variant in PORTRAIT_VARIANTS:
					self.infantry_portrait_library[unit_portrait][variant][portrait_nation] = self.portrait_library[national_filename][variant]

		# set up filter tags for unit gallery
		self.unit_filter_tags = {}
		for text in FILTER_TAGS:
			self.unit_filter_tags[text] = []
		for k, v in self.unit_types.items():
			for text in FILTER_TAGS[1:]:
				if text not in v: continue
				if v[text] not in self.unit_filter_tags[text]:
					self.unit_filter_tags[text].append(v[text])
		self.unit_filter_tags['origin_nation'] = list(self.nations)
		
		# tank portrait for main menu
		self.tank_portrait = None
		self.tank_portrait_id = None
		for tries in range(300):
			unit_id = choice(list(self.unit_types.keys()))
			if 'portrait' not in self.unit_types[unit_id]: continue
			if self.unit_types[unit_id]['class'] not in ['Tankette', 'Light Tank', 'Medium Tank', 'Heavy Tank', 'Tank Destroyer']: continue
			if not os.path.exists(PORTRAITPATH + self.unit_types[unit_id]['portrait']): continue
			
			# chance to choose a variant if any exist
			portrait_name = self.unit_types[unit_id]['portrait']
			portrait_variant = choice(PORTRAIT_VARIANTS[1:])
			if os.path.exists(PORTRAITPATH + portrait_variant + os.sep + portrait_name) and libtcod.random_get_int(0, 1, 3) == 3:
				filename = portrait_variant + os.sep + portrait_name
			else:
				filename = portrait_name			
			self.tank_portrait = LoadXP(filename)
			self.tank_portrait_id = unit_id
			break
		
		# campaign day map player unit animation offset
		self.cd_x_offset = 0
		self.cd_y_offset = 0
		
		# try to find campaign records file, create one if doesn't exist yet
		# new name, location, and file structure from 1.1.0
		if not os.path.exists(self.home_path + os.sep + 'campaign_records.dat'):
			with shelve.open(self.home_path + os.sep + 'campaign_records', 'n') as save:
				save['campaign_records'] = []
		
		# load sound effects and modded sound effects into session object
		self.sound_effects = {}
		for filename in os.listdir(SOUNDPATH):
			if not filename.endswith('.ogg'): continue
			if 'theme' in filename: continue
			if filename[-7] != '_':
				continue
			root_name = filename[:-7]
			if root_name not in self.sound_effects:
				self.sound_effects[root_name] = []
			self.sound_effects[root_name].append(SOUNDPATH + filename)
		
		for directory in mod_directories:
			file_path = self.mod_path + directory + os.sep + 'sounds' + os.sep
			# no custom sounds in this mod
			if not os.path.exists(file_path): continue
			for filename in os.listdir(file_path):
				if not filename.endswith('.ogg'): continue
				if 'theme' in filename: continue
				if filename[-7] != '_': continue
				root_name = filename[:-7]
				
				# don't create new categories
				if root_name not in self.sound_effects: continue
				
				# overwrite existing stock sound effect if present
				if SOUNDPATH + filename in self.sound_effects[root_name]:
					self.sound_effects[root_name].remove(SOUNDPATH + filename)
				
				self.sound_effects[root_name].append(file_path + filename)
				
				if directory not in self.active_mods:
					self.active_mods.append(directory)
		
		# placeholder for music data
		self.music = None
		
		# build a list of campaign day and scenario layer music tracks, only provided by mods
		self.cd_music_tracks = []
		self.scen_music_tracks = []
		for directory in mod_directories:
			file_path = self.mod_path + directory + os.sep + 'cd_music' + os.sep
			if os.path.exists(file_path):
				for filename in os.listdir(file_path):
					if not filename.endswith('.ogg'): continue
					self.cd_music_tracks.append(file_path + filename)
				
			file_path = self.mod_path + directory + os.sep + 'scen_music' + os.sep
			if os.path.exists(file_path):
				for filename in os.listdir(file_path):
					if not filename.endswith('.ogg'): continue
					self.scen_music_tracks.append(file_path + filename)
		
		# load crew talk dictionary
		with open(DATAPATH + 'crew_talk.json', encoding='utf8') as data_file:
			self.crew_talk = json.load(data_file)
		
		# map hex view mode stuff
		self.cd_hex_highlight_con = LoadXP('dayhex_highlight.xp')
		libtcod.console_set_key_color(self.cd_hex_highlight_con, KEY_COLOR)
		
		self.cd_view_mode = False
		self.cd_view_hex = None
		self.scen_view_mode = False
		self.scen_view_hex = None
		
	
	# start or stop playing a track of music, also handles selecting a random track from modded music lists
	def MusicHandler(self, music_name, start):
		if not config['ArmCom2'].getboolean('sounds_enabled'): return
		
		if start:
			if music_name == 'main':
				if not config['ArmCom2'].getboolean('music'): return
				self.music = mixer.Mix_LoadMUS((SOUNDPATH + 'armcom2_theme.ogg').encode('ascii'))
				repeat = -1
			
			elif music_name == 'bailout':
				if not config['ArmCom2'].getboolean('music'): return
				self.music = mixer.Mix_LoadMUS((SOUNDPATH + 'bailout_music.ogg').encode('ascii'))
				repeat = -1
			
			elif music_name == 'cd_music':
				if len(self.cd_music_tracks) == 0: return
				self.music = mixer.Mix_LoadMUS((choice(self.cd_music_tracks)).encode('ascii'))
				repeat = 0
			
			elif music_name == 'scen_music':
				if len(self.scen_music_tracks) == 0: return
				self.music = mixer.Mix_LoadMUS((choice(self.scen_music_tracks)).encode('ascii'))
				repeat = 0
			
			else:
				return
			
			if mixer.Mix_PlayMusic(self.music, repeat) < 0:
				print('Error: ' + str(sdl2.SDL_GetError()))
		else:
			if self.music is None: return
			if mixer.Mix_PlayingMusic() == 0: return
			mixer.Mix_FadeOutMusic(100)
	
	
	# update the stored values for window size and cell display size
	def UpdateDisplaySize(self):
		
		self.window_id += 1
		w, h = ctypes.c_int(), ctypes.c_int()
		
		# sanity check - make sure we have the most recent window
		while sdl2.SDL_GetWindowFromID(self.window_id) is None:
			self.window_id -= 1
		
		result = sdl2.SDL_GetRendererOutputSize(sdl2.SDL_GetRenderer(sdl2.SDL_GetWindowFromID(self.window_id)), w, h)
		self.window_w = w.value
		self.window_h = h.value
		print('Set display size to: ' + str(self.window_w) + ' x ' + str(self.window_h))
		
		if config.getboolean('ArmCom2', 'fullscreen'):
			if config.getboolean('ArmCom2', 'ultrawide'):
				self.window_cell_width = UW_SCREEN_WIDTH
				self.window_cell_height = UW_SCREEN_HEIGHT
			else:
				self.window_cell_width = SCREEN_WIDTH
				self.window_cell_height = SCREEN_HEIGHT
		else:
			self.window_cell_width = WINDOW_WIDTH
			self.window_cell_height = WINDOW_HEIGHT
	
	
	# generate keyboard encoding and decoding dictionaries
	def GenerateKeyboards(self):
		self.keyboard_decode = {}
		self.keyboard_encode = {}
		with open(DATAPATH + 'keyboard_mapping.json', encoding='utf8') as data_file:
			keyboards = json.load(data_file)
		dictionary = keyboards[KEYBOARDS[config['ArmCom2'].getint('keyboard')]]
		for key, value in dictionary.items():
			self.keyboard_encode[key] = value
			self.keyboard_decode[value] = key
	
	
	# modify a Steam user stat, and upload all current stats to the Steam servers
	def ModifySteamStat(self, stat_name, amount):
		if not steam_active: return
		steamworks.UserStats.RequestCurrentStats()
		steamworks.run_callbacks()
		value = steamworks.UserStats.GetStatInt(stat_name.encode('ascii'))
		if not steamworks.UserStats.SetStat(stat_name.encode('ascii'), value + amount):
			if DEBUG:
				print('DEBUG: Failed to increase Steam stat ' + stat_name + ' by ' + str(amount))
			return
		steamworks.UserStats.StoreStats()
		steamworks.run_callbacks()
	
	
	# update campaign records with new data
	def UpdateCampaignRecords(self, data):
		try:
			with shelve.open(self.home_path + os.sep + 'campaign_records') as save:
				campaign_records = save['campaign_records']
		except:
			print('Error: Could not load campaign records file!')
			return
		campaign_records.append(data)
		campaign_records.sort(key=lambda x: x['vp'], reverse=True)
		with shelve.open(self.home_path + os.sep + 'campaign_records', 'n') as save:
			save['campaign_records'] = campaign_records
	
	
	# save the current campaign records
	def SaveCampaignRecords(self, campaign_records):
		with shelve.open(self.home_path + os.sep + 'campaign_records', 'n') as save:
			save['campaign_records'] = campaign_records
		
	
	# add an entry to the memorial file
	def AddMemorial(self, crewman):
		if crewman is None: return
		if crewman.alive: return
		
		text1 = session.nations[crewman.nation]['rank_names'][str(crewman.rank)]
		text1 += ' ' + crewman.GetCrewmanName()
		if crewman.nickname != '':
			text1 += ' - "' + crewman.nickname + '"'
		text1 += ' - ' + session.nations[crewman.nation]['adjective'] + ' - '
		text2 = campaign.today
		
		# load existing memorial file
		if not os.path.exists(self.home_path + os.sep + 'graveyard.dat'):
			graveyard = []
		else:
			try:
				with shelve.open(self.home_path + os.sep + 'graveyard') as save:
					graveyard = save['graveyard']
			except:
				print('Error: Found memorial file but could not load it')
				return
		
		graveyard.append((text1, text2))
		graveyard.sort(key = lambda x: x[1])
		with shelve.open(self.home_path + os.sep + 'graveyard', 'n') as save:
			save['graveyard'] = graveyard
	
	
	# try to initialize SDL2 mixer
	def InitMixer(self):
		mixer.Mix_Init(mixer.MIX_INIT_OGG)
		if mixer.Mix_OpenAudio(48000, mixer.MIX_DEFAULT_FORMAT,	2, 1024) == -1:
			return False
		mixer.Mix_AllocateChannels(32)
		self.SetMasterVolume(config['ArmCom2'].getint('master_volume'))
		return True
	
	
	# set the master volume for sound effects (1-10)
	def SetMasterVolume(self, new_volume):
		mixer.Mix_Volume(-1, new_volume * 12)
		mixer.Mix_VolumeMusic(new_volume * 6)




# Personnel Class: represents an individual person within a unit 
# if avg_level is > 0, crewman is a replacement and may start at a higher level
class Personnel:
	def __init__(self, unit, nation, position, avg_level=0):
		self.unit = unit				# pointer to which unit they belong
		self.nation = nation				# nationality of person
		self.is_player_commander = False		# represents a Player Commander
		self.current_position = position		# pointer to current position in a unit
		
		self.default_start = None			# default hatch status and command at start of scenario
		
		# core data
		self.alive = True				# is crewman alive or not
		self.fatigue = BASE_FATIGUE			# current crew fatigue points
		self.condition = 'Good Order'			# current mental and physical condition
		self.injury = {					# injuries to different body systems
			'Head & Neck' : (None, None, False),	# status, severity, scarring
			'Torso & Groin' : (None, None, False),
			'Right Arm & Hand' : (None, None, False),
			'Left Arm & Hand' : (None, None, False),
			'Right Leg & Foot' : (None, None, False),
			'Left Leg & Foot' : (None, None, False)
		}
		self.first_aid_action_taken = False		# crewman has already performed a first aid action this turn
		self.field_hospital = None			# crewman must be sent to field hospital if set
		
		self.first_name = ''				# placeholders for first and last name
		self.last_name = ''				#   set by GenerateName()
		self.GenerateName()				# generate random first and last name
		self.nickname = ''				# player-set nickname
		self.age = 20					# age in years
		self.rank = 0					# rank level
		
		self.decorations = {}				# dictionary of decorations and number of times so decorated
		
		self.stats = {					# default stat values
			'Perception' : 1,			# used for spotting enemy units
			'Grit' : 1,				# reduced chance of injury or condition getting worse
			'Knowledge' : 1,			# adds a small bonus to most skill effects
			'Morale' : 1				# resist fatigue and recover from negative condition
		}
		
		# randomly increase two stats to 3
		for i in sample(range(4), 2):
			self.stats[CREW_STATS[i]] = 3
		
		self.skills = []				# list of skills
		
		# add any campaign skills
		self.AddCampaignSkills()
		
		fake_commander = False
		
		# check for position training skills
		if self.current_position is not None:
			
			# special: replacing a commander position but a trained commander is already in the unit
			if self.current_position.name in COMMANDER_POSITIONS and unit.HasMisplacedCommander():
				fake_commander = True
				self.skills.append('Trained Gunner')
				self.skills.append('Trained Driver')
			elif self.current_position.name == 'Commander':
				self.skills.append('Experienced Commander')
				self.skills.append('Trained Gunner')
				self.skills.append('Trained Driver')
			elif self.current_position.name == 'Commander/Gunner':
				self.skills.append('Experienced Commander')
				self.skills.append('Experienced Gunner')
				self.skills.append('Trained Driver')
			elif self.current_position.name == 'Commander/Loader':
				self.skills.append('Experienced Commander')
				self.skills.append('Trained Driver')
			elif self.current_position.name in ['Gunner', 'Gunner/Loader']:
				self.skills.append('Experienced Gunner')
				self.skills.append('Trained Driver')
			elif self.current_position.name in ['Driver', 'Co-Driver', 'Rear Driver']:
				self.skills.append('Experienced Driver')
		
		# current level, exp, and advance points
		self.level = 1
		self.exp = 0
		self.adv = 1
		
		# check for experienced replacement
		if avg_level > 1:
			new_level = libtcod.random_get_int(0, 1, avg_level)
			new_level = libtcod.random_get_int(0, 1, new_level)
			if new_level > 1:
				self.level = new_level
				self.exp = GetExpRequiredFor(self.level)
				self.adv = new_level
				self.age += libtcod.random_get_int(0, 2, 5)
				
				# promotion check
				for (k, v) in LEVEL_RANK_LIST.items():
					if int(k) > self.level: break
					if v <= self.rank: continue
					if GetPercentileRoll() <= PROMOTION_CHANCE:
						self.rank = v
						self.adv += 1
		
		# some positions have minimum starting levels and ranks
		if self.current_position is not None:
			
			# commanders start minimum level 4
			if self.current_position.name in COMMANDER_POSITIONS and not fake_commander:
				if self.level < 4:
					self.level = 4
					self.exp = GetExpRequiredFor(self.level)
					self.adv = 5
					self.age += libtcod.random_get_int(0, 3, 9)
				if self.rank < 2:
					self.rank = 2
			
			# gunners start minimum level 2
			elif self.current_position.name in ['Gunner', 'Gunner/Loader']:
				if self.level < 2:
					self.level = 2
					self.exp = GetExpRequiredFor(self.level)
					self.adv = 3
					self.age += libtcod.random_get_int(0, 2, 5)
				if self.rank < 1:
					self.rank = 1
		
		# special: some ranks not used before a certain date
		if self.nation == 'Empire of Japan' and self.rank == 0 and campaign.today < '1945.01.01':
			self.rank = 1
		
		# give current age, set random birthday
		year = int(campaign.today.split('.')[0].lstrip('0')) - self.age
		month = libtcod.random_get_int(0, 1, 12)
		day = libtcod.random_get_int(0, 1, monthrange(year, month)[1])
		self.birthday = str(year) + '.' + str(month).zfill(2) + '.' + str(day).zfill(2)
		
		# exposed / buttoned up status
		self.ce = False					# crewman is exposed in a vehicle
		self.SetCEStatus()				# set CE status
		
		self.cmd_list = []				# list of possible commands
		self.current_cmd = 'Spot'			# currently assigned command in scenario
		self.acted = False				# flag for whether this crewman has acted yet this scenario turn
		
		self.action_list = [('None', 0.0)]		# list of possible actions, eg. in bail-out
		self.current_action = self.action_list[0]	# currently assigned action
	
	
	# resolve all outstanding injuries on this crewman, usually called when returning from Field Hospital
	def ResolveOutstandingInjuries(self):
		for (k, v) in self.injury.items():
			(status, severity, scarring) = v
			if status is None and severity is None: continue
			text = "Your crewman's " + k + ' injury is now healed'
			# check for new scarring
			if self.ScarCheck(k):
				text += ' but has left scarring'
				scarring = True
			text += '.'
			status = None
			severity = None
			self.injury[k] = (status, severity, scarring)
			ShowMessage(text, crewman=self, longer_pause=True)

	
	# check to see if a healed injury leaves scarring
	def ScarCheck(self, location):
		
		(status, severity, scarring) = self.injury[location]
		
		# already scarring present here
		if scarring: return False
		
		scar_chance = -1.0
		if severity == 'Light':
			scar_chance = 5.0
		elif severity == 'Heavy':
			scar_chance = 15.0
		elif severity == 'Serious':
			scar_chance = 30.0
		scar_chance -= self.stats['Grit'] * 1.0
		
		roll = GetPercentileRoll()
		if roll > scar_chance: return False
		
		# reduce a random stat by one (never lower than 3) if possible
		stat_list = [0,1,2,3]
		shuffle(stat_list)
		for i in stat_list:
			if self.stats[CREW_STATS[i]] > 3:
				self.stats[CREW_STATS[i]] -= 1
				break
		
		return True
	
	
	# display a simple list of info for this crewman to a console
	def DisplaySimpleInfo(self, console, x, y):
		libtcod.console_set_default_foreground(console, libtcod.dark_grey)
		libtcod.console_hline(console, x, y+1, 28)
		libtcod.console_hline(console, x, y+3, 28)
		libtcod.console_hline(console, x, y+5, 28)
		libtcod.console_hline(console, x, y+7, 28)
		libtcod.console_hline(console, x, y+12, 28)
		
		libtcod.console_set_default_foreground(console, libtcod.lighter_blue)
		libtcod.console_print(console, x, y, 'Name')
		libtcod.console_print(console, x, y+2, 'Nickname')
		libtcod.console_print(console, x, y+4, 'Rank')
		libtcod.console_print(console, x, y+6, 'Position')
		libtcod.console_print(console, x, y+8, 'Stats')
		libtcod.console_print(console, x, y+13, 'Skills')
		
		libtcod.console_set_default_foreground(console, libtcod.white)
		PrintExtended(console, x+9, y, self.GetCrewmanName())
		if self.nickname == '':
			text = '[None]'
		else:
			text = self.nickname
		PrintExtended(console, x+9, y+2, text)
		libtcod.console_print(console, x+9, y+4, session.nations[self.nation]['rank_names'][str(self.rank)])
		
		if self.current_position is None:
			text = 'None'
		else:
			if self.current_position.name is None:
				text = 'None'
			else:
				text = self.current_position.name
		libtcod.console_print(console, x+9, y+6, text)
		
		# stats
		libtcod.console_put_char_ex(console, x+9, y+8, chr(4), libtcod.yellow, libtcod.black)
		libtcod.console_put_char_ex(console, x+9, y+9, chr(3), libtcod.red, libtcod.black)
		libtcod.console_put_char_ex(console, x+9, y+10, chr(5), libtcod.blue, libtcod.black)
		libtcod.console_put_char_ex(console, x+9, y+11, chr(6), libtcod.green, libtcod.black)
		y1 = y+8
		for t in CREW_STATS:
			libtcod.console_set_default_foreground(console, libtcod.white)
			libtcod.console_print(console, x+11, y1, t)
			libtcod.console_set_default_foreground(console, libtcod.light_grey)
			libtcod.console_print_ex(console, x+23, y1, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(self.stats[t]))
			y1 += 1
		
		# skills
		y1 = y+13
		libtcod.console_set_default_foreground(console, libtcod.white)
		if len(self.skills) == 0:
			libtcod.console_print(console, x+7, y1, 'None')
			y1 += 1
		else:
			for skill in self.skills:
				libtcod.console_print(console, x+7, y1, skill)
				y1 += 1
		
		# level, exp, and advance points
		libtcod.console_set_default_foreground(console, libtcod.dark_grey)
		libtcod.console_hline(console, x, y1, 28)
		
		libtcod.console_set_default_foreground(console, libtcod.lighter_blue)
		libtcod.console_print(console, x+4, y1+1, 'Level')
		libtcod.console_print(console, x+4, y1+2, 'Experience')
		libtcod.console_print(console, x+4, y1+3, 'Advance Points')
		
		libtcod.console_set_default_foreground(console, libtcod.white)
		libtcod.console_print_ex(console, x+23, y1+1, libtcod.BKGND_NONE,
			libtcod.RIGHT, str(self.level))
		libtcod.console_print_ex(console, x+23, y1+2, libtcod.BKGND_NONE,
			libtcod.RIGHT, str(self.exp))
		libtcod.console_print_ex(console, x+23, y1+3, libtcod.BKGND_NONE,
			libtcod.RIGHT, str(self.adv))
	
	
	# apply the effects from a level up for this crewman
	def LevelUp(self, levels_up):
		self.level += levels_up
		self.adv += levels_up
		if self.unit is None: return
		if self.unit != campaign.player_unit: return
		
		# test for gain of experience for another position in current vehicle
		for i in range(levels_up):
			
			# possible gain of position training
			result = None
			for position in sample(self.unit.positions_list, len(self.unit.positions_list)):
				
				roll = GetPercentileRoll()
				if position.name == self.current_position.name: roll -= 25.0
				if roll > float(self.stats['Knowledge']): continue
				
				if position.name in ['Commander', 'Commander/Loader']:
					if 'Trained Commander' not in self.skills and 'Experienced Commander' not in self.skills:
						self.skills.append('Trained Commander')
						result = 'Trained Commander'
					elif 'Experienced Commander' not in self.skills:
						self.skills.append('Experienced Commander')
						result = 'Experienced Commander'
				elif position.name == 'Commander/Gunner':
					if 'Trained Commander' not in self.skills and 'Experienced Commander' not in self.skills:
						self.skills.append('Trained Commander')
						result = 'Trained Commander'
					elif 'Experienced Commander' not in self.skills:
						self.skills.append('Experienced Commander')
						result = 'Experienced Commander'
					if 'Trained Gunner' not in self.skills and 'Experienced Gunner' not in self.skills:
						self.skills.append('Trained Gunner')
						result = 'Trained Gunner'
					elif 'Experienced Gunner' not in self.skills:
						self.skills.append('Experienced Gunner')
						result = 'Experienced Gunner'
				elif position.name in ['Gunner', 'Gunner/Loader']:
					if 'Trained Gunner' not in self.skills and 'Experienced Gunner' not in self.skills:
						self.skills.append('Trained Gunner')
						result = 'Trained Gunner'
					elif 'Experienced Gunner' not in self.skills:
						self.skills.append('Experienced Gunner')
						result = 'Experienced Gunner'
				elif position.name in ['Driver', 'Co-Driver', 'Rear Driver']:
					if 'Trained Driver' not in self.skills and 'Experienced Driver' not in self.skills:
						self.skills.append('Trained Driver')
						result = 'Trained Driver'
					elif 'Experienced Driver' not in self.skills:
						self.skills.append('Experienced Driver')
						result = 'Experienced Driver'
				
				# if any result, display it and return
				if result is not None:
					
					# check for skill replacements
					if 'replaces' in session.skills[result]:
						if session.skills[result]['replaces'] in self.skills:
							self.skills.remove(session.skills[result]['replaces'])
					
					
					if self.is_player_commander:
						ShowMessage('You have gained familiarity with a vehicle position: ' + result, longer_pause=True)
					else:
						ShowMessage('Your crewman has gained familiarity with a vehicle position: ' + result, crewman=self, longer_pause=True)
					return
		
	
	# remove any current campaign skills from crewman, called upon moving into a new campaign
	# any skill tagged as stat_bonus_skill is not removed, as it has already given a stat boost
	def RemoveCampaignSkills(self):
		for skill in reversed(self.skills):
			if skill not in session.skills: continue
			if 'stat_bonus_skill' in session.skills[skill]: continue
			if 'campaign_skill' in session.skills[skill]:
				self.skills.remove(skill)
		
	
	# award any campaign skills for current campaign, called upon spawn or after moving into a new campaign
	def AddCampaignSkills(self):
		
		if self.unit is None or self.current_position is None: return
		if not self.unit.is_player: return
		
		if 'campaign_skills' in campaign.stats:
			for skill in campaign.stats['campaign_skills']:
				
				# don't add twice
				if skill in self.skills: continue
				
				if 'position_list' in session.skills[skill]:
					if self.current_position is None: continue
					if self.current_position.name not in session.skills[skill]['position_list']:
						continue
				
				self.skills.append(skill)
		
		# check for skill effects on stats
		for skill in self.skills:
			if skill == 'Total Sacrifice':
				self.stats['Morale'] += 5
				if self.stats['Morale'] > 10:
					self.stats['Morale'] = 10
			elif skill in ['Defend the Motherland', 'Imperial Ambitions', 'Poland is Not Yet Lost', 'Semper Fi']:
				self.stats['Morale'] += 3
				if self.stats['Morale'] > 10:
					self.stats['Morale'] = 10
			elif skill == 'Exceptional Efforts':
				self.stats['Morale'] += 2
				if self.stats['Morale'] > 10:
					self.stats['Morale'] = 10
			elif skill == 'To Victory!':
				self.stats['Grit'] += 3
				if self.stats['Grit'] > 10:
					self.stats['Grit'] = 10
			elif skill == 'Audacia':
				self.stats['Perception'] += 3
				if self.stats['Perception'] > 10:
					self.stats['Perception'] = 10
			elif skill == 'Baptism of Fire':
				self.stats['Knowledge'] += 3
				if self.stats['Knowledge'] > 10:
					self.stats['Knowledge'] = 10
			elif skill == 'Fighting Qualities':
				self.stats['Morale'] += 2
				if self.stats['Morale'] > 10:
					self.stats['Morale'] = 10
				self.stats['Knowledge'] += 2
				if self.stats['Knowledge'] > 10:
					self.stats['Knowledge'] = 10
	
	# re-calculate crewman age based on current day in campaign calendar
	def CalculateAge(self):
		(year1, month1, day1) = self.birthday.split('.')
		(year2, month2, day2) = campaign.today.split('.')
		self.age = int(year2) - int(year1)
		if int(month2) >= int(month1):
			if int(day2) >= int(day1):
				self.age += 1
		
	
	# return the crewman's full name, or first initial and surname
	def GetCrewmanName(self, first_initial=False):
		if first_initial:
			first_name = self.first_name[0] + '.'
		else:
			first_name = self.first_name
		if 'surnames_first' in session.nations[self.nation]:
			return self.last_name + ' ' + first_name
		return first_name + ' ' + self.last_name
	
	
	# resolve current injuries for this crewman - called at end of campaign day
	def ResolveInjuries(self):
		
		hospital_min = 0
		hospital_max = 0
		hospital_chance = 0.0
		
		# run through injuries
		purple_heart_awarded = False
		wound_badge_awarded = False
		for (k, v) in self.injury.items():
			
			(status, severity, scarring) = v
			if status is None and severity is None: continue
			
			# fresh or patched up wounds may send crewman to field hospital
			if status in ['Fresh', 'Patched Up']:
				if severity == 'Heavy':
					hospital_chance += 50.0
					if hospital_min == 0:
						hospital_min = 3
					else:
						hospital_min += libtcod.random_get_int(0, 0, 1)
					if hospital_max < 7:
						hospital_max = 7
					else:
						hospital_max += libtcod.random_get_int(0, 0, 2)
				
				elif severity == 'Serious':
					hospital_chance += 80.0
					if hospital_min < 7:
						hospital_min = 7
					else:
						hospital_min += libtcod.random_get_int(0, 2, 4)
					if hospital_max < 21:
						hospital_max = 21
					else:
						hospital_max += libtcod.random_get_int(0, 2, 4)
			
			# fresh or patched up wounds start healing
			if status in ['Fresh', 'Patched Up']:
				status = 'Healing'
			
			self.injury[k] = (status, severity, scarring)
		
		# crewman grit effect
		grit_effect = int(self.stats['Grit'] / 2)
		if hospital_min > 0:
			hospital_min -= libtcod.random_get_int(0, 0, grit_effect)
			if hospital_min < 0:
				hospital_min = 0
		if hospital_max > 0:
			hospital_max -= libtcod.random_get_int(0, 0, grit_effect)
			if hospital_max < 0:
				hospital_max = 0
		if hospital_min > hospital_max:
			hospital_min = hospital_max
		
		if 'Only a Flesh Wound' in self.skills:
			hospital_chance -= 50.0
		elif 'Only a Scratch' in self.skills:
			hospital_chance -= 30.0
		
		if hospital_chance > 97.0:
			hospital_chance = 97.0
		
		# field hospital roll
		if hospital_min != 0 and hospital_max != 0 and hospital_chance > 0.0 and 'tutorial_campaign' not in campaign.stats:
			roll = GetPercentileRoll()
			if roll <= hospital_chance:
				self.field_hospital = (hospital_min, hospital_max)
				
				# Field Hospital injuries result in Purple Heart for American crewmen, Wound Badge for German crewmen
				if self.nation == 'United States of America' and not purple_heart_awarded:
					purple_heart_awarded = True
					if 'Purple Heart' in self.decorations:
						self.decorations['Purple Heart'] += 1
					else:
						self.decorations['Purple Heart'] = 1
					if self.is_player_commander:
						ShowMessage('You have been awarded a Purple Heart.', longer_pause=True)
						session.ModifySteamStat('dec_purple', 1)
					else:
						ShowMessage('Your crewman has been awarded a Purple Heart.', crewman=self, longer_pause=True)
				elif self.nation == 'Germany' and not wound_badge_awarded:
					wound_badge_awarded = True
					if 'Wound Badge' in self.decorations:
						self.decorations['Wound Badge'] += 1
					else:
						self.decorations['Wound Badge'] = 1
					if self.is_player_commander:
						ShowMessage('You have been awarded a Wound Badge.', longer_pause=True)
					else:
						ShowMessage('Your crewman has been awarded a Wound Badge.', crewman=self, longer_pause=True)
				
			else:
				self.field_hospital = None
		
	
	# returns true if this crewmen is currently working a position for which they lack training
	# only used for player for now
	def UntrainedPosition(self):
		if self.unit != campaign.player_unit: return False
		
		# check for required skills
		if self.current_position.name in ['Commander', 'Commander/Loader']:
			if 'Trained Commander' not in self.skills and 'Experienced Commander' not in self.skills:
				return True
		if self.current_position.name == 'Commander/Gunner':
			if 'Trained Commander' not in self.skills and 'Experienced Commander' not in self.skills:
				return True
			if 'Trained Gunner' not in self.skills and 'Experienced Gunner' not in self.skills:
				return True
		if self.current_position.name in ['Gunner', 'Gunner/Loader']:
			if 'Trained Gunner' not in self.skills and 'Experienced Gunner' not in self.skills:
				return True
		if self.current_position.name in ['Driver', 'Co-Driver', 'Rear Driver']:
			if 'Trained Driver' not in self.skills and 'Experienced Driver' not in self.skills:
				return True
		
		return False
		
	
	# resolve an incoming attack on this personnel
	# returns a string if there was a change in injury or status, otherwise returns None
	def ResolveAttack(self, attack_profile, explosion=False, show_messages=True):
		
		# randomly determine body location hit
		def GetHitLocation(attack_profile):
			
			roll = GetPercentileRoll()
			
			# location modifiers for sniper attack or landmine hit
			if 'sniper' in attack_profile:
				roll -= 21.0
			elif 'landmine' in attack_profile:
				roll += 35.0
			
			if roll <= 15.0:
				return 'Head & Neck'
			elif roll <= 50.0:
				return 'Torso & Groin'
			elif roll <= 65.0:
				return 'Right Arm & Hand'
			elif roll <= 80.0:
				return 'Left Arm & Hand'
			elif roll <= 90.0:
				return 'Right Leg & Foot'
			return 'Left Leg & Foot'
		
		
		# return one severity level higher
		def IncreaseSeverity(old_severity):
			if old_severity == 'Light':
				return 'Heavy'
			if old_severity == 'Heavy':
				return 'Serious'
			return 'Critical'
		
		
		# crewman is already dead, can't get worse
		if not self.alive:
			return None
		
		# check for debug flag here
		if DEBUG:
			if 'ko_hit' in attack_profile and session.debug['Player Crew Safe in Bail Out']:
				return None
		
		# don't show messages if this is not the player unit
		if self.unit != scenario.player_unit:
			show_messages = False
		
		# if tank exploded and Realistic Explosions campaign option is active, automatic KIA
		if explosion and campaign.options['explosion_kills']:
			self.KIA()
			return 'KIA'
		
		# final injury roll modifier
		modifier = 0.0
		
		# exposed to a firepower attack
		if 'firepower' in attack_profile:
			
			# currently in an armoured vehicle
			if self.unit.GetStat('armour') is not None:
				
				crewman_exposed = False
				
				# not exposed
				if not self.ce:
					return None
				
				# unconscious crewman are assumed to be slumped down and are protected
				if self.condition == 'Unconscious':
					return None
				
				# large hatch
				if self.current_position is not None:
					if self.current_position.large_hatch:
						modifier += 15.0
				
				# crewman on hunker down command
				if self.current_cmd == 'Hunker Down':
					modifier -= 50.0
				
				# crewman was not spotting and thus was better protected
				elif not session.crew_commands[self.current_cmd]['spotting_allowed']:
					modifier -= 25.0
				
			
			# determine chance of injury based on total incoming firepower
			fp = attack_profile['firepower']
			
			if fp <= 2:
				modifier -= 45.0
			elif fp <= 4:
				modifier -= 25.0
			elif fp <= 6:
				modifier -= 15.0
			elif fp <= 8:
				modifier += 5.0
			elif fp <= 10:
				modifier += 15.0
			elif fp <= 12:
				modifier += 20.0
			else:
				modifier += 25.0
			
			if campaign.options['realistic_injuries']:
				modifier += 25.0
		
		# spalling
		elif 'spalling' in attack_profile:
			if not campaign.options['realistic_injuries']:
				modifier -= (libtcod.random_get_int(0, 1, 40) * 1.0)
		
		# initial KO hit on vehicle
		elif 'ko_hit' in attack_profile:
						
			# additional risk if attack was close combat and crewman is CE
			if attack_profile['weapon'] is not None:
				if attack_profile['weapon'].GetStat('type') == 'Close Combat' and self.ce:
					modifier += 25.0
			
			# additional risk if in area of tank that was hit
			if attack_profile['location'] is not None and self.current_position.location is not None:
				if attack_profile['location'] == self.current_position.location:
					modifier += 20.0
			
			# additional risk for smaller vehicles
			if self.unit.GetStat('class') in ['Armoured Car', 'Tankette']:
				modifier += 20.0
			elif self.unit.GetStat('class') in ['Light Tank', 'Tank Destroyer']:
				modifier += 10.0
			
			# additional risk from extra ammo from each gun	
			for weapon in campaign_day.gun_list:
				total_ammo = 0
				for ammo_type in AMMO_TYPES:
					if ammo_type in weapon.ammo_stores:
						total_ammo += weapon.ammo_stores[ammo_type]
				
				if total_ammo > weapon.max_ammo:
					if weapon.GetStat('calibre') is not None:
						if int(weapon.GetStat('calibre')) <= 37:
							mod = 1.0 * (total_ammo - weapon.max_ammo)
						else:
							mod = 2.0 * (total_ammo - weapon.max_ammo)
						modifier += mod
		
		# part of bail-out - caught in burning vehicle
		elif 'burn_up' in attack_profile:
			modifier += (libtcod.random_get_int(0, 1, 4) * 5.0)
		
		# landmine hit
		elif 'landmine' in attack_profile:
			modifier = -10.0
		
		# tank explosion
		if explosion:
			if self.current_position.location == 'Vehicle Exterior':
				modifier += 20.0
			else:
				modifier += 80.0
		
		else:
		
			# skill checks
			if 'firepower' in attack_profile:
				if self.condition != 'Unconscious':
					if 'Lightning Reflexes' in self.skills:
						modifier -= 20.0
					elif 'Quick Reflexes' in self.skills:
						modifier -= 10.0
			
			# crewman grit modifier
			modifier -= self.stats['Grit'] * 3.0
			
			# shaken modifier
			if self.condition == 'Shaken':
				modifier += 10.0
		
		# determine location
		location = GetHitLocation(attack_profile)
		
		# if crewman is exposed in an AFV and leg/foot location is rolled, less chance of effect
		if 'firepower' in attack_profile and location in ['Right Leg & Foot', 'Left Leg & Foot']:
			modifier -= 10.0
		
		# already an injury here
		(status, severity, scarring) = self.injury[location]
		
		if status is not None:
			if status == 'Fresh':
				modifier += 20.0
			elif status == 'Patched Up':
				modifier += 15.0
			elif status == 'Healing':
				modifier += 5.0
		
		if scarring:
			modifier -= 20.0
		
		
		# do injury roll
		roll = GetPercentileRoll()
		
		# check for debug flag
		if DEBUG:
			if session.debug['Player Crew Hapless']:
				roll = 100.0
		
		# unmodified high roll always counts as KIA, otherwise modifier is applied
		if roll <= 99.5: roll += modifier
		
		
		# determine effect
		
		# miss - no effect
		if roll < 10.0:
			return None
		
		# near miss - possible change in condition
		elif roll <= 25.0:
			if self.condition != 'Good Order': return None
			if self.DoMoraleCheck(0.0): return None
			self.condition = 'Shaken'
			if show_messages:
				if self.is_player_commander:
					ShowMessage('You had a near miss and are now Shaken.', longer_pause=True)
				else:
					ShowMessage('Your crewman had a near miss and is now Shaken:', crewman=self, longer_pause=True)
			return 'Shaken'
		
		# grazing hit, no injury but possible stun if not already stunned
		elif roll <= 35.0:
			if self.condition == 'Stunned': return None
			if self.condition != 'Good Order':
				if show_messages:
					if self.is_player_commander:
						ShowMessage('You suffer a grazing hit but are no worse for wear.', longer_pause=True)
					else:
						ShowMessage('Your crewman suffers a grazing hit but is no worse for wear:', crewman=self, longer_pause=True)
				return None
			if self.DoMoraleCheck(0.0):
				self.condition = 'Shaken'
				self.DoFatigueCheck()
				if show_messages:
					if self.is_player_commander:
						ShowMessage('You suffer a grazing hit and are now Shaken.', longer_pause=True)
					else:
						ShowMessage('Your crewman suffers a grazing hit and is now Shaken:', crewman=self, longer_pause=True)
				return 'Shaken'
			else:
				self.condition = 'Stunned'
				self.DoFatigueCheck()
				if show_messages:
					if self.is_player_commander:
						ShowMessage('You suffer a grazing hit and are now Stunned.', longer_pause=True)
					else:
						ShowMessage('Your crewman suffers a grazing hit and is now Stunned:', crewman=self, longer_pause=True)
				return 'Stunned'
		
		# hit in a non-critical location
		elif roll <= 85.0:
			injury_roll = GetPercentileRoll()
			if injury_roll <= 50.0:
				new_severity = 'Light'
			elif injury_roll <= 80.0:
				new_severity = 'Heavy'
			else:
				new_severity = 'Serious'
			
		# hit in a possibly critical location
		elif roll <= 90.0:
			injury_roll = GetPercentileRoll()
			if injury_roll <= 40.0:
				new_severity = 'Light'
			elif injury_roll <= 60.0:
				new_severity = 'Heavy'
			elif injury_roll <= 85.0:
				new_severity = 'Serious'
			else:
				new_severity = 'Critical'
		
		# critical injury
		elif roll <= 98.9:
			new_severity = 'Critical'
		
		# KIA
		else:
			
			if 'tutorial_campaign' in campaign.stats:
				ShowMessage("Your crewman would be dead if this weren't a training exercise:", crewman=self, good_news=False)
				return None
			
			# check for fate point use
			if self.is_player_commander and campaign_day.fate_points > 0:
				campaign_day.fate_points -= 1
				ShowMessage('You narrowly escape death.', good_news=True)
				return None
			
			if self.is_player_commander:
				text = 'You have been hit in the ' + location + ' and killed. Your campaign is over.'
				if show_messages: ShowMessage(text, force_tab=True, good_news=False)
				campaign.AddJournal(text)
			else:
				text = 'Your crewman has been hit in the ' + location + ' and killed:'
				if show_messages: ShowMessage(text, crewman=self, longer_pause=True, good_news=False)
				campaign.AddJournal(text)
			
			self.KIA()
			
			return 'KIA'
		
		# apply injury (new system)
		injury_change = False
		
		
		# no previous injury in this location
		if status is None and severity is None:
			status = 'Fresh'
			severity = new_severity
			self.injury[location] = (status, severity, scarring)
			injury_change = True
		
		# previous injury already in this location
		else:
			
			# previous fresh injury
			if status == 'Fresh':
				new_severity = IncreaseSeverity(new_severity)
			else:
				status = 'Fresh'
				self.injury[location] = (status, severity, scarring)
			
			# light injury: chance of worsening to Heavy
			if new_severity == 'Light':
				if severity == 'Light':
					if GetPercentileRoll() <= 50.0:
						severity = 'Heavy'
						self.injury[location] = (status, severity, scarring)
						injury_change = True
			
			# heavy injury: chance of worsening to Serious
			elif new_severity == 'Heavy':
				if severity == 'Light':
					severity = 'Heavy'
					self.injury[location] = (status, severity, scarring)
					injury_change = True
				elif self.injury[location] == 'Heavy':
					if GetPercentileRoll() <= 50.0:
						severity = 'Serious'
						self.injury[location] = (status, severity, scarring)
						injury_change = True
			
			# serious injury
			elif new_severity == 'Serious':
				if severity in ['Light', 'Heavy']:
					severity = 'Serious'
					self.injury[location] = (status, severity, scarring)
					injury_change = True
				elif severity == 'Serious':
					if GetPercentileRoll() <= 50.0:
						severity = 'Critical'
						self.injury[location] = (status, severity, scarring)
						injury_change = True
			
			# critical injury
			elif new_severity == 'Critical':
				if severity != 'Critical':
					severity = 'Critical'
					self.injury[location] = (status, severity, scarring)
					injury_change = True
		
		if injury_change:
			self.DoFatigueCheck()
			if self.is_player_commander:
				text = 'You were hit in the ' + location + ' and suffer a ' + new_severity + ' injury.'
			else:
				text = 'Your crewman was hit in the ' + location + ' and suffers a ' + new_severity + ' injury:'
		else:
			if self.is_player_commander:
				text = 'You were hit in the ' + location + ' but suffer no further injury.'
			else:
				text = 'Your crewman was hit in the ' + location + ' but suffers no further injury:'
		if show_messages:
			if self.is_player_commander:
				ShowMessage(text, longer_pause=True)
			else:
				ShowMessage(text, crewman=self, longer_pause=True)
				
		campaign.AddJournal(text)
		
		if not injury_change:
			return severity + ' injury'
		
		# check for condition change (to Shaken, Stunned, or Unconscious) as a result of injury
		condition_change = None
		if location == 'Head & Neck':
			if not self.DoGritCheck(60.0):
				condition_change = 'Stunned'
			elif not self.DoGritCheck(40.0):
				condition_change = 'Unconscious'
			else:
				condition_change = 'Shaken'
		
		elif location == 'Torso & Groin':
			if not self.DoGritCheck(35.0):
				condition_change = 'Stunned'
			elif not self.DoGritCheck(20.0):
				condition_change = 'Unconscious'
			elif not self.DoGritCheck(0.0):
				condition_change = 'Shaken'
		
		else:
			if not self.DoGritCheck(25.0):
				condition_change = 'Stunned'
			elif not self.DoGritCheck(5.0):
				condition_change = 'Unconscious'
			elif not self.DoGritCheck(-10.0):
				condition_change = 'Shaken'
		
		if condition_change is None:
			return new_severity + ' injury'
		
		if condition_change == 'Shaken' and self.condition != 'Good Order': return new_severity + ' injury'
		if condition_change == 'Stunned' and self.condition in ['Stunned', 'Unconscious']: return new_severity + ' injury'
		if condition_change == 'Unconscious' and self.condition == 'Unconscious': return new_severity + ' injury'
		
		self.condition = condition_change
		
		if self.is_player_commander:
			text = 'As a result of your injury, you are now ' + condition_change + '.'
		else:
			# bit of a kludge, but prevents a crash during the bailout procedure
			if self.current_position.name is None:
				text = 'As a result of injury, your crewman is now ' + condition_change + '.'
			else:
				text = 'As a result of injury, your ' + self.current_position.name + ' is now ' + condition_change + '.'
		if show_messages:
			ShowMessage(text, longer_pause=True, good_news=False)
		campaign.AddJournal(text)
		return severity + ' injury, ' + condition_change
	
	
	# do a grit test for this crewman
	def DoGritCheck(self, modifier):
		if GetPercentileRoll() + modifier <= self.stats['Grit'] * 10.0: return True
		return False
		
	
	# do a morale check for this crewman
	def DoMoraleCheck(self, modifier):
		if self.unit.is_player:
			if 'Inspiring Leader' not in self.skills and campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Inspiring Leader'):
				modifier -= 30.0
			elif 'Natural Leader' not in self.skills and campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Natural Leader'):
				modifier -= 15.0
		if GetPercentileRoll() + modifier <= self.stats['Morale'] * 9.0: return True
		return False
	
	
	# do a perception check for this crewman
	def DoPerceptionCheck(self, modifier):
		if self.condition in ['Stunned', 'Unconscious']: return False
		if GetPercentileRoll() + modifier <= self.stats['Perception'] * 9.0: return True
		return False
	
	
	# do a stun check for this crewman
	def DoStunCheck(self, modifier):
		if self.condition not in ['Good Order', 'Shaken']: return True
		if GetPercentileRoll() + modifier <= self.stats['Grit'] * 9.0: return True
		return False
	
	
	# check for change in condition or injury status, called at start of turn
	def DoInjuryCheck(self, condition_only=False):
		
		# no need to check
		if not self.alive: return
		
		# check for critical injuries either stabilizing or causing death
		for (k, v) in self.injury.items():
			
			(status, severity, scarring) = v
			
			if status is None or severity is None: continue
			if severity != 'Critical': continue
			
			roll = GetPercentileRoll()
			
			# injury worsens and causes death
			if roll >= 97.0 and 'tutorial_campaign' not in campaign.stats:
				
				if self.is_player_commander:
					text = 'You succumb to your ' + k + ' injury and die. Your campaign is over.'
					ShowMessage(text, force_tab=True, good_news=False)
					campaign.AddJournal(text)
				else:
					text = 'Your crewman succumbed to their ' + k + ' injury and has died:'
					ShowMessage(text, crewman=self, good_news=False)
					campaign.AddJournal(text)
				self.KIA()
				return
			
			# injury may improve
			# check for fellow crewmen on First Aid command
			for position in self.unit.positions_list:
				if position.crewman is None: continue
				if position.crewman == self: continue
				if position.crewman.current_cmd == 'First Aid':
					roll -= 15.0
			
			if self.condition == 'Unconscious': roll += 15.0
			
			if roll <= self.stats['Grit'] * 9.0:
				
				severity = 'Serious'
				self.injury[k] = (status, severity, scarring)
				
				if self.current_position.name in COMMANDER_POSITIONS:
					text = 'Your ' + k + ' injury has stabilized and is now Serious.'
					ShowMessage(text, longer_pause=True, good_news=True)
					campaign.AddJournal(text)
				else:
					text = "Your crewman's " + k + ' injury has stabilized and is now Serious:'
					ShowMessage(text, crewman=self, good_news=True)
					campaign.AddJournal(text)
			
		# check for recovery from negative conditions
		if self.condition == 'Good Order': return
		
		if self.condition == 'Shaken':
			if self.DoMoraleCheck(25.0):
				self.condition = 'Good Order'
				if self.current_position.name in COMMANDER_POSITIONS:
					text = 'You recover from being Shaken.'
					ShowMessage(text, good_news=True)
				else:
					text = 'Your crewman recovers from being Shaken:'
					ShowMessage(text, crewman=self, good_news=True)
			return
		
		if self.condition == 'Stunned':
			if self.DoMoraleCheck(40.0):
				self.condition = 'Good Order'
				if self.current_position.name in COMMANDER_POSITIONS:
					text = 'You recover from being Stunned.'
					ShowMessage(text, good_news=True)
				else:
					text = 'Your crewman recovers from being Stunned:'
					ShowMessage(text, crewman=self, good_news=True)
			return
		
		if self.condition == 'Unconscious':
			if self.DoGritCheck(60.0):
				self.condition = 'Stunned'
				if self.current_position.name in COMMANDER_POSITIONS:
					text = 'You regain consciousness and are now Stunned.'
					ShowMessage(text, good_news=True)
				else:
					text = 'Your crewman regains consciousness and is now Stunned:'
					ShowMessage(text, crewman=self, good_news=True)
			return
		
	
	# crewman dies
	def KIA(self):
		self.alive = False
		self.condition = 'Dead'
		self.fatigue = 0
		
		# check for memorial addition
		if self.unit.is_player:
			session.AddMemorial(self)
		
		# check for player commander death
		if self.is_player_commander:
			
			# check for Steam achievements
			i = campaign.combat_calendar.index(campaign.today)
			if i == 0:
				session.ModifySteamStat('die_first_day', 1)
			if i == len(campaign.combat_calendar) - 1:
				session.ModifySteamStat('die_last_day', 1)
			
			if scenario is not None:
				scenario.finished = True
			campaign_day.ended = True
			campaign.ended = True
			campaign.player_oob = True
			return
		
		if self.unit is None: return
		
		if self.unit.is_player:
			
			# add to morgue list, so we can show KIA reports at end of day
			campaign_day.morgue.append(self)
			
			if campaign_day.ended: return
			
			# rest of player crew may be shaken
			for position in self.unit.positions_list:
				if position.crewman is None: continue
				if not position.crewman.alive: continue
				if position.crewman.condition != 'Good Order': continue
				if position.crewman.DoMoraleCheck(-50): continue
				position.crewman.condition = 'Shaken'
				# don't show message if during bail-out
				if self.unit.alive:
					ShowMessage('Your crewman is Shaken by the loss of a crewmate:',
						crewman=position.crewman, good_news=False)
	
	
	# award a number of exp to this crewman
	def AwardExp(self, exp):
		self.exp += int(float(exp) * EXP_MULTIPLIER)


	# check to see whether crewman is promoted, called for player crew once per week
	def PromotionCheck(self):
		
		if self.rank == 6: return
		
		for (k, v) in LEVEL_RANK_LIST.items():
			if int(k) > self.level: return
			if v <= self.rank: continue
					
			# rank not included in nation definitions
			if str(v) not in session.nations[self.nation]['rank_names']: continue
			
			# Special: Mladshiy Serzhant was only introduced in 1940
			rank_name = session.nations[self.nation]['rank_names'][str(v)]
			if rank_name == 'Mladshiy Serzhant' and campaign.today < '1940.01.01':
				continue
			
			# if there is a player commander and this is a crewman, don't allow them to be promoted over the commander
			if campaign.options['permadeath'] and not self.is_player_commander:
				
				skip_rank = False
				
				for position in campaign.player_unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.is_player_commander: continue
					
					# if this promotion occured, crewman would outrank player commander
					if position.crewman.rank <= v:
						skip_rank = True
						break
				
				if skip_rank: continue
			
			chance = PROMOTION_CHANCE
			
			# increase chance based on how many levels this crewman is beyond the minimum required
			if int(k) < self.level:
				chance += 15.0 * float(self.level - int(k))
			
			# player commanders have a higher chance
			if self.is_player_commander:
				chance = chance * 2.0
			
			if GetPercentileRoll() <= chance:
				self.rank = v
				self.adv += 2
				ShowMessage('Your crewman has been promoted to ' + rank_name +
					', and receives 2 advance points.', crewman=self,
					good_news=True)
			
			# don't check again this week
			return
	
	
	# display a menu for this crewman, used for members of player's unit
	def ShowCrewmanMenu(self):
		
		# update the crewman menu console
		def UpdateCrewmanMenuCon():
			libtcod.console_clear(crewman_menu_con)
			
			# frame and section dividers
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.grey)
			libtcod.console_hline(crewman_menu_con, 8, 48, 74)
			DrawFrame(crewman_menu_con, 8, 0, 74, 60)
			DrawFrame(crewman_menu_con, 29, 4, 32, 45)
			libtcod.console_hline(crewman_menu_con, 30, 4, 30)
			libtcod.console_hline(crewman_menu_con, 30, 6, 30)
			libtcod.console_hline(crewman_menu_con, 30, 8, 30)
			libtcod.console_hline(crewman_menu_con, 30, 10, 30)
			libtcod.console_hline(crewman_menu_con, 30, 12, 30)
			libtcod.console_hline(crewman_menu_con, 30, 15, 30)
			libtcod.console_hline(crewman_menu_con, 30, 20, 30)
			libtcod.console_hline(crewman_menu_con, 30, 23, 30)
			
			# main title
			libtcod.console_set_default_background(crewman_menu_con, libtcod.darker_blue)
			libtcod.console_rect(crewman_menu_con, 9, 1, 72, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(crewman_menu_con, libtcod.black)
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.lightest_blue)
			libtcod.console_print(crewman_menu_con, 38, 2, 'Crewman Report')
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.yellow)
			for y in range(1, 4):
				for x in [31, 32]:
					libtcod.console_put_char(crewman_menu_con, x, y, 174)
					libtcod.console_put_char(crewman_menu_con, x+26, y, 175)
			
			# decorations if any
			if 'decorations' in session.nations[self.unit.nation]:
				y = 5
				libtcod.console_set_default_foreground(crewman_menu_con, libtcod.gold)
				for (k, v) in session.nations[self.unit.nation]['decorations'].items():
					if v in self.decorations:
						text = v
						if self.decorations[v] > 1:
							text += ' x ' + str(self.decorations[v])
						lines = wrap(text, 18)
						for line in lines:
							libtcod.console_print(crewman_menu_con, 9, y, line)
							y += 1
						y += 1
			
			# section titles
			libtcod.console_set_default_foreground(crewman_menu_con, TITLE_COL)
			libtcod.console_print(crewman_menu_con, 30, 5, 'Name')
			libtcod.console_print(crewman_menu_con, 30, 7, 'Nickname')
			libtcod.console_print(crewman_menu_con, 30, 9, 'Age')
			libtcod.console_print(crewman_menu_con, 30, 11, 'Rank')
			libtcod.console_print(crewman_menu_con, 30, 13, 'Unit')
			libtcod.console_print(crewman_menu_con, 30, 14, 'Position')
			libtcod.console_print(crewman_menu_con, 30, 16, 'Stats')
			libtcod.console_print(crewman_menu_con, 30, 21, 'Status')
			libtcod.console_print(crewman_menu_con, 30, 22, 'Fatigue')
			libtcod.console_print(crewman_menu_con, 30, 24, 'Skills')
			
			# name
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
			if self.is_player_commander:
				libtcod.console_set_default_foreground(crewman_menu_con, PC_COL)
			PrintExtended(crewman_menu_con, 39, 5, self.GetCrewmanName())
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
			
			# nickname if any
			if self.nickname == '':
				text = '[None]'
			else:
				text = self.nickname
			PrintExtended(crewman_menu_con, 39, 7, text)
			
			# age, birthday and rank
			libtcod.console_print(crewman_menu_con, 39, 9, str(self.age))
			libtcod.console_print_ex(crewman_menu_con, 59, 9, libtcod.BKGND_NONE,
				libtcod.RIGHT, '(' + self.birthday + ')')
			libtcod.console_print(crewman_menu_con, 39, 11, session.nations[self.nation]['rank_names'][str(self.rank)])
			
			# current unit and position if any
			if self.field_hospital is not None:
				libtcod.console_print(crewman_menu_con, 39, 13, 'Field Hospital')
			else:
				if not self.unit.alive:
					libtcod.console_print(crewman_menu_con, 39, 13, 'None')
				else:
					libtcod.console_print(crewman_menu_con, 39, 13, self.unit.unit_id)
					if self.current_position.name is not None:
						if self.UntrainedPosition():
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_red)
						libtcod.console_print(crewman_menu_con, 39, 14, self.current_position.name)
						libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
			
			# stats
			libtcod.console_put_char_ex(crewman_menu_con, 39, 16, chr(4), libtcod.yellow, libtcod.black)
			libtcod.console_put_char_ex(crewman_menu_con, 39, 17, chr(3), libtcod.red, libtcod.black)
			libtcod.console_put_char_ex(crewman_menu_con, 39, 18, chr(5), libtcod.blue, libtcod.black)
			libtcod.console_put_char_ex(crewman_menu_con, 39, 19, chr(6), libtcod.green, libtcod.black)
			
			y = 16
			for t in CREW_STATS:
				libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
				libtcod.console_print(crewman_menu_con, 41, y, t)
				libtcod.console_set_default_foreground(crewman_menu_con, libtcod.lighter_grey)
				libtcod.console_print_ex(crewman_menu_con, 53, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(self.stats[t]))
				y += 1
			
			libtcod.console_set_default_background(crewman_menu_con, libtcod.darkest_grey)
			libtcod.console_rect(crewman_menu_con, 39, 17, 15, 1, False, libtcod.BKGND_SET)
			libtcod.console_rect(crewman_menu_con, 39, 19, 15, 1, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(crewman_menu_con, libtcod.black)
			
			# current condition and fatigue level
			libtcod.console_print(crewman_menu_con, 39, 21, self.condition)
			if self.fatigue > 0:
				libtcod.console_set_default_foreground(crewman_menu_con, libtcod.red)
				libtcod.console_print(crewman_menu_con, 39, 22, '-' + str(self.fatigue) + '%')
			else:
				libtcod.console_print(crewman_menu_con, 39, 22, '-')
			
			# list of crew skills
			y = 24
			number_of_skills = len(self.skills)
			i = 0
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
			for skill in self.skills:
				
				# scroll (skip some skills) if required
				if i < skill_top:
					i += 1
					continue
				
				libtcod.console_print(crewman_menu_con, 37, y, skill)
				y += 1
				i += 1
				
				# stop displaying list
				if y == 42:
					break
			
			# indicate if there are more skills below
			if i < number_of_skills:
				libtcod.console_put_char(crewman_menu_con, 40, y, 25)
				libtcod.console_put_char(crewman_menu_con, 45, y, 25)
				libtcod.console_put_char(crewman_menu_con, 50, y, 25)
			elif self.alive and self.field_hospital is None and i == number_of_skills:
				libtcod.console_print(crewman_menu_con, 37, y, '[Add New Skill]')
			
			# highlight selected skill
			if self.alive and self.field_hospital is None:
				libtcod.console_set_default_background(crewman_menu_con, HIGHLIGHT_MENU_COL)
				libtcod.console_rect(crewman_menu_con, 37, 24 + selected_skill - skill_top, 23, 1, False, libtcod.BKGND_SET)
				libtcod.console_set_default_background(crewman_menu_con, libtcod.black)
			
			# display info about selected skill or info about adding a new skill
			y = 24
			if not self.alive or self.field_hospital is not None:
				text = ''
			elif selected_skill == number_of_skills:
				text = 'Select this option to spend an advance point and add a new skill'
			else:
				# grab skill description from skills dictionary
				text = session.skills[self.skills[selected_skill]]['desc']
				
				if 'campaign_skill' in session.skills[self.skills[selected_skill]]:
					text += ' (Campaign Skill)'
				
			for line in wrap(text, 18):
				libtcod.console_print(crewman_menu_con, 62, y, line)
				y+=1	
			
			# current level, exp, exp to next level, advance points
			libtcod.console_set_default_background(crewman_menu_con, libtcod.darkest_grey)
			libtcod.console_rect(crewman_menu_con, 35, 44, 21, 4, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(crewman_menu_con, libtcod.black)
			
			libtcod.console_set_default_foreground(crewman_menu_con, TITLE_COL)
			libtcod.console_print(crewman_menu_con, 35, 44, 'Level')
			libtcod.console_print(crewman_menu_con, 35, 45, 'Current XP')
			libtcod.console_print(crewman_menu_con, 35, 46, 'XP to Next Level')
			# highlight if 1+ advance points
			if self.adv > 0:
				libtcod.console_set_default_foreground(crewman_menu_con, libtcod.orange)
			libtcod.console_print(crewman_menu_con, 35, 47, 'Advance Points')
			
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
			libtcod.console_print_ex(crewman_menu_con, 55, 44, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(self.level))
			libtcod.console_print_ex(crewman_menu_con, 55, 45, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(self.exp))
			
			exp = GetExpRequiredFor(self.level + 1)
			if exp == -1:
				text = '-'
			else:
				text = str(exp - self.exp)
			libtcod.console_print_ex(crewman_menu_con, 55, 46, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			libtcod.console_print_ex(crewman_menu_con, 55, 47, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(self.adv))
			
			# injuries if any
			if self.alive:
				libtcod.console_set_default_background(crewman_menu_con, libtcod.darker_blue)
				libtcod.console_rect(crewman_menu_con, 9, 49, 72, 1, False, libtcod.BKGND_SET)
				libtcod.console_set_default_background(crewman_menu_con, libtcod.black)
				libtcod.console_set_default_foreground(crewman_menu_con, TITLE_COL)
				libtcod.console_print_ex(crewman_menu_con, WINDOW_XM, 49, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Injuries')
				
				x = 9
				y = 51
				for (k, v) in self.injury.items():
					libtcod.console_set_default_foreground(crewman_menu_con, libtcod.white)
					libtcod.console_print(crewman_menu_con, x, y, k)
					
					(status, severity, scarring) = v
					
					if status is None and severity is None:
						libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_grey)
						libtcod.console_print(crewman_menu_con, x, y+1, 'None')
					else:
						if status == 'Fresh':
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_red)
						elif status == 'Patched Up':
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.red)
						else:
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_grey)
						libtcod.console_print(crewman_menu_con, x, y+1, status)
						
						if severity == 'Light':
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.dark_red)
						elif severity == 'Heavy':
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.red)
						elif severity == 'Serious':
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_red)
						else:
							libtcod.console_set_default_foreground(crewman_menu_con, libtcod.lighter_red)
						libtcod.console_print(crewman_menu_con, x+12, y+1, severity)
					
					if scarring:
						libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_grey)
						libtcod.console_print(crewman_menu_con, x, y+2, 'Scars')
					
					if y == 51:
						y = 55
					else:
						y = 51
						x += 24
			
			# display inputs
			if gamepad is not None:
				if self.alive and self.field_hospital is None:
					DisplayButton(crewman_menu_con, 12, 38, GAMEPADCHAR_X)
					DisplayButton(crewman_menu_con, 12, 40, GAMEPADCHAR_DPAD_UD)
					if selected_skill == number_of_skills:
						DisplayButton(crewman_menu_con, 12, 41, GAMEPADCHAR_A)
					DisplayButton(crewman_menu_con, 12, 43, GAMEPADCHAR_LSB)
					DisplayButton(crewman_menu_con, 12, 44, GAMEPADCHAR_RSB)
					DisplayButton(crewman_menu_con, 12, 45, GAMEPADCHAR_Y)
				DisplayButton(crewman_menu_con, 12, 47, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(crewman_menu_con, ACTION_KEY_COL)
				if self.alive and self.field_hospital is None:
					libtcod.console_print(crewman_menu_con, 10, 38, EnKey('q').upper())
					libtcod.console_print(crewman_menu_con, 10, 40, EnKey('w').upper() + '/' + EnKey('s').upper())
					if selected_skill == number_of_skills:
						libtcod.console_print(crewman_menu_con, 10, 41, EnKey('e').upper())
					libtcod.console_print(crewman_menu_con, 10, 43, EnKey('f').upper())
					libtcod.console_print(crewman_menu_con, 10, 44, EnKey('l').upper())
					libtcod.console_print(crewman_menu_con, 10, 45, EnKey('n').upper())
				libtcod.console_print(crewman_menu_con, 10, 47, 'Esc')
			
			libtcod.console_set_default_foreground(crewman_menu_con, libtcod.light_grey)
			if self.alive and self.field_hospital is None:
				libtcod.console_print(crewman_menu_con, 14, 38, 'Increase Stat')
				libtcod.console_print(crewman_menu_con, 14, 40, 'Select Skill')
				if selected_skill == number_of_skills:
					libtcod.console_print(crewman_menu_con, 14, 41, 'Add New Skill')
				libtcod.console_print(crewman_menu_con, 14, 43, 'First Name')
				libtcod.console_print(crewman_menu_con, 14, 44, 'Last Name')
				libtcod.console_print(crewman_menu_con, 14, 45, 'Nickname')
			libtcod.console_print(crewman_menu_con, 14, 47, 'Exit Menu')
			
			libtcod.console_blit(crewman_menu_con, 0, 0, 0, 0, con, 0, 0)
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			
			return number_of_skills
			
		
		global crewman_menu_con
		crewman_menu_con = NewConsole(WINDOW_WIDTH, WINDOW_HEIGHT, libtcod.black, libtcod.white)
		
		selected_skill = 0				# which crew skill is currently selected
		number_of_skills = 0				# how many skills this crewman has
		skill_top = 0					# for scrolling list of skills
		
		# draw screen for first time (also counts current number of crewman skills)
		number_of_skills = UpdateCrewmanMenuCon()
		
		ShowTutorialSlide('crewman_menu')
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			key_char = DeKey(chr(key.c).lower())
			
			# exit menu
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				exit_menu = True
				continue
			
			# limited options if crewman is dead or in hospital
			if not self.alive or self.field_hospital is not None: continue
			
			# increase stat
			if key_char == 'q' or session.gamepad_input == 2:
				
				pt_cost = 1
				if DEBUG:
					if session.debug['Free Crew Advances']:
						pt_cost = 0
				
				if self.adv - pt_cost < 0:
					ShowNotification('Crewman has no Advance Points remaining.')
					continue
				
				self.IncreaseStatMenu(pt_cost)
				UpdateCrewmanMenuCon()
				SaveGame()
				continue
						
			# change selected skill
			elif key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					if selected_skill == 0:
						selected_skill = len(self.skills)
						skill_top = len(self.skills) - 19
						if skill_top < 0:
							skill_top = 0
					else:
						selected_skill -= 1
				else:
					if selected_skill == len(self.skills):
						selected_skill = 0
						skill_top = 0
					else:
						selected_skill += 1
				
				# see if scrolling is required
				if selected_skill < skill_top:
					skill_top = selected_skill
				elif selected_skill >= 18 + skill_top:
					skill_top += 1
				
				PlaySoundFor(None, 'menu_select')
				UpdateCrewmanMenuCon()
				continue
			
			# display add skill menu
			elif (key_char == 'e' or session.gamepad_input == 0) and selected_skill == number_of_skills:
				result = ShowSkillMenu(self)
				if result != '':
					# spend an advance point and add the skill
					if DEBUG:
						if session.debug['Free Crew Advances']:
							self.adv += 1
					self.adv -= 1
					self.skills.append(result)
					PlaySoundFor(None, 'add_skill')
					
					# advanced skills can replace earlier ones
					if 'replaces' in session.skills[result]:
						old_skill = session.skills[result]['replaces']
						if old_skill in self.skills:
							self.skills.remove(old_skill)
					
					SaveGame()
					number_of_skills = UpdateCrewmanMenuCon()
				continue
			
			# set first, last, or nickname
			elif key_char in ['f', 'l', 'n'] or session.gamepad_input in [7, 8, 3]:
				
				# first name
				if key_char == 'f' or session.gamepad_input == 7:
					name_option = 0
					current_text = self.first_name
					prompt = 'Enter a new first name for this crewman'
					max_length = MAX_CREW_NAME_LENGTH - len(self.last_name) - 1
					random_list = session.nations[self.nation]['first_names']
				elif key_char == 'l' or session.gamepad_input == 8:
					name_option = 1
					current_text = self.last_name
					prompt = 'Enter a new last name for this crewman'
					max_length = MAX_CREW_NAME_LENGTH - len(self.first_name) - 1
					random_list = session.nations[self.nation]['surnames']
				else:
					name_option = 2
					current_text = self.nickname
					prompt = 'Enter a new nickname for this crewman'
					max_length = MAX_NICKNAME_LENGTH
					random_list = []
				
				new_text = ShowTextInputMenu(prompt, current_text, max_length, random_list)
				
				# nickname can be cleared, so set anything returned by the input menu
				if name_option == 2:
					self.nickname = new_text
				# otherwise some string has to be entered
				elif new_text != '':
					if name_option == 0:
						self.first_name = new_text
					elif name_option == 1:
						self.last_name = new_text
				UpdateCrewmanMenuCon()
				continue
	
	
	# show increase stat sub-menu
	def IncreaseStatMenu(self, pt_cost):
		
		def UpdateIncreaseStatMenu(selected_stat):
			
			libtcod.console_clear(menu_con)
			libtcod.console_set_default_foreground(menu_con, libtcod.grey)
			DrawFrame(menu_con, 0, 0, 50, 30)
			
			libtcod.console_set_default_foreground(menu_con, TITLE_COL)
			libtcod.console_print(menu_con, 20, 2, 'Increase Stat')
			
			# display list of stats
			libtcod.console_put_char_ex(menu_con, 6, 6, '1', ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 6, 8, '2', ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 6, 10, '3', ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 6, 12, '4', ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 8, 6, chr(4), libtcod.yellow, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 8, 8, chr(3), libtcod.red, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 8, 10, chr(5), libtcod.blue, libtcod.black)
			libtcod.console_put_char_ex(menu_con, 8, 12, chr(6), libtcod.green, libtcod.black)
			y = 6
			libtcod.console_set_default_foreground(menu_con, libtcod.white)
			for i in range(4):
				if i == selected_stat:
					libtcod.console_set_default_background(menu_con, HIGHLIGHT_MENU_COL)
					libtcod.console_rect(menu_con, 10, y, 10, 1, False, libtcod.BKGND_SET)
					libtcod.console_set_default_background(menu_con, libtcod.black)
				libtcod.console_print(menu_con, 10, y, CREW_STATS[i])
				y += 2
			
			# display info on currently selected stat
			y = 8
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			for line in wrap(CREW_STAT_DESC[selected_stat], 16):
				libtcod.console_print(menu_con, 30, y, line)
				y += 1
			
			# display inputs
			if gamepad is not None:
				DisplayButton(menu_con, 23, 26, GAMEPADCHAR_DPAD_UD)
				DisplayButton(menu_con, 23, 27, GAMEPADCHAR_A)
				DisplayButton(menu_con, 23, 28, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(menu_con, ACTION_KEY_COL)
				libtcod.console_print(menu_con, 20, 26, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(menu_con, 20, 27, EnKey('e').upper())
				libtcod.console_print(menu_con, 20, 28, 'Esc')
			
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			libtcod.console_print(menu_con, 25, 26, 'Select Stat')
			libtcod.console_print(menu_con, 25, 27, 'Increase Stat')
			libtcod.console_print(menu_con, 25, 28, 'Cancel')
			
			libtcod.console_blit(menu_con, 0, 0, 0, 0, con, 20, 15)
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)

		
		# create a local copy of the current screen to re-draw when we're done
		temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
		libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
		
		# darken background 
		libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
		
		# create display console
		menu_con = NewConsole(50, 30, libtcod.black, libtcod.white)
		
		selected_stat = 0
		UpdateIncreaseStatMenu(selected_stat)
		
		exit_menu = False
		while not exit_menu:
			
			libtcod.console_flush()
			if not GetInputEvent(): continue
			key_char = DeKey(chr(key.c).lower())
			
			# cancel
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				exit_menu = True
				PlaySoundFor(None, 'menu_select')
				continue
			
			# change selected stat
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					i = -1
				else:
					i = 1
				selected_stat += i
				if selected_stat < 0:
					selected_stat = 3
				elif selected_stat > 3:
					selected_stat = 0
				
				UpdateIncreaseStatMenu(selected_stat)
				PlaySoundFor(None, 'menu_select')
				continue
		
			# increase selected stat if possible 
			elif key_char == 'e' or session.gamepad_input == 0 or key_char in ['1', '2', '3', '4']:
				
				if key_char in ['1', '2', '3', '4']:
					selected_stat = int(key_char) - 1
					UpdateIncreaseStatMenu(selected_stat)
			
				stat_name = CREW_STATS[selected_stat]
				if self.stats[stat_name] == 10:
					ShowNotification('Stat already at maximum level.')
					continue
		
				# determine increase amount
				if self.stats[stat_name] < 5:
					increase = 2
				else:
					increase = 1
				
				if ShowNotification('Spend an advance point and increase ' + stat_name + ' by ' + str(increase) + '?', confirm=True):
					self.adv -= pt_cost
					self.stats[stat_name] += increase
					PlaySoundFor(None, 'add_skill')
					exit_menu = True
					continue
		
		# re-draw original screen
		libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)

	
	# generate a random first and last name for this person
	def GenerateName(self):
		name_okay = False
		while not name_okay:
			first_name = choice(session.nations[self.nation]['first_names'])
			last_name = choice(session.nations[self.nation]['surnames'])
			if first_name == last_name:
				continue
			if len(first_name + ' ' + last_name) > MAX_CREW_NAME_LENGTH: continue
			name_okay = True
		self.first_name = first_name
		self.last_name = last_name
	
	
	# return a given skill modifier according to the crewman's current status
	def GetSkillMod(self, skillname, modifier):
		
		# basic checks
		if not self.alive or self.condition == 'Unconscious': return None
		if skillname not in self.skills: return None
		
		base_modifier = modifier
		
		# check for skill use restrictions
		if skillname == 'Eagle Eyed' and not self.ce: return None
		
		# knowledge modifier
		modifier += modifier * (0.05 * self.stats['Knowledge'])
		
		# BU penalty modifier
		if not self.ce:
			if 'bu_penalty' in session.skills[skillname]:
				modifier = modifier * 0.5
		
		# stunned/fatigue modifier
		if self.condition == 'Stunned':
			modifier = modifier * 0.5
		
		elif self.fatigue > 0:
			modifier -= modifier * (0.05 * self.fatigue)
		
		# round, limit, and return
		modifier = round(modifier, 1)
		if modifier <= 0.0: return None
		return modifier
	
	
	# return an action modifier adjusted according to the crewman's current status
	def GetActionMod(self, modifier):
		if self.condition == 'Stunned':
			modifier = modifier * 0.5
		elif self.fatigue > 0:
			modifier -= modifier * (0.05 * self.fatigue)
		return round(modifier, 1)
	
	
	# check to see whether this crewman gains a fatigue point
	def DoFatigueCheck(self):
		if not self.alive or self.condition == 'Unconscious': return
		if self.fatigue == 10: return
		
		roll = GetPercentileRoll()
		if campaign_day.weather['Temperature'] in ['Cold', 'Hot']:
			if 'Acclimatized' not in self.skills:
				roll += 10.0
		elif campaign_day.weather['Temperature'] == 'Extreme Cold':
			if 'Acclimatized (Nordic)' in self.skills:
				roll += 5.0
			else:
				roll += 15.0
		elif campaign_day.weather['Temperature'] == 'Extreme Hot':
			if 'Acclimatized (Desert)' in self.skills or 'Acclimatized (Heat)' in self.skills:
				roll += 5.0
			else:
				roll += 15.0
		
		if self.current_position.location == 'Turret' and not self.ce and self.unit.GetStat('turret') == 'RST' and self.unit.GetStat('open_topped') is None:
			roll += 10.0
		
		if campaign_day.weather['Temperature'] == 'Extreme Cold':
			if self.ce:
				roll += 5.0
			else:
				roll -= 5.0
		elif campaign_day.weather['Temperature'] == 'Extreme Hot':
			if self.ce:
				roll -= 5.0
			else:
				roll += 5.0
		
		if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Excellent Coordination'):
			roll -= 20.0
		elif campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Coordination'):
			roll -= 10.0
		
		if 'Semper Fi' in self.skills:
			roll -= 10.0
		
		chance = float(self.stats['Morale']) * 9.5
		
		if roll <= chance:
			return
		
		self.fatigue += 1
		if self.fatigue > 10:
			self.fatigue = 10
	
	
	# crew recovers some fatigue from rest
	def Rest(self):
		if not self.alive: return
		if self.fatigue == BASE_FATIGUE: return
		max_loss = int(self.stats['Morale'] / 2)
		if max_loss == 0:
			max_loss = 1
		if campaign_day.map_hexes[campaign_day.player_unit_location].terrain_type == 'Oasis':
			max_loss = max_loss * 2
		i = libtcod.random_get_int(0, 0, max_loss)
		self.fatigue -= i
		if self.fatigue < BASE_FATIGUE:
			self.fatigue = BASE_FATIGUE
	
	
	# (re)build a list of possible commands for this turn
	def BuildCommandList(self):
		self.cmd_list = []
		
		# unconscious and dead crewmen cannot act
		if not self.alive or self.condition == 'Unconscious':
			self.cmd_list.append('None')
			return
		
		self.acted = False
		
		for (k, d) in session.crew_commands.items():
			
			# don't add "None" automatically
			if k == 'None': continue
			
			# weapon operation needs a weapon in the unit
			if k in ['Operate Gun', 'Operate MG', 'Operate AAMG', 'Operate Flame Thrower']:
				for weapon in self.unit.weapon_list:
					if k == 'Operate Gun' and weapon.GetStat('type') != 'Gun': continue
					
					if k == 'Operate MG':
						if weapon.GetStat('type') not in MG_WEAPONS: continue
						if weapon.GetStat('type') == 'AAMG': continue
					
					if k == 'Operate AAMG' and weapon.GetStat('type') != 'AAMG': continue
					
					if k == 'Operate Flame Thrower' and weapon.GetStat('type') != 'Flame Thrower': continue
					
					if weapon.GetStat('fired_by') is None: continue
					if self.current_position.name not in weapon.GetStat('fired_by'):
						continue
					
					# check that position is in same location as weapon mount if any
					if weapon.GetStat('mount') is not None:
						if weapon.GetStat('mount') != self.current_position.location: continue
					
					# add the command to fire this weapon
					self.cmd_list.append(k)
					break
					
				continue
			
			# repair radio needs a broken radio
			elif k == 'Repair Radio':
				if not self.unit.has_radio or self.unit.radio_destroyed: continue
				if not self.unit.radio_damaged: continue
				self.cmd_list.append(k)
				continue
			
			# manage ready rack needs at least one gun
			elif k == 'Manage Ready Rack':
				if self.current_position in scenario.rack_management_array:
					self.cmd_list.append(k)
				continue
			
			# command squad needs a squad
			elif k == 'Command Squad':
				if len(scenario.player_unit.squad) == 0:
					continue
			
			if 'position_list' in d:
				if self.current_position.name not in d['position_list']:
					continue
			
			if k in ['Abandon Tank', 'Abandon Vehicle']:
				can_abandon = False
				if self.unit.immobilized:
					can_abandon = True
				if self.unit.broken_down:
					can_abandon = True
				if self.unit.ko_hit:
					can_abandon = True
				for position in self.unit.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive:
						can_abandon = True
						break
				for weapon in self.unit.weapon_list:
					if weapon.broken:
						can_abandon = True
						break
				# always allow abandoning vehicle if debug flag is active
				if DEBUG:
					can_abandon = True
				if not can_abandon:
					continue
			
			# drive/drive into terrain commands can be used to unbog
			elif k in ['Drive', 'Drive Into Terrain']:
				if self.unit.immobilized or self.unit.broken_down: continue
			
			elif k == 'Withdraw':
				if self.unit.immobilized or self.unit.broken_down or self.unit.bogged: continue
			
			# check that a mortar is attached, and is fired by this position
			elif k == 'Fire Smoke Mortar':
				position_name = self.unit.GetStat('smoke_mortar')
				if position_name is None: continue
				if campaign_day.smoke_mortar_rounds == 0: continue
				
				if self.current_position.name != position_name: continue
				
				# Grants have two loaders, so they specify that the smoke mortar is in the turret
				location = self.unit.GetStat('smoke_mortar_location')
				if location is not None:
					if self.current_position.location != location: continue
			
			# smoke grenade
			elif k == 'Smoke Grenade':
				if campaign_day.smoke_grenades == 0: continue
			
			# some commands need a position that is always CE or has a hatch
			if k in ['Smoke Grenade', 'Fire Small Arms', 'Hunker Down']:
				if not self.current_position.open_top and not self.current_position.crew_always_ce and not self.current_position.hatch:
					continue
			
			# add the command
			self.cmd_list.append(k)
	
	
	# select a new command from command list
	def SelectCommand(self, reverse):
		
		# just in case - should not happen
		if self.current_cmd not in self.cmd_list:
			self.current_cmd = self.cmd_list[0]
			return
		
		c = 1
		if reverse:
			c = -1
		i = self.cmd_list.index(self.current_cmd)
		if i+c > len(self.cmd_list) - 1:
			i = 0
		elif i+c < 0:
			i = len(self.cmd_list) - 1
		else:
			i += c
		self.current_cmd = self.cmd_list[i]
	
	
	# attempt to toggle current hatch status
	def ToggleHatch(self):
		if not self.alive or self.condition == 'Unconscious': return False
		if not self.current_position.TogglePositionHatch(): return False
		self.SetCEStatus()
		return True
	
	
	# set crewman BU/CE status based on position status
	def SetCEStatus(self):
		if self.current_position is None:
			self.ce = True
			return
		if self.current_position.location == 'Vehicle Exterior':
			self.ce = True
		elif self.current_position.open_top or self.current_position.crew_always_ce:
			self.ce = True
		elif not self.current_position.hatch:
			self.ce = False
		elif self.current_position.hatch_open:
			self.ce = True
		else:
			self.ce = False

		
	

# Position class: represents a personnel position within a unit
class Position:
	def __init__(self, unit, position_dict):
		
		self.unit = unit
		self.name = position_dict['name']
		
		self.location = None
		if 'location' in position_dict:
			self.location = position_dict['location']
		
		self.hatch = False
		if 'hatch' in position_dict:
			self.hatch = True
		
		self.large_hatch = False
		if 'large_hatch' in position_dict:
			self.large_hatch = True
		
		self.hatch_group = None
		if 'hatch_group' in position_dict:
			self.hatch_group = int(position_dict['hatch_group'])
		
		self.open_top = False
		if 'open_top' in position_dict:
			self.open_top = True
		
		self.crew_always_ce = False
		if 'crew_always_exposed' in position_dict:
			self.crew_always_ce = True
		
		self.ce_visible = []
		if 'ce_visible' in position_dict:
			for direction in position_dict['ce_visible']:
				self.ce_visible.append(int(direction))
		
		self.bu_visible = []
		if 'bu_visible' in position_dict:
			for direction in position_dict['bu_visible']:
				self.bu_visible.append(int(direction))
		
		# person currently in this position
		self.crewman = None
		
		# current hatch open/closed status
		self.hatch_open = False
		
		# list of map hexes visible to this position
		self.visible_hexes = []
	
	
	# update the list of hexes currently visible from this position
	def UpdateVisibleHexes(self):
		
		self.visible_hexes = []
		
		if self.crewman is None: return
		
		# can always spot in own hex
		self.visible_hexes.append((self.unit.hx, self.unit.hy))
		
		# current crew command does not allow spotting
		if not session.crew_commands[self.crewman.current_cmd]['spotting_allowed']:
			return
		
		if self.crew_always_ce or self.open_top:
			direction_list = self.ce_visible
		elif self.hatch_open:
			direction_list = self.ce_visible
		else:
			direction_list = self.bu_visible
		
		# rotate based on hull or turret facing
		rotate = 0
		if self.location == 'Hull':
			if self.unit.facing is not None:
				rotate = self.unit.facing
		elif self.location == 'Turret':
			if self.unit.turret_facing is not None:
				rotate = self.unit.turret_facing
		
		for direction in direction_list:
			hextant_hex_list = GetCoveredHexes(self.unit.hx, self.unit.hy, ConstrainDir(direction + rotate))
			for (hx, hy) in hextant_hex_list:
				# hex is off map
				if (hx, hy) not in scenario.hex_dict: continue
				# already in list
				if (hx, hy) in self.visible_hexes: continue
				# too far away for BU crew
				if not self.hatch_open and not (self.crew_always_ce or self.open_top):
					if GetHexDistance(self.unit.hx, self.unit.hy, hx, hy) > MAX_BU_LOS:
						continue
				self.visible_hexes.append((hx, hy))


	# toggle the open/closed status of a hatch in this position
	def TogglePositionHatch(self):
		if not self.hatch: return False
		if self.open_top: return False
		if self.crew_always_ce: return False
		
		self.hatch_open = not self.hatch_open
		if scenario is not None:
			self.UpdateVisibleHexes()
		
		# toggle other linked hatches too
		if self.hatch_group is not None:
			for position in self.unit.positions_list:
				if position == self: continue
				if position.hatch_group is None: continue
				if position.hatch_group != self.hatch_group: continue
				position.hatch_open = self.hatch_open
				if position.crewman is not None:
					position.crewman.SetCEStatus()
				if scenario is not None:
					position.UpdateVisibleHexes()
		
		return True


# Weapon Class: represents a weapon mounted on or carried by a unit
class Weapon:
	def __init__(self, unit, stats):
		self.unit = unit			# unit that owns this weapon
		self.stats = stats.copy()		# dictionary of weapon stats
		
		# some weapons need a descriptive name generated
		if 'name' not in self.stats:
			if self.GetStat('type') == 'Gun':
				text = self.GetStat('calibre')
				if self.GetStat('long_range') is not None:
					text += self.GetStat('long_range')
				if 'autocannon' in self.stats:
					text += 'a'
				self.stats['name'] = text
				
			elif self.GetStat('type') == 'Cannon':
				text = self.GetStat('calibre')
				self.stats['name'] = text + 'mm Cannon'
			
			# high-calibre MG
			elif self.GetStat('type') in MG_WEAPONS and self.GetStat('calibre') is not None:
				self.stats['name'] = self.GetStat('type') + '+'
			
			else:
				self.stats['name'] = self.GetStat('type')
		
		# save maximum range as an local int
		self.max_range = 3
		if 'max_range' in self.stats:
			self.max_range = int(self.stats['max_range'])
			del self.stats['max_range']
		else:
			if self.stats['type'] in ['TMG', 'CMG', 'RMG', 'AAMG']:
				self.max_range = 2
			elif self.stats['type'] == 'BMG':
				self.max_range = 1
		
		self.ammo_type = None
		
		# if weapon is a gun, set up ammo stores and ready rack
		self.ammo_stores = None
		self.rr_size = 0
		self.using_rr = False
		
		self.rof_shots = 0			# number of RoF attacks so far this turn
				
		if self.GetStat('type') == 'Gun' and 'ammo_type_list' in self.stats:
			self.ammo_stores = {}
			self.ready_rack = {}
			self.rare_ammo = {}
			self.rare_ammo_na = []
			
			# player-defined default loads
			self.default_ammo_stores = {}	
			self.default_ready_rack = {}
			
			self.max_ammo = int(self.stats['max_ammo'])
			self.max_plus_extra_ammo = self.max_ammo + int(floor(float(self.max_ammo) * 0.15))
			
			# set maximum ready rack capacity
			if 'rr_size' in self.stats:
				self.rr_size = int(self.stats['rr_size'])
			else:
				self.rr_size = 6
			
			# set up empty categories first, also ready rack contents
			for ammo_type in self.stats['ammo_type_list']:
				self.ammo_stores[ammo_type] = 0
				self.ready_rack[ammo_type] = 0
			
			# check for regional special ammo definitions
			if 'special_ammo_regional' in self.stats and campaign is not None:
				if campaign.stats['region'] in self.stats['special_ammo_regional']:
					
					# run through each, and add or replace the normal one
					for ammo_type in self.stats['special_ammo_regional'][campaign.stats['region']]:
						if ammo_type not in self.stats['ammo_type_list']: continue
						if 'special_ammo' not in self.stats:
							self.stats['special_ammo'] = {}
						self.stats['special_ammo'][ammo_type] = self.stats['special_ammo_regional'][campaign.stats['region']][ammo_type]
			
			# if AI unit, automatically generate currently available rare ammo and current ammo load
			# (player is handled through AmmoReloadMenu)
			if not self.unit.is_player:
				self.GenerateRareAmmo()
				self.AddDefaultAmmoLoad()
		
		# Make sure RMGs are actually rear-facing, even if not explicitly set in files - an RMG, definitionally, is rear-facing.
		# Similar to TMGs counting for 'hd_ok' but less hassle to set it here than to check everywhere facing is tested.
		elif self.GetStat('type') == 'RMG':
			self.stats['rear_facing'] = True

		elif self.GetStat('type') == 'Flame Thrower':
			self.flame_ammo_max = int(self.stats['flame_ammo'])
			self.flame_ammo = self.flame_ammo_max
			self.external_fuel = False
			if self.GetStat('external_fuel') is not None:
				self.external_fuel = True
		
		# weapon statuses
		self.covered_hexes = []			# map hexes that could be targeted by this weapon
		self.weapon_target_list = []	# list of player-selectable targets in the covered hexes
		self.fired = False
		self.maintained_rof = False
		self.jammed = False			# weapon is jammed and cannot be fired
		self.broken = False			# weapon has broken and cannot be used
		self.selected_target = None		# for player unit
		self.acquired_target = None		# acquired target status and target unit
	
	
	# check for the value of a stat, return None if stat not present
	def GetStat(self, stat_name):
		if stat_name not in self.stats:
			return None
		return self.stats[stat_name]
	
	
	# for the player unit, try to find the crewman who is currently operating this weapon
	def GetOperatingCrewman(self):
		if not self.unit.is_player: return None
		
		if self.GetStat('fired_by') is not None:
			if self.GetStat('type') == 'Gun':
				command_req = 'Operate Gun'
			elif self.GetStat('type') == 'AAMG':
				command_req = 'Operate AAMG'
			elif self.GetStat('type') in MG_WEAPONS:
				command_req = 'Operate MG'
			elif self.GetStat('type') == 'Flame Thrower':
				command_req = 'Operate Flame Thrower'
			
			position_list = self.GetStat('fired_by')
			
			for position in self.unit.positions_list:
				if position.name not in position_list: continue
				if position.crewman is None: continue
				if position.crewman.current_cmd != command_req: continue
				
				# check that position is in same location as weapon mount if any
				if self.GetStat('mount') is not None:
					if position.location != self.GetStat('mount'):
						continue
				
				# if AAMG, crewman must normally be CE to operate
				if self.GetStat('type') == 'AAMG':
					if not position.crewman.ce and self.GetStat('bu_ok') is None:
						continue
				
				# found operating crewman
				return position.crewman
				
		# unable to find
		return None
	
	# To ensure consistency between filling methods.
	# Due to the way rare ammo amounts are tracked and updated, rare ammo must be updated first to make sure it's an accurate loadout.
	# either by calling GenerateRareAmmo(), or by using the update_rare_ammo argument to set rare ammo to the rounds currently loaded.
	# Note that this function assumes standard ammo is available in infinite amounts; use CheckLoadoutTemplate() if needed. 
	def GenerateDefaultLoadout(self, update_rare_ammo=False):
		# try to add x number of shells to the template stores or RR, return the number that was added
		def AddAmmo(ammo_type, use_rr, add_amount):
			if ammo_type not in self.stats['ammo_type_list']:
				return 0
			# check that ammo is not limited
			if ammo_type in self.rare_ammo:
				max_add_amount = self.rare_ammo[ammo_type] - default_ammo[ammo_type] - default_rr[ammo_type]
				if add_amount > max_add_amount:
					add_amount = max_add_amount
				if add_amount <= 0:
					return 0
			
			nonlocal remaining_rr_capacity
			nonlocal remaining_ammo_capacity

			if use_rr:
				if add_amount > remaining_rr_capacity:
					add_amount = remaining_rr_capacity
					if add_amount <= 0:
						return 0
				default_rr[ammo_type] += add_amount
				remaining_rr_capacity -= add_amount
			else:
				if add_amount > remaining_ammo_capacity:
					add_amount = remaining_ammo_capacity
					if add_amount <= 0:
						return 0
				default_ammo[ammo_type] += add_amount
				remaining_ammo_capacity -= add_amount
			return add_amount

		if self.stats['type'] != 'Gun': return

		default_ammo = {}
		default_rr = {}
		remaining_ammo_capacity = self.max_ammo
		remaining_rr_capacity = self.rr_size

		# Set up empty categories.
		for ammo_type in self.stats['ammo_type_list']:
			default_ammo[ammo_type] = 0
			default_rr[ammo_type] = 0

		if update_rare_ammo and 'special_ammo' in self.stats:
			for ammo_type in self.stats['special_ammo']:
				self.rare_ammo[ammo_type] = self.ammo_stores[ammo_type] + self.ready_rack[ammo_type]

		# First, try to load a 25% proportion of anti-armour ammo. Prefer basic AP in the RR, special ammo in main storage.
		rr_ap_to_add = round(0.25 * self.rr_size)
		stores_ap_to_add = round(0.25 * self.max_ammo)
		rr_ap_to_add -= AddAmmo('AP', True, rr_ap_to_add) # Try to fill the RR's anti-armour proportion with basic AP if possible.
		for ammo_type in ['APCR', 'APDS', 'HEAT']:
			rr_ap_to_add -= AddAmmo(ammo_type, True, rr_ap_to_add)
			stores_ap_to_add -= AddAmmo(ammo_type, False, stores_ap_to_add)
		stores_ap_to_add -= AddAmmo('AP', False, stores_ap_to_add) # Try to fill the rest of the stores anti-armour proportion with basic AP.

		# Second, load some smoke if we have it. Extra if we don't have a full load of anti-armour ammo. Prefer basic smoke in RR, WP in main storage.
		if rr_ap_to_add + stores_ap_to_add:
			rr_smoke_to_add = round(0.2 * self.rr_size)
			stores_smoke_to_add = round(0.15 * self.max_ammo)
		else:
			rr_smoke_to_add = 0
			stores_smoke_to_add = round(0.1 * self.max_ammo)

		rr_smoke_to_add -= AddAmmo('Smoke', True, rr_smoke_to_add)
		for ammo_type in ['WP', 'Smoke']:
			rr_smoke_to_add -= AddAmmo(ammo_type, True, rr_smoke_to_add)
			stores_smoke_to_add -= AddAmmo(ammo_type, False, stores_smoke_to_add)

		# Third, load as much remaining special ammo to the main rack as possible.
		for ammo_type in self.rare_ammo:
			AddAmmo(ammo_type, False, self.max_ammo)

		# Finally, attempt to fill up the remainder. Preferably with HE, failing that AP or whatever we *do* have in stock.
		AddAmmo('HE', True, self.rr_size)
		AddAmmo('HE', False, self.max_ammo)
		AddAmmo('AP', True, self.rr_size)
		AddAmmo('AP', False, self.max_ammo)
		if remaining_ammo_capacity or remaining_rr_capacity:
			for ammo_type in self.stats['ammo_type_list']:
				AddAmmo(ammo_type, True, self.rr_size)
				AddAmmo(ammo_type, False, self.max_ammo)

		return (default_ammo, default_rr)

	# load this gun with a default ammo loadout and, if an enemy unit, use up a random percentage of ammo
	# not used on player - AmmoReloadMenu() does that. If using it on player, update rare ammo first to ensure an accurate loadout.
	def AddDefaultAmmoLoad(self):
		if self.stats['type'] != 'Gun': return

		(default_ammo, default_rr) = self.GenerateDefaultLoadout()

		for ammo_type in default_ammo:
			self.ammo_stores[ammo_type] = default_ammo[ammo_type]
		for ammo_type in default_rr:
			self.ready_rack[ammo_type] = default_rr[ammo_type]
		
		# select first ammo type as default
		for ammo_type in self.ammo_stores:
			self.ammo_type = ammo_type
			break

		# if enemy unit, use up a random percentage of ammo
		if self.unit.owning_player == 1:
			for ammo_type in self.ammo_stores:
				current_load = self.ammo_stores[ammo_type]
				if current_load == 0: continue
				roll = libtcod.random_get_int(0, 2, 5) + libtcod.random_get_int(0, 2, 5)
				self.ammo_stores[ammo_type] = ceil(current_load * (0.1 * float(roll)))
					
	
	# generate a rare ammo supply for this weapon
	def GenerateRareAmmo(self, resupply=False):
		self.rare_ammo = {}
		self.rare_ammo_na = []
		if 'special_ammo' not in self.stats: return
				
		for ammo_type in list(self.stats['special_ammo']):
			
			max_available = None
			for date, amount in self.stats['special_ammo'][ammo_type].items():
				
				if max_available is None:
					if date > campaign.today:
						break
					max_available = int(amount)
					continue
				
				# break if this date is later than current date
				if date > campaign.today: break
			
			# not yet available at this date
			if max_available is None:
				self.rare_ammo[ammo_type] = 0
				self.rare_ammo_na.append(ammo_type)
				continue
			
			# if resupplying and ammo type is scarce, very limited amounts only
			if resupply and ammo_type not in ['APCR', 'APDS']:
				self.rare_ammo[ammo_type] = 1
				roll = libtcod.random_get_int(0, 1, 6)
				if roll == 6:
					self.rare_ammo[ammo_type] += 2
				elif roll > 3:
					self.rare_ammo[ammo_type] += 1
				continue
			
			# roll for amount available today
			amount_available = 0
			roll = libtcod.random_get_int(0, 1, max_available)
			if roll > amount_available:
				amount_available = roll
			
			# check for player crew skill
			if self.unit.is_player:
				if self.unit.CrewmanHasSkill(['Loader'], 'Ammo Bargainer'):
					amount_available += int(ceil(amount_available / 2))
				elif self.unit.CrewmanHasSkill(['Loader'], 'Ammo Scrounger'):
					amount_available += int(ceil(amount_available / 3))
			
			# add entry
			self.rare_ammo[ammo_type] = amount_available
		
		# if player unit, check for saved rare ammo from current stores and add to current max
		if self.unit.is_player:
			for ammo_type in list(self.rare_ammo):
				if self.ammo_stores[ammo_type] > 0:
					self.rare_ammo[ammo_type] += self.ammo_stores[ammo_type]
				if self.ready_rack[ammo_type] > 0:
					self.rare_ammo[ammo_type] += self.ready_rack[ammo_type]
		
	
	# do a jam test for this weapon
	def JamTest(self):
		if self.jammed: return False
		if self.unit.is_player and 'tutorial_campaign' in campaign.stats: return False
		
		chance = WEAPON_JAM_CHANCE
		if campaign_day.weather['Precipitation'] == 'Sandstorm':
			chance = chance * 2.0
		elif campaign_day.weather['Temperature'] in ['Extreme Cold', 'Extreme Hot']:
			chance = chance * 1.5
		if self.GetStat('reloaded_by') is not None:
			for position in self.GetStat('reloaded_by'):
				crewman = self.unit.GetPersonnelByPosition(position)
				if crewman is None: continue
				if crewman.current_cmd != 'Reload': continue
				if 'Gun Expert' in crewman.skills:
					chance = round(chance * 0.25, 1)
					break
				if 'Gun Maintenance' in crewman.skills:
					chance = round(chance * 0.50, 1)
					break
		
		roll = GetPercentileRoll()
		if roll > chance: return False
		self.jammed = True
		return True
	
	
	# see if this weapon becomes unjammed
	def AttemptUnjam(self, crewman):
		roll = GetPercentileRoll()
		if crewman is not None:
			if 'Apply Hammer' in crewman.skills:
				roll -= 25.0
			elif 'Unsticky Situation' in crewman.skills:
				roll -= 15.0
		if roll > WEAPON_UNJAM_CHANCE: return False
		self.jammed = False
		self.fired = True			# set this so that weapon can't fire in same turn as unjammed
		return True
	
	
	# do a break test for this weapon, taken after firing
	def BreakTest(self):
		if self.unit.is_player and 'tutorial_campaign' in campaign.stats: return False
		
		if self.GetStat('very_unreliable') is not None:
			chance = 0.8
		elif self.GetStat('unreliable') is not None:
			chance = 0.5
		else:
			chance = 0.1
		
		if campaign_day.weather['Temperature'] in ['Extreme Cold', 'Extreme Hot']:
			chance += 0.3
		
		if self.GetStat('reloaded_by') is not None:
			for position in self.GetStat('reloaded_by'):
				crewman = self.unit.GetPersonnelByPosition(position)
				if crewman is None: continue
				if 'Gun Expert' in crewman.skills:
					chance = chance * 0.25
					break
				if 'Gun Maintenance' in crewman.skills:
					chance = chance * 0.5
					break
		
		chance = round(chance, 1)
		roll = GetPercentileRoll()
		if roll > chance: return False
		self.broken = True
		return True

	# Empties all rounds in the ready rack to ammo stores in preparation for automatically filling the rack. Does not respect room in general stores.
	def DumpReadyRackToStores(self): 
		for ammo_type in self.ready_rack: 
			self.ammo_stores[ammo_type] += self.ready_rack[ammo_type] 
			self.ready_rack[ammo_type] = 0 

	# Fills the ready rack from ammo stores, attempting to match a given template/saved rack.
	# Doesn't fill with more ammo than is available, but doesn't care about ready rack size:
	# the templates this is intended to use are defaults or saved settings generated by functions that won't allow an excess.
	def FillReadyRackFromStores(self, target_rack):
		for ammo_type in target_rack:
			add_num = min(target_rack[ammo_type], self.ammo_stores[ammo_type])
			if add_num == 0: continue
			self.ready_rack[ammo_type] = add_num
			self.ammo_stores[ammo_type] -= add_num 

	# Takes ammo store and ammo rack templates and determines if there is enough ammunition on hand to fill them.
	# resupply argument means we're resupplying, so common ammo types are in infinite availability.
	# Returns modified (if necessary) ammo rack, ammo storage, and a list of any inadequate ammo types.
	def CheckLoadoutTemplate(self, target_ammo_rack = {}, target_ammo_store = {}, resupply = False):
		available_ammo = {}
		possible_ammo_store = {}
		possible_ammo_rack = {}
		insufficient_ammo = []

		# How much ammo do we have?
		for ammo_type in self.stats['ammo_type_list']:
			if resupply:
				if 'special_ammo' not in self.stats or ammo_type not in self.stats['special_ammo']:
					available_ammo[ammo_type] = 9999 # Resupplying and this is common ammo, we can get as much as we want.
				else:
					available_ammo[ammo_type] = self.rare_ammo[ammo_type]
			else:
				available_ammo[ammo_type] = self.ammo_stores[ammo_type] + self.ready_rack[ammo_type]

		# Do we have enough to fill the ready rack?
		for ammo_type in target_ammo_rack:
			if available_ammo[ammo_type] >= target_ammo_rack[ammo_type]:
				ammo_to_transfer = target_ammo_rack[ammo_type]
			else:
				ammo_to_transfer = available_ammo[ammo_type]
				insufficient_ammo.append(ammo_type)
			possible_ammo_rack[ammo_type] = ammo_to_transfer
			available_ammo[ammo_type] -= ammo_to_transfer

		# Do we have enough left to fill the storage?
		for ammo_type in target_ammo_store:
			if available_ammo[ammo_type] >= target_ammo_store[ammo_type]:
				ammo_to_transfer = target_ammo_store[ammo_type]
			else:
				ammo_to_transfer = available_ammo[ammo_type]
				if ammo_type not in insufficient_ammo:
					insufficient_ammo.append(ammo_type)
			possible_ammo_store[ammo_type] = ammo_to_transfer

		return (possible_ammo_rack, possible_ammo_store, insufficient_ammo)

	# move a shell into or out of Ready Rack
	def ManageRR(self, add_num):
		
		# calculate current total general stores and RR load
		total_num = 0
		for ammo_type in AMMO_TYPES:
			if ammo_type in self.ammo_stores:
				total_num += self.ammo_stores[ammo_type]
		rr_num = 0
		for ammo_type in AMMO_TYPES:
			if ammo_type in self.ready_rack:
				rr_num += self.ready_rack[ammo_type]
		
		# no room in RR
		if rr_num + add_num > self.rr_size:
			# try to add as many as possible
			add_num = self.rr_size - rr_num
			if add_num <= 0:
				return False
		
		# adding to RR
		if add_num > 0:
		
			# none remaining in stores
			if self.ammo_stores[self.ammo_type] == 0:
				return False
			
			# not enough remaining in stores, add as many as possible
			if self.ammo_stores[self.ammo_type] < add_num:
				add_num = self.ammo_stores[self.ammo_type]
		
		# removing from RR
		else:
		
			# none remaining in RR
			if self.ready_rack[self.ammo_type] == 0:
				return False
			
			# not enough remaining in RR, remove as many as possible
			if self.ready_rack[self.ammo_type] + add_num < 0:
				add_num = 0 - self.ready_rack[self.ammo_type]
		
			# no room in general stores
			# allow one more shell here just to give some room to rearrange ready rack
			if total_num - add_num > self.max_plus_extra_ammo + 1:
				return False
		
		self.ready_rack[self.ammo_type] += add_num
		self.ammo_stores[self.ammo_type] -= add_num
		
		PlaySoundFor(None, 'shell_move_1')
		
		return True
		
	
	# calculate the odds for maintain RoF with this weapon
	def GetRoFChance(self):
		
		# no RoF for jammed or broken weapons
		if self.jammed or self.broken:
			return 0.0
		
		# enemy unit
		if self.unit.owning_player == 1:
			if not campaign.options['enemy_rof'] and self.GetStat('name') != 'Rocket Launcher' and self.GetStat('type') not in MG_WEAPONS:
				return 0.0
		
		# no RoF chance if weapon is gun and unit has moved that turn
		if self.GetStat('type') == 'Gun' and self.unit.moving: return 0.0
		
		# no RoF chance for packed-up gun units
		if self.unit.GetStat('category') == 'Gun' and not self.unit.deployed: return 0.0
		
		# no RoF chance for airplanes, always moving
		if self.unit.GetStat('category') == 'Airplane': return 0.0
		
		# some guns are so slow-firing they can never maintain RoF
		if self.GetStat('rof_na') is not None: return 0.0
		
		# guns must have at least one shell of the current type available
		if self.GetStat('type') == 'Gun':
			if self.ammo_type is not None:
				if self.using_rr:
					if self.ready_rack[self.ammo_type] == 0:
						return 0.0
				else:
					if self.ammo_stores[self.ammo_type] == 0:
						return 0.0
		
		# FTR must have fuel remaining
		if self.GetStat('type') == 'Flame Thrower':
			if self.flame_ammo == 0:
				return 0.0
		
		# get base RoF, set default value if none
		chance = self.GetStat('rof')
		if chance is None:
			if self.GetStat('type') in MG_WEAPONS:
				chance = 15.0
			else:
				chance = 10.0
		else:
			chance = float(chance)
		
		# weapon is turret mounted and turret was rotated
		if self.GetStat('mount') == 'Turret':
			if self.unit.turret_facing is not None:
				if self.unit.turret_facing != self.unit.previous_turret_facing:
					if self.unit.GetStat('turret') == 'FT':
						chance = chance * 0.75
					elif self.unit.GetStat('turret') == 'VST':
						chance = chance * 0.25
					else:
						chance = chance * 0.5
		
		# weapon is hull mounted and hull was pivoted
		elif self.GetStat('mount') == 'Hull':
			if self.unit.facing is not None:
				if self.unit.facing != self.unit.previous_facing:
					if self.unit.GetStat('turntable') is not None:
						chance = chance * 0.75
					else:
						chance = chance * 0.5
		
		# gun modifiers; don't apply to rocket launchers
		if self.GetStat('type') == 'Gun' and self.GetStat('name') != 'Rocket Launcher':
			
			# small gun bonus
			if self.stats['name'] == 'AT Rifle':
				calibre = 20
			else:
				calibre = int(self.stats['calibre'])
			if 15 <= calibre <= 40:
				chance = chance * 2.0
			
			# if weapon has a dedicated loader, loader must be on Reload command
			if self.unit.is_player:

				position_list = self.GetStat('reloaded_by')
				if position_list is not None:
					crewman_found = False
					for position in position_list:
						crewman = self.unit.GetPersonnelByPosition(position)
						if crewman is None: continue
						if crewman.current_cmd != 'Reload': continue
						
						# check that position is in same location as weapon mount if any
						if self.GetStat('mount') is not None:
							if crewman.current_position.location != self.GetStat('mount'):
								continue
						
						crewman_found = True
						
						# Loader skill bonus
						modifier = crewman.GetSkillMod('Lightning Hands', 25.0)
						if modifier is not None:
							chance += modifier
						else:
							modifier = crewman.GetSkillMod('Fast Hands', 15.0)
							if modifier is not None:
								chance += modifier
						break
					if not crewman_found:
						chance = round(chance * 0.5, 1)
		
			# guns need to be using RR for full benefit
			if self.using_rr:
				
				# autocannons are simulated by having a much higher RoF chance when reloading from the RR
				if 'autocannon' in self.stats:
					chance = round(chance * 3.0)
				
			else:
				
				modifier = 0.25
				
				# check for crewman passing ammo
				for position in self.unit.positions_list:
					if position.crewman is None: continue
					if position.crewman.current_cmd == 'Pass Ammo':
						
						modifier = position.crewman.GetSkillMod('Shell Pitcher', 0.8)
						if modifier is not None:
							if modifier < 0.4:
								modifier = 0.4
							break
						
						modifier = position.crewman.GetSkillMod('Shell Tosser', 0.6)
						if modifier is not None:
							if modifier < 0.4:
								modifier = 0.4
							break
						
						modifier = 0.4
						break
				
				chance = chance * modifier
		
		# firing crewman modifiers
		if self.unit.is_player:
			position_list = self.GetStat('fired_by')
			if position_list is not None:
				for position in position_list:
					
					if self.unit.GetStat('crew_positions') is None: continue
					
					# check that position is in same location as weapon mount if any
					if self.GetStat('mount') is not None:
						mount = self.GetStat('mount')
						same_location = False
						for position2 in self.unit.GetStat('crew_positions'):
							if position2['name'] != position: continue
							if position2['location'] == mount:
								same_location = True
								break
						if not same_location: continue
					
					crewman = self.unit.GetPersonnelByPosition(position)
					if crewman is None: continue
					
					if self.GetStat('type') == 'Gun':
						modifier = crewman.GetSkillMod('Quick Trigger', 5.0)
						if modifier is not None:
							chance += modifier
						
						if self.selected_target is not None:
							if self.selected_target.moving:
								modifier = crewman.GetSkillMod('Skeet Shooter', 10.0)
								if modifier is not None:
									chance += modifier
							else:
								modifier = crewman.GetSkillMod('Time on Target', 10.0)
								if modifier is not None:
									chance += modifier
					
					elif self.GetStat('name') == 'Flame Thrower':
						if 'They Call Him Ronson' in crewman.skills:
							chance += 10.0
					
					elif self.GetStat('type') in MG_WEAPONS:
						modifier = crewman.GetSkillMod('Burst Fire', 10.0)
						if modifier is not None:
							chance += modifier
			
			# campaign skill bonus
			if self.GetStat('type') in MG_WEAPONS:
				if self.unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Superior Firepower'):
					chance += 25.0
		
		# acquired target modifiers
		if self.GetStat('name') != 'Flame Thrower':
			if self.acquired_target is None:
				chance -= 5.0
			else:
				chance += 10.0
		
		# modify by already successful shots this turn
		if self.rof_shots > 0:
			chance -= 10.0 * float(self.rof_shots)
		
		# round final chance
		chance = round(chance, 1)
		
		# minimum gun/mg RoF chances
		if self.GetStat('type') == 'Gun':
			if self.using_rr:
				if chance <= 5.0:
					chance = 5.0
			else:
				if chance <= 2.0:
					chance = 2.0
		elif self.GetStat('type') in MG_WEAPONS:
			if chance <= 15.0:
				chance = 15.0
		
		# absolute minimum and maximum RoF chances
		if chance < 1.0:
			chance = 1.0
		elif chance > 75.0:
			chance = 75.0
		return chance
		
	
	# display information about current available ammo to a console. Returns the modified y value IE y + number of lines added (not counting extra, for consistency).
	def DisplayAmmo(self, console, x, y, skip_active=False, no_extra=False):
		
		# highlight if RR is in use
		if self.using_rr:
			libtcod.console_set_default_foreground(console, libtcod.light_blue)
		else:
			libtcod.console_set_default_foreground(console, libtcod.dark_grey)
		libtcod.console_print_ex(console, x+11, y, libtcod.BKGND_NONE,
			libtcod.RIGHT, 'RR')
		
		y += 1
		total_general = 0
		# general stores and RR contents
		for ammo_type in self.stats['ammo_type_list']:
			if ammo_type in self.ammo_stores:
				
				# highlight if this ammo type currently active
				if self.ammo_type is not None and not skip_active:
					if self.ammo_type == ammo_type:
						libtcod.console_set_default_background(console, libtcod.darker_blue)
						libtcod.console_rect(console, x, y, 12, 1, True, libtcod.BKGND_SET)
						libtcod.console_set_default_background(console, libtcod.darkest_grey)
				
				libtcod.console_set_default_foreground(console, libtcod.white)
				libtcod.console_print(console, x, y, ammo_type)
				libtcod.console_set_default_foreground(console, libtcod.light_grey)
				libtcod.console_print_ex(console, x+8, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(self.ammo_stores[ammo_type]))
				total_general += self.ammo_stores[ammo_type]
				
				libtcod.console_print_ex(console, x+11, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(self.ready_rack[ammo_type]))
				
				y += 1
		
		y += 1
		libtcod.console_print(console, x, y, 'Max')
		libtcod.console_set_default_foreground(console, libtcod.light_grey)
		libtcod.console_print_ex(console, x+8, y, libtcod.BKGND_NONE,
			libtcod.RIGHT, self.stats['max_ammo'])
		libtcod.console_print_ex(console, x+11, y, libtcod.BKGND_NONE,
			libtcod.RIGHT, str(self.rr_size))
		
		if no_extra: return y
		
		# show if current total exceeds safe maximum
		extra_ammo = total_general - int(self.stats['max_ammo'])
		if extra_ammo > 0:
			libtcod.console_set_default_foreground(console, libtcod.light_red)
			libtcod.console_print(console, x, y+1, 'Extra')
			libtcod.console_print_ex(console, x+8, y+1, libtcod.BKGND_NONE,
				libtcod.RIGHT, str(extra_ammo))
		
		return y
	
	
	# add a target as the current acquired target, or add one level
	def AddAcquiredTarget(self, target):
		
		# target is not yet spotted
		if target.owning_player == 1 and not target.spotted: return
		
		# no target previously acquired
		if self.acquired_target == None:
			self.acquired_target = (target, 0)
		
		# adding one level
		elif self.acquired_target == (target, 0):
			self.acquired_target = (target, 1)
		
		# already at max
		elif self.acquired_target == (target, 1):
			return
		
		# same or new target
		else:
			self.acquired_target = (target, 0)
	
	
	# calculate the map hexes covered by this weapon
	def UpdateCoveredHexes(self):
		
		def AddAllAround():
			for r in range(1, self.max_range + 1):
				ring_list = GetHexRing(self.unit.hx, self.unit.hy, r)
				for (hx, hy) in ring_list:
					# make sure hex is on map
					if (hx, hy) in scenario.hex_dict:
						self.covered_hexes.append((hx, hy))
		
		# clear covered hexes
		self.covered_hexes = []
		
		# unit is not in a valid hex
		if GetHexDistance(0, 0, self.unit.hx, self.unit.hy) > 3:
			return
		
		# can always fire in own hex
		self.covered_hexes.append((self.unit.hx, self.unit.hy))
		
		# infantry and cavalry can fire all around
		if self.unit.GetStat('category') in ['Infantry', 'Cavalry']:
			AddAllAround()
			return
		
		# sanity check
		if self.unit.facing is None:
			print('WARNING - non infantry/cavalry unit has facing set to None: ' + self.unit.unit_id) 
			return
		
		# AAMGs normally can fire in any direction
		if self.GetStat('type') == 'AAMG':
			if self.GetStat('front_only') is None and self.GetStat('rear_facing') is None:
				AddAllAround()
				
				# possible that weapon is blocked by hull facing
				blocked_dirs = self.GetStat('blocked_hull_dirs')
				if blocked_dirs is not None:
					for direction in blocked_dirs:
						hex_list = GetCoveredHexes(self.unit.hx, self.unit.hy, int(direction))
						for (hx, hy) in hex_list:
							if (hx, hy) in self.covered_hexes:
								self.covered_hexes.remove((hx, hy))
				
				return
		
		# hull-mounted weapons fire in hull-facing direction, also weapons mounted high on the hull
		# if no rotatable turret present
		if self.GetStat('mount') == 'Hull' or self.unit.turret_facing is None:
			
			# possible for hull-mounted weapons to be mounted on rear of hull
			if self.GetStat('rear_facing') is not None:
				weapon_facing = ConstrainDir(self.unit.facing + 3)
			else:
				weapon_facing = self.unit.facing
			hextant_hex_list = GetCoveredHexes(self.unit.hx, self.unit.hy, weapon_facing)
			
			# hull-mounted weapons can add additional covered hexes
			if self.GetStat('extra_facings_covered') is not None:
				for text in self.GetStat('extra_facings_covered'):
					facing = int(text)
					for (hx, hy) in GetCoveredHexes(self.unit.hx, self.unit.hy, facing):
						
						# skip if out of range
						if GetHexDistance(self.unit.hx, self.unit.hy, hx, hy) > self.max_range:
							continue
						
						# add if not already in the list
						if (hx, hy) not in hextant_hex_list:
							hextant_hex_list.append((hx, hy))
			
		# turret-mounted weapons fire in turret direction
		elif self.GetStat('mount') == 'Turret':
			
			# possible for weapons to be mounted on rear of turret
			if self.GetStat('rear_facing') is not None:
				facing = ConstrainDir(self.unit.turret_facing + 3)
			else:
				facing = self.unit.turret_facing
			
			# possible that turret is blocked by hull facing
			blocked_dirs = self.GetStat('blocked_hull_dirs')
			if blocked_dirs is not None:
				if str(ConstrainDir(facing - self.unit.facing)) in blocked_dirs:
					return
			
			hextant_hex_list = GetCoveredHexes(self.unit.hx, self.unit.hy, facing)
		
		else:
			print('ERROR: Could not set covered hexes for weapon: ' + self.stats['name'])
			return
		
		for (hx, hy) in hextant_hex_list:
			if (hx, hy) not in scenario.hex_dict: continue		# hex is off map
			# out of range
			if GetHexDistance(self.unit.hx, self.unit.hy, hx, hy) > self.max_range:
				continue
			self.covered_hexes.append((hx, hy))


	# Pares down the scenario target list into specifically those that are within the weapon's covered hexes.
	# Keeps original order. Then selects a target, preferring units that are acquired or previously selected.
	def BuildTargetList(self):
		self.weapon_target_list = []

		for target in scenario.target_list:
			if (target.hx, target.hy) in self.covered_hexes:
				self.weapon_target_list.append(target)

		if len(self.weapon_target_list) == 0:
			self.selected_target = None
			return
		if self.acquired_target is not None:
			ac_target = self.acquired_target[0]
			if ac_target in self.weapon_target_list:
				self.selected_target = ac_target
				return
		if self.selected_target not in self.weapon_target_list:
			self.selected_target = self.weapon_target_list[0]


	# set/reset all scenario statuses for a new turn
	def ResetMe(self):
		self.fired = False
		self.maintained_rof = False
		self.UpdateCoveredHexes()
		self.weapon_target_list = []
	
	
	# try to select the previous or next ammo type
	# if wrap is True, wrap around to the next one
	def SelectAmmoType(self, forward, wrap=False):
		if self.GetStat('ammo_type_list') is None: return False
		
		# ammo type not yet selected!
		if self.ammo_type is None:
			self.ammo_type = self.stats['ammo_type_list'][0]
			return True
		
		# no other types possible
		if len(self.stats['ammo_type_list']) == 1:
			return False
		
		if forward:
			m = 1
		else:
			m = -1
		i = self.stats['ammo_type_list'].index(self.ammo_type)
		i += m
		
		if wrap:
			if i < 0:
				i = len(self.stats['ammo_type_list']) - 1
			elif i > len(self.stats['ammo_type_list']) - 1:
				i = 0
			self.ammo_type = self.stats['ammo_type_list'][i]
			return True
		
		# otherwise, don't wrap around
		if i < 0:
			return False
		elif i > len(self.stats['ammo_type_list']) - 1:
			return False
		self.ammo_type = self.stats['ammo_type_list'][i]
		return True
	
	
	# return the effective FP of an HE/HEAT hit from this weapon
	def GetEffectiveFP(self):
		
		if self.GetStat('type') != 'Gun':
			print('ERROR: ' + self.stats['name'] + ' is not a gun, cannot generate effective FP')
			return 1
		
		# some weapons might have a higher base firepower
		if self.GetStat('fp') is not None:
			return int(self.GetStat('fp'))
		
		for (calibre, fp) in HE_FP_EFFECT:
			if calibre <= int(self.GetStat('calibre')):
				if self.ammo_type == 'HEAT':
					return fp - 2
				return fp
		
		print('ERROR: Could not find effective FP for: ' + self.stats['name'])
		return 1



# AI: controller for enemy and player-allied units
class AI:
	def __init__(self, owner):
		self.owner = owner			# pointer to owning Unit
		self.attitude = ''			# can be Advance, Hold, Withdraw
		self.state = ''				# can be Lax, Alert, Heroic, Stunned
		self.leader_command = ''	
		self.previous_action = ''		# action that was executed last activation
		self.intended_target = None		# intended enemy target for future

	# set up initial AI state, called during spawn
	def Reset(self, squadmember=False, unloading=False):
		
		# player squad member
		if squadmember:
			self.attitude = 'Hold'
			self.state = 'Alert'
			self.leader_command = campaign.battlegroup_command
			return
		
		# enemy unit
		if self.owner.owning_player == 1:
			if campaign_day.mission in ['Fighting Withdrawal', 'Counterattack', 'Urban Defense', 'Hold the Line']:
				self.attitude = 'Advance'
			else:
				self.attitude = 'Hold'
			if campaign_day.mission in ['Fighting Withdrawal', 'Counterattack', 'Urban Defense', 'Hold the Line']:
				self.state = 'Alert'
			elif unloading:
				self.state = 'Alert'
			else:
				roll = GetPercentileRoll()
				if 'elite' in self.owner.stats:
					roll -= 15.0
				if roll <= 65.0:
					self.state = 'Alert'
				else:
					self.state = 'Lax'
			return
		
		# friendly unit
		self.attitude = 'Advance'
		self.state = 'Alert'


	# do the AI activation for this unit
	def DoActivation(self, defensive_fire=False):
		
		# show a debug message if debug flag enabled
		def AISpyMsg(text, add_space=False):
			if not DEBUG: return
			if not session.debug['AI Spy']: return
			if add_space: print('\n\n')
			print('AI SPY: ' + text)
		
		# check for debug flags
		if DEBUG:
			if self.owner.owning_player == 1 and session.debug['No Enemy AI Actions']:
				return
			elif self.owner in scenario.player_unit.squad and session.debug['No Player Squad Actions']:
				return
			elif self.owner not in scenario.player_unit.squad and self.owner.owning_player == 0 and session.debug['No Unit Support Actions']:
				return
		
		# start activation loop
		actions_taken = 0			# total number of actions taken so far this activation
		activation_over = False			# AI unit's entire activation for this turn is finished
		move_finished = False			# AI unit has completed a move action already this activation
		
		# essential info
		threat_list = []			# list of tuples: active enemy units and a threat score for each
		crewmen_acted = []			# list of crewmen who have already acted this activation
		
		# owning unit is armoured / has a reverse driver
		is_armoured = (self.owner.GetStat('armour') is not None and self.owner.GetStat('category') == 'Vehicle')
		has_r_driver = (self.owner.GetStat('reverse_driver') is not None and self.owner.GetStat('category') == 'Vehicle')
		
		while not activation_over:
		
			# unit has been destroyed
			if not self.owner.alive: return
			
			# has already taken 1+ actions
			if actions_taken > 0:
				if GetPercentileRoll() <= float(actions_taken) * 10.0:
					AISpyMsg(self.owner.unit_id + " won't take another action, ending activation")
					activation_over = True
					continue
			
			actions_taken += 1
			
			AISpyMsg(self.owner.unit_id + ' now acting, action #' + str(actions_taken), add_space=True)
			
			# check for all enemies dead and do nothing if so
			all_enemies_dead = True
			for unit in scenario.units:
				if unit.owning_player != self.owner.owning_player and unit.alive:
					all_enemies_dead = False
					break
			if all_enemies_dead:
				AISpyMsg('All enemies dead, ending activation')
				activation_over = True
				continue						
			
			# 0) (Re)build basic situational info
			#################################
			current_distance = GetHexDistance(0, 0, self.owner.hx, self.owner.hy)
			
			spotted_enemies = 0
			adjacent_enemies = 0
			allies_on_map = 0
			has_los_to_enemy = False
			ac_list = []
			for unit in scenario.units:
				if unit == self.owner: continue
				
				# friendly unit
				if unit.owning_player == self.owner.owning_player:
					if unit.alive: allies_on_map += 1
					continue
				
				if not unit.spotted: continue
				
				spotted_enemies += 1
				
				if GetHexDistance(unit.hx, unit.hy, self.owner.hx, self.owner.hy) <= 1:
					adjacent_enemies += 1
				if self.owner.los_table[unit]:
					has_los_to_enemy = True
				
				for weapon in unit.weapon_list:
					if weapon.broken: continue
					if weapon.acquired_target is None: continue
					if weapon.acquired_target[0] == self.owner:
						ac_list.append(unit)
						break
			
			player_crew_vulnerable = False
			if len(scenario.player_unit.VulnerableCrew()) > 0:
				player_crew_vulnerable = True
			
			is_limber_connected = False
			if self.owner.towed_by is not None or self.owner.towing is not None:
				is_limber_connected = True
			
			unit_mobile = True
			if self.owner.immobilized or 'immobile' in self.owner.stats:
				unit_mobile = False
			
			unit_unarmed = True
			for weapon in self.owner.weapon_list:
				if weapon.broken: continue
				unit_unarmed = False
				break
			
			tractor_unit = False
			if self.owner.GetStat('class') == 'Tractor' or self.owner.towing is not None:
				tractor_unit = True
			
			size_class = 'Normal'
			if self.owner.GetStat('size_class') is not None:
				size_class = self.owner.GetStat('size_class')
			
			# (re)build enemy threat list
			threat_list = {}
			owner_category = self.owner.GetStat('category')
			for unit in scenario.units:
				if unit.owning_player == self.owner.owning_player: continue
				if not unit.alive: continue
				if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
				if not self.owner.los_table[unit]: continue
				
				unarmed_enemy = False
				
				# unspotted enemy unit
				if not unit.spotted:
					score = libtcod.random_get_int(0, 5, 25)
				else:					
					enemy_category = unit.GetStat('category')
					enemy_class = unit.GetStat('class')
					unarmed_enemy = (len(unit.weapon_list) == 0)
					
					# calculate threat score for this enemy unit
					score = 0
					if owner_category in ['Infantry', 'Cavalry']:
						if enemy_category in ['Infantry', 'Cavalry']:
							score = 10
						else:
							if unarmed_enemy:
								score = 0
							else:
								score = 60
					
					elif owner_category == 'Gun':
						if enemy_category in ['Gun', 'Vehicle']:
							score = 80
						else:
							score = 20
					
					elif owner_category == 'Vehicle':
						# armoured owning vehicle
						if is_armoured:
							if enemy_category == 'Gun':
								score = 70
							elif enemy_category == 'Vehicle':
								score = 50
							elif enemy_class == 'Support Weapon Team':
								score = 70
							else:
								score = 10
						
						# unarmoured owning vehicle
						else:
							if enemy_category in ['Infantry', 'Cavalry']:
								score = 30
							else:
								if unarmed_enemy:
									score = 0
								else:
									score = 70
					
					# unknown owning unit category!
					else:
						continue
				
				# modify by range
				enemy_distance = GetHexDistance(self.owner.hx, self.owner.hy, unit.hx, unit.hy)
				if enemy_distance == 1:
					score = ceil(score * 1.5)
				elif enemy_distance == 2:
					score = ceil(score * 1.25)
				
				if score > 100:
					score = 100
				
				# both the owning unit and the enemy unit are unarmed
				if unit_unarmed and unarmed_enemy:
					score = 0
				
				if score == 0: continue
				
				threat_list[unit] = score
				
			# if large dictionary, prune the lowest scores from the list
			if len(threat_list) > 5:
				for score in range(100):
					for unit in threat_list:
						if threat_list[unit] <= score:
							del threat_list[unit]
							break
					if len(threat_list) <= 5:
						break
			
			
			# 1) Determine if a state change is required
			#############################################
			if self.state == 'Lax':
				
				# 1+ units in same hex are alert
				for unit in scenario.units:
					if unit == self.owner: continue
					if unit.owning_player != self.owner.owning_player: continue
					if not (unit.hx == self.owner.hx and unit.hx == self.owner.hy): continue
					if unit.ai is None: continue
					if unit.ai.state != 'Alert': continue
					self.state = 'Alert'
					ShowMessage(self.owner.GetName() + ' is now Alert.', scenario_highlight=(self.owner.hx, self.owner.hy))
					return
				
				if spotted_enemies > 0:
					roll = GetPercentileRoll()
					roll += float(campaign.options['ai_difficulty']) * 10.0
					if 'elite' in self.owner.stats:
						roll -= 15.0
					if roll <= float(spotted_enemies) * 25.0:
						self.state = 'Alert'
						ShowMessage(self.owner.GetName() + ' is now Alert.', scenario_highlight=(self.owner.hx, self.owner.hy))
						return
				AISpyMsg(self.owner.unit_id + ' is Lax, no action taken.')
				activation_over = True
				continue
			
			elif self.state == 'Stunned':
				roll = GetPercentileRoll()
				if roll <= 15.0:
					self.state = 'Alert'
					ShowMessage(self.owner.GetName() + ' has recovered from being Stunned.', scenario_highlight=(self.owner.hx, self.owner.hy))
					activation_over = True
					continue
			
			elif self.state == 'Alert' and not defensive_fire:
				if adjacent_enemies >= 1 and not self.owner.routed and self.owner not in scenario.player_unit.squad:
					roll = GetPercentileRoll()
					if roll <= float(adjacent_enemies) * 1.0:
						self.state = 'Heroic'
						ShowMessage(self.owner.GetName() + ' is now Heroic.', scenario_highlight=(self.owner.hx, self.owner.hy))
			
			
			# 2) Determine if a attitude change is triggered
			################################################
			if self.owner.owning_player == 0 and self.leader_command == 'On my Mark':
				
				# check player weapons; if any have fired, switch current command
				for weapon in scenario.player_unit.weapon_list:
					if weapon.fired:
						self.leader_command = 'Fire at Will'
						AISpyMsg(self.owner.unit_id + ' has switched to Fire at Will.')
						break
				
			elif self.owner.owning_player == 1:
				if self.attitude != 'Withdraw' and not defensive_fire:
					if campaign_day.ended and not self.owner.immobilized:
						if GetPercentileRoll() <= 25.0:
							self.attitude = 'Withdraw'
							AISpyMsg(self.owner.unit_id + ' now withdrawing')
				elif self.owner.routed:
					self.attitude = 'Withdraw'
			
			
			# 3) Determine if a compulsary action is required
			#################################################
			if self.attitude == 'Withdraw' and not defensive_fire:
				
				# calculate base chance of withdrawing from battle / abandoning
				chance = 0.0
				
				movement_class = self.owner.GetStat('movement_class')
				if movement_class is not None:
					if movement_class in ['Infantry', 'Slow Tank', 'Slow Wheeled']:
						chance = 3.0
					elif movement_class in ['Half-Tracked', 'Fast Tank', 'Fast Wheeled']:
						chance = 10.0
					else:
						chance = 5.0
				
				# specialist gun tractors are designed to move quickly
				if self.owner.GetStat('class') == 'Tractor':
					chance += 5.0
				
				# untowed guns, immobile units can only be abandoned
				must_abandon = False
				if not unit_mobile:
					chance = round(chance * 0.25, 1)
					must_abandon = True
				
				elif self.owner.GetStat('type') == 'Gun':
					
					# if already limber connected, don't withdraw on own
					if is_limber_connected:
						chance = -10.0
					else:
						must_abandon = True
						
						# if there is a friendly gun tractor available, gun crew will likely wait
						for unit in scenario.units:
							if unit.owning_player != self.owner.owning_player: continue
							if not unit.alive: continue
							if unit == self.owner: continue
							if unit.GetStat('towing_capacity') is not None:
								if TractorCanTow(unit.unit_id, size_class):
									chance = 3.0
									break
				
				# rescue units will never withdraw
				if scenario.cd_map_hex.objective is not None:
					if scenario.cd_map_hex.objective['type'] == 'Rescue':
						if self.owner == scenario.cd_map_hex.objective['rescue_unit']:
							chance = 0.0
				
				if chance > 0.0:
					AISpyMsg('Withdraw roll for ' + self.owner.unit_id + ', chance: ' + str(chance))
					if must_abandon:
						AISpyMsg('Crew must abandon the unit')
					
					if GetPercentileRoll() <= chance:
						if must_abandon or self.owner.bogged:
							text = 'The crew of ' + self.owner.GetName() + ' abandons their '
							if self.owner.GetStat('type') == 'Gun':
								text += 'gun.'
							else:
								text += 'vehicle.'
							ShowMessage(text, scenario_highlight=(self.owner.hx, self.owner.hy))
							self.owner.DestroyMe(abandoned=True)
						else:
							text = self.owner.GetName() + ' withdraws from this zone.'
							
							# check for towed gun withdrawing too
							if self.owner.towing is not None:
								text += ' It tows away a ' + self.owner.towing.GetName()
								self.owner.towing.DestroyMe(no_vp=True)
							PlaySoundFor(self.owner, 'movement')
							ShowMessage(text, scenario_highlight=(self.owner.hx, self.owner.hy))
							self.owner.DestroyMe(no_vp=True)
						activation_over = True
						continue
				
				
			# check for weapon un-jamming
			for weapon in self.owner.weapon_list:
				if not weapon.jammed: continue
				if weapon.broken: continue
				if weapon.AttemptUnjam(None):
					AISpyMsg(self.owner.unit_id + ' has unjammed its ' + weapon.stats['name'])
					continue
			
			
			# 4) Score all possible actions
			###############################
			
			action_list = []
			
			# Surrender - enemy only, and only as first action in activation
			if self.owner.owning_player == 1 and not defensive_fire and 'enemy_fanatic' not in campaign.stats and actions_taken == 1:
				
				score = 0.0
				
				if self.owner.routed:
					score += 25.0
				elif self.owner.reduced:
					score += 15.0
				elif self.owner.immobilized:
					score += 20.0
				
				if self.state == 'Stunned':
					score += 15.0
				
				if score > 0.0:
					if adjacent_enemies == 0:
						score = round(score * 0.25, 1)
					else:
						score += score * (float(adjacent_enemies) * 0.5)
				
				# pinned unit attempting to withdraw
				if self.attitude == 'Withdraw' and self.owner.pinned and self.state != 'Heroic':
					score = score * 3.0
				elif self.state == 'Heroic':
					score = round(score * 0.1, 1)
				elif self.owner.GetStat('armour') is not None:
					score = round(score * 0.5, 1)
				elif allies_on_map == 0 and self.owner.GetStat('category') in ['Gun', 'Infantry']:
					score = score * 2.0
				
				if self.owner.entrenched or self.owner.fortified:
					score = round(score * 0.5, 1)
				
				if self.owner.GetStat('category') == 'Train Car':
					score = 0.0
				elif self.owner.GetStat('armour') is not None and adjacent_enemies == 0:
					score = 0.0
				
				score = round(score, 2)
				
				if score > 1.0:
					action_list.append((score, ['Surrender']))
			
			
			# set withdraw status - only for non-player side units
			if self.attitude != 'Withdraw' and not defensive_fire and self.owner.owning_player != 0:
				score = -25.0
				
				if self.state == 'Stunned':
					score += 10.0
				
				# broken weapon or low ammo
				for weapon in self.owner.weapon_list:
					if weapon.broken:
						if weapon.GetStat('type') == 'Gun':
							score += 50.0
						else:
							score += 20.0
						continue
					
					if weapon.GetStat('type') == 'Gun' and 'ammo_type_list' in weapon.stats:
						ammo_remaining = False
						for ammo_type in weapon.stats['ammo_type_list']:
							if ammo_type in ['Smoke', 'WP']: continue
							if weapon.ready_rack[ammo_type] + weapon.ammo_stores[ammo_type] > 0:
								ammo_remaining = True
								continue
							if 'special_ammo' in weapon.stats:
								if ammo_type in weapon.stats['special_ammo']: continue
						
						if not ammo_remaining:
							score += 50.0
				
				# sole enemy on map
				if allies_on_map == 0:
					
					if self.owner.GetStat('category') in ['Assault Gun', 'Tank Destroyer', 'Medium Tank', 'Heavy Tank']:
						score += 5.0	
					else:
						score += 15.0
					if self.owner.dug_in or self.owner.entrenched:
						score -= 15.0	
					elif self.owner.fortified:
						score -= 25.0
				
					# sole unarmed unit
					if unit_unarmed:
						score += 25.0
					
					# only enemy ever spawned
					if scenario.enemy_units_spawned == 1:
						score -= 30.0
				
				# towing a withdrawing gun
				if self.owner.towing is not None:
					if self.owner.towing.ai.attitude == 'Withdraw':
						score = 100.0
				
				# specialist gun tractor with no friendly gun left to tow
				if self.owner.GetStat('class') == 'Tractor':
					no_guns_left = True
					for unit in scenario.units:
						if unit.owning_player != self.owner.owning_player: continue
						if not unit.alive: continue
						if unit.GetStat('type') != 'Gun': continue
						if 'immobile' in unit.stats: continue
						size_class = 'Normal'
						if unit.GetStat('size_class') is not None:
							size_class = unit.GetStat('size_class')
						if TractorCanTow(self.owner.unit_id, size_class):
							no_guns_left = False
							break
					
					if no_guns_left:
						score = 100.0
				
				# player is broken down
				if score > 0.0 and scenario.player_unit.immobilized:
					score = score * 2.0
				
				if self.owner.GetStat('category') == 'Train Car':
					score = 0.0
				
				if score > 0.0:
					action_list.append((score, ['Withdraw']))
			
			
			# Dig in
			if self.owner.GetStat('category') in ['Infantry', 'Gun'] and not defensive_fire and actions_taken == 1:
				if not is_limber_connected and not self.owner.dug_in and not self.owner.entrenched and not self.owner.fortified and self.attitude != 'Withdraw':
					score = (adjacent_enemies * 15.0) + float(libtcod.random_get_int(0, 0, 5))
					
					if self.attitude != 'Hold':
						score -= 20.0
					
					if self.owner.GetStat('category') == 'Gun' and len(threat_list) >= 1:
						score += 25.0
					
					if score > AI_ACTION_MIN:
						action_list.append((score, ['Dig In']))
			
			
			# Deploy / Pack Up
			if (self.owner.GetStat('category') == 'Gun' or self.owner.GetStat('deploy_to_fire') is not None) and not self.owner.pinned and not self.owner.moving:
				
				# Deploy
				if not self.owner.deployed and self.state != 'Stunned' and self.attitude != 'Withdraw':
					score = (spotted_enemies * 15.0) + (adjacent_enemies * 30.0) + float(libtcod.random_get_int(0, 5, 25))
					if score > 100.0:
						score = 100.0
					action_list.append((score, ['Deploy']))
			
				# Pack-Up
				elif self.owner.deployed and self.state != 'Stunned' and self.attitude == 'Withdraw' and unit_mobile:
					score = 40.0 + (adjacent_enemies * 20.0)
					if score > 100.0:
						score = 100.0
					action_list.append((100.0, ['Pack-Up']))
			
			
			# Unload passengers if any
			if self.owner.transport is not None and not defensive_fire and self.state != 'Stunned':
				if self.owner.owning_player == 0 or current_distance <= 1:
					action_list.append((90.0, ['Unload Passengers']))
				
				# some units can be unloaded further away from the player
				elif self.owner.owning_player == 1 and current_distance > 1:
					if self.owner.transport in ['AT Rifle Team', 'HMG Team', 'Medium Mortar Team', 'Heavy Mortar Team']:
						action_list.append((80.0, ['Unload Passengers']))
			
			
			# Fire attacks
			enemies_out_of_range = True
			if not unit_unarmed and current_distance <= 3 and not self.owner.routed and self.state != 'Stunned' and self.attitude != 'Withdraw' and not is_limber_connected:
				
				# build list of possible targets
				target_list = []
				for unit in scenario.units:
					if not unit.alive: continue
					if unit.owning_player == self.owner.owning_player: continue
					
					# target off map
					if GetHexDistance(0, 0, unit.hx, unit.hy) > 3: continue
					
					target_list.append(unit)
				
				# check for hold fire/on my mark squad leader order, clear target list if not going to attack
				if self.leader_command in ['Hold Fire', 'On my Mark']:
					target_list = []
				
				# check for need to deploy
				if self.owner.GetStat('category') == 'Gun':
					if self.owner.GetStat('deploy_to_fire') is not None:
						target_list = []
					elif not self.owner.deployed and self.owner.GetStat('size_class') not in ['Very Small', 'Small']:
						target_list = []
				
				# infantry units cannot move and fire in the same turn
				if self.owner.GetStat('movement_class') == 'Infantry' and self.owner.moving:
					target_list = []
				
				# unarmed unit
				if unit_unarmed:
					target_list = []
				
				# build list of player's acquired targets
				player_targets = []
				for weapon in scenario.player_unit.weapon_list:
					if weapon.acquired_target is None: continue
					player_targets.append(weapon.acquired_target[0])
				
				if len(target_list) == 0:
					if self.leader_command == 'Hold Fire':
						AISpyMsg('Holding fire')
					else:
						AISpyMsg('No possible targets for ' + self.owner.unit_id)
				else:
					
					for target in target_list:
						
						# skip any other possible targets if this is a defensive fire attack
						if defensive_fire:
							if not target.is_player and target not in scenario.player_unit.squad:
								continue
						
						for weapon in self.owner.weapon_list:
							
							# skip any weapons that fired in a previous action
							if weapon.fired:
								continue
							
							# check that operating crewman has not already acted this turn
							if weapon.GetStat('fired_by') is not None and self.owner.positions_list is not None:
								crewman_found = False
								for position_name in weapon.GetStat('fired_by'):
									for position in self.owner.positions_list:
										if position.name != position_name: continue
										if position.crewman is None: continue
										if not position.crewman.alive: continue
										
										if position.crewman in crewmen_acted:
											AISpyMsg('An AI crewman, ' + position_name + ', has already fired ' + weapon.stats['name'] + ' this activation', add_space=True)
											continue
										
										crewman_found = True
										break
									if crewman_found: break
								
								# no crewmen remaining who have not acted yet and could fire this weapon
								if not crewman_found:
									AISpyMsg(weapon.stats['name'] + ' has no crewman left to fire it', add_space=True)
									continue
							
							AISpyMsg('Checking possible attacks on ' + target.unit_id + ' for ' + weapon.stats['name'])
							
							if weapon.broken:
								AISpyMsg(weapon.stats['name'] + ' is broken')
								continue
							
							# don't allow ballistic weapons to fire in defensive fire
							if defensive_fire:
								if weapon.GetStat('ballistic_attack') is not None:
									continue
							
							# CC weapons need to have a spotted target
							if weapon.GetStat('type') == 'Close Combat' and not target.spotted:
								continue
							
							# some weapons cannot be used effectively if unit is moving
							if 'move_or_fire' in weapon.stats:
								if self.owner.moving:
									continue
							
							# make sure that target is in range
							distance = GetHexDistance(self.owner.hx, self.owner.hy, target.hx, target.hy)
							if distance > weapon.max_range:
								AISpyMsg('Target ' + target.unit_id + ' out of range for ' + weapon.stats['name'])
								continue
							
							# check for limited HEAT range
							if self.owner.GetStat('heat_max_range') is not None:
								if int(self.owner.GetStat('heat_max_range')) > distance:
									continue
							
							enemies_out_of_range = False
							
							# make sure there is LoS if required
							if not self.owner.los_table[target]:
								if weapon.GetStat('ballistic_attack') is None:
									continue
							
							# determine if a pivot or turret rotation would be required
							pivot_req = False
							turret_rotate_req = False
							mount = weapon.GetStat('mount')
							if mount is not None and (target.hx, target.hy) not in weapon.covered_hexes:
								if mount == 'Turret' and self.owner.turret_facing is not None:
									if self.owner.GetStat('turret') in ['FIXED', 'FXT']:
										pivot_req = True
									else:
										turret_rotate_req = True
								else:
									if (target.hx, target.hy) not in weapon.covered_hexes:
										pivot_req = True
							
							# determine requirement to pivot hull due to blocked firing direction
							if mount is not None and self.owner.turret_facing is not None:
								if mount == 'Turret' and self.owner.GetStat('turret') not in ['FIXED', 'FXT']:
									blocked_dirs = weapon.GetStat('blocked_hull_dirs')
									if blocked_dirs is not None:
										direction = ConstrainDir(self.owner.turret_facing - self.owner.facing)
										if str(direction) in blocked_dirs:
											pivot_req = True
							
							if turret_rotate_req:
								turret = self.owner.GetStat('turret')
								if turret is not None:
									if turret in ['FIXED', 'FXT']:
										AISpyMsg('Turret rotation required for this shot, cannot proceed')
										continue
							
							if pivot_req:
								if self.owner.immobilized or self.owner.bogged:
									continue
								
								# cannot pivot if being towed
								if self.owner.towed_by is not None:
									continue
								
								# player squadmates may have already moved with player and can't pivot now
								if self.owner.moving:
									AISpyMsg('Skipped an attack because needed to pivot, and unit moved already')
									continue
								
								AISpyMsg('Unit needs to pivot but is not moving!')
								
								# pivot NA during defensive fire
								if defensive_fire:
									continue
							
							ammo_type_list = []
							
							# gun weapons need to check multiple ammo type combinations
							if weapon.GetStat('type') != 'Gun':
								ammo_type_list.append('')
							elif 'ammo_type_list' not in weapon.stats:
								ammo_type_list.append('')
							else:
								ammo_list = weapon.stats['ammo_type_list']
								for ammo_type in ammo_list:
									# skip smoke/WP for now
									if ammo_type in ['Smoke', 'WP']: continue
									
									# make sure 1+ shells are available
									if weapon.ready_rack[ammo_type] == 0 and weapon.ammo_stores[ammo_type] == 0:
										continue
									
									ammo_type_list.append(ammo_type)
							
							# finally, run through each ammo type (for non-Guns, this will be just '')
							ammo_attack_list = []
							for ammo_type in ammo_type_list:
								
								# temporarily set ammo type if gun
								if ammo_type != '':
									
									# don't calculate gun attacks on unspotted targets with anything other than HE ammo
									if not target.spotted and ammo_type != 'HE':
										continue
									
									weapon.ammo_type = ammo_type
									
								profile = scenario.CalcAttack(self.owner, weapon, target,
									pivot=pivot_req, turret_rotate=turret_rotate_req)
								
								# attack not possible
								if profile is None:
									text = 'Attack not possible: '
									text += str(weapon.stats['name']) + ' against ' + target.unit_id
									if ammo_type != '':
										text += ' with: ' + ammo_type
									AISpyMsg(text)
									continue
								
								# nearly impossible to hit
								if profile['final_chance'] <= 0.5:
									if GetPercentileRoll() <= 95.0:
										AISpyMsg('Ignored an almost impossible shot')
										continue
								
								score = profile['final_chance']
								score -= 10.0
								score += float(libtcod.random_get_int(0, 0, 20))
								
								# if target is armoured, apply armour penetration chance to score
								if (weapon.GetStat('type') in ['Gun', 'AT Rifle', 'Close Combat'] or weapon.GetStat('type') in MG_WEAPONS) and target.GetStat('armour') is not None:
									
									# assume best case for ballistic attacks
									if profile['ballistic_attack']:
										profile['result'] = 'CRITICAL HIT'
									
									# check for both hull and turret hit
									profile['location'] = 'Hull'
									hull_profile = scenario.CalcAP(profile)
									hull_hit_modifier = round(hull_profile['final_chance'] / 75.0, 2)
									AISpyMsg('Hull AP modifier: ' + str(hull_hit_modifier))
									
									profile['location'] = 'Turret'
									turret_profile = scenario.CalcAP(profile)
									turret_hit_modifier = round(turret_profile['final_chance'] / 75.0, 2)
									AISpyMsg('Turret AP modifier: ' + str(turret_hit_modifier))
									
									# choose the higher of the two
									modifier = turret_hit_modifier
									if hull_hit_modifier > turret_hit_modifier:
										modifier = hull_hit_modifier
									
									# might be able to injure exposed crew
									if target.is_player and player_crew_vulnerable:
										if ammo_type in ['C', 'SH', 'HE'] or weapon.GetStat('type') == 'Close Combat' or weapon.GetStat('type') in MG_WEAPONS:
											modifier = modifier * 3.0
									
									score = score * (modifier * 2.0)
								
								
								# apply final score modifiers
								
								# part of player squad: check for bonus for player target
								if self.owner in scenario.player_unit.squad and len(player_targets) > 0:
									if target in player_targets:
										if self.leader_command == 'Attack my Target':
											score += 60.0
										else:
											score += 15.0
								
								# avoid AP or HEAT attacks on unarmoured targets
								if (ammo_type in AP_AMMO_TYPES or ammo_type == 'HEAT') and target.GetStat('armour') is None:
									if target.GetStat('category') != 'Vehicle':
										score = -25.0
									else:
										# if HE is an option
										if 'HE' in ammo_type_list:
											score -= 25.0
								
								# avoid HE attacks on armoured targets
								if ammo_type == 'HE' and target.GetStat('armour') is not None:
									if not (target.is_player and player_crew_vulnerable):
										score -= 20.0
								
								# avoid HE attacks on infantry unless entrenched or fortified
								if ammo_type == 'HE' and target.GetStat('category') in ['Infantry', 'Gun']:
									if not target.entrenched and not target.fortified:
										score -= 20.0
								
								# avoid attacks on units that are already routed
								if target.routed:
									score -= 35.0
								
								# avoid close combat attacks if already in a good position
								if weapon.GetStat('type') == 'Close Combat':
									if self.owner.fortified:
										score -= 45.0
									elif self.owner.entrenched:
										score -= 30.0
									elif self.owner.dug_in:
										score -= 20.0
								
								# heroic units more likely to attack
								if self.state == 'Heroic':
									if weapon.GetStat('type') == 'Close Combat':
										score += 30.0
									else:
										score += 15.0
								
								# if ambush is in progress, much more likely to attack
								if scenario.ambush and score > AI_ACTION_MIN:
									score += float(libtcod.random_get_int(0, 30, 50))
								
								# if defensive fire, much more likely to attack unless surrounded by smoke
								if defensive_fire:
									if self.owner.smoke == 2:
										score -= 20.0
									elif self.owner.smoke == 1:
										score -= 10.0
									else:
										score += 10.0
								
								# overrun attack, prefer units in target hex
								if self.owner.overrun:
									if not (target.hx == 0 and target.hy == -1):
										score -= 30.0
								
								# if withdrawing, much less likely to attack
								if self.attitude == 'Withdraw':
									score -= 35.0
								
								# if is an acquired target of this unit
								if target in ac_list:
									if score > 0.0:
										score += 25.0
								
								# high-threat target
								if target in threat_list:
									if threat_list[target] >= 50:
										score += 15.0
								
								if DEBUG:
									if target.is_player and session.debug['AI Hates Player']:
										if score > 0.0:
											score += 70.0
								
								# not sure if this is required, but seems to work
								score = round(score, 2)
								
								# add this attack, even if it has a very low score
								ammo_attack_list.append((score, ['Attack', (weapon, target, ammo_type)]))
							
							# choose best ammo to use for this attack and add the action
							if len(ammo_attack_list) > 0:
								ammo_attack_list.sort(key=lambda x:x[0], reverse=True)
								action_list.append(ammo_attack_list[0])
			
			if enemies_out_of_range:
				AISpyMsg('No enemies in range for an attack.')
			
			
			# Move Actions
			if not defensive_fire and self.state != 'Stunned' and unit_mobile and not self.owner.broken_down:
				
				cannot_move = False
				
				# build list of possible destinations
				hex_list = []
				for (hx, hy) in GetHexRing(self.owner.hx, self.owner.hy, 1):
					if (hx, hy) not in scenario.hex_dict: continue
					# don't move into player's hex if enemy
					if self.owner.owning_player == 1 and hx == 0 and hy == 0: continue
					dist = GetHexDistance(0, 0, hx, hy)
					if dist == 4:
						if GetPercentileRoll() <= 75.0:
							continue
					hex_list.append((hx, hy))
				
				# unit cannot move this turn
				if self.owner.pinned or self.owner.immobilized or self.owner.bogged:
					cannot_move = True
				elif self.owner in scenario.player_unit.squad:
					cannot_move = True
				elif move_finished:
					cannot_move = True
				elif self.owner.fired:
					cannot_move = True
				elif self.owner.towed_by is not None:
					cannot_move = True
				
				if (self.owner.GetStat('category') == 'Gun' or self.owner.GetStat('deploy_to_fire') is not None) and self.owner.deployed:
					if self.owner.GetStat('size_class') is None:
						cannot_move = True
					else:
						if self.owner.GetStat('size_class') != 'Very Small':
							cannot_move = True
				
				# infantry and guns can only make one move per turn
				if self.owner.moving and self.owner.GetStat('movement_class') in ['Infantry', 'Gun']:
					cannot_move = True
				
				# limbered guns cannot move on their own
				elif self.owner.towed_by is not None:
					cannot_move = True
				
				if cannot_move:
					hex_list = []
					AISpyMsg('Unit unable to move this turn.')
				
				# already moved or fired in a previous action
				if self.owner.moving or self.owner.fired:
					hex_list = []
					AISpyMsg('Unit already moved/fired in a previous action.')
				
				move_list = []
				for (hx, hy) in hex_list:
					
					# occupied by active enemy unit(s)
					if len(scenario.hex_dict[(hx,hy)].unit_stack) > 0:
						avoid_hex = False
						for unit in scenario.hex_dict[(hx,hy)].unit_stack:
							if not unit.alive: continue
							if unit.owning_player != self.owner.owning_player:
								avoid_hex = True
								break
						if avoid_hex:
							AISpyMsg('Avoided an enemy-held hex: ' + str(hx) + ',' + str(hy))
							continue
					
					dist = GetHexDistance(0, 0, hx, hy)
					
					# base score
					if self.owner.GetStat('category') in ['Vehicle', 'Cavalry']:
						score = 20.0
					else:
						score = 5.0
					if self.attitude == 'Withdraw':
						score += 20.0
					score += float(libtcod.random_get_int(0, 0, 5))
					
					# enemy unit
					if self.owner.owning_player == 1:
					
						# moving closer to player
						if dist < current_distance:
					
							if self.owner.GetStat('close_combat_team') is not None:
								score += 70.0
							elif self.owner.transport is not None:
								score += 55.0
							elif self.owner.unit_id in ['AT Rifle Team', 'HMG Team']:
								score += 30.0
							elif current_distance > 1:
								# increase chance if armed with FTR with fuel
								for weapon in self.owner.weapon_list:
									if weapon.GetStat('type') == 'Flame Thrower':
										if weapon.flame_ammo > 0:
											score += 50.0
											break
							
							if current_distance <= 1:
								score = 0.0
							elif self.attitude == 'Withdraw' or self.owner.routed:
								score = 0.0
						
						# moving away from the player
						elif dist > current_distance:
							
							if current_distance == 3:
								score -= 15.0
							if scenario.ambush:
								score -= 15.0
							
							if self.attitude == 'Withdraw' or self.owner.routed:
								score += 80.0
							if self.state == 'Heroic':
								score -= 25.0
						
						# Move laterally around the player
						else:
							
							if self.attitude == 'Withdraw':
								score -= 10.0
							elif scenario.player_unit.spotted and scenario.player_unit.facing is not None:
								if GetFacing(self.owner, scenario.player_unit) == 'Front' and hx != 0:
									score += 20.0
						
					# allied unit (not squadmate)
					else:
						
						# rescue units will be more cautious
						if scenario.cd_map_hex.objective is not None:
							if scenario.cd_map_hex.objective['type'] == 'Rescue':
								if self.owner == scenario.cd_map_hex.objective['rescue_unit']:
									for unit in scenario.units:
										if not unit.alive: continue
										if unit.owning_player == 0: continue
										score -= round(30.0 / float(GetHexDistance(unit.hx, unit.hy, hx, hy)), 2)
						
						# units may want to move toward enemy targets
						if ('close_combat_team' in self.owner.stats or enemies_out_of_range) and adjacent_enemies == 0:
							for unit in scenario.units:
								if not unit.alive: continue
								if unit.owning_player == 0: continue
								if GetHexDistance(unit.hx, unit.hy, self.owner.hx, self.owner.hy) == 1: continue
								score += round(60.0 / float(GetHexDistance(unit.hx, unit.hy, hx, hy)), 1)
						
					
					# general movement modifiers
					if self.owner.unit_id == 'HMG Team':
						if has_los_to_enemy:
							score -= 20.0
						else:
							score -= 5.0
					elif self.owner.dug_in or self.owner.entrenched or self.owner.fortified:
						score -= 20.0
					elif not enemies_out_of_range:
						score -= 10.0
					
					# gun tractor
					if tractor_unit:
						
						# already in the same hex as a gun that it can tow
						gun_in_location = False
						for unit in scenario.hex_dict[self.owner.hx, self.owner.hy].unit_stack:
							if unit == self.owner: continue
							if unit.owning_player != self.owner.owning_player: continue
							if not unit.alive: continue
							if unit.GetStat('type') != 'Gun': continue
							if 'immobile' in unit.stats: continue
							size_class = 'Normal'
							if unit.GetStat('size_class') is not None:
								size_class = unit.GetStat('size_class')
							if TractorCanTow(self.owner.unit_id, size_class):
								gun_in_location = True
								break
						
						if gun_in_location:
							score -= 60.0
						
					
					# if unit is deployed and must pack-up to move, see if it's worth add a pack-up action instead
					if self.owner.GetStat('deploy_to_fire') is not None and self.owner.deployed and not self.owner.pinned:
						if score >= 60.0:
							move_list.append((score, ['Pack-Up']))
						continue
					
					if score > AI_ACTION_MIN:
						move_list.append((score, ['Move', (hx, hy)]))
						
						# reverse driver units automatically add reverse move
						if has_r_driver:
							move_list.append((score, ['Reverse Move', (hx, hy)]))
						
						# for armoured units, see if a Reverse Move action would be useful
						elif is_armoured:
							
							reverse_score = 0
							for unit, threat_score in threat_list.items():
								if GetFacing(unit, self.owner) == 'Front':
									reverse_score += threat_score
									
							if reverse_score >= 250:
								move_list.append((score * 1.5, ['Reverse Move', (hx, hy)]))
								
				
				# if 1+ move actions are possible, copy over the top two
				if len(move_list) > 0:
					move_list.sort(key=lambda x:x[0], reverse=True)
					for entry in move_list[:2]:
						action_list.append(entry)
				
				# Reposition or Pivot toward a target
				if not self.owner.routed and not cannot_move and self.attitude != 'Withdraw' and not self.owner.moving and not is_limber_connected:
				
					# Reposition in place
					score = 0.0
					if not has_los_to_enemy:
						
						# less mobile units less likely to reposition to get LoS
						if self.owner.GetStat('category') in ['Infantry', 'Gun', 'Train Car']:
							score += 3.0
						else:
							score += 25.0
					
					# modify by current terrain TEM
					tem = self.owner.GetTEM()
					if tem != 0.0:
						score -= round(tem * 0.25, 2)
					
					# non-combat unit
					if len(self.owner.weapon_list) == 0:
						score -= 25.0
					
					# deployed and must deploy to fire
					if self.owner.GetStat('deploy_to_fire') is not None and self.owner.deployed:
						score -= 25.0
					
					if self.owner.dug_in or self.owner.entrenched or self.owner.fortified:
						score = 0.0
					elif self.owner.pinned or self.owner.immobilized:
						score = 0.0
					elif self.owner.GetStat('immobile') is not None:
						score = 0.0
					
					if score > AI_ACTION_MIN:
						action_list.append((score, ['Reposition']))
					
					# pivot
					if self.owner.facing is not None:
						
						# pivot to face intended target
						if self.intended_target is not None:
							if GetFacing(self.intended_target, self.owner) != 'Front':
								score = 25.0 + float(libtcod.random_get_int(0, 0, 5))
								if self.owner.pinned or self.owner.immobilized:
									score = 0.0
								elif self.owner.GetStat('immobile') is not None:
									score = 0.0
								elif len(self.owner.weapon_list) == 0:
									score = 0.0
								
								if score > AI_ACTION_MIN:
									action_list.append((score, ['Pivot toward', (self.intended_target.hx, self.intended_target.hy)]))
						
						# pivot to have better armour facing a threat
						elif is_armoured and len(threat_list) > 0:	
							for unit, threat_score in threat_list.items():
								
								if threat_score <= 30: continue
								
								if GetFacing(unit, self.owner) != 'Front':
									score = (15.0 * (100/threat_score))
									
									if self.owner.pinned or self.owner.immobilized:
										score = 0.0
									elif self.owner.GetStat('immobile') is not None:
										score = 0.0
									elif len(self.owner.weapon_list) == 0:
										score = 0.0
									
									if score > AI_ACTION_MIN:
										action_list.append((score, ['Pivot toward', (unit.hx, unit.hy)]))
			
			# Unbog attempt
			if self.owner.bogged and not move_finished and not defensive_fire:
				if enemies_out_of_range or not has_los_to_enemy:
					score = 100.0
				else:
					score = 50.0
				action_list.append((score, ['Attempt Unbog']))
			
			# no possible actions
			if len(action_list) == 0:
				AISpyMsg('No possible actions for ' + self.owner.unit_id)
				activation_over = True
				continue
			
			
			# 5) Rank possible actions, determine winning action, and execute
			#################################################################
			
			AISpyMsg(str(len(action_list)) + ' possible actions for ' + self.owner.unit_id + ':')
			action_list.sort(key=lambda x:x[0], reverse=True)
			if DEBUG:
				n = 1
				for (score, action) in action_list:
					text = '#' + str(n) + ' (' + str(score) + '%): ' + action[0]
					if len(action) > 1:
						
						if action[0] == 'Attack':
							(weapon, target, ammo_type) = action[1]
							text += ' with ' + str(weapon.stats['name']) + ' against ' + target.unit_id
							if ammo_type != '':
								text += ' with: ' + ammo_type
						
						elif action[0] == 'Move':
							(hx, hy) = action[1]
							text += ' to ' + str(hx) + ',' + str(hy)
						
					AISpyMsg(text)
					n += 1
			
			# clear any intended target - would have been used in action calculations
			self.intended_target = None
			
			# run through actions from best to worst, rolling for activation for each one
			action_over = False
			for (score, action) in action_list:
				
				if activation_over: break
				if action_over: break
				
				# for attack actions, the score might not be high, but we may want to try in a future turn
				if action[0] == 'Attack':
					if score <= AI_ACTION_MIN:
						if self.intended_target is None:
							(weapon, target, ammo_type) = action[1]
							self.intended_target = target
							AISpyMsg('Set intended target as: ' + target.unit_id)
						action_over = True
						continue
				
				roll = GetPercentileRoll()
				
				if self.owner.owning_player == 0:
					roll -= 35.0
				else:
					roll -= float(campaign.options['ai_difficulty']) * 15.0
					if campaign.options['ai_difficulty'] >= 1 and 'elite' in self.owner.stats:
						roll -= 15.0
				
				if defensive_fire:
					roll -= 25.0
				
				# did not choose this action, possible that the unit passes the rest of this activation
				if roll > score:
					pass_chance = AI_PASS_TURN_CHANCE
					if self.owner.owning_player == 0:
						pass_chance -= 8.0
					elif self.owner.owning_player == 1 and campaign.options['ai_difficulty'] == -1:
						pass_chance += 5.0
					if defensive_fire:
						pass_chance -= 3.0
					if GetPercentileRoll() <= pass_chance:
						AISpyMsg('Passing, no further action this turn')
						action_over = True
						activation_over = True
					continue
				
				AISpyMsg('Executing action: ' + action[0])
				
				
				##########################################################
				# Surrender
				if action[0] == 'Surrender':
					self.owner.spotted = True
					ShowMessage(self.owner.unit_id + ' has surrendered to you.',
						scenario_highlight=(self.owner.hx, self.owner.hy),
						good_news=True)
					self.owner.DestroyMe(surrender=True)
					action_over = True
					activation_over = True
					continue
				
				
				##########################################################
				# Set Withdraw Status
				elif action[0] == 'Withdraw':
					self.attitude = 'Withdraw'
					AISpyMsg('Withdrawing')
					action_over = True
					activation_over = True
					continue
				
				
				##########################################################
				# Dig In
				elif action[0] == 'Dig In':
					if self.owner.AttemptDigIn():
						text = ' is now dug-in.'
					else:
						text = ' is trying to dig in.'
					if self.owner.owning_player == 0 or self.owner.spotted:
						ShowMessage(self.owner.unit_id + text, scenario_highlight=(self.owner.hx, self.owner.hy))
					action_over = True
					activation_over = True
					continue
				
				
				##########################################################
				# Attempt to Deploy / Pack-Up
				elif action[0] == 'Deploy':
					
					# may need to unlimber first
					if is_limber_connected:
						if self.owner.AttemptUnlimber():
							if not (self.owner.owning_player == 1 and not self.owner.spotted):
								ShowMessage(self.owner.unit_id + ' is now unlimbered.',
									scenario_highlight=(self.owner.hx, self.owner.hy))
						else:
							action_over = True
							continue
					
					if self.owner.AttemptDeploy():
						text = ' is now deployed.'
						self.owner.moving = False
					else:
						text = ' is trying to deploy.'	
					if not (self.owner.owning_player == 1 and not self.owner.spotted):
						ShowMessage(self.owner.unit_id + text,
							scenario_highlight=(self.owner.hx, self.owner.hy))
					action_over = True
					activation_over = True
					continue
	
				elif action[0] == 'Pack-Up':
					if self.owner.AttemptPackup():
						text = ' is now packed-up.'
					else:
						text = ' is trying to pack up.'	
					if not (self.owner.owning_player == 1 and not self.owner.spotted):
						ShowMessage(self.owner.unit_id + text,
							scenario_highlight=(self.owner.hx, self.owner.hy))
					action_over = True
					activation_over = True
					continue
	
	
				##########################################################
				# Move action
				elif action[0] in ['Move', 'Reverse Move']:
					
					(hx, hy) = action[1]
					
					reverse_move = False
					if action[0] == 'Reverse Move':
						reverse_move = True
					
					# if destination is off-map, remove from game
					if (hx, hy) not in scenario.hex_dict:
						self.owner.RemoveFromPlay()
						action_over = True
						activation_over = True
						continue
						
					# turn hull to face destination if required, also change turret facing if any
					pivoted = False
					if self.owner.facing is not None:
						direction = GetDirectionToAdjacent(self.owner.hx, self.owner.hy, hx, hy)
						
						# switch direction if reverse move
						if reverse_move:
							direction = ConstrainDir(direction + 3)
						
						if self.owner.facing != direction:
							self.owner.facing = direction
							pivoted = True
							turret = self.owner.GetStat('turret')
							if turret is not None and self.owner.turret_facing is not None:
								self.owner.PivotTurretToFace(direction)
							for weapon2 in self.owner.weapon_list:
								weapon2.UpdateCoveredHexes()
					
					# set unit statuses
					self.owner.moving = True
					self.owner.dug_in = False
					self.owner.entrenched = False
					self.owner.fortified = False
					self.owner.ClearAcquiredTargets()
					
					# do same for towed unit if any
					if self.owner.towing is not None:
						self.owner.towing.moving = True
					
					# check for double bog check 
					if 'Double Bog Check' in SCENARIO_TERRAIN_EFFECTS[self.owner.terrain]:
						self.owner.DoBogCheck(True)
						if self.owner.bogged:
							if self.owner.spotted:
								ShowMessage(self.owner.GetName() + ' has become bogged down.',
									scenario_highlight=(self.owner.hx, self.owner.hy))
							move_finished = True
							action_over = True
							continue
					
					# do landmine check
					if self.owner.DoLandmineCheck():
						action_over = True
						continue
					
					# do movement roll - add bonus if not pivoted, otherwise reset bonus
					if reverse_move:
						chance = self.owner.reverse_move_chance
						if not pivoted:
							chance += self.owner.reverse_move_bonus
						else:
							self.owner.reverse_move_bonus = 0.0
					else:
						chance = self.owner.forward_move_chance
						if not pivoted:
							chance += self.owner.forward_move_bonus
						else:
							self.owner.forward_move_bonus = 0.0
					
					roll = GetPercentileRoll()
					
					# move was successful
					if roll <= chance:
						
						# move was successful but may be cancelled by a breakdown
						if self.owner.BreakdownCheck():
							ShowMessage(self.owner.GetName() + ' has broken down.',
								scenario_highlight=(self.owner.hx, self.owner.hy))
							action_over = True
							move_finished = True
							continue
						
						# show message to player
						text = self.owner.GetName() + ' moves'
						if reverse_move:
							text += ' in reverse'
						dist1 = GetHexDistance(0, 0, self.owner.hx, self.owner.hy)
						dist2 = GetHexDistance(0, 0, hx, hy)
						if dist2 > dist1:
							text += ' further away.'
						elif dist2 < dist1:
							text += ' closer.'
						else:
							text += '.'
						ShowMessage(text, scenario_highlight=(self.owner.hx, self.owner.hy))
						
						# do sound effect
						PlaySoundFor(self.owner, 'movement')
						
						# show movement animation if destination is on board
						if dist2 <= 3:
							(x1, y1) = scenario.PlotHex(self.owner.hx, self.owner.hy)
							(x2, y2) = scenario.PlotHex(hx, hy)
							self.owner.animation_cells = GetLine(x1, y1, x2, y2)
							
							# animate movement
							for i in range(6):
								if len(self.owner.animation_cells) > 0:
									self.owner.animation_cells.pop(0)
								scenario.UpdateUnitCon()
								scenario.UpdateScenarioDisplay()
								Wait(15)
							self.owner.animation_cells = []
						
						# clear any bonus and move into new hex
						if reverse_move:
							self.owner.reverse_move_chance = BASE_REVERSE_MOVE_CHANCE
							self.owner.reverse_move_bonus = 0.0
						else:
							self.owner.forward_move_chance = BASE_FORWARD_MOVE_CHANCE
							self.owner.forward_move_bonus = 0.0
						
						# remove from hex stack if unit is still on map
						if GetHexDistance(0, 0, self.owner.hx, self.owner.hy) <= 3:
							scenario.hex_dict[(self.owner.hx, self.owner.hy)].unit_stack.remove(self.owner)
						self.owner.hx = hx
						self.owner.hy = hy
						scenario.hex_dict[(hx, hy)].unit_stack.append(self.owner)
						for weapon2 in self.owner.weapon_list:
							weapon2.UpdateCoveredHexes()
						
						# move towed unit as well if any
						if self.owner.towing is not None:
							unit2 = self.owner.towing
							if GetHexDistance(0, 0, unit2.hx, unit2.hy) <= 3:
								scenario.hex_dict[(unit2.hx, unit2.hy)].unit_stack.remove(unit2)
							unit2.hx = hx
							unit2.hy = hy
							scenario.hex_dict[(hx, hy)].unit_stack.append(unit2)
							for weapon2 in unit2.weapon_list:
								weapon2.UpdateCoveredHexes()
						
					
					# move was not successful
					else:
						if self.owner.owning_player == 0 or self.owner.spotted:
							PlaySoundFor(self.owner, 'movement')
							text = self.owner.GetName() + ' moves but not far enough to enter a new hex.'
							ShowMessage(text, scenario_highlight=(self.owner.hx, self.owner.hy))
						if reverse_move:
							self.owner.reverse_move_bonus += BASE_MOVE_BONUS
						else:
							self.owner.forward_move_bonus += BASE_MOVE_BONUS
					
					# generate new terrain, LoS, etc.
					self.owner.GenerateTerrain()
					scenario.GenerateUnitLoS(self.owner)
					self.owner.CheckForHD()
					self.owner.SetSmokeDustLevel()
					
					# do same for towed unit if any
					if self.owner.towing is not None:
						unit2 = self.owner.towing
						unit2.terrain = self.owner.terrain
						scenario.GenerateUnitLoS(unit2)
						unit2.CheckForHD()
						unit2.SetSmokeDustLevel()
					
					# recalculate move chances and do bog check in new location
					self.owner.CalculateMoveChances()
					self.owner.DoBogCheck(True)
					
					if self.owner.bogged:
						if self.owner.owning_player == 0 or self.owner.spotted:
							ShowMessage(self.owner.GetName() + ' has become bogged down.',
								scenario_highlight=(self.owner.hx, self.owner.hy))
						move_finished = True
						action_over = True
						activation_over = True
						continue
					
					# check for extra move
					if not self.owner.ExtraMoveCheck():
						move_finished = True
					
					action_over = True
					continue
				
				
				##########################################################
				# Attempt to Unbog
				elif action[0] == 'Attempt Unbog':
					if self.owner.DoUnbogCheck():
						if self.owner.spotted:
							ShowMessage(self.owner.GetName() + ' has unbogged itself.',
								scenario_highlight=(self.owner.hx, self.owner.hy))
						AISpyMsg('Unbogged')
					if not self.owner.ExtraMoveCheck():
						move_finished = True
					action_over = True
					continue
				
				
				##########################################################
				# Unload passengers action
				elif action[0] == 'Unload Passengers':
					# try to spawn passenger
					unit = self.owner.UnloadPassengers()
					if unit is not None:
						# withdraw if not otherwise armed
						if len(self.owner.weapon_list) == 0:
							self.attitude = 'Withdraw'
						if self.owner.spotted:
							ShowMessage(self.owner.GetName() + ' has unloaded a ' + unit.GetName() + ' unit!',
								scenario_highlight=(self.owner.hx, self.owner.hy))
						action_over = True
					continue
				
				
				##########################################################
				# Reposition action
				elif action[0] == 'Reposition':
					
					# set statuses
					self.owner.moving = True
					self.owner.dug_in = False
					self.owner.entrenched = False
					self.owner.fortified = False
					self.owner.ClearAcquiredTargets()
					
					# do bog check
					if self.owner.DoBogCheck(True, reposition=True):
						if self.owner.spotted:
							ShowMessage(self.owner.GetName() + ' has become bogged down.')
						AISpyMsg('Bogged during reposition attempt')
						action_over = True
						activation_over = True
						continue
					
					if self.owner.owning_player == 1 and self.owner.spotted:
						ShowMessage(self.owner.GetName() + ' repositions itself.', 
							scenario_highlight=(self.owner.hx, self.owner.hy))
					
					# breakdown during attempt
					if self.owner.BreakdownCheck(reposition=True):
						ShowMessage(self.owner.GetName() + ' has broken down.',
							scenario_highlight=(self.owner.hx, self.owner.hy))
					else:
						self.owner.GenerateTerrain()
						scenario.GenerateUnitLoS(self.owner)
						self.owner.CheckForHD()
						self.owner.SetSmokeDustLevel()
					action_over = True
					
					# deployed and must deploy to fire - no more actions allowed
					if self.owner.GetStat('deploy_to_fire') is not None and self.owner.deployed:
						activation_over = True
					
					continue
				
				
				##########################################################
				# Pivot toward a target unit
				elif action[0] == 'Pivot toward':
					(hx, hy) = action[1]
					direction = GetDirectionToward(self.owner.hx, self.owner.hy, hx, hy)
					self.owner.facing = direction
					if self.owner.GetStat('turret') is not None and self.owner.turret_facing is not None:
						hextants_pivoted = direction - self.owner.facing
						self.owner.PivotTurretToFace(ConstrainDir(self.owner.turret_facing + hextants_pivoted))
					self.owner.ClearAcquiredTargets(no_enemy=True)
					for weapon2 in self.owner.weapon_list:
						weapon2.UpdateCoveredHexes()
					scenario.UpdateUnitCon()
					scenario.UpdateScenarioDisplay()
					AISpyMsg('Pivoted to face: ' + str(hx) + ',' + str(hy))
					action_over = True
					continue
				
				
				##########################################################
				# Attack action
				elif action[0] == 'Attack':
					(weapon, target, ammo_type) = action[1]
					
					# pivot or rotate turret if required
					mount = weapon.GetStat('mount')
					if mount is not None and (target.hx, target.hy) not in weapon.covered_hexes:
						
						direction = GetDirectionToward(self.owner.hx, self.owner.hy, target.hx, target.hy)
						
						if mount == 'Turret' and self.owner.turret_facing is not None:
							
							# fixed turret - pivot hull too
							if self.owner.GetStat('turret') in ['FIXED', 'FXT']:
								self.owner.facing = direction
								self.owner.PivotTurretToFace(direction)
								self.owner.ClearAcquiredTargets(no_enemy=True)
								AISpyMsg('Unit pivoted hull to fire from fixed turret')
							else:
								self.owner.PivotTurretToFace(direction)
								AISpyMsg('Unit rotated turret to fire') 
						
						elif mount == 'Hull' and self.owner.facing is not None:
							self.owner.facing = direction
							if self.owner.turret_facing is not None:
								self.owner.PivotTurretToFace(direction)
							self.owner.ClearAcquiredTargets(no_enemy=True)
							AISpyMsg('Unit pivoted hull to fire') 
						
						scenario.UpdateUnitCon()
						scenario.UpdateScenarioDisplay()
						for weapon2 in self.owner.weapon_list:
							weapon2.UpdateCoveredHexes()
					
					# check for need for hull pivot due to blocked firing direction
					if mount is not None and self.owner.turret_facing is not None:
						if mount == 'Turret' and self.owner.GetStat('turret') not in ['FIXED', 'FXT']:
							blocked_dirs = weapon.GetStat('blocked_hull_dirs')
							if blocked_dirs is not None:
								direction = ConstrainDir(self.owner.turret_facing - self.owner.facing)
								if str(direction) in blocked_dirs:
									self.owner.facing = ConstrainDir(self.owner.facing + 3)
									self.owner.ClearAcquiredTargets(no_enemy=True)
								for weapon2 in self.owner.weapon_list:
									weapon2.UpdateCoveredHexes()
					
					# move target to top of hex stack and re-draw screen
					target.MoveToTopOfStack()
					scenario.UpdateUnitCon()
					
					# set ammo type if any
					if weapon.GetStat('type') == 'Gun' and ammo_type != '':
						weapon.ammo_type = ammo_type
						
						# use RR if possible
						if 'ammo_type_list' in weapon.stats:
							weapon.using_rr = False
							if ammo_type in weapon.ready_rack:
								if weapon.ready_rack[ammo_type] > 0:
									weapon.using_rr = True
					
					# set firing crewman status
					if weapon.GetStat('fired_by') is not None and self.owner.positions_list is not None:
						crewman_found = False
						for position_name in weapon.GetStat('fired_by'):
							for position in self.owner.positions_list:
								if position.name != position_name: continue
								if position.crewman is None: continue
								if not position.crewman.alive: continue
								crewman_found = True
								crewmen_acted.append(position.crewman)
								AISpyMsg('An AI crewman acted by firing a weapon: ' + position_name + ' fired ' + weapon.stats['name'], add_space=True)
								break
							if crewman_found: break
					
					# do the attack!
					result = self.owner.Attack(weapon, target)
					
					if not result:
						AISpyMsg('ERROR: Tried to attack but it was not possible!')
					else:
						action_over = True
					
					# clear the LoS depiction
					scenario.UpdateGuiCon()
					scenario.UpdateScenarioDisplay()
					libtcod.console_flush()
					
					continue
					
				else:
					AISpyMsg('ERROR: Unrecognized action: ' + action[0])
					continue
				
				# record this action and continue
				self.previous_action = action
			
			# did not roll any action
			if not action_over:
				activation_over = True
				AISpyMsg('No action rolled for ' + self.owner.unit_id)
	
		# activation finished
		AISpyMsg(self.owner.unit_id + ' is finished acting.\n')



# Unit Class: represents a single vehicle or gun, or a squad or small team of infantry
class Unit:
	def __init__(self, unit_id, is_player=False, owning_player=0):
		
		self.unit_id = unit_id			# unique ID for unit type
		self.nick_name = ''			# nickname for model, eg. Sherman
		self.unit_name = ''			# name of tank, etc.
		self.owning_player = owning_player	# unit is allied to 0:player 1:enemy
		self.nation = None			# nationality of unit and personnel
		self.ai = None				# AI controller if any
		self.is_player = is_player		# unit is controlled by player
		self.squad = None			# list of units in player squad
		self.ko_hit = False			# unit has taken a KO hit during the day
		
		self.positions_list = []		# list of crew/personnel positions
		
		# load unit stats
		if unit_id not in session.unit_types:
			print('ERROR: Could not find unit id: ' + unit_id)
			self.unit_id = None
			return
		self.stats = session.unit_types[unit_id].copy()
		
		if 'nick_name' in self.stats:
			self.nick_name = self.stats['nick_name']
		
		if 'crew_positions' in self.stats:
			for position_dict in self.stats['crew_positions']:
				self.positions_list.append(Position(self, position_dict))
		
		# roll for HVSS if any
		if 'HVSS' in self.stats:
			if campaign.today < '1944.12.01':
				del self.stats['HVSS']
			else:
				chance = float(self.stats['HVSS'])
				if GetPercentileRoll() <= chance:
					self.stats['HVSS'] = True
				else:
					del self.stats['HVSS']
		
		# set up weapons
		self.weapon_list = []
		if 'weapon_list' in self.stats:
			for weapon_dict in self.stats['weapon_list']:
				if 'available_from' in weapon_dict:
					if weapon_dict['available_from'] > campaign.today:
						continue
				self.weapon_list.append(Weapon(self, weapon_dict))
		
		# set up radio info
		self.has_radio = False
		if 'armour' in self.stats and self.stats['category'] == 'Vehicle':
			if 'no_radio' not in self.stats:
				self.has_radio = True
			elif 'radio_after' in self.stats:
				if campaign.today >= self.stats['radio_after']:
					self.has_radio = True
			
		self.radio_damaged = False
		self.radio_destroyed = False
		
		# placeholder for transport
		self.transport = None
		
		# set up initial scenario statuses
		self.ResetMe()
	
	
	# set/reset all scenario statuses for this unit
	def ResetMe(self):
		
		self.alive = True			# unit is alive
		
		self.hx = 0				# location in scenario hex map
		self.hy = 0
		self.terrain = None			# surrounding terrain
		self.terrain_seed = 0			# seed for terrain depiction greebles
		self.dest_hex = None			# destination hex for move
		self.animation_cells = []		# list of x,y unit console locations for animation
		
		self.los_table = {}			# other units to which this one has line of sight
		self.spotted = False			# unit has been spotted by opposing side
		self.smoke = 0				# unit smoke level
		self.dust = 0				# unit dust level
		
		self.hull_down = []			# list of directions unit in which Hull Down
		self.moving = False			# unit has moved this turn
		self.broken_down = False		# unit is broken down, immobile but can be repaired
		self.left_squad = False			# unit left the player squad due to breakdown
		self.immobilized = False		# unit is immobilized
		self.overrun = False			# unit is doing an overrun attack (player and player squad only)
		self.bogged = False			# unit is bogged down, cannot move or pivot
		self.fired = False			# unit has fired at least one weapon this turn
		self.hit_by_fp = False			# was hit by an effective fp attack this turn
		self.hit_by_ft = False			# was hit by a flame thrower attack this turn
		
		self.towed_by = None			# unit is a gun hitched to a tractor unit
		self.towing = None			# unit is a tractor hitched to a gun unit
		
		self.facing = None			# unit is facing this direction
		self.previous_facing = None
		self.turret_facing = None
		self.previous_turret_facing = None
		
		self.pinned = False			# unit is pinned down - guns, infantry, and cavalry only
		self.deployed = False			# for guns and mortar teams
		self.unit_fatigue = 0			# unit fatigue points
		self.reduced = False			# unit has been reduced through casualites
		self.routed = False			# unit has been routed
		
		self.dug_in = False			# unit is dug-in
		self.entrenched = False			# " entrenched
		self.fortified = False			# " fortified
		
		self.forward_move_chance = 0.0		# set by CalculateMoveChances()
		self.reverse_move_chance = 0.0
		self.bog_chance = 0.0			# "
		
		self.forward_move_bonus = 0.0
		self.reverse_move_bonus = 0.0
		self.hd_attempt_bonus = 0.0
		
		self.fp_to_resolve = 0			# fp from attacks to be resolved
		self.ap_hits_to_resolve = []		# list of unresolved AP hits
		self.he_hits_to_resolve = []		# " HE hits
		
		for weapon in self.weapon_list:
			weapon.selected_target = None
			weapon.acquired_target = None
	
	
	# reset this unit for new turn
	def ResetForNewTurn(self, skip_smoke=False):
		
		# check for smoke and dust dispersal
		if not skip_smoke:
		
			if self.smoke > 0:
				roll = GetPercentileRoll()
				
				if self.moving:
					roll -= 5.0
				
				if campaign_day.weather['Precipitation'] == 'Rain':
					roll -= 5.0
				elif campaign_day.weather['Precipitation'] == 'Heavy Rain':
					roll -= 15.0
				
				if campaign_day.weather['Wind'] >= 2:
					roll -= 25.0
				
				if roll <= 5.0:
					self.smoke -= 1
					
					# show message if player
					if self == scenario.player_unit:
						if self.smoke > 0:
							ShowMessage('Some of the smoke nearby disperses somewhat.')
						else:
							ShowMessage('The smoke nearby has completely dispersed.')
						scenario.UpdatePlayerInfoCon()
			
			if self.dust > 0:
				roll = GetPercentileRoll()
				if not self.moving:
					roll -= 20.0
				
				if campaign_day.weather['Precipitation'] == 'Rain':
					roll -= 35.0
				elif campaign_day.weather['Precipitation'] == 'Heavy Rain':
					roll -= 55.0
				elif campaign_day.weather['Wind'] == 0:
					roll -= 10.0
				
				if roll <= 5.0:
					self.dust -= 1
					if self == scenario.player_unit:
						if self.dust > 0:
							ShowMessage('Some of the dust around you has settled.')
						else:
							ShowMessage('The dust around you has completely settled.')
						scenario.UpdatePlayerInfoCon()
		
		self.moving = False
		self.previous_facing = self.facing
		self.previous_turret_facing = self.turret_facing
		
		self.fired = False
		for weapon in self.weapon_list:
			weapon.ResetMe()
		
		# select first player weapon if none selected so far
		if self == scenario.player_unit:
			if scenario.selected_weapon is None:
				scenario.selected_weapon = self.weapon_list[0]
		
		# update crew positions
		for position in self.positions_list:
			
			# update visible hexes
			position.UpdateVisibleHexes()
			
			if position.crewman is None: continue
			
			# check for crew condition or injury change
			position.crewman.DoInjuryCheck()

	
	# check for the value of a stat, return None if stat not present
	def GetStat(self, stat_name):
		if stat_name not in self.stats:
			return None
		return self.stats[stat_name]
	
	
	# player unit only - check for spalling injuries from an incoming attack
	# if location is None, all locations will be affected
	def CheckForSpallingInjuries(self, location):
		if not self.is_player: return
		for position in self.positions_list:
			if position.crewman is None: continue
			if position.location is not None:
				if position.location != location: continue
			position.crewman.ResolveAttack({'spalling':True})
			if scenario is not None:
				scenario.UpdateCrewInfoCon()
	
	
	# player unit only - set gun RR use based on current status
	def SetGunRRUse(self):
		if not self.is_player: return
		for weapon in self.weapon_list:
			if weapon.rr_size == 0 or weapon.ammo_type is None: continue
			if weapon.broken or weapon.jammed: continue
			
			# switch to using RR if possible
			if not weapon.using_rr and not self.moving:
				if weapon.ready_rack[weapon.ammo_type] > 0:
					weapon.using_rr = True
			
			# switch off using RR if possible
			elif weapon.using_rr and self.moving:
				if weapon.ammo_stores[weapon.ammo_type] > 0:
					weapon.using_rr = False
		
	
	# player unit only - crewmen have a chance to button up or hunker down in advance of an enemy air/artillery attack
	def CrewButtonUpCheck(self):
		if not self.is_player: return
		for position in self.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			if not position.crewman.ce: continue
			
			# crewmen in OT or always CE positions can test to hunker down
			if position.open_top or position.crew_always_ce:
				if position.crewman.DoPerceptionCheck(0):
					position.crewman.current_cmd = 'Hunker Down'
					ShowMessage('Your crewman hunkers down before the attack:',
						crewman=position.crewman, good_news=True)
				continue
			
			if not position.hatch: continue
			if position.crewman.DoPerceptionCheck(0):
				if position.crewman.ToggleHatch():
					ShowMessage('Your crewman buttons up before the attack:',
						crewman=position.crewman, good_news=True)
	
	# pivot the turret of this unit to face the given direction
	def PivotTurretToFace(self, direction):
		if 'turret' not in self.stats: return
		if self.facing is None: return
		
		# fixed turrets always set to hull facing direction
		if self.GetStat('turret') in ['FIXED', 'FXT']:
			self.turret_facing = self.facing
		else:
			self.turret_facing = direction
		
	
	# called at spawn, check for the additional spawning of a tractor unit
	def CheckForTractorSpawn(self, force_tractor=False):
		
		if self.GetStat('category') != 'Gun': return
		if self.GetStat('immobile') is not None: return
		
		# some missions won't have tractors
		if self.owning_player == 1 and campaign_day.mission in ['Amphibious Assault', 'Urban Assault']:
			return
		
		# chance of spawn depends on whether unit is being spawned in friendly territory or not
		if scenario.cd_map_hex.controlled_by != self.owning_player:
			chance = 95.0
		else:
			chance = 15.0
		if force_tractor: chance = 100.0
		
		if GetPercentileRoll() > chance:
			return
		
		# choose tractor unit to spawn - build a list of all possible tractors first
		unit_list = []
		unit_list.append('Horse Limber')
		unit_list.append('Large Horse Limber')
		
		# add any tractor units from nation defs
		if 'gun_tractors' in session.nations[self.nation]:
			for unit_id in session.nations[self.nation]['gun_tractors']:
				
				# make sure there is a definition for this tractor
				if unit_id not in session.unit_types: continue
				unit_list.append(unit_id)
		
		# prune out tractors that cannot tow this size of gun
		size_class = 'Normal'
		if self.GetStat('size_class') is not None:
			size_class = self.GetStat('size_class')
		
		for unit_id in reversed(unit_list):
			if 'towing_capacity' not in session.unit_types[unit_id]:
				unit_list.remove(unit_id)
				continue
			if not TractorCanTow(unit_id, size_class):
				unit_list.remove(unit_id)
				continue
		
		# could not find any applicable tractor units
		if len(unit_list) == 0: return
		
		# go through list, rolling against rarity, until one is selected or list runs out
		unit_id = None
		shuffle(unit_list)
		
		for tractor_id in unit_list:
			if campaign.DoRarityCheck(tractor_id):
				unit_id = tractor_id
				break
		
		# unable to roll a tractor unit
		if unit_id is None: return
		
		# spawn the tractor unit
		unit = Unit(unit_id, owning_player=self.owning_player)
		unit.nation = self.nation
		unit.ai = AI(unit)
		unit.ai.Reset()
		unit.GenerateNewPersonnel()
		unit.SpawnAt(self.hx, self.hy)
		
		# set tractor facing if required
		if unit.GetStat('category') != 'Cavalry':
			if self.facing is not None:
				unit.facing = self.facing
			else:
				unit.facing = GetDirectionToward(unit.hx, unit.hy, 0, 0)
		scenario.GenerateUnitLoS(unit)
		
		# determine if gun is currently hitched up to tractor
		# never hitched up if already deployed
		if self.deployed: return
		
		if scenario.cd_map_hex.controlled_by != self.owning_player:
			chance = 50.0
		else:
			chance = 5.0
		
		if GetPercentileRoll() <= chance:
			self.towed_by = unit
			unit.towing = self
	
	
	# called at spawn, see if this unit starts deployed
	def DeploymentCheck(self):
		if self.GetStat('category') != 'Gun' and self.GetStat('deploy_to_fire') is None: return
		
		# still hooked up to tractor
		if self.towed_by is not None: return
		
		# enemy or neutral territory
		if scenario.cd_map_hex.controlled_by != self.owning_player:
			return
		
		# some missions have automatic deployment
		if self.owning_player == 1 and campaign_day.mission in ['Amphibious Assault', 'Urban Assault']:
			self.deployed = True
			return
		
		chance = 80.0
		
		size_class = self.GetStat('size_class')
		if size_class is not None:
			if size_class in ['Very Small', 'Small']:
				chance += 15.0
		
		if GetPercentileRoll() <= chance:
			self.deployed = True
	
	
	# attempt to deploy during a battle
	def AttemptDeploy(self):
		if self.GetStat('category') != 'Gun' and self.GetStat('deploy_to_fire') is None: return False
		if self.deployed: return False
		
		self.moving = True
		
		chance = 65.0
		if self.pinned:
			chance -= 50.0
		
		size_class = self.GetStat('size_class')
		if size_class is not None:
			if size_class in ['Very Small', 'Small']:
				chance += 15.0
			elif size_class == 'Large':
				chance -= 15.0
			elif size_class == 'Very Large':
				chance -= 25.0
			elif size_class == 'Extra Large':
				chance -= 35.0
		if self.GetStat('category') == 'Infantry':
			chance += 20.0
		if GetPercentileRoll() <= chance:
			self.deployed = True
			
			# have deployed unit face the nearest enemy unit
			closest_enemy_hexes = []
			for distance in range(1, 6):
				for (hx, hy) in GetHexRing(self.hx, self.hy, distance):
					
					# break if we have already found one closer
					if len(closest_enemy_hexes) > 0:
						if closest_enemy_hexes[0][2] < distance:
							break
					
					if (hx, hy) not in scenario.hex_dict: continue
					if len(scenario.hex_dict[(hx,hy)].unit_stack) == 0: continue
					for unit in scenario.hex_dict[(hx,hy)].unit_stack:
						if not unit.alive: continue
						if unit.owning_player != self.owning_player:
							closest_enemy_hexes.append((hx, hy, distance))
							break
			
			if len(closest_enemy_hexes) > 0:
				
				# choose a random hex from the list and face it
				(hx, hy, distance) = choice(closest_enemy_hexes)
				self.facing = GetDirectionToward(self.hx, self.hy, hx, hy)
				for weapon in self.weapon_list:
					weapon.UpdateCoveredHexes()
			
			return True
		return False
	
	
	# attempt to pack up during a battle
	def AttemptPackup(self):
		if self.GetStat('category') != 'Gun' and self.GetStat('deploy_to_fire') is None: return False
		if not self.deployed: return False
		
		self.moving = True
		
		chance = 25.0
		if self.pinned:
			chance -= 20.0
		size_class = self.GetStat('size_class')
		if size_class is not None:
			if size_class in ['Very Small', 'Small']:
				chance += 10.0
			elif size_class == 'Large':
				chance -= 15.0
			elif size_class == 'Very Large':
				chance -= 20.0
			elif size_class == 'Extra Large':
				chance -= 30.0
		if self.GetStat('category') == 'Infantry':
			chance += 25.0
		
		roll = GetPercentileRoll()
		if roll <= chance:
			self.deployed = False
			return True
		return False
	
	
	# attempt to unlimber a gun from a tractor
	def AttemptUnlimber(self):
		if self.towed_by is None: return False
		
		self.moving = True
		
		size_class = self.GetStat('size_class')
		if size_class in ['Very Small', 'Small']:
			chance = 80.0
		elif size_class in ['Large', 'Very Large']:
			chance = 40.0
		else:
			chance = 60.0
		
		# do roll and apply result
		if GetPercentileRoll() <= chance:
			# break the connection
			self.towed_by.towing = None
			self.towed_by = None
			return True
		return False
	
	
	# returns true if this unit has a trained commander but an empty commander position
	def HasMisplacedCommander(self):
		empty_commander_position = False
		commander_in_wrong_position = False
		for position in self.positions_list:
			if position.name in COMMANDER_POSITIONS:
				if position.crewman is None:
					empty_commander_position = True
			else:
				if position.crewman is not None:
					if 'Experienced Commander' in position.crewman.skills:
						commander_in_wrong_position = True
					elif 'Trained Commander' in position.crewman.skills:
						commander_in_wrong_position = True
		if empty_commander_position and commander_in_wrong_position:
			return True
		return False
	
	
	# spawn a transported unit
	# units unloaded from a transport always start moving and packed-up if gun/mortar team
	def UnloadPassengers(self):
		if self.transport is None: return None
		if scenario is None: return None
		unit = Unit(self.transport, owning_player=self.owning_player)
		unit.nation = self.nation
		unit.ai = AI(unit)
		unit.ai.Reset(unloading=True)
		unit.GenerateNewPersonnel()
		unit.SpawnAt(self.hx, self.hy)
		scenario.GenerateUnitLoS(unit)
		if self.spotted:
			unit.spotted = True
		unit.moving = True
		self.transport = None
		return unit
	
	
	# returns true if any personel in the list have the given skill
	# for now, player unit only
	def CrewmanHasSkill(self, position_list, skillname):
		if not self.is_player: return False
		for position in self.positions_list:
			if len(position_list) > 0:
				if position.name not in position_list: continue
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			if position.crewman.condition == 'Unconscious': continue
			if skillname in position.crewman.skills:
				return True
		return False
	
	
	# returns the location on the screen of this unit
	def GetScreenLocation(self):
		(x,y) = scenario.PlotHex(self.hx, self.hy)
		if self.overrun: y -= 1
		return (x,y)
	
	
	# check to see whether this unit regains concealment as a result of being out of LoS
	def DoConcealmentCheck(self):
		
		if not self.spotted: return
		if not self.alive: return
		
		# skip if no enemy units remaining
		all_enemies_dead = True
		for unit in scenario.units:
			if unit.owning_player != self.owning_player and unit.alive:
				all_enemies_dead = False
				break
		if all_enemies_dead: return
		
		for unit, los in self.los_table.items():
			if not unit.alive: continue
			if unit.owning_player == self.owning_player: continue
			# unit has LoS to at least one enemy unit
			if los: return
		
		# no LoS to any alive enemy units, may regain concealment
		chance = BASE_RECONCEAL_CHANCE
		if campaign_day.weather['Precipitation'] == 'Rain':
			chance += 10.0
		elif campaign_day.weather['Precipitation'] in ['Heavy Rain', 'Snow']:
			chance += 15.0
		elif campaign_day.weather['Precipitation'] == 'Blizzard':
			chance += 20.0
		
		roll = GetPercentileRoll()
		if roll <= chance:
			# don't display message if friendly unit
			if self.is_player or self.owning_player == 1:
				if self.is_player:
					text = 'You are now Unspotted.'
				else:
					text = self.GetName() + ' is now Unspotted.'
				ShowMessage(text, portrait=self, scenario_highlight=(self.hx, self.hy))
			self.spotted = False
			
	
	# clear all ammo loads for all guns in this unit
	def ClearGunAmmo(self):
		for weapon in self.weapon_list:
			if weapon.GetStat('type') != 'Gun': continue
			for ammo_type in AMMO_TYPES:
				if ammo_type in weapon.ammo_stores:
					weapon.ammo_stores[ammo_type] = 0
	
	
	# see if this unit has moved quickly enough to take another move action
	# player only for now
	def ExtraMoveCheck(self, forward=False):
		
		if self.GetStat('movement_class') not in ['Fast Tank', 'Fast Wheeled']:
			return False
		if self.overrun:
			return False
		
		if self.GetStat('recce') is None:
			chance = 15.0
		else:
			chance = 25.0
		
		if campaign_day.weather['Ground'] == 'Deep Snow':
			chance = round(chance * 0.5, 1)
		elif campaign_day.weather['Ground'] in ['Muddy', 'Snow']:
			chance = round(chance * 0.75, 1)
		
		if self.is_player:
			if not forward and self.GetPersonnelByPosition('Rear Driver') is not None:
				crewman = self.GetPersonnelByPosition('Rear Driver')
			else:
				crewman = self.GetPersonnelByPosition('Driver')
			if crewman is not None:
				modifier = crewman.GetSkillMod('Goldfoot', 25.0)
				if modifier is not None:
					chance += modifier
				else:
					modifier = crewman.GetSkillMod('Leadfoot', 15.0)
					if modifier is not None:
						chance += modifier
		
		if GetPercentileRoll() <= chance:
			return True
		return False

	
	# attempt to dig-in; infantry and guns only
	def AttemptDigIn(self):
		if self.GetStat('category') not in ['Infantry', 'Gun']: return False
		if self.dug_in or self.entrenched or self.fortified: return False
		if 'dug_in_na' in SCENARIO_TERRAIN_EFFECTS[self.terrain]: return False
		if self.terrain in ['Wooden Buildings', 'Woods', 'Rubble']:
			chance = 50.0
		elif self.terrain in ['Brush', 'Broken Ground']:
			chance = 30.0
			if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
				chance = 10.0
		else:
			chance = 15.0
			if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
				chance = 3.0
		if GetPercentileRoll() <= chance:
			self.dug_in = True
			return True
		self.moving = True
		return False
	
	
	# do a bog check
	def DoBogCheck(self, forward, pivot=False, reposition=False):
		if self.GetStat('category') not in ['Vehicle', 'Gun']: return
		if 'tutorial_campaign' in campaign.stats: return
		chance = self.bog_chance
		if pivot:
			chance = chance * 0.25
		elif reposition:
			if not (self.GetStat('deploy_to_fire') is not None and self.deployed):
				chance = chance * 0.5
		elif not forward:
			chance = chance * 1.5 
		chance = round(chance, 1)
		
		if GetPercentileRoll() <= chance:
			self.bogged = True
			if not (self.owning_player == 1 and not self.spotted):
				PlaySoundFor(None, 'bogged')
	
	
	# attempt to unbog unit
	def DoUnbogCheck(self):
		if not self.bogged: return
		
		roll = GetPercentileRoll()
		
		# check for Driver skill
		if self.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Swamprunner'):
			roll -= 25.0
		elif self.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Mudrunner'):
			roll -= 15.0
		
		if roll <= self.GetUnbogChance():
			self.bogged = False
			self.moving = True
			self.ClearAcquiredTargets(movement=True)
			return True
		
		self.ClearAcquiredTargets(no_enemy=True)
		return False
	
	
	# do a vehicle breakdown check
	def BreakdownCheck(self, reposition=False):
		
		# doesn't apply
		if self.broken_down or self.immobilized: return
		if self.GetStat('category') not in ['Vehicle']: return
		if 'tutorial_campaign' in campaign.stats: return
		
		# base roll
		if libtcod.random_get_int(0, 1, 20) != 1: return
		
		if 'very_unreliable' in self.stats:
			chance = 6.0
		elif 'unreliable' in self.stats:
			chance = 3.0
		else:
			chance = 1.0
		
		if campaign_day.weather['Temperature'] == 'Extreme Hot':
			chance += 2.0
		if campaign_day.weather['Precipitation'] == 'Sandstorm':
			chance += 2.0
		
		# possible winter weather modifiers
		winter_modifier = True
		if self.nation == 'Finland':
			winter_modifier = False
		elif self.nation == 'Soviet Union' and campaign.today >= '1941.01.01':
			winter_modifier = False
		
		if winter_modifier:
			if campaign_day.weather['Temperature'] == 'Extreme Cold':
				chance += 2.0
			if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
				chance += 3.0
		
		if self.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Expert Mechanic'):
			chance -= 2.0
		elif self.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Mechanic'):
			chance -= 1.0
		
		if reposition:
			chance = round(chance * 0.5, 1)
		
		roll = GetPercentileRoll()
		
		# permanent immobilization
		if roll <= chance * 0.3:
			self.immobilized = True
		elif roll <= chance:
			self.broken_down = True
		else:
			return
		
		# if during a scenario and unit is part of the player squad, remove it from the squad
		if scenario is not None:
			if self in scenario.player_unit.squad:
				if self.immobilized:
					scenario.player_unit.squad.remove(self)
					ShowMessage(self.unit_id + ' has dropped out of your squad.',
						scenario_highlight=(self.hx, self.hy))
				elif self.broken_down: 
					self.left_squad = True
					scenario.player_unit.squad.remove(self)
					ShowMessage(self.unit_id + ' has temporarily dropped out of your squad.',
						scenario_highlight=(self.hx, self.hy))
	
	
	# check for a landmine hit
	def DoLandmineCheck(self):
		
		if not campaign_day.map_hexes[campaign_day.player_unit_location].landmines:
			return False
		if self.GetStat('category') != 'Vehicle': return False
		
		roll = GetPercentileRoll()
		
		if self.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Very Cautious Driver'):
			roll -= 4.0
		elif self.CrewmanHasSkill(['Driver', 'Co-Driver', 'Rear Driver'], 'Cautious Driver'):
			roll -= 2.0
		
		if roll > LANDMINE_CHANCE:
			return False
		
		# sound effect
		if not (self.owning_player == 1 and not self.spotted):
			PlaySoundFor(None, 'landmine')
		
		# unarmoured vehicles are destroyed here
		if self.GetStat('armour') is None:
			if self.is_player:
				ShowMessage('You have hit a landmine! The explosion rips your ' +
					'vehicle apart.', longer_pause=True, good_news=False)
			elif self.owning_player == 0 or (self.owning_player == 1 and self.spotted):
				ShowMessage(self.GetName() + ' was destroyed by a landmine.',
					longer_pause=True, good_news=False)
			self.DestroyMe(no_vp=True)
			return True
		
		roll = GetPercentileRoll()
		
		if roll > LANDMINE_KO_CHANCE:
			if self.is_player:
				ShowMessage('You have hit a landmine! The explosion shakes your ' +
					'tank but there was no damage.', longer_pause=True)
			elif self.owning_player == 0 or (self.owning_player == 1 and self.spotted):
				ShowMessage(self.GetName() + ' hit a landmine but appears to have ' +
					'suffered no damage.', longer_pause=True)
			return False
		
		# tank immobilized
		if self.is_player:
			ShowMessage('You have hit a landmine! The explosion shakes your vehicle and ' +
				'you stop suddenly. Your vehicle is immobilized.', longer_pause=True,
				good_news=False)
		elif self.owning_player == 0 or (self.owning_player == 1 and self.spotted):
			ShowMessage(self.GetName() + ' hit a landmine and was immobilized.',
				good_news=False)
		self.ImmobilizeMe()
		
		# check for crew injury on player unit
		if self.is_player:
			for position in self.positions_list:
				if position.crewman is None: continue
				if position.location is not None:
					if position.location != 'Hull': continue
				position.crewman.ResolveAttack({'landmine' : True})
				scenario.UpdateCrewInfoCon()
		return True
	
	
	# set a random smoke level for this unit, upon spawn or after move
	# also check for dust generation
	def SetSmokeDustLevel(self):
		
		# smoke
		roll = GetPercentileRoll()
		
		if campaign_day.weather['Wind'] > 0:
			roll -= 1.0
		
		if roll <= 98.0:
			self.smoke = 0
		elif roll <= 99.5:
			self.smoke = 1
		else:
			self.smoke = 2
		
		# dust
		if campaign_day.weather['Ground'] != 'Dry' or campaign_day.weather['Precipitation'] != 'None':
			self.dust = 0
			return
		
		roll = GetPercentileRoll()
		
		if campaign_day.weather['Temperature'] in ['Hot', 'Extreme Hot']:
			if self.moving:
				roll += 25.0
			else:
				roll += 20.0
		if self.terrain in ['Sand', 'Hamada', 'Broken Ground']:
			if self.moving:
				roll += 30.0
			else:
				roll += 15.0
		
		if self.GetStat('category') != 'Vehicle':
			roll -= 25.0
		
		if campaign_day.weather['Wind'] >= 2:
			roll += 15.0
		elif campaign_day.weather['Wind'] == 1:
			roll += 5.0
		
		if roll <= 90.0:
			self.dust = 0
		elif roll <= 95.0:
			self.dust = 1
		else:
			self.dust = 2
		
	
	# returns list of crew in this unit that are vulnerable to small-arms fire
	def VulnerableCrew(self):
		crew_list = []
		for position in self.positions_list:
			if position.crewman is None: continue
			if not position.crewman.ce: continue
			if not position.crewman.alive: continue
			if position.crewman.condition == 'Unconscious': continue
			crew_list.append(position.crewman)
		return crew_list
		
	
	# return a to-hit modifier given current terrain
	def GetTEM(self):
		
		if self.terrain not in SCENARIO_TERRAIN_EFFECTS: return 0.0
		terrain_dict = SCENARIO_TERRAIN_EFFECTS[self.terrain]
		if 'TEM' not in terrain_dict: return 0.0
		tem_dict = terrain_dict['TEM']
		
		if 'All' in tem_dict: return tem_dict['All']
		
		if self.GetStat('category') == 'Vehicle':
			if 'Vehicle' in tem_dict:
				return tem_dict['Vehicle']
		
		if self.GetStat('category') == 'Infantry':
			if 'Infantry' in tem_dict:
				return tem_dict['Infantry']
		
		# Cavalry and Motorcycle teams use different TEM depending on if they are moving or not
		if self.GetStat('category') == 'Cavalry' or self.GetStat('class') == 'Motorcycle Team':
			if self.moving:
				if 'Vehicle' in tem_dict:
					return tem_dict['Vehicle']
			else:
				if 'Infantry' in tem_dict:
					return tem_dict['Infantry']
		
		if self.GetStat('category') == 'Gun':
			if self.deployed:
				if 'Deployed Gun' in tem_dict:
					return tem_dict['Deployed Gun']
			if 'Vehicle' in tem_dict:
				return tem_dict['Vehicle']
		
		return 0.0
	
	
	# get a descriptive name of this unit
	def GetName(self):
		if self.owning_player == 1 and not self.spotted:
			return 'Unspotted Unit'
		return self.unit_id
	
	
	# return the person in the given position
	def GetPersonnelByPosition(self, position_name):
		for position in self.positions_list:
			if position.crewman is None: continue
			if position.name == position_name:
				return position.crewman
		return None
	
	
	# clear any acquired target from this unit, and clear it from any enemy unit
	# if no_enemy, enemy units retain AC on this unit
	def ClearAcquiredTargets(self, no_enemy=False, movement=False):
		if self.weapon_list is not None:
			for weapon in self.weapon_list:
				
				if weapon.acquired_target is None: continue
				
				(ac_target, level) = weapon.acquired_target
				
				# target may have disappeared in the meantime
				if ac_target not in scenario.units or ac_target not in self.los_table:
					weapon.acquired_target = None
					continue
				
				# gyrostabilized guns may be able to keep an acquired target
				if self.is_player and movement and 'gyro' in self.stats and weapon.GetStat('type') == 'Gun':
					if (ac_target.hx, ac_target.hy) in weapon.covered_hexes and self.los_table[ac_target]:
						crewman = weapon.GetOperatingCrewman()
						if crewman is not None:
							if 'Advanced Gyro Use' in crewman.skills:
								continue
				weapon.acquired_target = None
		if no_enemy: return
		for unit in scenario.units:
			if unit.owning_player == self.owning_player: continue
			if unit.weapon_list is None: continue
			for weapon in unit.weapon_list:
				if weapon.acquired_target is None: continue
				(ac_target, level) = weapon.acquired_target
				if ac_target == self:
					weapon.acquired_target = None
		
	
	# calculate chances of a successful forward/reverse move action for this unit
	# also calculate bog chances
	# Infantry and Cavalry will never be Bogged Down
	def CalculateMoveChances(self):
		
		# set values to base values
		self.forward_move_chance = BASE_FORWARD_MOVE_CHANCE
		self.reverse_move_chance = BASE_REVERSE_MOVE_CHANCE
		self.bog_chance = 0.3
		
		# apply modifier from unit movement type
		movement_class = self.GetStat('movement_class')
		if movement_class == 'Slow Tank':
			self.forward_move_chance -= 15.0
			self.bog_chance += 1.0
		elif movement_class == 'Slow Wheeled':
			self.forward_move_chance -= 10.0
		elif movement_class == 'Fast Tank':
			self.forward_move_chance += 10.0
		elif movement_class == 'Half-Tracked':
			self.forward_move_chance += 5.0
			self.bog_chance -= 0.5
		elif movement_class == 'Wheeled':
			self.forward_move_chance += 5.0
			self.bog_chance += 2.0
		elif movement_class == 'Fast Wheeled':
			self.forward_move_chance += 15.0
			self.bog_chance += 3.0
		elif movement_class == 'Cavalry':
			self.forward_move_chance += 25.0
			self.bog_chance = 0.0
		
		if self.GetStat('powerful_engine') is not None:
			self.forward_move_chance += 5.0
			self.bog_chance -= 0.5
		if self.GetStat('HVSS') is not None:
			self.forward_move_chance += 10.0
			self.reverse_move_chance += 10.0
			self.bog_chance -= 1.5
		
		# apply modifier from current terrain type
		if self.terrain is not None:
			
			# off-road vehicles not affected by terrain
			if self.GetStat('off_road') is None:
			
				if 'Movement Mod' in SCENARIO_TERRAIN_EFFECTS[self.terrain]:
					mod = SCENARIO_TERRAIN_EFFECTS[self.terrain]['Movement Mod']
					self.forward_move_chance += mod
					self.reverse_move_chance += mod
				if 'Bog Mod' in SCENARIO_TERRAIN_EFFECTS[self.terrain]:
					mod = SCENARIO_TERRAIN_EFFECTS[self.terrain]['Bog Mod']
					self.bog_chance += mod

		# apply modifiers for ground conditions
		if campaign_day.weather['Ground'] != 'Dry':
			mod = 0.0
			bog_mod = 0.0
			if campaign_day.weather['Ground'] == 'Deep Snow':
				if movement_class in ['Fast Wheeled', 'Wheeled']:
					mod = -45.0
					bog_mod = 4.0
				elif movement_class == 'Half-Tracked':
					mod = -20.0
					bog_mod = 1.0
				else:
					mod = -30.0
					bog_mod = 2.0
			elif campaign_day.weather['Ground'] in ['Muddy', 'Snow']:
				if movement_class in ['Fast Wheeled', 'Wheeled']:
					mod = -25.0
					bog_mod = 2.0
				elif movement_class == 'Half-Tracked':
					mod = -10.0
					bog_mod = 0.5
				else:
					mod = -15.0
					bog_mod = 1.0
			
			if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
				if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Motti'):
					bog_mod = round(bog_mod * 0.5, 1)
			
			self.forward_move_chance += mod
			self.reverse_move_chance += mod
			self.bog_chance += bog_mod
		
		# ground pressure modifier
		gp = self.GetStat('ground_pressure')
		if gp is not None:
			if gp == 'Light':
				self.bog_chance = round(self.bog_chance * 0.8, 1)
			elif gp == 'Heavy':
				self.bog_chance = round(self.bog_chance * 1.2, 1)
		
		# zone type modifier
		if scenario.cd_map_hex.terrain_type == 'Mountain Pass':
			self.forward_move_chance = round(self.forward_move_chance * 0.8, 1)
			self.reverse_move_chance = round(self.reverse_move_chance * 0.8, 1)
		
		# add bonuses from previous moves if has not pivoted
		if not (self.is_player and scenario.player_pivot != 0):
			self.forward_move_chance += self.forward_move_bonus
			self.reverse_move_chance += self.reverse_move_bonus
		
		if self.GetStat('category') == 'Vehicle':
		
			# add bonuses from commander direction
			for position in COMMANDER_POSITIONS:
				crewman = self.GetPersonnelByPosition(position)
				if crewman is not None:
					if crewman.current_cmd == 'Direct Movement':
						modifier = crewman.GetActionMod(15.0)
						if not crewman.ce: modifier = modifier * 0.5
						self.forward_move_chance += modifier
						modifier = crewman.GetActionMod(10.0)
						if not crewman.ce: modifier = modifier * 0.5
						self.reverse_move_chance += modifier
					break
			
			# apply modifiers for driver / co-driver / rear driver
			for position_name in ['Driver', 'Co-Driver', 'Rear Driver']:
				
				# don't check for a rear driver if unit cannot use one (just in case!)
				if position_name == 'Rear Driver' and self.GetStat('reverse_driver') is None:
					continue
				crewman = self.GetPersonnelByPosition(position_name)
				if crewman is None: continue
				if not crewman.alive: continue
				if crewman.current_cmd not in ['Drive', 'Drive Into Terrain']: continue
				
				# modify move chances
				if crewman.UntrainedPosition():
					self.forward_move_chance = self.forward_move_chance * 0.4
					self.reverse_move_chance = self.reverse_move_chance * 0.4
				
				# skills
				else:
					if 'Very Cautious Driver' in crewman.skills:
						self.bog_chance = self.bog_chance * 0.25
					elif 'Cautious Driver' in crewman.skills:
						self.bog_chance = self.bog_chance * 0.5
					if 'I Said Reverse!' in crewman.skills:
						self.reverse_move_chance = self.reverse_move_chance * 1.4
					elif 'Reverse!' in crewman.skills:
						self.reverse_move_chance = self.reverse_move_chance * 1.2
				
				# penalty for moving into specific terrain
				if crewman.current_cmd == 'Drive Into Terrain':
					self.forward_move_chance = self.forward_move_chance * 0.8
					self.reverse_move_chance = self.reverse_move_chance * 0.8
				
				# CE driver
				if crewman.ce:
					self.forward_move_chance = self.forward_move_chance * 1.3
					self.reverse_move_chance = self.reverse_move_chance * 1.3
				
				# crew fatigue modifier
				if crewman.fatigue > 0:
					self.bog_chance += 0.5 * crewman.fatigue
				
				# swap move chances if reverse driver
				if position_name == 'Rear Driver':
					self.reverse_move_chance,self.forward_move_chance = self.forward_move_chance,self.reverse_move_chance
				
				break
			
		# limit chances
		self.forward_move_chance = RestrictChance(self.forward_move_chance)
		self.reverse_move_chance = RestrictChance(self.reverse_move_chance)
		self.bog_chance = round(self.bog_chance, 1)
		
		if self.bog_chance < 0.1:
			self.bog_chance = 0.1
		elif self.bog_chance > 97.0:
			self.bog_chance = 97.0
	
	
	# calcuclate current chance of this unit unbogging itself
	def GetUnbogChance(self):
		chance = round(100.0 - (10.0 * self.bog_chance), 1)
		if chance < 20.0:
			chance = 20.0
		return chance
	
	
	# calculate current chance of this unit gaining Hull Down
	def GetHDChance(self, driver_attempt=False):
		
		# unit not eligible for HD
		if self.GetStat('category') in ['Infantry', 'Cavalry', 'Gun']: return 0.0
		if self.overrun: return 0.0
		
		# calculate base chance of HD
		if self.terrain not in SCENARIO_TERRAIN_EFFECTS: return 0.0
		chance = SCENARIO_TERRAIN_EFFECTS[self.terrain]['HD Chance']
		
		# apply size modifier
		size_class = self.GetStat('size_class')
		if size_class is not None:
			chance += HD_SIZE_MOD[size_class]
		
		# bonus for driver action and commander direction if any
		if driver_attempt:
			crewman = self.GetPersonnelByPosition('Driver')
			if crewman is None:
				crewman = self.GetPersonnelByPosition('Rear Driver')
			if crewman is not None:
				
				# check for operating crewman in untrained position
				if crewman.UntrainedPosition():
					mod = -20.0
				else:
					mod = crewman.GetActionMod(6.0)
					if not crewman.ce: mod = mod * 0.5
				chance += mod
			
			for position in COMMANDER_POSITIONS:
				crewman = self.GetPersonnelByPosition(position)
				if crewman is None: continue
				if crewman.current_cmd == 'Direct Movement':
					modifier = crewman.GetSkillMod('Lay of the Land', 15.0)
					if modifier is not None:
						chance += modifier
					else:
						modifier = crewman.GetActionMod(5.0)
						if not crewman.ce: modifier = modifier * 0.5
						chance += modifier
				break
		
		# regular move action
		else:
			crewman = self.GetPersonnelByPosition('Driver')
			if crewman is None:
				crewman = self.GetPersonnelByPosition('Rear Driver')
			if crewman is not None:
				if not crewman.UntrainedPosition():
					modifier = crewman.GetSkillMod('Instinct for Cover', 15.0)
					if modifier is not None:
						chance += modifier
					else:
						modifier = crewman.GetSkillMod('Eye for Cover', 5.0)
						if modifier is not None:
							chance += modifier
		
		chance += self.hd_attempt_bonus
		
		return RestrictChance(chance)
	
	
	# upon spawning into a scenario map hex, or after moving or repositioning, roll to
	# see if this unit gains HD status
	# if driver_attempt is True, then the driver is actively trying to get HD
	# if spawn is True, unit is being spawned into a scenario
	def CheckForHD(self, driver_attempt=False, spawn=False):
		
		# Emplacements are automatically HD in all directions
		if self.GetStat('category') == 'Emplacement' and self.GetStat('armour') is not None:
			self.hull_down = [0,1,2,3,4,5]
			return
		
		if self.GetStat('category') != 'Vehicle': return
		if self.facing is None: return
		
		# clear any previous HD status
		self.hull_down = []
		
		chance = self.GetHDChance(driver_attempt=driver_attempt)
		
		# spawned into friendly territory
		if spawn:
			if (self.owning_player == 0 and scenario.player_attacking) or (self.owning_player == 1 and not scenario.player_attacking):
				chance += 40.0
		
		if chance == 0.0: return False
		
		roll = GetPercentileRoll()
		
		# check for debug flag
		if self == scenario.player_unit and DEBUG:
			if session.debug['Player Always HD']:
				roll = 1.0
		
		# unsuccessful
		if roll > chance:
			self.hd_attempt_bonus += BASE_HD_BONUS
			return False
		
		# successful!
		self.hd_attempt_bonus = 0.0
		if driver_attempt or spawn:
			direction = self.facing
		else:
			direction = choice(range(6))
		self.hull_down = [direction]
		self.hull_down.append(ConstrainDir(direction + 1))
		self.hull_down.append(ConstrainDir(direction - 1))
		return True
	
	
	# chance of hitting the hull if firing at this unit.
	def GetHullHitChance(self, ballistic=False):
		if self.GetStat('turret') is None:
			return 100.0
		elif ballistic or self.GetStat('large_turret') is not None:
			return 50.0
		else:
			return 75.0
	
	
	# build lists of possible commands for each personnel in this unit
	def BuildCmdLists(self):
		for position in self.positions_list:
			if position.crewman is None: continue
			position.crewman.BuildCommandList()
			
			# cancel current command if no longer possible
			if position.crewman.current_cmd not in position.crewman.cmd_list:
				position.crewman.current_cmd = position.crewman.cmd_list[0]
			
			# reset first aid action flag
			position.crewman.first_aid_action_taken = False
	
	
	# do a round of spotting from the player unit
	def DoSpotChecks(self):
			
		# unit out of play range
		if GetHexDistance(0, 0, self.hx, self.hy) > 3:
			return
		
		# create a local list of crew positions in a random order
		position_list = sample(self.positions_list, len(self.positions_list))
		
		for position in position_list:
			
			# no crewman in position
			if position.crewman is None:
				continue
			
			# build list of units that it's possible to spot
			spot_list = []
			for unit in scenario.units:
				if unit.owning_player == self.owning_player: continue
				if not unit.alive: continue
				if unit.spotted: continue
				if (unit.hx, unit.hy) not in position.visible_hexes: continue
				if not self.los_table[unit]: continue
				spot_list.append(unit)
			
			# no units possible to spot from this position
			if len(spot_list) == 0: continue
			
			# select a random target unit and attempt to reveal it
			unit = choice(spot_list)
			chance = scenario.CalcSpotChance(self, unit, crewman=position.crewman)
			if GetPercentileRoll() > chance: continue
			
			unit.MoveToTopOfStack()
			unit.SpotMe()
			scenario.UpdateUnitCon()
			scenario.UpdateScenarioDisplay()
			
			ShowTutorialSlide('scenario_crewman_spotted')
			
			# highlight hex
			scenario.animation['hex_highlight'] = (unit.hx, unit.hy)
			scenario.animation['hex_flash'] = 1
			
			# display message
			ShowCrewChatter(None, position.crewman, override_text=unit.GetName() + ' spotted!')
			
			# clear highlight
			scenario.animation['hex_highlight'] = False
			scenario.UpdateAnimCon()
	
	# reveal this unit after being spotted
	def SpotMe(self):
		self.spotted = True
		
		# check for Steam Achievement
		if self.owning_player == 1:
			rarity = campaign.DoRarityCheck(self.unit_id, get_rarity=True)
			if rarity is not False:
				if rarity <= 0.03:
					session.ModifySteamStat('rare_encounter', 1)
		
		if self.is_player: DisplayTimeInfo(scen_time_con)
	
	
	# generate new personnel sufficent to fill all personnel positions
	def GenerateNewPersonnel(self):
		for position in self.positions_list:
			if position.crewman is not None: continue
			position.crewman = Personnel(self, self.nation, position)
		
		# check for player commander
		if not self.is_player: return
		if not campaign.options['permadeath']: return
		
		player_commander_present = False
		for position in self.positions_list:
			if position.crewman is None: continue
			if position.crewman.is_player_commander:
				player_commander_present = True
				break
		if player_commander_present: return
		
		for position in self.positions_list:
			if position.crewman is None: continue
			if position.name not in COMMANDER_POSITIONS: continue
			position.crewman.is_player_commander = True
			return
		
	
	# spawn this unit into the given scenario map hex
	def SpawnAt(self, hx, hy):
		self.hx = hx
		self.hy = hy
		
		scenario.units.append(self)
		for map_hex in scenario.map_hexes:
			if map_hex.hx == hx and map_hex.hy == hy:
				map_hex.unit_stack.append(self)
				break
		
		self.GenerateTerrain()
		self.SetSmokeDustLevel()
	
	
	# randomly determine what kind of terrain this unit is in
	# possible to set a target terrain type
	def GenerateTerrain(self, target_terrain=None):
		
		if target_terrain is not None:
			(terrain, odds) = target_terrain
			if GetPercentileRoll() <= odds:
				self.terrain = terrain
				self.terrain_seed = libtcod.random_get_int(0, 1, 128)
				if self.is_player:
					ShowSimpleMessage('Success, moving into terrain: ' + self.terrain)
				return
		
		self.terrain = None
		self.terrain_seed = 0
		
		if scenario is None: return
		
		self.terrain_seed = libtcod.random_get_int(0, 1, 128)
		odds_dict = CD_TERRAIN_TYPES[scenario.cd_map_hex.terrain_type]['scenario_terrain_odds']
		
		# keep rolling until we find a suitable terrain type
		for tries in range(300):
			terrain, odds = choice(list(odds_dict.items()))
			
			# some scenario terrain is never used in some regions
			if campaign.stats['region'] == 'North Africa':
				if terrain in ['Woods', 'Wooden Buildings', 'Fields', 'Marsh']: continue
			
			if GetPercentileRoll() <= odds:
				self.terrain = terrain
				
				# check to see if dug-in is N/A in this terrain and cancel
				if self.dug_in:
					if 'dug_in_na' in SCENARIO_TERRAIN_EFFECTS[self.terrain]:
						self.dug_in = False
				
				if target_terrain is not None and self.is_player:
					# got lucky!
					if target_terrain[0] == self.terrain:
						ShowSimpleMessage('Success, moving into terrain: ' + self.terrain)
					else:
						ShowSimpleMessage('Check failed, moving into terrain: ' + self.terrain)
				
				return
		
		# if we get here, something has gone wrong, so hopefully the first terrain type is always ok
		for terrain, odds in odds_dict.items():
			self.terrain = terrain
			return
	
	
	# move this unit to the top of its current hex stack
	def MoveToTopOfStack(self):
		if not self.alive: return
		if GetHexDistance(0, 0, self.hx, self.hy) > 3: return
		map_hex = scenario.hex_dict[(self.hx, self.hy)]
		if len(map_hex.unit_stack) == 1: return
		if self not in map_hex.unit_stack: return
		map_hex.unit_stack.remove(self)
		map_hex.unit_stack.insert(0, self)
	
	
	# remove this unit from the scenario
	def RemoveFromPlay(self):
		scenario.hex_dict[(self.hx, self.hy)].unit_stack.remove(self)
		scenario.units.remove(self)
	
	
	# return the display character to use on the map viewport
	def GetDisplayChar(self):
		# player unit
		if self.is_player: return '@'
		
		# unknown enemy unit
		if self.owning_player == 1 and not self.spotted: return '?'
		
		if 'Team' in self.GetStat('class'): return 178
		
		unit_category = self.GetStat('category')
		if unit_category == 'Infantry': return 176
		if unit_category == 'Cavalry': return 252
		if unit_category == 'Train Car': return 7
		
		# gun, set according to deployed status / hull facing
		if unit_category == 'Gun':
			if self.facing is None:		# facing not yet set
				return '!'
			if not self.deployed:
				return 124
			elif self.facing in [5, 0, 1]:
				return 232
			elif self.facing in [2, 3, 4]:
				return 233
			else:
				return '!'		# should not happen
		
		# vehicle
		if unit_category == 'Vehicle':
			
			# turretless vehicle
			if self.turret_facing is None:
				return 249
			return 9

		# default
		return '!'
	
	
	# draw this unit and its terrain to the scenario unit layer console
	def DrawMe(self, x_offset, y_offset):
		
		# don't display if not alive any more
		if not self.alive: return
		
		# determine draw location
		if len(self.animation_cells) > 0:
			(x,y) = self.animation_cells[0]
		else:
			(x,y) = scenario.PlotHex(self.hx, self.hy)
		
		if self.overrun:
			y -= 1
		
		# armoured trains have to be drawn in middle of hex, no room otherwise
		if self.GetStat('class') != 'Armoured Train Car':
			x += x_offset
			y += y_offset
		
		# determine background colour to use
		distance = GetHexDistance(0, 0, self.hx, self.hy)
		if 4 - distance <= campaign_day.weather['Fog']:
			bg_col = libtcod.Color(128,128,128)
		elif scenario.cd_map_hex.terrain_type == 'Beach':
			bg_col = libtcod.Color(102,102,0)
		elif campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
			bg_col = libtcod.Color(191,191,191)
		elif campaign_day.rattenkrieg:
			bg_col = libtcod.Color(77,77,77)
		elif campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
			bg_col = libtcod.Color(0,102,0)
		elif campaign.stats['region'] == 'North Africa':
			bg_col = libtcod.Color(102,82,51)
		elif campaign_day.weather['Season'] == 'Winter':
			bg_col = libtcod.Color(51,41,26)
		else:
			bg_col = libtcod.Color(0,64,0)
		
		# draw terrain greebles - don't draw if currently moving or offset
		if x_offset == 0 and len(self.animation_cells) == 0 and self.terrain is not None and not (self.owning_player == 1 and not self.spotted):
			generator = libtcod.random_new_from_seed(self.terrain_seed)
			
			if self.terrain == 'Open Ground':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if campaign.stats['region'] == 'North Africa':
						break
					if libtcod.random_get_int(generator, 1, 9) <= 2: continue
					
					c_mod = libtcod.random_get_int(generator, 0, 20)
					if campaign_day.rattenkrieg:
						col = libtcod.Color(50+c_mod, 50+c_mod, 50+c_mod)
					elif campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
						col = libtcod.Color(0, 130+c_mod, 0)
					else:
						col = libtcod.Color(30+c_mod, 90+c_mod, 20+c_mod)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 46, col, bg_col)
				
			elif self.terrain == 'Broken Ground':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) <= 2: continue
					c_mod = libtcod.random_get_int(generator, 10, 40)
					col = libtcod.Color(70+c_mod, 60+c_mod, 40+c_mod)
					if libtcod.random_get_int(generator, 1, 10) <= 4:
						char = 250
					else:
						char = 240
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, char, col, bg_col)

			elif self.terrain == 'Brush':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) <= 3: continue
					if campaign.stats['region'] == 'North Africa':
						col = libtcod.Color(32,64,0)
					elif campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
						col = libtcod.Color(0,64,0)
					else:
						col = libtcod.Color(0,libtcod.random_get_int(generator, 80, 120),0)
					if libtcod.random_get_int(generator, 1, 10) <= 6:
						char = 15
					else:
						char = 37
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, char, col, bg_col)
				
			elif self.terrain == 'Woods':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) == 1: continue
					col = libtcod.Color(0,libtcod.random_get_int(generator, 100, 170),0)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 6, col, bg_col)
					
			elif self.terrain in ['Wooden Buildings', 'Stone Buildings']:
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					c_mod = libtcod.random_get_int(generator, 10, 40)
					if self.terrain == 'Wooden Buildings':
						col = libtcod.Color(70+c_mod, 60+c_mod, 40+c_mod)
					else:
						col = libtcod.Color(190+c_mod, 170+c_mod, 140+c_mod)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 249, col, bg_col)
			
			elif self.terrain == 'Hills':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) <= 3: continue
					if campaign.stats['region'] == 'North Africa':
						c_mod = libtcod.random_get_int(generator, -15, 15)
						col = libtcod.Color(160+c_mod,130+c_mod,100+c_mod)
					elif campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
						c_mod = libtcod.random_get_int(generator, 0, 50)
						col = libtcod.Color(200+c_mod,200+c_mod,200+c_mod)
					else:
						c_mod = libtcod.random_get_int(generator, 10, 40)
						col = libtcod.Color(20+c_mod, 110+c_mod, 20+c_mod)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 220, col, bg_col)
				
			elif self.terrain == 'Fields':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) == 1: continue
					if campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
						c = libtcod.random_get_int(generator, 20, 90)
					else:
						c = libtcod.random_get_int(generator, 120, 190)
					col = libtcod.Color(c, c, 0)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
						176, col, bg_col)
			
			elif self.terrain == 'Marsh':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) == 1: continue
					if campaign.stats['region'] in ['South Pacific', 'Southeast Asia']:
						col = libtcod.Color(0,0,140)
					else:
						col = libtcod.Color(45,0,180)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 176,
						col, bg_col)
			
			elif self.terrain == 'Rubble':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) <= 2: continue
					if libtcod.random_get_int(generator, 1, 3) == 1:
						char = 249
					else:
						char = 250
					c = libtcod.random_get_int(generator, 120, 190)
					col = libtcod.Color(c, c, c)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, char,
						col, bg_col)
			
			elif self.terrain == 'Hamada':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) <= 2: continue
					if libtcod.random_get_int(generator, 1, 3) <= 2:
						char = 177
					else:
						char = 250
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, char,
						libtcod.Color(51,51,51), bg_col)
			
			elif self.terrain == 'Sand':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					c = libtcod.random_get_int(generator, 130, 150)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 176,
						libtcod.Color(c,c,0), bg_col)
			
			elif self.terrain == 'Deep Sand':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					c = libtcod.random_get_int(generator, 110, 130)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 177,
						libtcod.Color(c,c,0), bg_col)
			
			# Rattenkrieg terrain
			elif self.terrain == 'Concrete Buildings':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					c_mod = libtcod.random_get_int(generator, 10, 40)
					col = libtcod.Color(130+c_mod, 130+c_mod, 130+c_mod)
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
						249, col, bg_col)
			
			elif self.terrain == 'Boulevard':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
						177, libtcod.grey, bg_col)
			
			elif self.terrain == 'Row Houses':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) <= 2: continue
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 179,
						libtcod.darkest_sepia, bg_col)
			
			elif self.terrain == 'Craters':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 3) == 1: continue
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
						7, libtcod.darkest_grey, bg_col)
			
			# South Pacific / Southeast Asian Terrain
			elif self.terrain == 'Jungle':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 3) == 1: continue
					roll = libtcod.random_get_int(generator, 1, 10)
					if roll == 1:
						col = libtcod.Color(102,82,51)
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
							124, col, bg_col)
					elif roll <= 4:
						col = libtcod.Color(0,64,0)
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
							177, col, bg_col)
					elif roll <= 6:
						col = libtcod.Color(0,64,0)
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
							7, col, bg_col)
					else:
						col = libtcod.Color(0,102,0)
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod,
							167, col, bg_col)
			
			elif self.terrain == 'Cogon Grass':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					if libtcod.random_get_int(generator, 1, 9) == 1: continue
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 176,
						libtcod.Color(108,217,0), bg_col)
			
			elif self.terrain == 'Bamboo Forest':
				col = libtcod.Color(140,140,0)
				col2 = libtcod.Color(0,217,0)
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					roll = libtcod.random_get_int(generator, 1, 10)
					if roll == 1: continue
					if roll <= 8:
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 124, col, bg_col)
					elif roll <= 9:
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 47, col, bg_col)
					else:
						libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 5, col2, bg_col)
			
			elif self.terrain == 'Rice Paddy':
				for (xmod, ymod) in GREEBLE_LOCATIONS:
					libtcod.console_put_char_ex(unit_con, x+xmod, y+ymod, 19,
						libtcod.Color(134,178,0), bg_col)
		
		# determine foreground color to use
		if self.owning_player == 1:
			col = ENEMY_UNIT_COL
		else:	
			if self == scenario.player_unit:
				col = libtcod.white
			else:
				col = ALLIED_UNIT_COL
		
		# enemy units outside of LoS have a different background colour
		# and greeble backgrounds are set to dark
		if self.owning_player == 1:
			if self in scenario.player_unit.los_table:
				if not scenario.player_unit.los_table[self]:
					bg_col = libtcod.darkest_grey
					for (xmod, ymod) in GREEBLE_LOCATIONS:
						libtcod.console_set_char_background(unit_con, x+xmod, y+ymod,
							libtcod.darkest_grey, libtcod.BKGND_SET)
		
		# armoured trains have additional display characters if spotted
		if self.GetStat('class') == 'Armoured Train Car' and not (self.owning_player == 1 and not self.spotted):
			for x1 in range(x-4, x+5):
				libtcod.console_put_char_ex(unit_con, x1, y, 35, libtcod.dark_grey, bg_col)
			for x1 in range(x-1, x+2):
				libtcod.console_put_char_ex(unit_con, x1, y, 219, libtcod.grey, bg_col)
			
		# draw main display character
		libtcod.console_put_char_ex(unit_con, x, y, self.GetDisplayChar(), col, bg_col)
		
		# draw smoke or dust,but don't draw if currently moving
		if x_offset == 0 and len(self.animation_cells) == 0:
			if self.smoke > 0:
				if self.smoke == 1:
					smoke_col = libtcod.dark_grey
				else:
					smoke_col = libtcod.darker_grey
				libtcod.console_put_char_ex(unit_con, x-1, y-1, 177, smoke_col, bg_col)
				libtcod.console_put_char_ex(unit_con, x+1, y-1, 177, smoke_col, bg_col)
				libtcod.console_put_char_ex(unit_con, x-1, y+1, 177, smoke_col, bg_col)
				libtcod.console_put_char_ex(unit_con, x+1, y+1, 177, smoke_col, bg_col)
		
			elif self.dust > 0:
				if self.dust == 1:
					dust_col = libtcod.sepia
				else:
					dust_col = libtcod.light_sepia
				libtcod.console_put_char_ex(unit_con, x-1, y-1, 177, dust_col, bg_col)
				libtcod.console_put_char_ex(unit_con, x+1, y-1, 177, dust_col, bg_col)
				libtcod.console_put_char_ex(unit_con, x-1, y+1, 177, dust_col, bg_col)
				libtcod.console_put_char_ex(unit_con, x+1, y+1, 177, dust_col, bg_col)
		
		# don't draw anything else for concealed enemy units
		if self.owning_player == 1 and not self.spotted: return
		
		# determine if we need to display a turret / gun depiction
		draw_turret = True
		
		if self.GetStat('category') in ['Infantry', 'Cavalry']: draw_turret = False
		if self.GetStat('category') == 'Gun' and not self.deployed: draw_turret = False
		if len(self.weapon_list) == 0: draw_turret = False
		
		if draw_turret:
			# use turret facing if present, otherwise hull facing
			if self.turret_facing is not None:
				facing = self.turret_facing
			else:
				facing = self.facing
			
			# determine location to draw turret/gun character
			x_mod, y_mod = PLOT_DIR[facing]
			char = TURRET_CHAR[facing]
			libtcod.console_put_char_ex(unit_con, x+x_mod, y+y_mod, char, col, bg_col)
		
		# not top of stack
		if x_offset != 0: return
		
		# draw depiction of dug-in, entrenched, or fortified here
		if not self.dug_in and not self.entrenched and not self.fortified: return
		
		if self.dug_in:
			libtcod.console_put_char_ex(unit_con, x-1, y, 174, libtcod.dark_sepia, bg_col)
			libtcod.console_put_char_ex(unit_con, x+1, y, 175, libtcod.dark_sepia, bg_col)
		elif self.entrenched:
			libtcod.console_put_char_ex(unit_con, x-1, y, 91, libtcod.dark_sepia, bg_col)
			libtcod.console_put_char_ex(unit_con, x+1, y, 93, libtcod.dark_sepia, bg_col)
		else:
			libtcod.console_put_char_ex(unit_con, x-1, y, 249, libtcod.grey, bg_col)
			libtcod.console_put_char_ex(unit_con, x+1, y, 249, libtcod.grey, bg_col)
	
	
	# calculate the effective firepower from a hit from this unit
	def CalcHEEffectiveFP(self, profile):
		
		effective_fp = float(profile['weapon'].GetEffectiveFP())
						
		# ballistic attack - normally an indirect hit
		if profile['ballistic_attack']:
			if profile['result'] == 'HIT':
				effective_fp = effective_fp * BALLISTIC_HE_FP_MOD
		
		# apply critical hit multiplier
		if profile['result'] == 'CRITICAL HIT':
			effective_fp = effective_fp * 2.0
		
		# apply partial hit modifier
		elif profile['result'] == 'PARTIAL HIT':
			effective_fp = effective_fp * 0.5
		
		target = profile['target']
		
		# apply modifiers
		
		# apply fortified, entrenched, or dug-in modifier
		if target.fortified:
			
			# possible that fortifications are destroyed by impact
			if profile['result'] == 'CRITICAL HIT' and GetPercentileRoll() <= effective_fp:
				target.fortified = False
				target.terrain = 'Rubble'
				if target.owning_player == 0 or (target.owning_player == 1 and target.spotted):
					ShowMessage(target.unit_id + "'s fortification has been destroyed.", scenario_highlight=(target.hx, target.hy))
				effective_fp = effective_fp * 2.0
				profile['modifier'] = 'Rubble Effect: +100% FP'
			elif profile['weapon'].GetStat('name') in ['Demolition Charge', 'Molotovs', 'Grenades']:
				effective_fp = effective_fp * 0.5
				profile['modifier'] = 'Fortified: -50% FP'
			else:
				effective_fp = effective_fp * 0.1
				profile['modifier'] = 'Fortified: -90% FP'
		elif target.entrenched:
			if profile['ballistic_attack'] and profile['result'] in ['HIT', 'CRITICAL HIT']:
				effective_fp = effective_fp * 1.25
				profile['modifier'] = 'Entrenched: +25% FP'
			elif profile['weapon'].GetStat('name') in ['Demolition Charge', 'Molotovs', 'Grenades']:
				effective_fp = effective_fp * 0.75
				profile['modifier'] = 'Entrenched: -25% FP'
			else:
				effective_fp = effective_fp * 0.25
				profile['modifier'] = 'Entrenched: -75% FP'
		elif target.dug_in:
			if profile['ballistic_attack'] and profile['result'] in ['HIT', 'CRITICAL HIT']:
				effective_fp = effective_fp * 1.5
				profile['modifier'] = 'Dug-In: +50% FP'
			elif profile['weapon'].GetStat('name') in ['Demolition Charge', 'Molotovs', 'Grenades']:
				effective_fp = effective_fp * 0.9
				profile['modifier'] = 'Dug-In: -10% FP'
			else:
				effective_fp = effective_fp * 0.5
				profile['modifier'] = 'Dug-In: -50% FP'
		
		# Check for HE airburst or hamada effect
		elif target.terrain in ['Woods', 'Jungle', 'Bamboo Forest']:
			profile['modifier'] = 'Airburst Effect: +25% FP'
			effective_fp = effective_fp * 1.25
		elif target.terrain == 'Hamada':
			profile['modifier'] = 'Hamada Effect: +25% FP'
			effective_fp = effective_fp * 1.25
		elif target.terrain == 'Marsh':
			profile['modifier'] = 'Marsh Effect: -25% FP'
			effective_fp = effective_fp * 0.75
		
		# apply ground conditions modifier
		elif campaign_day.weather['Ground'] == 'Deep Snow':
			profile['modifier'] = 'Deep Snow: -50% FP'
			effective_fp = effective_fp * 0.5
		elif campaign_day.weather['Ground'] in ['Muddy', 'Snow']:
			profile['modifier'] = campaign_day.weather['Ground'] + ': -25% FP'
			effective_fp = effective_fp * 0.75
		
		# urban ground conditions
		elif campaign_day.mission in ['Urban Assault', 'Urban Defense']:
			profile['modifier'] = 'Urban Terrain: +25% FP'
			effective_fp = effective_fp * 1.25
		
		# if target is unspotted, don't display the modifier information
		if target.owning_player == 1 and not target.spotted:
			profile['modifier'] = ''
		
		# round up final effective fp
		effective_fp = int(ceil(effective_fp))
		
		# minimum 1 fp
		if effective_fp < 1:
			effective_fp = 1
		
		profile['effective_fp'] = effective_fp
		
		return profile
		
	
	# initiate an attack from this unit with the specified weapon against the specified target
	def Attack(self, weapon, target, attempt_immobilize=False):
		
		# make sure correct information has been supplied
		if weapon is None or target is None: return False
		
		# make sure attack is possible
		if scenario.CheckAttack(self, weapon, target) != '': 
			return False
		
		# if immobilization attempt, check that is possible
		if attempt_immobilize:
			if not scenario.CanImmobilize(self, weapon, target):
				return False
		
		# tutorial slides
		if self.is_player:
			ShowTutorialSlide('scenario_player_attack')
		elif target.is_player:
			ShowTutorialSlide('scenario_player_attacked')
		if attempt_immobilize:
			ShowTutorialSlide('scenario_player_attempt_immobilize')
		
		# if firing weapon is mounted on turret and turret has rotated, all weapons on turret lose acquired target
		if weapon.GetStat('Mount') == 'Turret' and self.turret_facing is not None:
			if self.turret_facing != self.previous_turret_facing:
				for weapon2 in self.weapon_list:
					if weapon2.GetStat('Mount') == 'Turret':
						if weapon2.GetStat('firing_group') == weapon.GetStat('firing_group'):
							weapon2.acquired_target = None
		
		# only display message if player is the target
		if target == scenario.player_unit: 
			text = self.GetName() + ' attacks you'
			if self.owning_player == 0 or self.spotted:
				text += ' with '
				if weapon.GetStat('type') == 'Gun' and weapon.GetStat('calibre') is not None:
					text += weapon.GetStat('calibre') + 'mm'
					if weapon.GetStat('long_range') is not None:
						text += ' ' + weapon.GetStat('long_range')
					text += ' Gun'
				else:
					text += weapon.stats['name']
	
				if weapon.ammo_type is not None:
					text += ' (' + weapon.ammo_type + ')'
			ShowMessage(text, scenario_highlight=(self.hx, self.hy))
				
		# determine if attack profile should be displayed on screen
		display_profile = False
		if self == scenario.player_unit:
			display_profile = True
		elif self.spotted and target == scenario.player_unit:
			display_profile = True
		
		# attack loop, possible to maintain RoF and do multiple attacks within this loop
		attack_finished = False
		while not attack_finished:
			
			fate_point_used = False
			
			# automatically switch to reload from general stores if RR is empty
			if self == scenario.player_unit:
				if weapon.GetStat('type') == 'Gun' and weapon.ammo_type is not None:
					if weapon.using_rr and weapon.ready_rack[weapon.ammo_type] == 0:
						weapon.using_rr = False
						scenario.UpdateContextCon()
						scenario.UpdateScenarioDisplay()
						libtcod.console_flush()
			
			# calculate attack profile
			profile = scenario.CalcAttack(self, weapon, target, attempt_immobilize=attempt_immobilize)
			
			# attack not possible for some reason
			if profile is None:
				print('ERROR: Unable to calculate attack!')
				attack_finished = True
				continue
			
			# display attack profile on screen if player is involved
			if display_profile:
				scenario.DisplayAttack(profile)
				# activate the attack console and display to screen
				scenario.attack_con_active = True
				scenario.UpdateScenarioDisplay()
				CheckForAnimationUpdate()
				libtcod.console_flush()
				
				# don't wait for player input if they are the target and fate point cannot be used
				skip_player_input = False
				if target == scenario.player_unit and (campaign_day.fate_points == 0 or not profile['fate_point_allowed']):
					skip_player_input = True
				
				# wait for player input:
				# player can cancel attack if they were the attacker, or
				# possibly use a fate point if they are the target
				if not weapon.maintained_rof and not skip_player_input:
					result = WaitForAttackInput(campaign_day.fate_points > 0 and profile['fate_point_allowed'] is True)
					
					if target != scenario.player_unit and result == 'cancel':
						scenario.attack_con_active = False
						return True
					
					if result == 'fate_point':
						fate_point_used = True
			
			# profile not displayed, but still give player a chance to use a fate point if they are the target
			elif target == scenario.player_unit and campaign_day.fate_points > 0 and profile['final_chance'] not in [0.0, 100.0]:
				if ShowNotification('Use a fate point to avoid this attack?', confirm=True, simple_yn=True):
					fate_point_used = True
			
			# set weapon and unit fired flags
			weapon.fired = True
			self.fired = True
			
			# if player unit is attacking, possible to switch 'On my Mark' to 'Fire at Will' battlegroup command
			if self == scenario.player_unit and scenario.battlegroup_command == 'On my Mark':
				scenario.battlegroup_command = 'Fire at Will'
				scenario.UpdateCommsCon()
			
			# if player unit is attacking, set crewmen acted flags
			if profile['crewman'] is not None:
				profile['crewman'].acted = True
			
			# set flags if initiating a close combat attack
			if profile['type'] == 'Close Combat':
				self.moving = True
				self.dug_in = False
				self.entrenched = False
				self.fortified = False
				self.ClearAcquiredTargets()
			
			# if overrun attack, attacker is automatically spotted
			if self.overrun:
				self.SpotMe()
				scenario.UpdateUnitCon()
				scenario.UpdateScenarioDisplay()
			
			# do weapon jam test for player
			if self == scenario.player_unit:
				if weapon.JamTest():
					PlaySoundFor(None, 'weapon_jam')
					ShowMessage(weapon.GetStat('name') + ' has jammed!', good_news=False)
					scenario.UpdatePlayerInfoCon()
					scenario.UpdateScenarioDisplay()
					libtcod.console_flush()
					attack_finished = True
					continue
			
			if weapon.GetStat('type') == 'Flame Thrower':
				expend_fuel = True
				if profile['crewman'] is not None:
					if 'Conflagration' in profile['crewman'].skills:
						if GetPercentileRoll() <= 20.0:
							expend_fuel = False
				if expend_fuel:
					weapon.flame_ammo -= 1
			
			# expend a shell if gun weapon is firing
			if weapon.GetStat('type') == 'Gun' and weapon.ammo_type is not None:
				if weapon.using_rr:
					if weapon.ready_rack[weapon.ammo_type] > 0:
						weapon.ready_rack[weapon.ammo_type] -= 1
					else:
						# if no more RR ammo, default to general stores
						weapon.ammo_stores[weapon.ammo_type] -= 1
						weapon.using_rr = False
				else:
					weapon.ammo_stores[weapon.ammo_type] -= 1
				scenario.UpdateContextCon()
				scenario.UpdateScenarioDisplay()
				libtcod.console_flush()
				
			
			##### Attack Animation and Sound Effects #####
			
			# skip if in fast mode
			if not (DEBUG and session.debug['Fast Mode']):
				
				FlushKeyboardEvents()
				
				# hide LoS highlight
				scenario.UpdateGuiCon(hide_los=True)
				scenario.UpdateScenarioDisplay()
				
				(x1, y1) = self.GetScreenLocation()
				(x2, y2) = target.GetScreenLocation()
				
				# start correct type of attack animation and set animation flag
				if weapon.GetStat('type') == 'Gun':
					
					# C/sh ammo uses a different animation series
					if weapon.ammo_type in ['C', 'SH']:
						
						# do canister fire animation first
						scenario.animation['canister_fire'] = GetLine(x1,y1,x2,y2)[2]
						scenario.animation['canister_fire_lifetime'] = 11
						PlaySoundFor(weapon, 'fire')
						while scenario.animation['canister_fire']:
							libtcod.console_flush()
							CheckForAnimationUpdate()
						
						scenario.animation['canister_hit'] = (x2,y2)
						scenario.animation['canister_hit_lifetime'] = 6
						PlaySoundFor(None, 'canister_hit')
						scenario.animation['attack_animation_active'] = True
					
					else:
					
						# special sequence for rockets
						if weapon.GetStat('rocket_launcher') is not None:
							scenario.animation['canister_fire'] = GetLine(x1,y1,x2,y2)[2]
							scenario.animation['canister_fire_lifetime'] = 11
							PlaySoundFor(weapon, 'fire')
							scenario.animation['attack_animation_active'] = True
						
						# regular guns
						else:
							scenario.animation['gun_fire_active'] = True
							scenario.animation['gun_fire_line'] = GetLine(x1,y1,x2,y2)
							PlaySoundFor(weapon, 'fire')
							scenario.animation['attack_animation_active'] = True
						
						# if ammo is HE/HEAT/Smoke/WP, run the firing animation first then start the impact animation
						if weapon.ammo_type in ['HE', 'HEAT', 'Smoke', 'WP']:
							
							while scenario.animation['attack_animation_active']:
								libtcod.console_flush()
								CheckForAnimationUpdate()
						
							# start explosion effect if HE or HEAT ammo
							if weapon.ammo_type in ['HE', 'HEAT']:
								scenario.animation['bomb_effect'] = (x2, y2)
								scenario.animation['bomb_effect_lifetime'] = 7
								PlaySoundFor(weapon, 'he_explosion')
								scenario.animation['attack_animation_active'] = True
							
							# start smoke effect if smoke/WP
							elif weapon.ammo_type in ['Smoke', 'WP']:
								scenario.animation['smoke_effect'] = (x2, y2)
								scenario.animation['smoke_effect_lifetime'] = 7
								PlaySoundFor(None, 'smoke')
								scenario.animation['attack_animation_active'] = True
				
				elif weapon.GetStat('type') == 'Small Arms' or weapon.GetStat('type') in MG_WEAPONS:
					scenario.animation['small_arms_fire_action'] = True
					scenario.animation['small_arms_fire_line'] = GetLine(x1,y1,x2,y2)
					scenario.animation['small_arms_lifetime'] = 10
					PlaySoundFor(weapon, 'fire')
					scenario.animation['attack_animation_active'] = True
				
				elif weapon.GetStat('type') == 'Close Combat':
					
					if weapon.GetStat('name') == 'Submachine Guns':
						scenario.animation['small_arms_fire_action'] = True
						scenario.animation['small_arms_fire_line'] = GetLine(x1,y1,x2,y2)
						scenario.animation['small_arms_lifetime'] = 8
						PlaySoundFor(weapon, 'fire')
						scenario.animation['attack_animation_active'] = True
					
					elif weapon.GetStat('name') == 'Grenades':
						scenario.animation['grenade_effect'] = (x2, y2)
						scenario.animation['grenade_effect_lifetime'] = 3
						PlaySoundFor(weapon, 'fire')
						scenario.animation['attack_animation_active'] = True
					
					elif weapon.GetStat('name') == 'Molotovs':
						scenario.animation['grenade_effect'] = (x2, y2)
						scenario.animation['grenade_effect_lifetime'] = 1
						PlaySoundFor(None, 'grenades')
						scenario.animation['attack_animation_active'] = True
						while scenario.animation['grenade_effect']:
							libtcod.console_flush()
							CheckForAnimationUpdate()
						scenario.animation['ft_effect'] = (x2, y2)
						scenario.animation['ft_effect_lifetime'] = 4
						PlaySoundFor(None, 'flamethrower')
						scenario.animation['attack_animation_active'] = True
					
					elif weapon.GetStat('name') == 'Flame Thrower':
						scenario.animation['ft_effect'] = (x2, y2)
						scenario.animation['ft_effect_lifetime'] = 9
						PlaySoundFor(weapon, 'fire')
						scenario.animation['attack_animation_active'] = True
					
					elif weapon.GetStat('name') in ['Panzerschreck', 'Panzerfaust', 'Panzerfaust Klein', 'PIAT', 'Bazooka']:
						scenario.animation['psk_fire_action'] = True
						scenario.animation['psk_fire_line'] = GetLine(x1,y1,x2,y2)
						PlaySoundFor(weapon, 'fire')
						
						# separate animation
						while scenario.animation['psk_fire_action']:
							libtcod.console_flush()
							CheckForAnimationUpdate()
						scenario.animation['bomb_effect'] = (x2, y2)
						scenario.animation['bomb_effect_lifetime'] = 7
						PlaySoundFor(weapon, 'he_explosion')
						scenario.animation['attack_animation_active'] = True
					
					elif weapon.GetStat('name') == 'Demolition Charge':
						scenario.animation['bomb_effect'] = (x2, y2)
						scenario.animation['bomb_effect_lifetime'] = 7
						PlaySoundFor(weapon, 'he_explosion')
						scenario.animation['attack_animation_active'] = True
				
				# vehicle flamethower
				elif weapon.GetStat('type') == 'Flame Thrower':
					scenario.animation['ft_effect'] = (x2, y2)
					scenario.animation['ft_effect_lifetime'] = 14
					PlaySoundFor(weapon, 'fire')
					scenario.animation['attack_animation_active'] = True
			
			# fate point was spent
			if fate_point_used:
				campaign_day.fate_points -= 1
				ShowMessage('The attack missed and had no effect.')
				scenario.attack_con_active = False
				scenario.UpdatePlayerInfoCon()
				scenario.UpdateScenarioDisplay()
				return True
			
			# again, automatically switch to reload from general stores if RR is empty, for RoF
			if self == scenario.player_unit:
				if weapon.GetStat('type') == 'Gun' and weapon.ammo_type is not None:
					if weapon.using_rr and weapon.ready_rack[weapon.ammo_type] == 0:
						weapon.using_rr = False
						scenario.UpdateContextCon()
						scenario.UpdateScenarioDisplay()
						libtcod.console_flush()
			
			# do the roll, display results to the screen, and modify the attack profile
			# also checks for RoF and waits for attack animation to finish
			profile = scenario.DoAttackRoll(profile)
			
			# add one level of acquired target if allowed and firing gun or MG
			if weapon.GetStat('no_ac') is None and (weapon.GetStat('type') == 'Gun' or weapon.GetStat('type') in MG_WEAPONS):
				weapon.AddAcquiredTarget(target)
			
			# if a gun weapon is firing in dry ground conditions, chance that dust is produced
			if weapon.GetStat('type') == 'Gun' and campaign_day.weather['Ground'] == 'Dry' and self.dust < 2:
				if GetPercentileRoll() <= 5.0:
					self.dust += 1
					if self == scenario.player_unit:
						scenario.UpdatePlayerInfoCon()
						scenario.UpdateScenarioDisplay()
						ShowNotification('Firing your gun has kicked up dust around your vehicle.')
			
			# breakdown check for player weapons
			if self == scenario.player_unit:
				if weapon.BreakTest():
					PlaySoundFor(None, 'weapon_break')
					ShowNotification(weapon.GetStat('name') + ' has broken down! It may not be used again for the rest of the day.')
					
					# update the attack console in case RoF was maintained
					libtcod.console_print_ex(attack_con, 13, 54, libtcod.BKGND_NONE,
						libtcod.CENTER, '                       ')
					libtcod.console_print(attack_con, 6, 56, '     ')
					libtcod.console_print(attack_con, 12, 56, '          ')
					scenario.UpdatePlayerInfoCon()
					attack_finished = True
					weapon.maintained_rof = False
			
			# restore LoS highlight
			scenario.UpdateGuiCon()
			scenario.UpdateScenarioDisplay()
			
			# wait for the player if the attack was displayed
			# if RoF is maintained, may choose to attack again
			attack_finished = True
			if display_profile:
				
				scenario.UpdateScenarioDisplay()
				
				if self == scenario.player_unit and weapon.maintained_rof:
					ShowTutorialSlide('scenario_player_rof')
				
				end_pause = False
				while not end_pause:
					CheckForAnimationUpdate()
					libtcod.console_flush()
					if not GetInputEvent(): continue
					
					key_char = DeKey(chr(key.c).lower())
					
					# player RoF
					if self == scenario.player_unit and weapon.maintained_rof:
						if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or key_char == 'f' or session.gamepad_input == 0:
							attack_finished = False
							end_pause = True
						elif key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
							end_pause = True
					else:
						if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB, sdl2.SDLK_ESCAPE] or session.gamepad_input == 0:
							end_pause = True
							
			
			# apply results of this attack if any
			
			# check for debug flag
			skip_effects = False
			if DEBUG:
				if session.debug['Attacks Have No Effect']:
					skip_effects = True
			
			if not skip_effects:
				
				# immobilization attempt
				if profile['immobilize']:
					if profile['result'] == 'HIT':
						if target.RollToImmobilize(profile['weapon']):
							ShowMessage(target.unit_id + ' has been immobilized.',
								scenario_highlight=(target.hx, target.hy))
							target.ImmobilizeMe()
						else:
							ShowMessage('Immobilization attempt had no effect on ' + target.unit_id,
								scenario_highlight=(target.hx, target.hy))
			
				# area fire attack
				elif profile['type'] == 'Area Fire':
						
					if profile['result'] in ['CRITICAL EFFECT', 'FULL EFFECT', 'PARTIAL EFFECT']:
						target.fp_to_resolve += profile['effective_fp']
						target.hit_by_fp = True
					
					# possible it was converted into an AP MG hit
					elif profile['result'] in ['HIT', 'CRITICAL HIT']:	
						target.ap_hits_to_resolve.append(profile)
						
						# also applies fp
						target.fp_to_resolve += profile['effective_fp']
						target.hit_by_fp = True
					
					# chance that a miss will still reveal a concealed unit
					elif profile['result'] in ['NO EFFECT', 'MISS - HULL DOWN', 'MISS - NO TURRET'] and not target.hit_by_fp:
						if GetPercentileRoll() <= MISSED_FP_REVEAL_CHANCE:
							target.hit_by_fp = True
				
				# close combat hit
				elif profile['type'] == 'Close Combat':
					
					if profile['result'] in ['CRITICAL HIT', 'HIT']:
						
						# special: nikuhaku attacks may be dropped into an open hatch or open top
						open_hatch_attack = False
						if profile['result'] == 'CRITICAL HIT' and self.unit_id == 'Nikuhaku Team':
							if 'open_rear_turret' in target.stats:
								open_hatch_attack = True
							elif 'open_topped' in target.stats:
								open_hatch_attack = True
							elif target.is_player:
								for position in target.positions_list:
									if position.open_top:
										open_hatch_attack = True
										break
									elif position.crew_always_ce:
										open_hatch_attack = True
										break
									elif position.hatch_open:
										open_hatch_attack = True
										break
							
							# otherwise, treat it as a normal hit
							if not open_hatch_attack:
								profile['result'] = 'HIT'
						
						if open_hatch_attack:
							if target.is_player:
								text = self.GetName() + ' drops an explosive charge into your vehicle.'
							else:
								text = self.GetName() + ' drops an explosive charge into ' + target.GetName() + '.'
							ShowMessage(text, scenario_highlight=(target.hx, target.hy))
							target.DestroyMe(dest_weapon=weapon, force_explosion=True)
						
						else:
						
							# apply fp to target
							target.fp_to_resolve += profile['effective_fp']
							target.hit_by_fp = True
							
							# FT hits cause a rout test too
							if weapon.GetStat('name') == 'Flame Thrower':
								target.RoutTest()
							
							# apply an AP hit to an armoured target
							if target.GetStat('armour') is not None:
								target.ap_hits_to_resolve.append(profile)	
				
				# vehicle flame thrower hit
				elif profile['type'] == 'Flame Thrower':
					if profile['result'] in ['FULL EFFECT', 'PARTIAL EFFECT']:
						target.fp_to_resolve += profile['effective_fp']
						target.hit_by_fp = True
						target.RoutTest()
					
					elif profile['result'] in ['HIT', 'CRITICAL HIT']:	
						target.ap_hits_to_resolve.append(profile)
						target.fp_to_resolve += profile['effective_fp']
						target.hit_by_fp = True
					
					# chance that a miss will still reveal a concealed unit
					elif profile['result'] in ['NO EFFECT', 'MISS - HULL DOWN', 'MISS - NO TURRET'] and not target.hit_by_fp:
						if GetPercentileRoll() <= MISSED_FP_REVEAL_CHANCE:
							target.hit_by_fp = True
				
				# point fire hit
				elif profile['type'] == 'Point Fire':
					
					if profile['result'] in ['CRITICAL HIT', 'HIT', 'PARTIAL HIT']:
					
						# record if player scored a hit
						if self == scenario.player_unit:
							campaign_day.AddRecord('Gun Hits', 1)
						
						# add stat if player was hit
						elif target == scenario.player_unit and profile['ammo_type'] not in ['Smoke', 'WP']:
							session.ModifySteamStat('hits_taken', 1)
						
						# smoke round
						if profile['ammo_type'] == 'Smoke':
							target.smoke = 2
						
						# WP round
						elif profile['ammo_type'] == 'WP':
							target.smoke = 1
							target.fp_to_resolve += profile['effective_fp']
							target.hit_by_fp = True
							target.RoutTest()
								
						# canister/shrapnel round
						elif profile['ammo_type'] in ['C', 'SH']:
							# apply to all units in stack
							map_hex = scenario.hex_dict[(target.hx, target.hy)]
							for unit in map_hex.unit_stack:
								unit.fp_to_resolve += profile['effective_fp']
								unit.hit_by_fp = True
						
						# infantry, cavalry, or gun target
						elif target.GetStat('category') in ['Infantry', 'Cavalry', 'Gun']:
							
							# if HE/HEAT hit, apply effective FP
							if profile['ammo_type'] in ['HE', 'HEAT']:
								target.fp_to_resolve += profile['effective_fp']
								target.hit_by_fp = True
							
							# AP hit
							elif profile['ammo_type'] in AP_AMMO_TYPES:
								
								# limited base effect on 'soft' targets
								target.fp_to_resolve += profile['effective_fp']
								
								# entrenchment/fortification may be destroyed
								if target.entrenched or target.fortified:
									
									if weapon.stats['name'] == 'AT Rifle':
										calibre = 20
									elif 'calibre' not in weapon.stats:
										calibre = 20
									else:
										calibre = int(weapon.stats['calibre'])
									
									if calibre <= 28:
										chance = 5.0
									elif calibre <= 77:
										chance = 10.0
									else:
										chance = 15.0
									
									if target.fortified:
										chance = chance * 0.25
									
									if profile['result'] == 'CRITICAL HIT':
										chance = chance * 2.0
									
									chance = round(chance, 1)
									
									roll = GetPercentileRoll()
									if roll <= chance:
										
										if target.entrenched:
											target.entrenched = False
											ShowNotification("The hit has destroyed the target's entrenchments!")
											target.fp_to_resolve += 3
										else:
											target.fortified = False
											ShowNotification("The hit has destroyed the target's fortifications!")
											target.fp_to_resolve += 6
									
								# critical hits have some additional effect
								if profile['result'] == 'CRITICAL HIT':
									if target.GetStat('category') == 'Gun':
										ShowNotification("The attack has hit the gun itself and destroys it! The crew scatters.")
										target.DestroyMe()
									elif target.GetStat('class') == 'Motorcycle Team':
										ShowNotification("The attack has hit the motorcycle itself and destroys it! The crew scatters.")
										target.DestroyMe()
									else:
										target.fp_to_resolve += 2
							
						# unarmoured vehicle target, slightly different procedure
						elif target.GetStat('armour') is None:
							if profile['ammo_type'] in AP_AMMO_TYPES:
								target.ap_hits_to_resolve.append(profile)
							else:
								target.he_hits_to_resolve.append(profile)
								target.hit_by_fp = True
						
						# armoured target
						elif target.GetStat('armour') is not None:
							target.ap_hits_to_resolve.append(profile)
							
							# HE/HEAT also applies firepower to target and may immobilize it
							if profile['ammo_type'] in ['HE', 'HEAT']:
								target.fp_to_resolve += profile['effective_fp']
								target.he_hits_to_resolve.append(profile)
								target.hit_by_fp = True
					
						# HE may also cause dust
						if profile['ammo_type'] in ['HE', 'HEAT']:
							if campaign.stats['region'] == 'North Africa' or campaign_day.rattenkrieg:
								
								chance = 30.0
								if profile['result'] == 'PARTIAL HIT':
									chance = 10.0
								
								if GetPercentileRoll() <= chance and target.dust < 2:
									target.dust += 1
									if target == scenario.player_unit:
										ShowNotification('The explosion kicks up dust around you.')
									elif self == scenario.player_unit:
										ShowNotification('The explosion kicks up dust around the target.')
					
					# chance that a miss will still reveal a concealed unit
					elif profile['ammo_type'] == 'HE' and profile['result'] == 'MISS' and not target.hit_by_fp:
						if GetPercentileRoll() <= MISSED_FP_REVEAL_CHANCE:
							target.hit_by_fp = True
					
					# player crew might comment on a miss
					if target.is_player and profile['result'] == 'MISS' and not self.spotted and weapon.GetStat('calibre') is not None:
						if GetPercentileRoll() <= 20.0:
							text = 'That sounded like a ' + weapon.GetStat('calibre') + 'mm gun!'
							ShowCrewChatter(None, None, override_text=text)
				
				# if player was target but attacker was not spotted, display result as a pop-up message
				if not display_profile and target == scenario.player_unit:
					text = 'Result: ' + profile['result']
					ShowMessage(text, scenario_highlight=(self.hx, self.hy))
				
				# if target was destroyed outright, cannot maintain RoF
				if not target.alive:
					weapon.maintained_rof = False
					attack_finished = True
				
			# nikuhaku attacks can result in destruction of attacker
			if self.unit_id == 'Nikuhaku Team':
				weapon.maintained_rof = False
				attack_finished = True
				if profile['result'] == 'CRITICAL HIT':
					chance = 20.0
				else:
					chance = 80.0
				if GetPercentileRoll() <= chance:
					ShowMessage(self.GetName() + ' has blown itself up.', scenario_highlight=(self.hx, self.hy))
					self.DestroyMe(no_vp=True)
			
			# update context console in case we maintained RoF
			scenario.UpdateContextCon()
			scenario.UpdateScenarioDisplay()
			
			# maintained RoF (player-involved RoF is handled above)
			if self != scenario.player_unit and weapon.maintained_rof:
				attack_finished = False
			
		# turn off attack console display if any
		scenario.attack_con_active = False
		scenario.UpdateScenarioDisplay()
		
		# reset weapon RoF
		weapon.maintained_rof = False
		weapon.rof_shots = 0
		
		# check for special weapon depletion
		if weapon.stats['name'] in ['Panzerfaust', 'Panzerfaust Klein', 'Demolition Charge', 'Molotovs']:
			if libtcod.random_get_int(0, 1, 10) > 3:
				self.weapon_list.remove(weapon)
		
		# alert target if lax, check for break of Hold Fire command
		if target.ai is not None:
			if target.ai.state == 'Lax':
				target.ai.state = 'Alert'
			
			if target.ai.leader_command == 'Hold Fire':
				if GetPercentileRoll() <= 75.0:
					target.ai.leader_command == 'Fire at Will'
		
		# attack is finished
		return True
	
	
	# resolve all unresolved HE hits on this unit - vehicles only
	def ResolveHEHits(self):
		if not self.alive: return
		if len(self.he_hits_to_resolve) == 0: return
		if self.GetStat('category') not in ['Vehicle']:
			self.he_hits_to_resolve = []
			return
		
		# armoured vehicle targets
		if self.GetStat('armour') is not None and self.GetStat('category') == 'Vehicle':
			
			# possible for armoured targets to be immobilized by HE
			if not self.immobilized:
				for profile in self.he_hits_to_resolve:
					calibre = profile['weapon'].GetStat('calibre')
					if calibre is None:
						continue
					calibre = int(calibre)
					if calibre >= 200:
						chance = 10.0
					elif calibre >= 100:
						chance = 3.0
					elif calibre >= 75:
						chance = 1.0
					else:
						chance = 0.3
					
					roll = GetPercentileRoll()
					if roll > chance: continue
					
					if self == scenario.player_unit:
						text = 'You were '
					else:
						text = self.GetName() + ' was '
					text += 'immobilized by an HE hit from '
					if profile['attacker'] == scenario.player_unit:
						text += 'you.'
					else:
						text += profile['attacker'].GetName() + '.'
					ShowMessage(text)
					
					# immobilze the target and skip any further immobilization checks
					self.ImmobilizeMe()
					if self == scenario.player_unit:
						campaign.AddJournal('Vehicle was immobilized')
						scenario.UpdatePlayerInfoCon()
					scenario.UpdateUnitInfoCon()
					break
			
			self.he_hits_to_resolve = []
			return
		
		# unarmoured target
		# determine base odds
		for profile in self.he_hits_to_resolve:
			
			calibre = profile['weapon'].GetStat('calibre')
			if calibre is None:
				continue
			
			profile['type'] = 'he'
			
			calibre = int(calibre)
			if calibre >= 150:
				base_score = 20
			elif calibre >= 120:
				base_score = 18
			elif calibre >= 100:
				base_score = 16
			elif calibre >= 80:
				base_score = 14
			elif calibre >= 70:
				base_score = 12
			elif calibre >= 50:
				base_score = 10
			elif calibre >= 40:
				base_score = 9
			elif calibre >= 30:
				base_score = 8
			elif calibre >= 20:
				base_score = 6
			else:
				continue
			
			if profile['result'] == 'CRITICAL HIT':
				base_score = base_score * 2
			elif profile['ballistic_attack']:
				base_score = int(ceil(base_score * 0.5))
			
			profile['base_chance'] = base_score
			profile['modifier_list'] = []
			profile['final_score'] = base_score
			
			# determine final destruction odds and roll
			if base_score >= 12:
				chance = 100.0
			else:
				chance = Get2D6Odds(base_score)
			profile['final_chance'] = chance
			
			fate_point_used = False
			
			# display attack console if player is involved
			if profile['attacker'] == scenario.player_unit or self == scenario.player_unit:
				scenario.DisplayAttack(profile)
				scenario.attack_con_active = True
				scenario.UpdateScenarioDisplay()
				
			# do the attack roll; modifies the attack profile
			profile = scenario.DoAttackRoll(profile)
			
			# wait if player is involved
			if profile['attacker'] == scenario.player_unit or self == scenario.player_unit:
				scenario.UpdateScenarioDisplay()
				WaitForContinue()
			
			# turn off attack console display if any
			scenario.attack_con_active = False
			scenario.UpdateScenarioDisplay()
			
			# no effect
			if profile['result'] == 'NO EFFECT': continue
			
			# show message
			if profile['result'] == 'IMMOBILIZED':
				result_text = 'immobilized'
				
			elif profile['result'] == 'STUNNED':
				result_text = 'stunned'
			else:
				result_text = 'destroyed'
			
			# if player was destroyed by an unspotted unit, spot it now
			if profile['result'] == 'DESTROYED' and self == scenario.player_unit and not profile['attacker'].spotted:
				profile['attacker'].spotted = True
			
			if self == scenario.player_unit:
				text = 'You were '
			else:
				text = self.GetName() + ' was '
			text += result_text + ' by an HE hit from '
			if profile['attacker'] == scenario.player_unit:
				text += 'you.'
			else:
				text += profile['attacker'].GetName() + '.'
			
			# apply result
			if profile['result'] == 'DESTROYED':
				self.DestroyMe(location=profile['location'], dest_weapon=profile['weapon'])
				if profile['attacker'] == scenario.player_unit:
					campaign.AddJournal('Destroyed a ' + self.GetName() + ' with HE.')
			
			elif profile['result'] == 'IMMOBILIZED':
				if self.immobilized: continue
				self.ImmobilizeMe()
				if self == scenario.player_unit:
					campaign.AddJournal('Vehicle was immobilized')
					scenario.UpdatePlayerInfoCon()
				scenario.UpdateUnitInfoCon()
			
			elif profile['result'] == 'STUNNED':
				self.ai.state = 'Stunned'
				scenario.UpdateUnitInfoCon()
			
			ShowMessage(text)
			
			# don't resolve further hits if already destroyed
			if profile['result'] == 'DESTROYED':
				break
				
		# clear resolved hits
		self.he_hits_to_resolve = []
			
	
	# resolve all unresolved AP hits on this unit
	def ResolveAPHits(self):
		if not self.alive: return
		
		# no hits to resolve! doing fine!
		if len(self.ap_hits_to_resolve) == 0: return
		
		# no effect if infantry, cavalry or gun
		if self.GetStat('category') in ['Infantry', 'Cavalry', 'Gun']:
			self.ap_hits_to_resolve = []
			return
		
		# move to top of hex stack
		self.MoveToTopOfStack()
		scenario.UpdateUnitCon()
		
		# handle AP hits
		for profile in self.ap_hits_to_resolve:
			
			# ballistic hits don't penetrate unless they are a direct hit
			if profile['ballistic_attack'] and profile['result'] != 'CRITICAL HIT':
				continue
			
			# C/sh rounds don't have an AP effect
			elif profile['ammo_type'] in ['C', 'SH']:
				continue
			
			# partial HE hits don't have an AP effect, but can take out the crew of an OT or OTR vehicle
			elif profile['ammo_type'] == 'HE' and profile['result'] == 'PARTIAL HIT':
				
				if self.is_player: continue
				
				# For AI OT or OTR vehicles, roll for effect on crew
				chance = 0.0
				if 'open_topped' in self.stats:
					chance = 1.0
				elif 'open_rear_turret' in self.stats and profile['location'] == 'Turret':
					chance = 0.8
				if chance > 0.0:
					chance = round(chance * profile['effective_fp'], 1)
					if GetPercentileRoll() <= chance:
						profile['result'] == 'PENETRATED'
						
						# display message and attack console if player is involved
						if profile['attacker'] == scenario.player_unit or self == scenario.player_unit:
							ShowMessage('The hit knocks out the exposed crew of the target vehicle and destroys it.')
							scenario.DisplayAttack(profile)
							scenario.attack_con_active = True
							scenario.UpdateScenarioDisplay()
							WaitForContinue()
				continue
			
			# do normal AP roll if not already destroyed
			if profile['result'] != 'PENETRATED':
			
				profile = scenario.CalcAP(profile)
				
				fate_point_used = False
				
				if profile['attacker'] == scenario.player_unit:
					ShowTutorialSlide('scenario_player_ap_hit')
				elif self == scenario.player_unit:
					ShowTutorialSlide('scenario_player_ap_was_hit')
				
				# display attack console if player is involved
				if profile['attacker'] == scenario.player_unit or self == scenario.player_unit:
					scenario.DisplayAttack(profile)
					scenario.attack_con_active = True
					scenario.UpdateScenarioDisplay()
					
				# store whether hit was a critical hit or not
				critical_hit = False
				if profile['result'] == 'CRITICAL HIT':
					critical_hit = True
				
				# do the attack roll; modifies the attack profile
				profile = scenario.DoAttackRoll(profile)
				
				if profile['result'] == 'NO PENETRATION':
					PlaySoundFor(None, 'armour_save')
				elif profile['result'] == 'PENETRATED':
					PlaySoundFor(None, 'armour_penetrated')
			
				# wait if player is involved
				if profile['attacker'] == scenario.player_unit or self == scenario.player_unit:
					scenario.UpdateScenarioDisplay()
					WaitForContinue()
			
			# turn off attack console display if any
			scenario.attack_con_active = False
			scenario.UpdateScenarioDisplay()
			
			# show message for unarmoured vehicle saves
			if profile['result'] == 'MINOR DAMAGE':
				if profile['attacker'] == scenario.player_unit:
					ShowMessage('The attack punched right through the body of the target, but caused no critical damage.', longer_pause=True)
				elif self == scenario.player_unit:
					ShowMessage("The attack punched right through your vehicle's body, but caused no critical damage.", longer_pause=True)
					self.ko_hit = True
					self.CheckForSpallingInjuries(profile['location'])
			
			# shock test - not for flame weapons
			if profile['result'] == 'NO PENETRATION' and profile['weapon'].GetStat('name') not in ['Flame Thrower', 'Molotovs']:
				
				# check to see if unit had any acquired targets to begin with
				had_acquired_target = False
				for weapon in self.weapon_list:
					if weapon.acquired_target is not None:
						had_acquired_target = True
						break
				
				if had_acquired_target:
					if GetPercentileRoll() <= profile['final_chance']:
						for weapon in self.weapon_list:
							weapon.acquired_target = None
						if self == scenario.player_unit:
							ShowMessage('The impact has knocked your weapons off target. All acquired targets lost.')
			
			# apply result
			if profile['result'] == 'NO PENETRATION':
				
				# check for stun or recall check
				difference = profile['roll'] - profile['final_chance']
				if profile['final_chance'] == 0.0 or difference < 0.0: continue
					
				# recall check, enemy units only
				if self.owning_player == 1:
					if profile['location'] == 'Turret' and difference <= AP_RECALL_MARGIN and self.ai.attitude != 'Withdraw':
						roll = GetPercentileRoll()
						if self.GetStat('turret') is not None:
							if self.GetStat('turret') == 'RST':
								roll = round(roll * 0.5, 1)
						if roll <= AP_RECALL_CHANCE :
							self.ai.attitude = 'Withdraw'
				
				if self.is_player and GetPercentileRoll() <= 3.5:
					ShowCrewChatter('ap_save', None)
				
			elif profile['result'] == 'PENETRATED':
				
				# if the player unit has been penetrated, multiple outcomes are possible
				if self == scenario.player_unit:
					
					# possible outcomes: minor damage, spalling, immobilized, knocked out
					
					# apply roll penalty based on how much original roll passed by
					difference = round((profile['final_chance'] - profile['roll']) * 0.25, 2)
					roll = GetPercentileRoll() + difference
					
					if self.GetStat('class') in ['Armoured Car', 'Tankette']:
						roll += 20.0
					elif self.GetStat('class') in ['Light Tank', 'Tank Destroyer']:
						roll += 10.0
					
					# MG weapons much less likely to KO
					if profile['weapon'].GetStat('type') in MG_WEAPONS:
						roll = round(roll / 2, 1)
					
					if DEBUG:
						if session.debug['Player Always Penetrated']:
							roll = 100.0
					
					# radio damage check
					if self.has_radio and roll <= 40.0:
						if not self.radio_destroyed:
							radio_roll = GetPercentileRoll()
							if radio_roll <= 0.5:
								ShowMessage('Your radio has been destroyed!', longer_pause=True,
									good_news=False)
								self.radio_destroyed = True
							elif radio_roll <= 1.0 and not self.radio_damaged:
								ShowMessage('Your radio has been damaged!', longer_pause=True,
									good_news=False)
								self.radio_damaged = True
					
					# hits from Demo Charges more likely to cause immobilization
					if profile['weapon'].GetStat('name') == 'Demolition Charge' and not self.immobilized and roll > 25.0:
						if GetPercentileRoll() <= 70.0:
							roll = 20.0
					
					# hits from Flame Throwers and Molotovs more likely to only cause minor damage
					elif profile['weapon'].GetStat('name') in ['Flame Thrower', 'Molotovs'] and roll > 7.0:
						if GetPercentileRoll() <= 50.0:
							roll = 7.0
					
					# morale effect - high morale crew might turn a KO into a PH
					if not self.ko_hit and profile['weapon'].GetStat('name') not in ['Flame Thrower', 'Molotovs'] and roll > 40.0:
						
						morale_save = False
						for position in self.positions_list:
							if position.crewman is None: continue
							if not position.crewman.alive: continue
							if position.crewman.condition in ['Stunned', 'Unconscious']: continue
							chance = round(float(position.crewman.stats['Morale']) * 0.5, 1)
							if GetPercentileRoll() <= chance:
								morale_save = True
								break
						
						if morale_save:
							self.ko_hit = True
							self.CheckForSpallingInjuries(profile['location'])
							ShowMessage("Your vehicle's armour has been penetrated, but your crew is " +
								'determined to fight on in spite of the damage!', longer_pause=True,
								good_news=True)
							continue
					
					# minor damage
					if roll <= 7.0:
						ShowMessage('Your vehicle suffers only minor damage. Its armour ' +
							'is pierced but there is no critical damage to the vehicle.', longer_pause=True,
							good_news=True)
						self.ko_hit = True
						self.CheckForSpallingInjuries(profile['location'])
						continue
					
					# flame weapons can't cause the below types of damage
					if profile['weapon'].GetStat('name') not in ['Flame Thrower', 'Molotovs']:
					
						# immobilized
						if roll <= 25.0 and not self.immobilized:
							ShowMessage('The hit knocks out the engine and drivetrain, immobilizing your vehicle.',
								longer_pause=True, good_news=False)
							campaign.AddJournal('Vehicle was immobilized')
							self.ImmobilizeMe()
							self.ko_hit = True
							self.CheckForSpallingInjuries(profile['location'])
							scenario.UpdatePlayerInfoCon()
							continue
						
						# spalling
						elif roll <= 40.0:
							text = 'The hit shatters the armour plate, sending shards of hot metal into the ' + profile['location']
							ShowMessage(text, longer_pause=True, good_news=False)
							campaign.AddJournal('Suffered spalling from a hit')
							self.ko_hit = True
							self.CheckForSpallingInjuries(profile['location'])
							continue
					
					# otherwise, destroyed
				
				# if player was destroyed by an unspotted unit, spot it now
				if self == scenario.player_unit and not profile['attacker'].spotted:
					profile['attacker'].spotted = True
				
				# display message
				if self == scenario.player_unit:
					text = 'You were'
				else:
					text = self.GetName() + ' was'
				text += ' destroyed by '
				if profile['attacker'] == scenario.player_unit:
					text += 'you.'
				else:
					text += profile['attacker'].GetName() + ' using ' + profile['weapon'].stats['name'] + '.'
				ShowMessage(text)
				
				# attacker was player
				if profile['attacker'] == scenario.player_unit:
					campaign.AddJournal('Destroyed a ' + self.GetName())
				
				# attacker was a support unit, not in player's squad
				elif profile['attacker'].owning_player == 0 and profile['attacker'] not in scenario.player_unit.squad:
					session.ModifySteamStat('dest_support', 1)
				
				if self.owning_player == 1 and critical_hit:
					session.ModifySteamStat('dest_crit', 1)
				
				# destroy the unit
				self.DestroyMe(location=profile['location'], dest_weapon=profile['weapon'])
				
				# don't resolve any further hits
				break
			
			# for player unit, possibility that a hit might stun or knock out crewmen in location hit
			if self == scenario.player_unit and self.alive:
			
				if profile['ammo_type'] not in IMM_AMMO_TYPES: continue
				
				chance = round(profile['final_chance'] * AP_STUN_MULT, 1)
				if chance <= 3.0: continue
				
				for position in self.positions_list:
					if position.crewman is None: continue
					if not position.crewman.alive: continue
					if position.crewman.condition == 'Unconscious': continue
					if position.location is not None:
						if position.location != profile['location']: continue
					
					# initial effect roll
					if GetPercentileRoll() > chance: continue
					
					# stun result
					if GetPercentileRoll() > chance and position.crewman.condition != 'Stunned':
						position.crewman.condition = 'Stunned'
						if position.crewman.is_player_commander:
							ShowMessage('You have been Stunned by the impact.',
								good_news=False)
						else:
							ShowMessage('Your crewman has been Stunned by the impact:',
								crewman=position.crewman, good_news=False)
					
					# possible unconscious result
					else:
						if position.crewman.DoGritCheck(20.0): continue
						position.crewman.condition = 'Unconscious'
						if position.crewman.is_player_commander:
							ShowMessage('You have been knocked unconscious by the impact.',
								good_news=False)
						else:
							ShowMessage('Your crewman has been knocked unconscious by the impact:',
								crewman=position.crewman, good_news=False)
					
					scenario.UpdateCrewInfoCon()

		# clear resolved hits
		self.ap_hits_to_resolve = []
	
	
	# resolve FP on this unit if any
	def ResolveFP(self):
		if not self.alive: return
		if self.fp_to_resolve == 0: return
		
		# skip if armoured unit and no chance of effect
		if self.GetStat('armour') is not None and (self != scenario.player_unit or len(self.VulnerableCrew()) == 0):
			self.fp_to_resolve = 0
			return
		
		# move to top of hex stack
		self.MoveToTopOfStack()
		scenario.UpdateUnitCon()
		
		if self.is_player:
			ShowTutorialSlide('scenario_player_fp')
		elif self.owning_player == 1:
			ShowTutorialSlide('scenario_enemy_fp')
		
		# check for Steam achievement
		if self.owning_player == 1 and self.fp_to_resolve >= 150:
			session.ModifySteamStat('overkill', 1)
		
		# highlight unit and show initial message
		text = 'Resolving ' + str(self.fp_to_resolve) + ' firepower on '
		if self.is_player:
			text += 'you.'
		else:
			text += self.GetName() + '.'
		ShowMessage(text, scenario_highlight=(self.hx, self.hy))
		
		# unarmoured unit
		if self.GetStat('armour') is None:
		
			concealed = False
			if self.owning_player == 1 and not self.spotted:
				concealed = True
			
			if not concealed:
				# create pop-up window
				window_con = libtcod.console_new(27, 25)
				libtcod.console_set_default_background(window_con, libtcod.black)
				libtcod.console_set_default_foreground(window_con, libtcod.white)
				DrawFrame(window_con, 0, 0, 27, 25)
				
				# window title, odds header
				libtcod.console_set_default_background(window_con, libtcod.darker_blue)
				libtcod.console_rect(window_con, 1, 1, 25, 2, False, libtcod.BKGND_SET)
				libtcod.console_rect(window_con, 1, 12, 25, 1, False, libtcod.BKGND_SET)
				libtcod.console_set_default_background(window_con, libtcod.black)
				
				# Check the name isn't too long and display title
				text = 'Resolving ' + str(self.fp_to_resolve) + ' firepower'
				target_name = self.GetName()
				if len(self.GetName()) > 21:
					libtcod.console_print_ex(window_con, 13, 1, libtcod.BKGND_NONE, libtcod.CENTER, text + ' on')
					libtcod.console_print_ex(window_con, 13, 2, libtcod.BKGND_NONE, libtcod.CENTER, target_name)
				else:
					libtcod.console_print_ex(window_con, 13, 1, libtcod.BKGND_NONE, libtcod.CENTER, text)
					libtcod.console_print_ex(window_con, 13, 2, libtcod.BKGND_NONE, libtcod.CENTER,	'on ' + target_name)
				
				# display target portrait if any
				libtcod.console_set_default_background(window_con, PORTRAIT_BG_COL)
				libtcod.console_rect(window_con, 1, 3, 25, 8, False, libtcod.BKGND_SET)
				DisplayUnitPortrait(window_con, 1, 3, self, campaign.portrait_variant)
				
				# list of possible outcomes
				libtcod.console_print_ex(window_con, 13, 12, libtcod.BKGND_NONE, libtcod.CENTER,
					'Outcome Odds:')
				
			destroy_odds = 0.0
			rout_odds = 0.0
			reduction_odds = 0.0
			
			# fp has a different type of effect on vehicles and trains
			if self.GetStat('category') in ['Vehicle', 'Train Car']:
				for (fp, score) in VEH_FP_TK:
					if fp <= self.fp_to_resolve:
						destroy_odds = score
						break
				if destroy_odds > 97.0:
					destroy_odds = 97.0
			
			else:
			
				# calculate chance of destruction
				destroy_odds = RESOLVE_FP_BASE_CHANCE
				for i in range(2, self.fp_to_resolve + 1):
					destroy_odds += RESOLVE_FP_CHANCE_STEP * (RESOLVE_FP_CHANCE_MOD ** (i-1)) 
				if self.unit_fatigue > 0:
					destroy_odds += float(self.unit_fatigue) * 5.0
				destroy_odds = RestrictChance(destroy_odds)
				
				# calculate reduction odds if possible
				if 'Team' in self.GetStat('class'):
					destroy_odds = RestrictChance(destroy_odds * 1.85)
				elif self.reduced:
					destroy_odds = RestrictChance(destroy_odds * 1.2)
				elif self.GetStat('category') == 'Gun' and not self.deployed:
					destroy_odds = RestrictChance(destroy_odds * 1.4)
				else:
					reduction_odds = round(destroy_odds * 0.85, 1)
				
				# calculate rout odds if possible
				if not self.routed:
					rout_odds = destroy_odds * 0.425
					if self.fortified or self.terrain == 'Stone Buildings':
						rout_odds -= 15.0
					elif self.entrenched or self.terrain in ['Wooden Buildings', 'Woods']:
						rout_odds -= 10.0
					elif self.dug_in:
						rout_odds -= 5.0
					if rout_odds < 0.0:
						rout_odds = 0.0
					rout_odds = round(rout_odds, 1)
					
					if (self.owning_player == 1 and 'enemy_fanatic' in campaign.stats) or (self.owning_player == 0 and 'player_fanatic' in campaign.stats):
						rout_odds = 0.0
						destroy_odds = RestrictChance(destroy_odds * 1.1)
				
				# already routed
				else:
					destroy_odds = RestrictChance(destroy_odds * 3.0)

				# overkill destruction chance, if FP is high enough
				if self.fp_to_resolve >= 40 and destroy_odds == 97.0:
					destroy_odds = 99.5

				# make sure total is <= 100%
				if destroy_odds + rout_odds + reduction_odds > 100.0:
					rout_odds = max(0.0, round(100.0 - destroy_odds - reduction_odds, 1))
				
				if destroy_odds + rout_odds + reduction_odds > 100.0:
					reduction_odds = max(0.0, round(100.0 - destroy_odds - rout_odds, 1))
				
				# add unit fatigue
				self.unit_fatigue += 1
			
			# round all odds
			destroy_odds = round(destroy_odds, 1)
			rout_odds = round(rout_odds, 1)
			reduction_odds = round(reduction_odds, 1)

			text = ''
			if destroy_odds + rout_odds + reduction_odds > 0.0:
				# do roll
				roll = GetPercentileRoll()
				
				text = ''
				if roll <= destroy_odds:
					text = 'DESTROYED'
					campaign.AddJournal(self.GetName() + ' was destroyed.')
				
				elif roll <= destroy_odds + reduction_odds:
					text = 'REDUCED'
					campaign.AddJournal(self.GetName() + ' was reduced.')
				
				elif roll <= destroy_odds + reduction_odds + rout_odds:
					text = 'ROUTED'
					campaign.AddJournal(self.GetName() + ' was routed.')
				
				else:
					# guns, cavalry, and infantry test for pin here
					if self.GetStat('category') in ['Gun', 'Cavalry', 'Infantry'] and not self.pinned:
						self.PinTest(self.fp_to_resolve)
						if self.pinned:
							text = 'PINNED'
						else:
							text = 'NO EFFECT'
					else:
						text = 'NO EFFECT'
				
				# only display if there are odds of any effect
				if not concealed:
					# draw chance graph.
					# no damage, maybe pin
					DrawOddsBar(window_con, 1, 13, 25, 100, libtcod.red, False)
					
					# adjust text position based on number of possibilities
					previous_text = False

					if rout_odds > 0.0:
						cumulative_odds = round(destroy_odds + reduction_odds + rout_odds, 1)
						DrawOddsBar(window_con, 1, 13, 25, cumulative_odds, libtcod.darkest_green, False)
						libtcod.console_print_ex(window_con, 24, 14, libtcod.BKGND_NONE,
							libtcod.RIGHT, 'ROUT')
						libtcod.console_print_ex(window_con, 24, 15, libtcod.BKGND_NONE,
							libtcod.RIGHT, str(cumulative_odds) + '%')
						previous_text = True

					if reduction_odds > 0.0:
						cumulative_odds = round(destroy_odds + reduction_odds, 1)
						DrawOddsBar(window_con, 1, 13, 25, cumulative_odds, libtcod.darker_green, False)
						
						if previous_text:
							text_x = 14
							alignment = libtcod.CENTER
						else:
							text_x = 24
							alignment = libtcod.RIGHT

						libtcod.console_print_ex(window_con, text_x, 14, libtcod.BKGND_NONE,
							alignment, 'REDUCE')
						libtcod.console_print_ex(window_con, text_x, 15, libtcod.BKGND_NONE,
							alignment, str(cumulative_odds) + '%')
						previous_text = True

					if destroy_odds > 0.0:
						# destruction odds are never *exactly* 100%, so we want a bit of the underlying bar to remind the player that even if the odds are very high, 'memento alei'.
						DrawOddsBar(window_con, 1, 13, 25, destroy_odds, libtcod.dark_green, True)

						if previous_text:
							text_x = 2
							alignment = libtcod.LEFT
						else:
							text_x = 13
							alignment = libtcod.CENTER
						
						libtcod.console_print_ex(window_con, text_x, 14, libtcod.BKGND_NONE,
							alignment, 'DESTROY')
						libtcod.console_print_ex(window_con, text_x, 15, libtcod.BKGND_NONE,
							alignment, str(destroy_odds) + '%')

					elif not previous_text: # Shouldn't happen but just in case.
						libtcod.console_print_ex(window_con, 13, 14, libtcod.BKGND_NONE,
							libtcod.CENTER, 'Impossible')

					libtcod.console_set_default_foreground(window_con, libtcod.white)
					libtcod.console_set_default_background(window_con, libtcod.black)

					# blit window to screen and display a cosmetic diceroll, unless it's an automatic kill. Same 4-side roll as in bailout.
					if destroy_odds < 100.0:
						libtcod.console_blit(window_con, 0, 0, 0, 0, con, WINDOW_XM, WINDOW_YM-14)
						libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
						libtcod.console_flush()

						for i in range(3):
							libtcod.console_print_ex(window_con, 13, 17, libtcod.BKGND_NONE,
								libtcod.CENTER, 'Roll: ' + str(GetPercentileRoll()))
							libtcod.console_blit(window_con, 0, 0, 0, 0, con, WINDOW_XM, WINDOW_YM-14)
							libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
							libtcod.console_flush()
							Wait(15, ignore_animations=True)
							libtcod.console_print_ex(window_con, 13, 17, libtcod.BKGND_NONE,
								libtcod.CENTER, '           ')
						libtcod.console_print_ex(window_con, 13, 17, libtcod.BKGND_NONE,
							libtcod.CENTER, 'Roll: ' + str(roll))

					# blit window to screen again with the outcome and wait
					libtcod.console_print_ex(window_con, 13, 19, libtcod.BKGND_NONE,
						libtcod.CENTER, text)
					
					# display inputs
					if gamepad is not None:
						DisplayButton(window_con, 8, 22, GAMEPADCHAR_A)
					else:
						libtcod.console_set_default_foreground(window_con, ACTION_KEY_COL)
						libtcod.console_print(window_con, 7, 22, 'Tab')
					libtcod.console_set_default_foreground(window_con, libtcod.white)
					libtcod.console_print(window_con, 12, 22, 'Continue')

					libtcod.console_blit(window_con, 0, 0, 0, 0, con, WINDOW_XM, WINDOW_YM-14)
					libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
					libtcod.console_flush()

					if config['ArmCom2'].getboolean('message_prompt'):
						WaitForContinue(ignore_animations=True)
					else:
						FlushKeyboardEvents()
						Wait(400 + (40 * config['ArmCom2'].getint('message_pause')), allow_skip=True, ignore_animations=True)
			
				# pop-up message if unit was unspotted by player
				else:
					ShowMessage('Result: ' + text, scenario_highlight=(self.hx, self.hy))
			else:
				ShowMessage('No Effect', scenario_highlight=(self.hx, self.hy))
			
			# apply effect - we wait until here so that messages don't pop up before the window is finished
			if text == 'DESTROYED':
				self.DestroyMe()
			elif text == 'REDUCED':
				self.ReduceMe()
			elif text == 'ROUTED':
				self.RoutMe()
		
		# if unit took FP and player is overrunning their hex location, test for rout
		if self.alive and not self.routed and scenario.player_unit.overrun:
			if self.hx == 0 and self.hy == -1 and self.GetStat('category') in ['Infantry', 'Cavalry', 'Gun'] and not self.entrenched and not self.fortified:
				if not self.MoraleCheck(0.0):
					if not (self.owning_player == 1 and 'enemy_fanatic' in campaign.stats):
						if not concealed:
							ShowMessage(self.GetName() + ' was routed by the overrun attack.', scenario_highlight=(0, -1))
						self.RoutMe()
		
		# if player unit, check for crew injury
		if self == scenario.player_unit:
			result = False
			for position in self.positions_list:
				if position.crewman is None: continue
				if position.crewman.ResolveAttack({'firepower' : self.fp_to_resolve}) is not None:
					scenario.UpdateCrewInfoCon()
					result = True
			if not result:
				ShowMessage('Your crewmen suffered no injuries from the attack.', scenario_highlight=(self.hx, self.hy))
			else:
				ShowTutorialSlide('scenario_crewman_hit_by_fp')
		
		# clear fp to resolve and return
		self.fp_to_resolve = 0
	
	
	# do a morale check for this unit, eg. to recover from Pinned status
	def MoraleCheck(self, modifier):
		
		chance = MORALE_CHECK_BASE_CHANCE + modifier
		
		# apply modifiers
		if self.fortified:
			chance += 30.0
		elif self.entrenched:
			chance += 25.0
		elif self.dug_in or self.terrain == 'Stone Buildings':
			chance += 15.0
		elif self.terrain in ['Wooden Buildings', 'Woods']:
			chance += 5.0
		
		if 'elite' in self.stats:
			chance += 10.0
		
		if GetPercentileRoll() <= RestrictChance(chance):
			return True
		return False
	
	
	# do a pin test on this unit
	def PinTest(self, fp):
		
		# only infantry, cavalry, and guns are subject to pinning
		if self.GetStat('category') not in ['Infantry', 'Cavalry', 'Gun']:
			return False
		
		if self.pinned: return False
		
		chance = float(fp) * 8.0
		
		# apply modifiers
		if self.fortified:
			chance -= 35.0
		elif self.entrenched:
			chance -= 20.0
		elif self.dug_in or self.terrain == 'Stone Buildings':
			chance -= 15.0
		elif self.terrain in ['Wooden Buildings', 'Woods']:
			chance -= 10.0
		
		if 'elite' in self.stats:
			chance -= 20.0
		
		chance = RestrictChance(chance)
		
		roll = GetPercentileRoll()

		if roll <= chance:
			self.PinMe()
			return True
		return False
	
	
	# do a rout test on this unit
	def RoutTest(self):
		
		if self.routed: return
		if self.GetStat('category') not in ['Infantry', 'Cavalry', 'Gun']: return
		if self.owning_player == 1 and 'enemy_fanatic' in campaign.stats: return
		if self.owning_player == 0 and 'player_fanatic' in campaign.stats: return
		
		chance = 45.0
		if self.fortified:
			chance -= 25.0
		elif self.entrenched:
			chance -= 15.0
		if 'elite' in self.stats:
			chance -= 15.0
		if GetPercentileRoll() <= chance:
			self.RoutMe()
			if not (self.owning_player == 1 and not self.spotted):
				ShowNotification(self.GetName() + ' has been routed by the attack.')
		
	
	# pin this unit
	def PinMe(self):
		if self.GetStat('category') not in ['Gun', 'Cavalry', 'Infantry']: return
		self.pinned = True
		self.moving = False
		self.ClearAcquiredTargets(no_enemy=True)
		if self.ai is not None:
			if self.ai.state == 'Lax':
				self.ai.state = 'Alert'
		scenario.UpdateUnitCon()
		scenario.UpdateScenarioDisplay()


	# reduce this unit
	def ReduceMe(self):
		if self.GetStat('category') not in ['Gun', 'Cavalry', 'Infantry']: return
		self.reduced = True
		self.pinned = True
		self.moving = False
		self.ClearAcquiredTargets(no_enemy=True)
		scenario.UpdateUnitCon()
		scenario.UpdateScenarioDisplay()
	
	
	# rout this unit
	def RoutMe(self):
		self.routed = True
		self.pinned = False
		if self.ai is not None:
			self.ai.attitude = 'Withdraw'
		scenario.UpdateUnitCon()
		scenario.UpdateScenarioDisplay()
	
	
	# roll to see if this unit is immobilized from an immobilization attempt
	def RollToImmobilize(self, weapon):
		chance = 0.0
		
		if weapon.stats['name'] == 'AT Rifle':
			calibre = 20
		else:
			if 'calibre' not in weapon.stats: return False
			calibre = int(weapon.stats['calibre'])
		
		if weapon.ammo_type in ['HE', 'HEAT']:
			if calibre <= 37:
				chance = 2.0
			elif calibre <= 75:
				chance = 5.0
			elif calibre <= 150:
				chance = 10.0
			else:
				chance = 20.0
			
			if weapon.ammo_type == 'HEAT':
				chance = round(chance * 0.5, 1)
		
		else:
			
			if calibre <= 57:
				chance = 50.0
			elif calibre <= 95:
				chance = 75.0
			else:
				chance = 95.0
		
		movement_class = self.GetStat('movement_class')
		if movement_class is not None:
			if movement_class in ['Slow Wheeled', 'Wheeled', 'Fast Wheeled']:
				chance = round(chance * 1.5, 1)
		
		if chance > 97.0:
			chance = 97.0
		
		if GetPercentileRoll() <= chance:
			return True
		return False


	# immobilize this unit
	def ImmobilizeMe(self):
		if self.GetStat('category') != 'Vehicle': return
		
		# if non-player vehicle was moving, possible that it comes to a stop facing a slightly different direction
		if self.moving and not self.bogged and not self.is_player:
			if GetPercentileRoll() <= 40.0:
				f = choice([-1, 1])
				if self.facing is not None:
					self.facing = ConstrainDir(self.facing + f)
				if self.turret_facing is not None:
					self.PivotTurretToFace(ConstrainDir(self.turret_facing + f))
				for weapon in self.weapon_list:
					weapon.UpdateCoveredHexes()
		
		self.moving = False
		self.immobilized = True
		self.broken_down = False
		self.bogged = False
		
		# if this unit is part of player squad, remove it from the squad
		if self in scenario.player_unit.squad:
			scenario.player_unit.squad.remove(self)
			ShowMessage(self.unit_id + ' is no longer part of your squad.',
				scenario_highlight=(self.hx, self.hy))
	
	
	# destroy this unit and remove it from the game
	# if location is set, that was the location of the knock-out hit for vehicles
	def DestroyMe(self, location=None, dest_weapon=None, no_vp=False, surrender=False, force_explosion=False, abandoned=False):
		
		# check for debug flag
		if self == scenario.player_unit and DEBUG:
			if session.debug['Player Immortality']:
				ShowMessage('Debug powers save you from death!')
				self.ap_hits_to_resolve = []
				return
		
		# set flag
		self.alive = False
		
		# play sound if not surrendering / no vp
		if not (surrender or no_vp):
			PlaySoundFor(self, 'unit_ko')
		
		# remove from hex stack
		map_hex = scenario.hex_dict[(self.hx, self.hy)]
		if self in map_hex.unit_stack:
			map_hex.unit_stack.remove(self)
			
		# remove from scenario unit list
		if self in scenario.units:
			scenario.units.remove(self)
		
		# if unit was towing or being towed, break the connection
		if self.towed_by is not None:
			self.towed_by.towing = None
			self.towed_by = None
		if self.towing is not None:
			self.towing.towed_by = None
			self.towing = None
		
		# squad member was destroyed, remove from list
		if self in scenario.player_unit.squad:
			scenario.player_unit.squad.remove(self)
			campaign.AddJournal('A ' + self.unit_id + ' from our squad, commanded by ' + self.positions_list[0].crewman.last_name + ', was knocked out.')
			
			# player crew may be shaken
			for position in scenario.player_unit.positions_list:
				if position.crewman is None: continue
				if position.crewman.condition != 'Good Order': continue
				if position.crewman.DoMoraleCheck(-50): continue
				position.crewman.condition = 'Shaken'
				ShowMessage('The loss of a squadmate has shaken your crewman:',
					crewman=position.crewman, good_news=False)
		
		# remove as selected target from all player weapons, and remove from target lists
		for weapon in scenario.player_unit.weapon_list:
			if weapon.selected_target == self:
				weapon.selected_target = None
			if self in weapon.weapon_target_list:
				weapon.weapon_target_list.remove(self)
		if self in scenario.target_list:
			scenario.target_list.remove(self)
		
		# award VP to player for enemy unit destruction
		if self.owning_player == 1:
			
			if not no_vp:
				
				# add unit id to day records
				if self.unit_id in campaign_day.enemies_destroyed:
					campaign_day.enemies_destroyed[self.unit_id] += 1
				else:
					campaign_day.enemies_destroyed[self.unit_id] = 1
				
				# determine vp award amount and add to day records
				category = self.GetStat('category')
				
				if category in ['Infantry', 'Cavalry']:
					campaign_day.AddRecord('Infantry Destroyed', 1)
					vp_amount = 1
				elif category == 'Gun':
					campaign_day.AddRecord('Guns Destroyed', 1)
					vp_amount = 2
				elif category == 'Vehicle':
					campaign_day.AddRecord('Vehicles Destroyed', 1)
					if self.GetStat('class') in ['Truck', 'Tractor', 'Tankette']:
						vp_amount = 1
						if scenario.cd_map_hex.objective is not None:
							if scenario.cd_map_hex.objective['type'] == 'Convoy Attack' and self.GetStat('class') == 'Truck':
								vp_amount = 4
						
					elif self.GetStat('class') == 'Heavy Tank':
						vp_amount = 4
					else:
						vp_amount = 3
				elif category == 'Train Car':
					vp_amount = 3
				else:
					vp_amount = 2
				
				if self.transport is not None:
					vp_amount += 1
					text = self.GetStat('class') + ' was transporting a ' + self.transport + ' unit, '
					
					# passengers can possibly bail out
					roll = GetPercentileRoll()
					
					# APC
					if self.GetStat('armour') is not None:
						roll -= 15.0
					
					# if vehicle was abandoned, passengers always bail out
					if abandoned:
						roll = 0.0
					
					if roll <= 25.0:
						unit = self.UnloadPassengers()
						if unit is None:
							text += 'also destroyed.'
							session.ModifySteamStat('dest_passengers', 1)
							if self.transport in campaign_day.enemies_destroyed:
								campaign_day.enemies_destroyed[self.transport] += 1
							else:
								campaign_day.enemies_destroyed[self.transport] = 1
						else:
							text += 'which bails out of the vehicle!'
							unit.SpotMe()
					else:
						if surrender:
							text += 'which also surrenders.'
						else:
							text += 'also destroyed.'
							session.ModifySteamStat('dest_passengers', 1)
						if self.transport in campaign_day.enemies_destroyed:
							campaign_day.enemies_destroyed[self.transport] += 1
						else:
							campaign_day.enemies_destroyed[self.transport] = 1
					ShowMessage(text, scenario_highlight=(self.hx, self.hy))
				
				if campaign.stats['region'] == 'North Africa':
					vp_amount = int(float(vp_amount) * DESERT_DESTROY_MULTIPLER)
				
				if campaign_day.mission in ['Fighting Withdrawal', 'Patrol']:
					vp_amount += 1
				elif campaign_day.mission == 'Major Battle':
					vp_amount += 2
				
				if campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Defensive Strategy'):
					vp_amount += 1
				elif campaign.player_unit.CrewmanHasSkill(COMMANDER_POSITIONS, 'Exceptional Efforts'):
					vp_amount += 1
				
				if surrender and category in ['Gun', 'Vehicle']:
					vp_amount += int(float(vp_amount) * 0.5)
				
				campaign.AwardVP(vp_amount)
		
			# check for Steam stat increases
			if surrender:
				session.ModifySteamStat('dest_surrender', 1)
			
			elif not no_vp:
				
				if self.GetStat('class') == 'Infantry Squad':
					session.ModifySteamStat('dest_inf', 1)
				elif self.GetStat('class') == 'Support Weapon Team':
					session.ModifySteamStat('dest_teams', 1)
				elif self.GetStat('class') == 'Anti-Tank Gun':
					session.ModifySteamStat('dest_at', 1)
				elif self.GetStat('class') == 'Armoured Car':
					session.ModifySteamStat('dest_ac', 1)
				
				# destroyed a heavy tank with a tankette or light tank
				elif scenario.player_unit.GetStat('class') in ['Tankette', 'Light Tank'] and self.GetStat('class') == 'Heavy Tank':
					if dest_weapon is not None:
						if dest_weapon.unit == scenario.player_unit:	
							session.ModifySteamStat('destroyed_same_tank', 1)
				
				elif self.GetStat('class') == 'Armoured Train Car': 
					session.ModifySteamStat('destroyed_train_car', 1)
				
				if scenario.player_unit.overrun:
					session.ModifySteamStat('dest_overrun', 1)
				
				for weapon in self.weapon_list:
					if weapon.acquired_target is None: continue
					(ac_target, level) = weapon.acquired_target
					if ac_target == scenario.player_unit:
						session.ModifySteamStat('dest_acquired', 1)
						break
				
				if self.GetStat('class') in ['Tankette', 'Light Tank', 'Medium Tank', 'Heavy Tank', 'Tank Destroyer']:
					if len(self.positions_list) > len(scenario.player_unit.positions_list):
						session.ModifySteamStat('dest_bigger_tanks', 1)
				
				if self.GetStat('class') in ['Medium Tank', 'Heavy Tank']:
					session.ModifySteamStat('dest_real_tanks', 1)
		
		# friendly unit destroyed
		else:
		
			# player unit has been destroyed
			if self == scenario.player_unit:
				
				campaign.AddJournal('Our ' + self.unit_id + ' tank was knocked out')
				session.ModifySteamStat('knocked_out', 1)
				
				# set end-scenario flag
				scenario.finished = True
				
				# check for Steam achievement
				if campaign_day.records['Engagements Fought'] == 1:
					session.ModifySteamStat('ko_in_first_battle', 1)
				
				ShowTutorialSlide('scenario_player_ko')
				
				# do bail-out procedure
				scenario.PlayerBailOut(location=location, weapon=dest_weapon, force_explosion=force_explosion)
			
			# rescue unit was destroyed
			elif scenario.cd_map_hex.objective is not None:
				if scenario.cd_map_hex.objective['type'] == 'Rescue' and scenario.cd_map_hex.objective['rescue_unit'] is not None:
					if self == scenario.cd_map_hex.objective['rescue_unit']:
						ShowMessage('The unit that you were to rescue has been destroyed.',
							scenario_highlight=(self.hx, self.hy), longer_pause=True,
							good_news=False)
						scenario.cd_map_hex.objective = None
		
		scenario.UpdateUnitCon()
		scenario.UpdateScenarioDisplay()
	
	
	# do an explosion roll on a vehicle that has been destroyed
	def DoExplosionRoll(self, location, weapon, fire=False):
		
		if self.GetStat('category') != 'Vehicle': return False
		if 'tutorial_campaign' in campaign.stats: return
		
		chance = 0.0
		
		# hull hit
		if location is not None:
			if location == 'Hull':
				chance += 3.0
		
		# large-calibre gun hit
		if weapon is not None:
			if weapon.GetStat('type') == 'Gun':
				if weapon.GetStat('calibre') is not None:
					if int(weapon.GetStat('calibre')) >= 88:
						chance += 3.0
			elif weapon.GetStat('type') in MG_WEAPONS:
				chance -= 2.5
		
		# only MGs on vehicle, no guns or flamethrowers
		no_guns_or_ftr = True
		for weapon2 in self.weapon_list:
			if weapon2.GetStat('type') in ['Gun', 'Flame Thrower']:
				no_guns_or_ftr = False
				break
		
		if no_guns_or_ftr:
			chance -= 1.5
		
		else:
		
			# extra ammo bring carried
			extra_ammo = 0
			for weapon in self.weapon_list:
				if weapon.stats['type'] != 'Gun': continue
				total_loaded = 0
				for ammo_type in AMMO_TYPES:
					if ammo_type in weapon.ammo_stores:
						total_loaded += weapon.ammo_stores[ammo_type]
				if total_loaded > weapon.max_ammo:
					extra_ammo += weapon.max_ammo - total_loaded
			
			if extra_ammo > 0:
				chance += 0.5 * float(extra_ammo)
			
			if self.GetStat('wet_stowage') is None:
				chance += 3.0
		
			# check for flamethrower fuel on board
			for weapon2 in self.weapon_list:
				if weapon2.GetStat('type') != 'Flame Thrower': continue
				if weapon2.external_fuel: continue
				if weapon2.flame_ammo > 0:
					chance += 2.0 * float(weapon2.flame_ammo)
		
		# explosion check for an ongoing fire
		if fire:
			chance = round(chance * 0.25)
			if chance <= 0.5:
				chance = 0.5
		
		if chance <= 0.0: return False
		
		roll = GetPercentileRoll()
		
		if roll <= chance:
			return True
		return False
	
	
	# attempt to recover from pinned status at the end of an activation
	def DoRecoveryRoll(self):
		if not self.pinned: return
		
		# can't test to recover if hit by fp this turn
		if self.hit_by_fp:
			self.hit_by_fp = False
			return
		
		if not self.MoraleCheck(0): return
		self.pinned = False
		scenario.UpdateUnitCon()
		scenario.UpdateScenarioDisplay()
		if not (self.owning_player == 1 and not self.spotted):
			ShowMessage(self.GetName() + ' is no longer Pinned.', scenario_highlight=(self.hx, self.hy))



# MapHex: a single hex on the scenario map
class MapHex:
	def __init__(self, hx, hy):
		self.hx = hx
		self.hy = hy
		self.unit_stack = []				# list of units present in this map hex
		
	# Returns a unit in the hex based on the mouse's x position and the number of possibilities, or None if there aren't any at all.
	# This is almost, but not *quite*, the nearest to the mouse
	def GetMouseUnit(self, mouse_x):
		if len(self.unit_stack) == 0:
			return None
		if config['ArmCom2'].getboolean('unit_stack_display'):
			x = scenario.PlotHex(self.hx, self.hy)[0]
			if len(self.unit_stack) >= 2 and mouse_x <= x - 2:
				return self.unit_stack[1]
			elif len(self.unit_stack) >= 3 and mouse_x >= x + 2:
				return self.unit_stack[2]
		return self.unit_stack[0]


##########################################################################################
#                                  General Functions                                     #
##########################################################################################	

# display a string of text with extended characters to a console
# has options for formatting crew names
def PrintExtended(console, x, y, text, nation=None, center=False):
	if center:
		cx = x - int(len(text) / 2)
	else:
		cx = x
	for char in text:
		if char in CHAR_MAP:
			char_code = CHAR_MAP[char]
		else:
			char_code = ord(char.encode('IBM850', errors='replace'))
		libtcod.console_put_char(console, cx, y, char_code)
		cx += 1
	

# return the amount of EXP required for a personel to be at a given level
def GetExpRequiredFor(level):
	if level > CREWMAN_LEVEL_CAP:
		return -1
	exp = 0
	for l in range(1, level):
		exp += int(ceil(BASE_EXP_REQUIRED * (pow(float(l), EXP_EXPONENT))))
	return exp


# generate and return a console image of a plane
def GeneratePlaneCon(direction):
	temp_con = libtcod.console_new(3, 3)
	libtcod.console_set_default_background(temp_con, libtcod.black)
	libtcod.console_set_default_foreground(temp_con, libtcod.lightest_grey)
	libtcod.console_clear(temp_con)
	
	libtcod.console_put_char(temp_con, 0, 1, chr(196))
	libtcod.console_put_char(temp_con, 1, 1, chr(197))
	libtcod.console_put_char(temp_con, 2, 1, chr(196))
	if direction == -1:
		libtcod.console_put_char(temp_con, 1, 2, chr(193))
	else:
		libtcod.console_put_char(temp_con, 1, 0, chr(194))
	return temp_con


# export the campaign log to a text file, normally done at the end of a campaign
def ExportLog():
	
	filename = session.log_path + os.sep + 'ArmCom2_Campaign_Log_' + datetime.now().strftime("%Y-%m-%d_%H_%M_%S") + '.txt'
	with open(filename, 'w', encoding='utf-8') as f:
			
		# campaign information
		f.write(campaign.stats['name'] + '\n')
		f.write(GetDateText(campaign.stats['start_date']) + ' - ' + GetDateText(campaign.today) + '\n')
		f.write('\n')
		
		# final player tank and crew information
		f.write(campaign.player_unit.unit_id + '\n')
		if campaign.player_unit.unit_name != '':
			f.write('"' + campaign.player_unit.unit_name + '"\n')
		f.write('\n')
		
		for position in campaign.player_unit.positions_list:
			f.write(position.name + ':\n')
			if position.crewman is None:
				f.write('  [Empty]\n\n')
				continue
			f.write('  ' + position.crewman.GetCrewmanName() + '\n')
			if not position.crewman.alive:
				f.write('  KIA\n')
			else:
				f.write('  Injuries:\n')
				injured = False
				for (k, v) in position.crewman.injury.items():
					
					(status, severity, scarring) = v
					if (status is None or severity is None) and scarring is False: continue
					
					text = '  ' + k + ': '
					if status is None or severity is None:
						text += 'Scarring'
					else:
						text += severity + ' (' + status + ')'
					f.write(text + '\n')
					injured = True
				if not injured:
					f.write('  None\n')
			f.write('\n')
		f.write('\n')
		
		# Enemies destroyed over entire campaign
		f.write('Enemies Destroyed\n\n')
		if len(campaign.enemies_destroyed) == 0:
			f.write('None\n')
		else:
			for k, v in campaign.enemies_destroyed.items():
				f.write(k + ': ' + str(v) + '\n')
		
		f.write('\n\nCombat Day Journals\n\n')
		
		# list of campaign day records and journal entries
		for day, value in campaign.logs.items():
			f.write(GetDateText(day) + ':\n')
			for record in RECORD_LIST:
				if record not in value: continue
				f.write('  ' + record + ': ' + str(value[record]) + '\n')
			f.write('\n')
			
			if day in campaign.journal:
				for (time, text) in campaign.journal[day]:
					f.write(time + ' - ' + text + '\n')
			f.write('\n')
	
	ShowMessage('Campaign log saved in {user folder}\ArmCom2\logs', ignore_animations=True, no_log=True)


# show a menu for selecting a new crewman skill
def ShowSkillMenu(crewman):
	
	# update the display console
	def UpdateSkillMenu():
		
		libtcod.console_clear(skill_menu_con)
		libtcod.console_set_default_foreground(skill_menu_con, libtcod.grey)
		DrawFrame(skill_menu_con, 0, 0, 53, 55)
		
		libtcod.console_set_default_background(skill_menu_con, libtcod.darkest_blue)
		libtcod.console_rect(skill_menu_con, 1, 1, 51, 3, True, libtcod.BKGND_SET)
		libtcod.console_set_default_background(skill_menu_con, libtcod.black)
		
		libtcod.console_set_default_foreground(skill_menu_con, TITLE_COL)
		libtcod.console_print(skill_menu_con, 23, 2, 'Add Skill')
		
		# list of skills
		libtcod.console_set_default_foreground(skill_menu_con, libtcod.gold)
		libtcod.console_print(skill_menu_con, 2, 5, 'Skills')
		libtcod.console_print(skill_menu_con, 26, 5, 'Info')
		
		# more above scrolling list
		if skill_offset > 0:
			for x in range(2, 20, 3):
				libtcod.console_put_char_ex(skill_menu_con, x, 7, 24, libtcod.black, libtcod.light_grey)
		
		y = 8
		n = 0
		for (skill_name, flagged) in skill_list:
			
			# for scrolling list
			if n < skill_offset:
				n += 1
				continue
			
			if flagged:
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.grey)
			else:
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.white)
			libtcod.console_print(skill_menu_con, 2, y, skill_name)
			if n == selected_skill:
				
				# highlight selected skill
				libtcod.console_set_default_background(skill_menu_con, HIGHLIGHT_MENU_COL)
				libtcod.console_rect(skill_menu_con, 2, y, 22, 1, False, libtcod.BKGND_SET)
				libtcod.console_set_default_background(skill_menu_con, libtcod.black)
				
				# information for selected skill
				lines = wrap(session.skills[skill_name]['desc'], 23)
				y1 = 7
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.lighter_grey)
				for line in lines:
					libtcod.console_print(skill_menu_con, 26, y1, line)
					y1 += 1
				
				y1 += 1
				
				# prerequisite(s) if any
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.white)
				libtcod.console_print(skill_menu_con, 26, y1+1, 'Prerequisite(s):')
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.light_grey)
				if 'prerequisites' in session.skills[skill_name]:
					for text in session.skills[skill_name]['prerequisites']:
						libtcod.console_print(skill_menu_con, 26, y1+2, text)
						y1+=1
				else:
					libtcod.console_print(skill_menu_con, 26, y1+2, 'None')
					y1+=1
				y1+=2
				
				# minimum stats if any
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.white)
				libtcod.console_print(skill_menu_con, 26, y1+1, 'Minimum Stat(s):')
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.light_grey)
				if 'stat_req' in session.skills[skill_name]:
					for k, v in session.skills[skill_name]['stat_req'].items():
						libtcod.console_print(skill_menu_con, 26, y1+2, k + ':')
						libtcod.console_set_default_foreground(skill_menu_con, libtcod.lighter_blue)
						libtcod.console_print(skill_menu_con, 28 + len(k), y1+2, str(v))
						y1+=1
				else:
					libtcod.console_print(skill_menu_con, 26, y1+2, 'None')
				y1+=2
				
				# replaces other skill if any
				if 'replaces' in session.skills[skill_name]:
					libtcod.console_set_default_foreground(skill_menu_con, libtcod.white)
					libtcod.console_print(skill_menu_con, 26, y1+1, 'Replaces:')
					libtcod.console_set_default_foreground(skill_menu_con, libtcod.light_grey)
					libtcod.console_print(skill_menu_con, 26, y1+2, session.skills[skill_name]['replaces'])
					y1+=3
				
			y += 1
			n += 1
			
			# no more room, end display here
			if y == 47:
				break
		
		if n < len(skill_list) - skill_offset:
			for x in range(2, 20, 3):
				libtcod.console_put_char_ex(skill_menu_con, x, 47, 25, libtcod.black, libtcod.light_grey)
		
		# display inputs
		if gamepad is not None:
			if not skills_sorted:
				DisplayButton(skill_menu_con, 24, 49, GAMEPADCHAR_Y)
			DisplayButton(skill_menu_con, 24, 50, GAMEPADCHAR_DPAD_UD)
			if not skill_list[selected_skill][1]:
				DisplayButton(skill_menu_con, 24, 52, GAMEPADCHAR_A)
			DisplayButton(skill_menu_con, 24, 53, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(skill_menu_con, ACTION_KEY_COL)
			if skills_sorted:
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.darker_grey)
			libtcod.console_print(skill_menu_con, 16, 49, EnKey('q').upper())
			libtcod.console_set_default_foreground(skill_menu_con, ACTION_KEY_COL)
			libtcod.console_print(skill_menu_con, 16, 50, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(skill_menu_con, 16, 51, 'PgUp/PgDn')
			libtcod.console_print(skill_menu_con, 16, 53, 'Esc')
			if skill_list[selected_skill][1]:
				libtcod.console_set_default_foreground(skill_menu_con, libtcod.darker_grey)
			libtcod.console_print(skill_menu_con, 16, 52, EnKey('e').upper())
		
		libtcod.console_set_default_foreground(skill_menu_con, libtcod.light_grey)
		if skills_sorted:
			libtcod.console_set_default_foreground(skill_menu_con, libtcod.darker_grey)
		libtcod.console_print(skill_menu_con, 26, 49, 'Sort Skill List')
		libtcod.console_set_default_foreground(skill_menu_con, libtcod.light_grey)
		libtcod.console_print(skill_menu_con, 26, 50, 'Select Skill')
		libtcod.console_print(skill_menu_con, 26, 51, 'Select Skill (Skip 5)')
		libtcod.console_print(skill_menu_con, 26, 53, 'Cancel')
		if skill_list[selected_skill][1]:
			libtcod.console_set_default_foreground(skill_menu_con, libtcod.darker_grey)
		libtcod.console_print(skill_menu_con, 26, 52, 'Add Skill')
		
		libtcod.console_blit(skill_menu_con, 0, 0, 0, 0, con, 18, 3)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	
	# build list of skills that can be added
	skill_list = []
	for k, value in session.skills.items():
		
		# campaign skill
		if 'campaign_skill' in value: continue
		
		# crewman already has this skill
		if k in crewman.skills: continue
		
		# restricted to one or more positions
		if 'position_list' in value:
			if crewman.current_position.name not in value['position_list']: continue
		
		# crewman has an antirequistie skill
		if 'antirequisites' in value:
			has_anti = False
			for skill_name in value['antirequisites']:
				if skill_name in crewman.skills:
					has_anti = True
					break
			if has_anti: continue
		
		# crewman already has skill that is replaced by this one
		has_replaced = False
		for skill in crewman.skills:
			if 'replaces' not in session.skills[skill]: continue
			if k == session.skills[skill]['replaces']:
				has_replaced = True
				break
		if has_replaced: continue
		
		# gyro skills need a tank with a gyro
		if k in ['Basic Gyro Use', 'Advanced Gyro Use']:
			if crewman.unit is None: continue
			if not crewman.unit.alive: continue
			if 'gyro' not in crewman.unit.stats: continue
		
		# crewman does not have 1+ requirements for this skill, add to list but flag
		missing_req = False
		if 'prerequisites' in value:
			for skill_name in value['prerequisites']:
				if skill_name not in crewman.skills:
					missing_req = True
					break
		
		if 'stat_req' in value:
			for stat_name, min_value in value['stat_req'].items():
				if crewman.stats[stat_name] < min_value:
					missing_req = True
					break
		
		if missing_req:
			skill_list.append((k, True))
		else:
			skill_list.append((k, False))
	
	# no more skills can be added
	if len(skill_list) == 0:
		ShowMessage('No further skills available for this crewman.')
		return ''
	
	# create a local copy of the current screen to re-draw when we're done
	temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
	
	# darken background 
	libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
	
	# create display console
	skill_menu_con = NewConsole(53, 55, libtcod.black, libtcod.white)
	
	skills_sorted = False
	skill_offset = 0
	selected_skill = 0
	result = ''
	
	UpdateSkillMenu()
	ShowTutorialSlide('add_skill_menu')
	
	exit_menu = False
	while not exit_menu:
		
		libtcod.console_flush()
		if not GetInputEvent(allow_repeat=True): continue
		key_char = DeKey(chr(key.c).lower())
		
		# exit menu
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			exit_menu = True
			UpdateSkillMenu()
			continue
		
		# sort skill list alphabetically
		if not skills_sorted and (key_char == 'q' or session.gamepad_input == 3):
			skills_sorted = True
			skill_list = sorted(skill_list, key = lambda x: x[0])
			skill_offset = 0
			selected_skill = 0
			UpdateSkillMenu()
			continue
		
		# change selected skill
		if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
			
			if key.vk in [sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN]:
				step = 5
			else:
				step = 1
			if key_char == 'w' or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_PAGEUP] or session.gamepad_input == 11:
				selected_skill -= step
				if selected_skill < 0:
					selected_skill = len(skill_list) - 1	
			else:
				selected_skill += step
				if selected_skill > len(skill_list) - 1:
					selected_skill = 0
			
			# scroll list if required
			if selected_skill - skill_offset > 38:
				skill_offset = selected_skill - 38
			elif selected_skill < skill_offset:
				skill_offset = selected_skill
			
			UpdateSkillMenu()
			continue
		
		# add skill
		elif key_char == 'e' or session.gamepad_input == 0:
			
			(skillname, flagged) = skill_list[selected_skill]
			if flagged: continue
			
			# make sure crewman has 1+ advance point to spend
			adv_pt = False
			if DEBUG:
				if session.debug['Free Crew Advances']:
					adv_pt = True
			if crewman.adv > 0:
				adv_pt = True
			
			if not adv_pt:
				ShowNotification('Crewman has no Advance Points remaining.')
				UpdateSkillMenu()
				continue
			
			# get confirmation from player before adding skill
			if ShowNotification('Spend one advance point to gain the skill: ' + skillname + '?', confirm=True):
				result = skillname
				exit_menu = True
			UpdateSkillMenu()
			continue
	
	# re-draw original screen
	libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	del temp_con
	
	return result


# shortcut for generating consoles
def NewConsole(x, y, bg, fg, key_colour=False):
	new_con = libtcod.console_new(x, y)
	libtcod.console_set_default_background(new_con, bg)
	libtcod.console_set_default_foreground(new_con, fg)
	if key_colour:
		libtcod.console_set_key_color(new_con, KEY_COLOR)
	libtcod.console_clear(new_con)
	return new_con


# return a text description of a given calendar date
def GetDateText(text):
	date_list = text.split('.')
	return (MONTH_NAMES[int(date_list[1].lstrip('0'))] + ' ' + str(date_list[2].lstrip('0')) + 
		', ' + date_list[0])


# display date, time, and phase information to a console
# console should be 21x6
def DisplayTimeInfo(console):
	libtcod.console_clear(console)
	libtcod.console_set_default_foreground(console, libtcod.white)
	
	if campaign is None: return
	
	libtcod.console_print_ex(console, 10, 0, libtcod.BKGND_NONE, libtcod.CENTER, GetDateText(campaign.today))
	
	if campaign_day is None: return
	
	# depiction of time remaining in day
	libtcod.console_set_default_background(console, libtcod.darker_yellow)
	libtcod.console_rect(console, 0, 1, 21, 1, True, libtcod.BKGND_SET)
	
	hours = campaign_day.day_clock['hour'] - campaign_day.start_of_day['hour']
	minutes = campaign_day.day_clock['minute'] - campaign_day.start_of_day['minute']
	if minutes < 0:
		hours -= 1
		minutes += 60
	minutes += (hours * 60)
	x = int(21.0 * float(minutes) / float(campaign_day.day_length))
	libtcod.console_set_default_background(console, libtcod.dark_yellow)
	libtcod.console_rect(console, 0, 1, x, 1, True, libtcod.BKGND_SET)
	libtcod.console_set_default_background(console, libtcod.black)
	
	text = str(campaign_day.day_clock['hour']).zfill(2) + ':' + str(campaign_day.day_clock['minute']).zfill(2)
	libtcod.console_print_ex(console, 10, 1, libtcod.BKGND_NONE, libtcod.CENTER, text)
	
	# add sunrise and sunset times too
	libtcod.console_set_default_foreground(console, libtcod.dark_grey)
	text = str(campaign_day.start_of_day['hour']).zfill(2) + ':' + str(campaign_day.start_of_day['minute']).zfill(2)
	libtcod.console_print(console, 0, 1, text)
	text = str(campaign_day.end_of_day['hour']).zfill(2) + ':' + str(campaign_day.end_of_day['minute']).zfill(2)
	libtcod.console_print_ex(console, 20, 1, libtcod.BKGND_NONE, libtcod.RIGHT, text)
	                                              
	# Rattenkrieg/Urban Combat day
	if campaign_day.rattenkrieg:
		libtcod.console_set_default_foreground(console, libtcod.lighter_grey)
		libtcod.console_set_default_background(console, libtcod.dark_grey)
		libtcod.console_print_ex(console, 10, 3, libtcod.BKGND_SET,
			libtcod.CENTER, 'Urban Combat')
		libtcod.console_set_default_background(console, libtcod.black)
	
	# no scenario active, but may display the current number of maps traversed
	if scenario is None:
		if campaign_day.rattenkrieg or campaign_day.mission in ['Hold the Line', 'Amphibious Assault']:
			return
		libtcod.console_set_default_foreground(console, libtcod.light_grey)
		libtcod.console_print_ex(console, 10, 2, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Map Area: ' + str(campaign_day.maps_traversed + 1))
		return
	if not scenario.init_complete: return
	
	# current phase
	libtcod.console_set_default_foreground(console, SCEN_PHASE_COL[scenario.phase])
	libtcod.console_print_ex(console, 10, 2, libtcod.BKGND_NONE, libtcod.CENTER, 
		SCEN_PHASE_NAMES[scenario.phase] + ' Phase')
	
	# current spotted status
	if scenario.player_unit.spotted:
		libtcod.console_set_default_foreground(console, libtcod.light_grey)
		text = 'Spotted'
	else:
		libtcod.console_set_default_foreground(console, libtcod.grey)
		text = 'Unspotted'
	libtcod.console_print_ex(console, 10, 5, libtcod.BKGND_NONE, libtcod.CENTER, 
		text)
	


# display weather conditions info to a console, 18x12
def DisplayWeatherInfo(console):
	
	libtcod.console_clear(console)
	
	if campaign_day is None: return
	
	# current season on first line
	libtcod.console_set_default_foreground(console, libtcod.white)
	libtcod.console_print_ex(console, 9, 0, libtcod.BKGND_NONE, libtcod.CENTER, campaign_day.weather['Season'])
	
	# cloud conditions on second-third lines
	libtcod.console_set_default_background(console, libtcod.dark_blue)
	libtcod.console_rect(console, 0, 1, 18, 2, False, libtcod.BKGND_SET)
	
	if campaign_day.weather['Cloud Cover'] == 'Scattered':
		num = 8
	elif campaign_day.weather['Cloud Cover'] == 'Heavy':
		num = 12
	elif campaign_day.weather['Cloud Cover'] ==  'Overcast':
		num = 18
	else:
		# clear
		num = 0
	
	cell_list = (sample(list(range(18)), 18) + sample(list(range(18)), 18))
	for i in range(num):
		libtcod.console_set_char_background(console, cell_list[i], 1, libtcod.dark_grey,
			libtcod.BKGND_SET)
	for i in range(num):
		libtcod.console_set_char_background(console, cell_list[i+num], 2, libtcod.dark_grey,
			libtcod.BKGND_SET)
	
	libtcod.console_set_default_foreground(console, libtcod.white)
	libtcod.console_print_ex(console, 9, 1, libtcod.BKGND_NONE, libtcod.CENTER,
		campaign_day.weather['Cloud Cover'])
	if campaign_day.weather['Cloud Cover'] not in ['Clear', 'Overcast']:
		libtcod.console_print_ex(console, 9, 2, libtcod.BKGND_NONE, libtcod.CENTER,
			'Clouds')
	
	# precipitation
	if campaign_day.weather['Precipitation'] in ['Rain', 'Heavy Rain']:
		char = 250
		libtcod.console_set_default_foreground(console, libtcod.light_blue)
		libtcod.console_set_default_background(console, libtcod.dark_blue)
	elif campaign_day.weather['Precipitation'] in ['Mist', 'Light Snow', 'Snow', 'Blizzard']:
		char = 249
		libtcod.console_set_default_foreground(console, libtcod.light_grey)
		libtcod.console_set_default_background(console, libtcod.dark_grey)
	elif campaign_day.weather['Precipitation'] == 'Sandstorm':
		char = 177
		libtcod.console_set_default_foreground(console, libtcod.light_sepia)
		libtcod.console_set_default_background(console, libtcod.darker_sepia)
	else:
		char = 0
	libtcod.console_rect(console, 0, 3, 18, 7, False, libtcod.BKGND_SET)
	
	if campaign_day.weather['Precipitation'] in ['Rain', 'Light Snow']:
		num = 18
	elif campaign_day.weather['Precipitation'] in ['Heavy Rain', 'Snow']:
		num = 28
	elif campaign_day.weather['Precipitation'] == 'Blizzard':
		num = 34
	elif campaign_day.weather['Precipitation'] == 'Sandstorm':
		num = 50
	else:
		num = 0
	
	for i in range(num):
		x = libtcod.random_get_int(0, 0, 18)
		y = libtcod.random_get_int(0, 3, 9)
		libtcod.console_put_char(console, x, y, char)
	
	libtcod.console_set_default_foreground(console, libtcod.white)
	if campaign_day.weather['Precipitation'] != 'None':
		libtcod.console_print_ex(console, 9, 4, libtcod.BKGND_NONE, libtcod.CENTER,
			campaign_day.weather['Precipitation'])
	
	# storm status
	if campaign_day.weather['Storm']:
		libtcod.console_print_ex(console, 9, 5, libtcod.BKGND_NONE, libtcod.CENTER,
			'Storm')
	
	# temperature
	if campaign_day.weather['Temperature'] == 'Extreme Hot':
		libtcod.console_set_default_foreground(console, libtcod.light_yellow)
	elif campaign_day.weather['Temperature'] == 'Extreme Cold':
		libtcod.console_set_default_foreground(console, libtcod.lighter_blue)
	libtcod.console_print_ex(console, 9, 7, libtcod.BKGND_NONE, libtcod.CENTER,
		campaign_day.weather['Temperature'])
	
	# fog
	if campaign_day.weather['Fog'] > 0:
		libtcod.console_set_default_background(console, libtcod.light_grey)
		libtcod.console_rect(console, 0, 8, 18, 2, True, libtcod.BKGND_SET)
		libtcod.console_set_default_foreground(console, libtcod.darker_grey)
		text = ''
		if campaign_day.weather['Fog'] == 1:
			text = 'Light'
		elif campaign_day.weather['Fog'] == 3:
			text = 'Heavy'
		libtcod.console_print_ex(console, 9, 8, libtcod.BKGND_NONE, libtcod.CENTER,
			text + ' Fog')
	
	# wind conditions
	if campaign_day.weather['Wind'] > 0:
		libtcod.console_set_default_foreground(console, libtcod.white)
		if campaign_day.weather['Wind'] == 1:
			text = 'Light'
		elif campaign_day.weather['Wind'] == 2:
			text = 'Gusty'
		else:
			text = 'Strong'
		libtcod.console_print_ex(console, 9, 9, libtcod.BKGND_NONE, libtcod.CENTER,
			text + ' Winds')
	
	# ground conditions
	if campaign_day.weather['Ground'] in ['Dry', 'Wet']:
		libtcod.console_set_default_foreground(console, libtcod.light_grey)
		libtcod.console_set_default_background(console, libtcod.dark_sepia)
	elif campaign_day.weather['Ground'] == 'Muddy':
		libtcod.console_set_default_foreground(console, libtcod.grey)
		libtcod.console_set_default_background(console, libtcod.darker_sepia)
	elif campaign_day.weather['Ground'] in ['Snow', 'Deep Snow']:
		libtcod.console_set_default_foreground(console, libtcod.light_blue)
		libtcod.console_set_default_background(console, libtcod.grey)
	libtcod.console_rect(console, 0, 10, 18, 3, False, libtcod.BKGND_SET)
	
	text = campaign_day.weather['Ground']
	if campaign_day.weather['Ground'] not in ['Snow', 'Deep Snow']:
		text += ' Ground'
	libtcod.console_print_ex(console, 9, 11, libtcod.BKGND_NONE, libtcod.CENTER,
		text)


# draw an ArmCom2-style frame to the given console
# if h==0, draw a horizontal line
def DrawFrame(console, x, y, w, h):
	libtcod.console_put_char(console, x, y, 249)
	libtcod.console_put_char(console, x+w-1, y, 249)
	if h > 0:
		libtcod.console_put_char(console, x, y+h-1, 249)
		libtcod.console_put_char(console, x+w-1, y+h-1, 249)
	for x1 in range(x+1, x+w-1):
		libtcod.console_put_char(console, x1, y, 196)
		if h > 0:
			libtcod.console_put_char(console, x1, y+h-1, 196)
	if h == 0: return
	for y1 in range(y+1, y+h-1):
		libtcod.console_put_char(console, x, y1, 179)
		libtcod.console_put_char(console, x+w-1, y1, 179)


# display speech from a crewman, used for spotting enemy units and for random chatter
def ShowCrewChatter(tag, crewman, override_text=None):
	
	if 'tutorial_campaign' in campaign.stats: return
	if override_text is None:
		if tag not in session.crew_talk: return
		text = choice(session.crew_talk[tag])
	else:
		text = override_text
	
	obj = campaign
	if scenario is not None:
		if scenario.init_complete:
			obj = scenario
	
	# if crewman is None, try to select a random live and conscious crewman in the player unit
	if crewman is None:
		crew_list = []
		for position in obj.player_unit.positions_list:
			if position.crewman is None: continue
			if not position.crewman.alive: continue
			if position.crewman.condition == 'Unconscious': continue
			crew_list.append(position.crewman)
		if len(crew_list) == 0: return
		crewman = choice(crew_list)
	else:
		if not crewman.alive: return
		if crewman.condition == 'Unconscious': return
	
	# set display location and adjust for fullscreen
	x = 27 + window_x
	y = 4 + window_y
	
	lines = wrap(text, 16)
	h = len(lines) + 8
	if config['ArmCom2'].getboolean('message_prompt'):
		h += 2
	if h > 6:
		y -= int((h-6)/2)
	
	# set the console draw location
	session.msg_location = (x, y)
	
	# create message console and draw crewman name and message to it
	session.msg_con = NewConsole(30, h, libtcod.black, libtcod.lighter_blue)
	libtcod.console_set_default_background(session.msg_con, libtcod.darkest_grey)
	libtcod.console_rect(session.msg_con, 1, 0, 29, h, False, libtcod.BKGND_SET)
	DrawFrame(session.msg_con, 1, 0, 29, h)
	libtcod.console_put_char(session.msg_con, 0, int(h/2), 196)
	libtcod.console_set_default_foreground(session.msg_con, libtcod.white)
	PrintExtended(session.msg_con, 15, 1, crewman.GetCrewmanName(first_initial=True), nation=crewman.nation, center=True)
	libtcod.console_print_ex(session.msg_con, 15, 2, libtcod.BKGND_NONE, libtcod.CENTER, 'says:')
	
	y1 = 4
	for line in lines:
		libtcod.console_print_ex(session.msg_con, 15, y1, libtcod.BKGND_NONE,
			libtcod.CENTER, line)
		y1 += 1
	
	if config['ArmCom2'].getboolean('message_prompt'):
		libtcod.console_print_ex(session.msg_con, 15, h-2, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Tab to Continue')
	
	# game option to have all messages need to be dismissed manually
	if config['ArmCom2'].getboolean('message_prompt'):
		WaitForContinue()
	else:
		# allow the message to be viewed by player
		Wait(200 + (40 * config['ArmCom2'].getint('message_pause')))
	
	FlushKeyboardEvents()
	
	# add to msg log
	if campaign_day is not None:
		campaign_day.message_log.append(crewman.GetCrewmanName() + ' says: ' + text)
	
	# erase console and re-draw screen
	session.msg_con = None
	session.msg_location = None
	
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()

	
# display a message window on the screen, pause, and then clear message from screen
# possible to highlight a CD/scenario hex, and have message appear near highlighed hex but not covering it
# 'portrait' is a portrait/console to be drawn at the top of the message. The message is expanded as necessary to fit it.
# It can be a pre-prepared console or any valid 'unit' arg to be passed to DisplayUnitPortrait().
def ShowMessage(text, longer_pause=False, portrait=None, cd_highlight=None, scenario_highlight=None,
	ignore_animations=False, crewman=None, force_tab=False, good_news=None, no_log=False):
	
	# if scenario_highlight is off-map, don't show anything
	if scenario_highlight is not None:
		(hx, hy) = scenario_highlight
		if GetHexDistance(0, 0, hx, hy) > 3: return
	
	# determine size of console, loading a portrait if necessary and sizing as needed.
	if isinstance(portrait, str) or isinstance(portrait, Unit):
		portrait = DisplayUnitPortrait(unit = portrait, portrait_variant = campaign.portrait_variant)
	# the above may have failed to load anything.
	if portrait is not None:
		width = max(25, portrait.width + 2)
		height = 4 + portrait.height
	else:
		width = 25
		height = 4
	
	lines = wrap(text, width-4)
	height += len(lines)
	
	if crewman is not None:
		height += 3
	
	if config['ArmCom2'].getboolean('message_prompt'):
		height += 2
	
	# determine display location of console on screen
	
	# if we are highlighting a hex, position the console close to but not obscuring the hex
	if cd_highlight is not None:
		(hx, hy) = cd_highlight
		(x,y) = campaign_day.PlotCDHex(hx, hy)
		
		x += 29 - int(width/2)
		
		# make sure window is not too far to the right
		if x + width + window_x > WINDOW_WIDTH:
			x = WINDOW_WIDTH - width - window_x
		
		if hy <= 4:
			y += 11
		else:
			y -= (height - 2)
	
	elif scenario_highlight is not None:
		(hx, hy) = scenario_highlight
		(x,y) = scenario.PlotHex(hx, hy)
		
		x += 32 - int(width/2)
		# make sure window is not too far to the right
		if x + width + window_x> WINDOW_WIDTH:
			x = WINDOW_WIDTH - width - window_x
		
		if y >= 24:
			y -= (height - 6)
		else:
			y += 13
	
	else:
		
		# generic location in centre of map
		x = WINDOW_XM + 1 - int(width / 2)
		
		if scenario is not None:
			if not scenario.finished:
				x += 12
		
		y = WINDOW_YM - int(height / 2)
	
	# adjust for fullscreen
	x += window_x
	y += window_y
	
	# set the console display location
	session.msg_location = (x, y)
	
	# create message console
	session.msg_con = NewConsole(width, height, libtcod.darkest_grey, libtcod.white)
	
	if good_news is None:
		DrawFrame(session.msg_con, 0, 0, width, height)
	else:
		if good_news:
			libtcod.console_set_default_foreground(session.msg_con, libtcod.lighter_blue)
		else:
			libtcod.console_set_default_foreground(session.msg_con, libtcod.light_red)
		DrawFrame(session.msg_con, 0, 0, width, height)
		libtcod.console_set_default_foreground(session.msg_con, libtcod.white)
	
	# display portrait if any
	if portrait is not None:
		libtcod.console_blit(portrait, 0, 0, 0, 0, session.msg_con, 1, 1)
	
	# display message
	# try to center message vertically within console
	x = int(width / 2)
	y = int(height / 2) - int(len(lines) / 2)
	if crewman is not None: y -= 1
	if config['ArmCom2'].getboolean('message_prompt'): y -= 1
	if portrait is not None:
		y += ceil(portrait.height/2)
	
	for line in lines:
		libtcod.console_print_ex(session.msg_con, x, y, libtcod.BKGND_NONE, libtcod.CENTER, line.encode('IBM850'))
		if y == height-1: break
		y += 1
	
	# display crewman name if any
	text2 = ''
	if crewman is not None:
		y += 1
		text2 = crewman.GetCrewmanName()
		x1 = int(width / 2) - int(len(text2) / 2)
		PrintExtended(session.msg_con, x1, y, text2)
		y += 1
	
	if config['ArmCom2'].getboolean('message_prompt') or force_tab:
		libtcod.console_print_ex(session.msg_con, x, y+2, libtcod.BKGND_NONE, libtcod.CENTER,
			'Tab to Continue')
	
	# start hex highlight if any
	if cd_highlight is not None:
		campaign_day.animation['hex_highlight'] = (hx, hy)
		campaign_day.animation['hex_flash'] = 1
	elif scenario_highlight is not None:
		scenario.animation['hex_highlight'] = (hx, hy)
		scenario.animation['hex_flash'] = 1
	
	# game option to have all messages need to be dismissed manually
	if config['ArmCom2'].getboolean('message_prompt') or force_tab:
		WaitForContinue(ignore_animations=ignore_animations)
	else:
		FlushKeyboardEvents()
	
		# allow the message (and animation) to be viewed by player
		if longer_pause:
			wait_time = 200
		else:
			wait_time = 110
		Wait(wait_time + (40 * config['ArmCom2'].getint('message_pause')),
			allow_skip=True, ignore_animations=ignore_animations)
	
	FlushKeyboardEvents()
	
	# clear hex highlight if any
	if cd_highlight is not None:
		campaign_day.animation['hex_highlight'] = False
		campaign_day.UpdateAnimCon()
	elif scenario_highlight is not None:
		scenario.animation['hex_highlight'] = False
		scenario.UpdateAnimCon()
	
	# add to message log
	if campaign_day is not None and not no_log:
		if text2 != '':
			text += ' ' + text2
		campaign_day.message_log.append(text)
	
	# erase console and re-draw screen
	session.msg_con = None
	session.msg_location = None
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()


# display a simple message on the root console, no animations, just one option
def ShowSimpleMessage(text, crewman=None):
	width = 21
	lines = wrap(text, width-4)
	height = 4 + len(lines)
	if crewman is not None:
		height += 2
	text_x = int(width / 2)
	text_y = int(height / 2) - int(len(lines) / 2)
	if config['ArmCom2'].getboolean('message_prompt'):
		height += 2
	x = WINDOW_XM + 1 - int(width / 2) + window_x
	y = WINDOW_YM - int(height / 2) + window_y
	temp_con = NewConsole(width, height, libtcod.darkest_grey, libtcod.white)
	DrawFrame(temp_con, 0, 0, width, height)
	for line in lines:
		libtcod.console_print_ex(temp_con, text_x, text_y, libtcod.BKGND_NONE,
			libtcod.CENTER, line.encode('IBM850'))
		if text_y == height-1: break
		text_y += 1
	if crewman is not None:
		text_y += 1
		text = crewman.GetCrewmanName()
		text_x = int(width / 2) - int(len(text) / 2)
		PrintExtended(temp_con, text_x, text_y, text)
		text_y += 1
	if config['ArmCom2'].getboolean('message_prompt'):
		libtcod.console_print_ex(temp_con, 11, text_y+1, libtcod.BKGND_NONE, libtcod.CENTER, 'Tab to Continue')
	libtcod.console_blit(temp_con, 0, 0, 0, 0, 0, x, y)
	libtcod.console_flush()
	if config['ArmCom2'].getboolean('message_prompt'):
		WaitForContinue(ignore_animations=True)
	else:
		Wait(130 + (40 * config['ArmCom2'].getint('message_pause')), ignore_animations=True)
	FlushKeyboardEvents()
	if campaign_day is not None:
		campaign_day.message_log.append(text)
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()


# show a tutorial slide and message for the tutorial campaign, skip if this was already shown this session
def ShowTutorialSlide(slidename):
	if 'tutorial_campaign' not in campaign.stats: return
	if slidename in campaign.tutorial_slides: return
	if slidename not in session.tutorial_slides:
		print('ERROR: Missing text for tutorial slide: ' + slidename)
		return
	campaign.tutorial_slides.append(slidename)
	
	# create a new console and blit the training background console to it
	temp_con = NewConsole(65, 54, libtcod.darkest_grey, libtcod.gold)
	libtcod.console_blit(session.training_bkg, 0, 0, 0, 0, temp_con, 0, 0)
	
	slide_data = session.tutorial_slides[slidename]
	
	# display slide title
	libtcod.console_print_ex(temp_con, 32, 4, libtcod.BKGND_NONE,
		libtcod.CENTER, slide_data['title'])
	
	# display main slide text here
	y = 8
	libtcod.console_set_default_foreground(temp_con, libtcod.white)
	for text in slide_data['text']:
		for line in wrap(text, 30):
			libtcod.console_print(temp_con, 17, y, line)
			y += 1
		y += 2
	
	# display inputs
	if gamepad is not None:
		DisplayButton(temp_con, 29, 51, GAMEPADCHAR_A)
	else:
		libtcod.console_set_default_foreground(temp_con, ACTION_KEY_COL)
		libtcod.console_print(temp_con, 26, 51, 'Tab')
	libtcod.console_set_default_foreground(temp_con, libtcod.lightest_grey)
	libtcod.console_print(temp_con, 31, 51, 'Dismiss')
	
	# display the finished console, wiping in from the top
	for y in range(1, 55, 3):
		libtcod.console_blit(temp_con, 0, 0, 0, y, 0, window_x+12, window_y+3)
		libtcod.console_flush()
	libtcod.console_blit(temp_con, 0, 0, 0, 0, 0, window_x+12, window_y+3)
	WaitForContinue(ignore_animations=True)
	FlushKeyboardEvents()
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	
	
# get keyboard and/or mouse and/or game controller event; returns False if no new input
def GetInputEvent(allow_repeat=False):
	
	global key, mouse
	
	# clear the key input information
	key.vk = 0
	key.c = 0
	
	# game controller input check
	if gamepad is not None:
		
		sdl2.SDL_PumpEvents()
		
		# check for button still down from last check - don't trigger any further events until released
		if session.gamepad_button_down and sdl2.SDL_GameControllerGetButton(gamepad, session.gamepad_input) > 0:
			return False
		
		gamepad_event = False
		
		# check for left stick movement - add a 'dead zone' to ignore small inputs
		left_stick_x = sdl2.SDL_GameControllerGetAxis(gamepad, 0)
		left_stick_y = sdl2.SDL_GameControllerGetAxis(gamepad, 1)
		if left_stick_x != session.left_stick_x:
			if -CONTROLLER_STICK_DEADZONE < left_stick_x < CONTROLLER_STICK_DEADZONE:
				session.left_stick_x = 0
			else:
				session.left_stick_x = left_stick_x
				gamepad_event = True
		if left_stick_y != session.left_stick_y:
			if -CONTROLLER_STICK_DEADZONE < left_stick_y < CONTROLLER_STICK_DEADZONE:
				session.left_stick_y = 0
			else:
				session.left_stick_y = left_stick_y
				gamepad_event = True
		
		# no left stick input, reset status
		if session.left_stick_x == 0 and session.left_stick_y == 0 and session.left_stick_direction is not None:
			session.left_stick_hold_repeat = False
			session.left_stick_direction = None
		
		elif (session.left_stick_x != 0 or session.left_stick_y != 0):
			
			# store direction of left stick
			if scenario is not None:
				# flat-topped hexes
				if left_stick_y < 0:
					if left_stick_x < -CONTROLLER_STICK_X_THRESHOLD:
						session.left_stick_direction = 5
					elif left_stick_x > CONTROLLER_STICK_X_THRESHOLD:
						session.left_stick_direction = 1
					else:
						session.left_stick_direction = 0
				else:
					if left_stick_x < -CONTROLLER_STICK_X_THRESHOLD:
						session.left_stick_direction = 4
					elif left_stick_x > CONTROLLER_STICK_X_THRESHOLD:
						session.left_stick_direction = 2
					else:
						session.left_stick_direction = 3
			else:
				# pointy-topped hexes
				if left_stick_x < 0:
					if left_stick_y < -CONTROLLER_STICK_Y_THRESHOLD:
						session.left_stick_direction = 5
					elif left_stick_y > CONTROLLER_STICK_Y_THRESHOLD:
						session.left_stick_direction = 3
					else:
						session.left_stick_direction = 4
				else:
					if left_stick_y < -CONTROLLER_STICK_Y_THRESHOLD:
						session.left_stick_direction = 0
					elif left_stick_y > CONTROLLER_STICK_Y_THRESHOLD:
						session.left_stick_direction = 2
					else:
						session.left_stick_direction = 1
		
		# check for trigger activation or release
		trigger_left = sdl2.SDL_GameControllerGetAxis(gamepad, 4)
		trigger_right = sdl2.SDL_GameControllerGetAxis(gamepad, 5)
		if not session.trigger_active:
			if trigger_left > CONTROLLER_TRIGGER_DEADZONE or trigger_right > CONTROLLER_TRIGGER_DEADZONE:
				session.trigger_active = True
				gamepad_event = True
		else:
			if trigger_left <= CONTROLLER_TRIGGER_DEADZONE and trigger_right <= CONTROLLER_TRIGGER_DEADZONE:
				session.trigger_active = False
		
		# check for button inputs
		session.gamepad_input = -2
		session.gamepad_button_down = False
		for button_code in range(22):
			if sdl2.SDL_GameControllerGetButton(gamepad, button_code) > 0:
				session.gamepad_input = button_code
				session.gamepad_button_down = True
				gamepad_event = True
				break
		
		if gamepad_event:
			session.key_down = False
			return True
	
	
	# new input system - go through the SDL input queue, setting the global key and mouse objects as appropriate
	new_input = False
	event = sdl2.SDL_Event()
	while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:
		
		# check for new controller being added, or current one being removed
		# if so, show a pop-up notification, and then re-scan controllers
		if event.type == sdl2.SDL_JOYDEVICEADDED:
			ShowSimpleMessage('New game controller connected, now re-scanning controllers.')
			InitControllers()
		
		elif event.type == sdl2.SDL_JOYDEVICEREMOVED:
			ShowSimpleMessage('Game controller disconnected, now re-scanning controllers.')
			
			# we reset the selected controller and activate the most recent connected one if any
			config['ArmCom2']['active_controller'] = '0'
			InitControllers(first_time=True)
		
		elif event.type == sdl2.SDL_KEYUP:
			session.key_down = False
		
		elif event.type == sdl2.SDL_KEYDOWN:
			
			# ignore repeated key inputs unless allowed
			if session is not None:
				if session.key_down and not allow_repeat:
					continue
			
			# ignore shift/alt keys being pressed
			if event.key.keysym.sym in [sdl2.SDLK_LSHIFT, sdl2.SDLK_RSHIFT, sdl2.SDLK_LALT, sdl2.SDLK_RALT]:
				continue
			
			# update information in key object
			key.vk = event.key.keysym.sym
			key.shift = ((event.key.keysym.mod & sdl2.KMOD_SHIFT) >= 1)
			key_name = sdl2.SDL_GetKeyName(event.key.keysym.sym)
			key_char = key_name.lower()
			
			if key.vk == sdl2.SDLK_SPACE:
				key.c = 32
				key.text = ' '
			
			elif len(key_char) == 1:
				key.c = ord(key_char)
				key.text = str(key_char)
			
			# not a character
			else:
				key.c = 0
				key.text = ''
			
			new_input = True
			if session is not None:
				session.key_down = True
		
		elif event.type == sdl2.SDL_MOUSEMOTION and session is not None:
			new_cx = int(floor(event.motion.x / session.window_w * session.window_cell_width))
			new_cy = int(floor(event.motion.y / session.window_h * session.window_cell_height))
			if new_cx != mouse.cx or new_cy != mouse.cy:
				mouse.cx = new_cx
				mouse.cy = new_cy
				new_input = True
		
		elif event.type == sdl2.SDL_MOUSEBUTTONDOWN:
			if event.button.button == sdl2.SDL_BUTTON_LEFT:
				mouse.lbutton_pressed = True
			elif event.button.button == sdl2.SDL_BUTTON_RIGHT:
				mouse.rbutton_pressed = True
			new_input = True
		
		elif event.type == sdl2.SDL_MOUSEWHEEL:
			if event.wheel.y < 0:
				mouse.wheel_up = True
			elif event.wheel.y > 0:
				mouse.wheel_down = True
			new_input = True
	
	return new_input


# clear all keyboard events
def FlushKeyboardEvents():
	exit = False
	while not exit:
		libtcod.console_flush()
		event = libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS, key, mouse)
		if event != libtcod.EVENT_KEY_PRESS: exit = True
	session.key_down = False


# wait for a specified amount of miliseconds, refreshing the screen in the meantime
def Wait(wait_time, allow_skip=False, ignore_animations=False):
	
	# check for debug fast mode
	if DEBUG:
		if session.debug['Fast Mode']:
			wait_time = int(wait_time/4)
	
	wait_time = wait_time * 0.01
	start_time = time.time()
	while time.time() - start_time < wait_time:
		
		# if window is minimized, pause everything
		while not libtcod.console_is_active():
			libtcod.console_flush()
			FlushKeyboardEvents()
			continue
		
		# check for animation update in scenario or campaign day or layer
		if not ignore_animations:
			CheckForAnimationUpdate()
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		if allow_skip:
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				return
		
		FlushKeyboardEvents()


# wait for player to press continue key
# option to allow backspace pressed instead, returns True if so 
def WaitForContinue(allow_cancel=False, ignore_animations=False):
	end_pause = False
	cancel = False
	while not end_pause:
		if not ignore_animations:
			CheckForAnimationUpdate()
		libtcod.console_flush()
		if not GetInputEvent(): continue
		if (key.vk in [sdl2.SDLK_BACKSPACE, sdl2.SDLK_ESCAPE] or session.gamepad_input == 1) and allow_cancel:
			end_pause = True
			cancel = True
		elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
			end_pause = True
	if allow_cancel and cancel:
		return True
	return False


# wait for player input during an attack roll
def WaitForAttackInput(fate_point_allowed):
	end_pause = False
	while not end_pause:
		CheckForAnimationUpdate()
		libtcod.console_flush()
		if not GetInputEvent(): continue
		if key.vk in [sdl2.SDLK_BACKSPACE, sdl2.SDLK_ESCAPE] or session.gamepad_input == 1:
			return 'cancel'
		elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
			return 'continue'
		
		# can use either trigger on gamepad too
		if gamepad is not None and session.trigger_active:
			return 'continue'
			
		if (chr(key.c).lower() == 'f' or session.gamepad_input == 3) and fate_point_allowed:
			if ShowNotification('Spend a Fate Point to save yourself?', confirm=True):
				return 'fate_point'


# check for animation frame update and console update
def CheckForAnimationUpdate():
	
	weather_update_timer = 0.15 
	anim_update_timer = 0.05 + (0.05 * config['ArmCom2'].getint('animation_speed'))
	
	if scenario is not None:
		if scenario.init_complete:
			if time.time() - session.weather_anim_timer >= weather_update_timer:
				scenario.UpdateAnimCon(weather=True)
				scenario.UpdateScenarioDisplay()
			
			if time.time() - session.anim_timer >= anim_update_timer:
				scenario.UpdateAnimCon()
				scenario.UpdateScenarioDisplay()
		
	elif campaign_day is not None:
		if campaign_day.started and not campaign_day.ended:
			if time.time() - session.weather_anim_timer >= weather_update_timer:
				campaign_day.UpdateAnimCon(weather=True)
				campaign_day.UpdateCDDisplay()	
			
			if time.time() - session.anim_timer >= anim_update_timer:
				campaign_day.UpdateAnimCon()
				campaign_day.UpdateCDDisplay()	
	
	# display message console overtop if any
	if session.msg_con is not None:
		(x, y) = session.msg_location
		libtcod.console_blit(session.msg_con, 0, 0, 0, 0, 0, x, y)


# load a console image from an .xp file
def LoadXP(filename):
	
	# find file
	if os.path.exists(PORTRAITPATH + filename):
		pathname = PORTRAITPATH
	elif os.path.exists(DATAPATH + filename):
		pathname = DATAPATH
	elif os.path.exists(filename):
		pathname = ''
	else:
		# file not found
		console = libtcod.console_new(1, 1)
		libtcod.console_put_char_ex(console, 0, 0, '?', libtcod.red, libtcod.black)
		return console
	
	xp_file = gzip.open(pathname + filename)
	raw_data = xp_file.read()
	xp_file.close()
	xp_data = xp_loader.load_xp_string(raw_data)
	console = libtcod.console_new(xp_data['width'], xp_data['height'])
	xp_loader.load_layer_to_console(console, xp_data['layer_data'][0])
	return console


# Bresenham's Line Algorithm (based on an implementation on the roguebasin wiki)
# returns a series of x, y points along a line
def GetLine(x1, y1, x2, y2):
	points = []
	issteep = abs(y2-y1) > abs(x2-x1)
	if issteep:
		x1, y1 = y1, x1
		x2, y2 = y2, x2
	rev = False
	if x1 > x2:
		x1, x2 = x2, x1
		y1, y2 = y2, y1
		rev = True
	deltax = x2 - x1
	deltay = abs(y2-y1)
	error = int(deltax / 2)
	y = y1
	
	if y1 < y2:
		ystep = 1
	else:
		ystep = -1
	for x in range(x1, x2 + 1):
		if issteep:
			points.append((y, x))
		else:
			points.append((x, y))
		error -= deltay
		if error < 0:
			y += ystep
			error += deltax
	if rev:
		points.reverse()
	return points


# constrain a direction to a value 0-5
def ConstrainDir(direction):
	while direction < 0:
		direction += 6
	while direction > 5:
		direction -= 6
	return direction


# transforms an hx, hy hex location to cube coordinates
def GetCubeCoords(hx, hy):
	x = int(hx - (hy - hy&1) / 2)
	z = hy
	y = 0 - hx - z
	return (x, y, z)


# returns distance in hexes between two hexes
def GetHexDistance(hx1, hy1, hx2, hy2):
	(x1, y1, z1) = GetCubeCoords(hx1, hy1)
	(x2, y2, z2) = GetCubeCoords(hx2, hy2)
	return int((abs(x1-x2) + abs(y1-y2) + abs(z1-z2)) / 2)


# rotates a hex location around 0,0 clockwise r times
def RotateHex(hx, hy, r):
	# convert to cube coords
	(xx, yy, zz) = GetCubeCoords(hx, hy)
	for r in range(r):
		xx, yy, zz = -zz, -xx, -yy
	# convert back to hex coords
	return(int(xx + (zz - zz&1) / 2), zz)


# returns the adjacent hex in a given direction
def GetAdjacentHex(hx, hy, direction):
	direction = ConstrainDir(direction)
	(hx_mod, hy_mod) = DESTHEX[direction]
	return (hx+hx_mod, hy+hy_mod)


# returns arrow character used to indicate given direction
def GetDirectionalArrow(direction):
	if direction == 0:
		return chr(24)
	elif direction == 1:
		return chr(228)
	elif direction == 2:
		return chr(229)
	elif direction == 3:
		return chr(25)
	elif direction == 4:
		return chr(230)
	elif direction == 5:
		return chr(231)
	return '*'


# return a list of hexes along a line from hex1 to hex2
# adapted from http://www.redblobgames.com/grids/hexagons/implementation.html#line-drawing
def GetHexLine(hx1, hy1, hx2, hy2):
	
	def Lerp(a, b, t):
		a = float(a)
		b = float(b)
		return a + (b - a) * t
	
	def CubeRound(x, y, z):
		rx = round(x)
		ry = round(y)
		rz = round(z)
		x_diff = abs(rx - x)
		y_diff = abs(ry - y)
		z_diff = abs(rz - z)
		if x_diff > y_diff and x_diff > z_diff:
			rx = 0 - ry - rz
		elif y_diff > z_diff:
			ry = 0 - rx - rz
		else:
			rz = 0 - rx - ry
		return (int(rx), int(ry), int(rz))

	# get cube coordinates and distance between start and end hexes
	# (repeated here from GetHexDistance because we need more than just the distance)
	(x1, y1, z1) = GetCubeCoords(hx1, hy1)
	(x2, y2, z2) = GetCubeCoords(hx2, hy2)
	distance = int((abs(x1-x2) + abs(y1-y2) + abs(z1-z2)) / 2)
	
	hex_list = []
	
	for i in range(distance+1):
		t = 1.0 / float(distance) * float(i)
		x = Lerp(x1, x2, t)
		y = Lerp(y1, y2, t)
		z = Lerp(z1, z2, t)
		(x,y,z) = CubeRound(x,y,z)
		# convert from cube to hex coordinates and add to list
		hex_list.append((x, z))

	return hex_list


# returns a ring of hexes around a center point for a given radius
def GetHexRing(hx, hy, radius):
	if radius == 0: return [(hx, hy)]
	hex_list = []
	# get starting point
	hx -= radius
	hy += radius
	direction = 0
	for hex_side in range(6):
		for hex_steps in range(radius):
			hex_list.append((hx, hy))
			(hx, hy) = GetAdjacentHex(hx, hy, direction)
		direction += 1
	return hex_list


# returns the direction to an adjacent hex
def GetDirectionToAdjacent(hx1, hy1, hx2, hy2):
	hx_mod = hx2 - hx1
	hy_mod = hy2 - hy1
	if (hx_mod, hy_mod) in DESTHEX:
		return DESTHEX.index((hx_mod, hy_mod))
	# hex is not adjacent
	return -1


# returns the best facing to point in the direction of the target hex
def GetDirectionToward(hx1, hy1, hx2, hy2):
	(x1, y1) = scenario.PlotHex(hx1, hy1)
	(x2, y2) = scenario.PlotHex(hx2, hy2)
	bearing = GetBearing(x1, y1, x2, y2)
	
	if bearing >= 330 or bearing <= 30:
		return 0
	elif bearing <= 90:
		return 1
	elif bearing >= 270:
		return 5
	elif bearing <= 150:
		return 2
	elif bearing >= 210:
		return 4
	return 3


# return a list of hexes covered by the given hextant in direction d from hx, hy
# max range is 3
def GetCoveredHexes(hx, hy, d):
	hex_list = []
	hex_list.append((hx, hy))
	for i in range(2):
		(hx, hy) = GetAdjacentHex(hx, hy, d)
	hex_list.append((hx, hy))
	hex_list += GetHexRing(hx, hy, 1)
	return hex_list


# returns the compass bearing from x1, y1 to x2, y2
def GetBearing(x1, y1, x2, y2):
	return int((degrees(atan2((y2 - y1), (x2 - x1))) + 90.0) % 360)


# returns a bearing from 0-359 degrees
def RectifyBearing(h):
	while h < 0: h += 360
	while h > 359: h -= 360
	return h


# get the bearing from unit1 to unit2, rotated for unit1's facing
def GetRelativeBearing(unit1, unit2):
	(x1, y1) = scenario.PlotHex(unit1.hx, unit1.hy)
	(x2, y2) = scenario.PlotHex(unit2.hx, unit2.hy)
	bearing = GetBearing(x1, y1, x2, y2)
	return RectifyBearing(bearing - (unit1.facing * 60))


# get the relative facing of one unit from the point of view of another unit
# unit1 is the observer, unit2 is being observed
def GetFacing(attacker, target, turret_facing=False):
	bearing = GetRelativeBearing(target, attacker)
	if turret_facing and target.turret_facing is not None:
		turret_diff = target.turret_facing - target.facing
		bearing = RectifyBearing(bearing - (turret_diff * 60))
	if bearing >= 320 or bearing <= 40:
		return 'Front'
	if 140 <= bearing <= 220:
		return 'Rear'
	return 'Side'


# return a random float between 0.0 and 100.0
def GetPercentileRoll():
	return float(libtcod.random_get_int(0, 0, 1000)) / 10.0


# return a percentage chance based on a given 2d6 score
def Get2D6Odds(score):
	if score == 2:
		return 2.7
	elif score == 3:
		return 8.3
	elif score == 4:
		return 16.7
	elif score == 5:
		return 27.8
	elif score == 6:
		return 41.8
	elif score == 7:
		return 58.3
	elif score == 8:
		return 72.2
	elif score == 9:
		return 83.3
	elif score == 10:
		return 91.7
	else:
		return 97.2


# round and restrict odds to between 3.0 and 97.0
def RestrictChance(chance):
	chance = round(chance, 1)
	if chance < 3.0: return 3.0
	if chance > 97.0: return 97.0
	return chance


# newer, more restrictive restrict chance
def RestrictChanceNew(chance):
	chance = round(chance, 1)
	if chance < 0.5: return 0.5
	if chance > 99.5: return 99.5
	return chance


# save the current campaign to a backup
def BackupGame():
	if DEBUG:
		if session.debug['Suspend Save']: return
	
	path = SAVEPATH + campaign.filename + os.sep
	backup_path = BACKUP_PATH + campaign.filename + os.sep
	
	# previous backup already exists
	if os.path.exists(backup_path):
		os.remove(backup_path + 'savegame.dat')
		os.remove(backup_path + 'savegame.dir')
		os.remove(backup_path + 'savegame.bak')
	else:
		os.mkdir(backup_path)
	
	copyfile(path + 'savegame.dat', backup_path + 'savegame.dat')
	copyfile(path + 'savegame.dir', backup_path + 'savegame.dir')
	copyfile(path + 'savegame.bak', backup_path + 'savegame.bak')
	

# save the current campaign in progress
def SaveGame():
	if DEBUG:
		if session.debug['Suspend Save']: return
	
	path = SAVEPATH + campaign.filename + os.sep
	if not os.path.isdir(path):
		os.mkdir(path)
	
	save = shelve.open(path + 'savegame', 'n')
	save['campaign'] = campaign
	save['campaign_day'] = campaign_day
	save['scenario'] = scenario
	save['version'] = VERSION
	save['datetime'] = datetime.now().strftime("%Y-%m-%d_%H_%M_%S")
	save.close()


# load a saved game
def LoadGame(directory):
	global campaign, campaign_day, scenario
	
	libtcod.console_clear(con)
	libtcod.console_print_ex(con, WINDOW_XM, WINDOW_YM, libtcod.BKGND_NONE, libtcod.CENTER,
		'Loading...')
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	with shelve.open(SAVEPATH + directory + os.sep + 'savegame') as save:
		campaign = save['campaign']
		campaign_day = save['campaign_day']
		scenario = save['scenario']
	
	# backward compatibility checks
	if not hasattr(campaign, 'enemies_destroyed'):
		campaign.enemies_destroyed = {}
	if scenario is not None:
		if scenario.player_unit is not None:
			for position in scenario.player_unit.positions_list:
				if position.crewman is None: continue
				if position.crewman.current_cmd not in session.crew_commands:
					position.crewman.current_cmd = 'Spot'
			if scenario.phase == PHASE_SHOOTING:
				scenario.BuildTargetList()
			if not hasattr(scenario, 'rack_management_array'):
				scenario.BuildRRManagementArray()
			if not hasattr(scenario, 'player_attacking'):
				scenario.player_attacking = True


# check the saved game to see if it is compatible with the current game version: Semantic Versioning https://semver.org/
def CheckSavedGameVersion(saved_version):
	for text in ['Alpha', 'Beta']:
		if text in saved_version or text in VERSION:
			if saved_version != VERSION:
				return saved_version
	if saved_version.split('.')[0] == VERSION.split('.')[0]:
		return ''
	return saved_version


# remove a saved game
def EraseGame(directory):
	if DEBUG:
		if session.debug['Suspend Save']: return
	
	if not os.path.isdir(SAVEPATH + directory): return
	
	os.remove(SAVEPATH + directory + os.sep + 'savegame.dat')
	os.remove(SAVEPATH + directory + os.sep + 'savegame.dir')
	os.remove(SAVEPATH + directory + os.sep + 'savegame.bak')
	os.rmdir(SAVEPATH + directory)
	
	# remove backup too if it exists
	if not os.path.isdir(BACKUP_PATH + directory + os.sep): return
	os.remove(BACKUP_PATH + directory + os.sep + 'savegame.dat')
	os.remove(BACKUP_PATH + directory + os.sep + 'savegame.dir')
	os.remove(BACKUP_PATH + directory + os.sep + 'savegame.bak')
	os.rmdir(BACKUP_PATH + directory)
	

# try to load game settings from config file
def LoadCFG():
	
	CONFIG_KEYS = [
		'display_font',
		'sounds_enabled',
		'fullscreen',
		'ultrawide',
		'master_volume',
		'music',
		'unit_stack_display',
		'fancy_portraits',
		'ready_rack_refill',
		'message_pause',
		'message_prompt',
		'animation_speed',
		'keyboard',
		'glossary',
		'active_controller'
		]
	
	global config
	
	config = ConfigParser()
	
	# check for config file in old, incorrect location
	if os.path.exists(HOMEPATH + 'armcom2.cfg'):
		config_filename = HOMEPATH + 'armcom2.cfg'
	elif os.path.exists(DATAPATH + 'armcom2.cfg'):
		config_filename = DATAPATH + 'armcom2.cfg'
	
	# check for config file in correct location
	elif os.path.exists(HOMEPATH + os.sep + 'armcom2.cfg'):
		config_filename = HOMEPATH + os.sep + 'armcom2.cfg'
	
	# create a new config file in correct location
	else:
		config_filename = HOMEPATH + os.sep + 'armcom2.cfg'
	
	# try to load config file
	if os.path.exists(config_filename):
		try:
			config.read(config_filename)
			for k in CONFIG_KEYS:
				
				# compatibility checks
				if k == 'ultrawide' and k not in config['ArmCom2']:
					config['ArmCom2']['ultrawide'] = 'false'
					with open(DATAPATH + 'armcom2.cfg', 'w', encoding='utf8') as configfile:
						config.write(configfile)
					continue
				
				if k == 'ready_rack_refill' and k not in config['ArmCom2']:		
					config['ArmCom2']['ready_rack_refill'] = 'true'
					with open(DATAPATH + 'armcom2.cfg', 'w', encoding='utf8') as configfile:
						config.write(configfile)
					continue

				if k == 'fancy_portraits' and k not in config['ArmCom2']:		
					config['ArmCom2']['fancy_portraits'] = 'true'
					with open(DATAPATH + 'armcom2.cfg', 'w', encoding='utf8') as configfile:
						config.write(configfile)
					continue

				if k == 'active_controller' and k not in config['ArmCom2']:
					config['ArmCom2']['active_controller'] = '0'
					with open(DATAPATH + 'armcom2.cfg', 'w', encoding='utf8') as configfile:
						config.write(configfile)
					continue
				
				if k == 'music' and k not in config['ArmCom2']:
					config['ArmCom2']['music'] = config['ArmCom2']['main_menu_music']
					with open(DATAPATH + 'armcom2.cfg', 'w', encoding='utf8') as configfile:
						config.write(configfile)
					continue

				if k not in config['ArmCom2']:
					raise Exception('Missing config key: ' + k)
			
			# erase old config file if any and save to new location
			if config_filename in [DATAPATH + 'armcom2.cfg', HOMEPATH + 'armcom2.cfg']:
				os.remove(config_filename)
				SaveCFG()
				print('Moved old config file to user directory')
			
			return
		except:
			print('ERROR: Unable to read config file, creating a new one.')
	
	# create a new config file and write to disk
	config['ArmCom2'] = {
		'display_font' : '2',
		'sounds_enabled' : 'true',
		'fullscreen' : 'false',
		'ultrawide' : 'false',
		'master_volume' : '7',
		'music' : 'true',
		'unit_stack_display' : 'true',
		'fancy_portraits' : 'true',
		'ready_rack_refill' : 'true',
		'message_pause' : '1',
		'message_prompt' : 'false',
		'animation_speed' : '1',
		'keyboard' : '0',
		'glossary' : 'English',
		'active_controller' : '0'
	}
	SaveCFG()
	

# save current config to file
def SaveCFG():
	with open(HOMEPATH + os.sep + 'armcom2.cfg', 'w', encoding='utf8') as configfile:
		config.write(configfile)


# display a pop-up message on the root console
# can be used for yes/no confirmation
def ShowNotification(text, confirm=False, add_pause=False, simple_yn=False):
	
	# don't pause if in debug mode, we should know what we're doing!
	if DEBUG: add_pause = False
	
	# determine window x, height, and y position
	x = WINDOW_XM - 30
	lines = wrap(text, 56)
	h = len(lines) + 6
	y = WINDOW_YM - int(h/2)
	
	# create a local copy of the current screen to re-draw when we're done
	temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
	
	# darken background 
	libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.5)
	
	# draw a black rect and an outline
	libtcod.console_rect(con, x, y, 60, h, True, libtcod.BKGND_SET)
	
	DrawFrame(con, x, y, 60, h)
	
	# display message
	libtcod.console_set_default_foreground(con, libtcod.white)
	ly = y+2
	for line in lines:
		libtcod.console_print_ex(con, WINDOW_XM, ly, libtcod.BKGND_NONE,
			libtcod.CENTER, line)
		ly += 1
	
	# can add a pause to prevent accidental input
	if add_pause:
		libtcod.console_print_ex(con, WINDOW_XM, y+h-2, libtcod.BKGND_NONE, libtcod.CENTER,
			'...')
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		libtcod.console_flush()
		Wait(200, ignore_animations=True)
	
	# if asking for confirmation, display yes/no choices, otherwise display a simple message
	if gamepad is not None:
		if confirm:
			if simple_yn:
				DisplayButton(con, WINDOW_XM-1, y+h-2, GAMEPADCHAR_A)
				libtcod.console_print(con, WINDOW_XM, y+h-2, '/')
				DisplayButton(con, WINDOW_XM+1, y+h-2, GAMEPADCHAR_B)
			else:
				libtcod.console_print(con, WINDOW_XM-7, y+h-2, 'Proceed?')
				DisplayButton(con, WINDOW_XM+2, y+h-2, GAMEPADCHAR_A)
				libtcod.console_print(con, WINDOW_XM+3, y+h-2, '/')
				DisplayButton(con, WINDOW_XM+4, y+h-2, GAMEPADCHAR_B)
		else:
			DisplayButton(con, WINDOW_XM-6, y+h-2, GAMEPADCHAR_A)
			libtcod.console_print(con, WINDOW_XM-4, y+h-2, 'to Continue')
	else:
		if confirm:
			if simple_yn:
				text = 'Y/N'
			else:
				text = 'Proceed? Y/N'
		else:
			text = 'Tab to Continue'
		libtcod.console_print_ex(con, WINDOW_XM, y+h-2, libtcod.BKGND_NONE, libtcod.CENTER,
			text)
	
	# show to screen
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		key_char = chr(key.c).lower()
		if confirm:
			if key_char in ['y', 'n'] or session.gamepad_input in [0, 1]:
				libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
				libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
				del temp_con
				if key_char == 'y' or session.gamepad_input == 0:
					return True
				else:
					return False
		else:
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
				libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
				libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
				del temp_con
				return


# display the swap crew position menu, can be accessed from the scenario, campaign day, or
# campaign calendar layer
# if spotting_phase is true, this is taking place during a scenario
def ShowSwapPositionMenu(spotting_phase=False):
	
	# draw the menu console
	def DrawMenuCon():
		libtcod.console_clear(con)
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_rect(con, 0, 0, WINDOW_WIDTH, 1, False, libtcod.BKGND_SET)
		libtcod.console_set_default_foreground(con, libtcod.yellow)
		libtcod.console_print_ex(con, WINDOW_XM, 0, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Swap Crewmen Positions')
		
		# central column
		libtcod.console_set_default_foreground(con, libtcod.white)
		DrawFrame(con, 31, 1, 27, 59)
		DrawFrame(con, 31, 18, 27, 35)
		
		# display player unit and list of player crew
		DisplayUnitInfo(con, 32, 2, unit.unit_id, unit, status=False, position_highlight=position_2)
		DisplayCrew(unit, con, 32, 20, None, show_cmd=spotting_phase)
		
		# display crewman (if any) for selected position one and highlight
		crewman = unit.positions_list[position_1].crewman
		if crewman is not None:
			crewman.DisplaySimpleInfo(con, 1, 12)
		for y in range(4):
			libtcod.console_put_char_ex(con, 30, (20 + position_1 * 5) + y, 62, libtcod.lighter_blue, libtcod.darker_blue)
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_rect(con, 32, 20 + (position_1 * 5), 24, 4, False, libtcod.BKGND_SET)
		
		# display crewman (if any) for selected position two and highlight
		crewman = unit.positions_list[position_2].crewman
		if crewman is not None:
			crewman.DisplaySimpleInfo(con, 60, 12)
		for y in range(4):
			libtcod.console_put_char_ex(con, 58, (20 + position_2 * 5) + y, 60, libtcod.lighter_blue, libtcod.darker_blue)
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_rect(con, 32, 20 + (position_2 * 5), 24, 4, False, libtcod.BKGND_SET)
		libtcod.console_set_default_background(con, libtcod.black)
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 37, 54, GAMEPADCHAR_DPAD_UD)
			DisplayButton(con, 37, 55, GAMEPADCHAR_DPAD_LR)
			DisplayButton(con, 37, 56, GAMEPADCHAR_Y)
			DisplayButton(con, 37, 57, GAMEPADCHAR_A)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 33, 54, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(con, 33, 55, EnKey('a').upper() + '/' + EnKey('d').upper())
			libtcod.console_print(con, 33, 56, EnKey('e').upper())
			libtcod.console_print(con, 33, 57, 'Tab')
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		libtcod.console_print(con, 39, 54, 'Select Position 1')
		libtcod.console_print(con, 39, 55, 'Select Position 2')
		libtcod.console_print(con, 39, 56, 'Swap Positions')
		libtcod.console_print(con, 39, 57, 'Finish & Exit Menu')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	# determine which object we're working with
	if scenario is not None:
		unit = scenario.player_unit
	else:
		unit = campaign.player_unit
	
	# no positions to switch!
	if len(unit.positions_list) <= 1: return
	
	# record original crewman in each position
	original_crew = []
	for position in unit.positions_list:
		original_crew.append(position.crewman)
	
	# select first and second position as default
	position_1 = 0
	position_2 = 1
	
	# generate menu console for the first time and blit to screen
	DrawMenuCon()
	
	# get input from player
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		# continue
		if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB, sdl2.SDLK_ESCAPE] or session.gamepad_input == 0:
			
			# warn player if their commander is not in the correct position
			if unit.HasMisplacedCommander():
				text = 'You have a trained commander but an empty commander position - if you get a replacement crewman, they will not be a trained commander.'
				if not ShowNotification(text, confirm=True):
					continue
			
			exit_menu = True
			continue
		
		key_char = DeKey(chr(key.c).lower())
		
		# swap selected positions
		if key_char == 'e' or session.gamepad_input == 3:
			
			# do the swap
			temp = unit.positions_list[position_1].crewman
			unit.positions_list[position_1].crewman = unit.positions_list[position_2].crewman
			if unit.positions_list[position_1].crewman is not None:
				unit.positions_list[position_1].crewman.current_position = unit.positions_list[position_1]
				unit.positions_list[position_1].crewman.SetCEStatus()
				
			unit.positions_list[position_2].crewman = temp
			if unit.positions_list[position_2].crewman is not None:
				unit.positions_list[position_2].crewman.current_position = unit.positions_list[position_2]
				unit.positions_list[position_2].crewman.SetCEStatus()
			
			DrawMenuCon()
			continue
		
		# select position 1, but don't allow selecting same position as position 2
		elif key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
			new_position = position_1
			if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
				new_position -= 1
				if new_position == position_2:
					new_position -= 1
			else:
				new_position += 1
				if new_position == position_2:
					new_position += 1
			if new_position < 0 or new_position >= len(unit.positions_list): continue
			position_1 = new_position
			PlaySoundFor(None, 'menu_select')
			DrawMenuCon()
			continue
		
		# select position 2, but don't allow selecting same position as position 1
		if key_char in ['a', 'd'] or key.vk in [sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [13, 14]:
			new_position = position_2
			if key_char == 'a' or key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
				new_position -= 1
				if new_position == position_1:
					new_position -=1
			else:
				new_position += 1
				if new_position == position_1:
					new_position += 1
			if new_position < 0 or new_position >= len(unit.positions_list): continue
			position_2 = new_position
			PlaySoundFor(None, 'menu_select')
			DrawMenuCon()
			continue
	
	# if we're in a scenario right now, any crewman that swapped positions has their current
	# command set to None
	if scenario is not None:
		i = 0
		for position in unit.positions_list:
			if position.crewman is None:
				i += 1
				continue
			
			if position.crewman != original_crew[i]:
				if position.crewman.alive:
					position.crewman.current_cmd = 'None'
			i += 1


# display the in-game menu: 84x54
def ShowGameMenu():
	
	# draw the menu console
	def DrawMenuCon():
		
		MENU_TABS = [
			('Esc', 'Game'), ('F1', 'Glossary'), ('F2', 'Messages'), ('F3', 'Campaign'),
			('F4', 'Settings')
		]
		
		libtcod.console_clear(game_menu_con)
		
		# draw a frame to the game menu console
		libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
		DrawFrame(game_menu_con, 0, 0, 84, 54)
		
		# display game name and version number
		libtcod.console_print_ex(game_menu_con, 42, 2, libtcod.BKGND_NONE,
			libtcod.CENTER, NAME)
		libtcod.console_print_ex(game_menu_con, 42, 3, libtcod.BKGND_NONE,
			libtcod.CENTER, VERSION)
		
		# display menu tabs and highlight active tab - thanks Vanagandr!
		x = 1 
		for i in range(len(MENU_TABS)):
			
			# don't display input key if controller is active
			if gamepad is not None:
				text1 = ''
			else:
				text1 = MENU_TABS[i][0] 
			text2 = MENU_TABS[i][1] 
			if i == session.active_menu_tab: 
				y_offset = 0 
			else: 
				y_offset = 1 
			libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL) 
			libtcod.console_print(game_menu_con, x+2, 6+y_offset, text1) 
			if i == session.active_menu_tab: 
				libtcod.console_set_default_foreground(game_menu_con, libtcod.white) 
			else: 
				libtcod.console_set_default_foreground(game_menu_con, libtcod.dark_grey) 
			libtcod.console_print(game_menu_con, x+2, 7+y_offset, text2) 
			     
			libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey) 
			for y in range(6, 9): 
				libtcod.console_put_char(game_menu_con, x, y+y_offset, 14) 
				libtcod.console_put_char(game_menu_con, x+len(text2)+3, y+y_offset, 13) 
			libtcod.console_put_char(game_menu_con, x, 5+y_offset, chr(47)) 
			for i in range(1, len(text2)+3): 
				libtcod.console_put_char(game_menu_con, x+i, 5+y_offset, 15) 
				libtcod.console_put_char(game_menu_con, x+len(text2)+3, 5+y_offset, chr(92)) 
             
			x += len(text2)+4
		
		# display cycle tab command
		if gamepad is not None:
			DisplayButton(game_menu_con, x+9, 6, GAMEPADCHAR_LB)
			DisplayButton(game_menu_con, x+11, 6, GAMEPADCHAR_RB)
		else:
			libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL)
			libtcod.console_print(game_menu_con, x+8, 6, 'Tab')
		libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
		libtcod.console_print(game_menu_con, x+2, 7, 'to cycle menu tab')
		
		libtcod.console_hline(game_menu_con, 1, 9, 82)
		
		
		# main game menu
		if session.active_menu_tab == 0:
			
			# display inputs
			if gamepad is not None:
				DisplayButton(game_menu_con, 33, 26, GAMEPADCHAR_START)
				DisplayButton(game_menu_con, 33, 27, GAMEPADCHAR_Y)
				DisplayButton(game_menu_con, 33, 28, GAMEPADCHAR_A)
			else:
			
				libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL)
				libtcod.console_print(game_menu_con, 30, 26, 'Esc')
				libtcod.console_print(game_menu_con, 30, 27, 'G')
				libtcod.console_print(game_menu_con, 30, 28, 'Q')
			libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_grey)
			libtcod.console_print(game_menu_con, 35, 26, 'Close Menu')
			libtcod.console_print(game_menu_con, 35, 27, 'View Unit Gallery')
			libtcod.console_print(game_menu_con, 35, 28, 'Save and Quit to Main Menu')
		
			# display quote
			libtcod.console_set_default_foreground(game_menu_con, libtcod.grey)
			libtcod.console_print(game_menu_con, 25, 44, 'We are the Dead. Short days ago')
			libtcod.console_print(game_menu_con, 25, 45, 'We lived, felt dawn, saw sunset glow,')
			libtcod.console_print(game_menu_con, 25, 46, 'Loved and were loved, and now we lie')
			libtcod.console_print(game_menu_con, 25, 47, 'In Flanders fields.')
			libtcod.console_print(game_menu_con, 25, 49, 'John McCrae (1872-1918)')
		
		# glossary
		elif session.active_menu_tab == 1:
			
			libtcod.console_set_default_background(game_menu_con, libtcod.darkest_green)
			libtcod.console_rect(game_menu_con, 1, 10, 82, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(game_menu_con, libtcod.black)
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print_ex(game_menu_con, 42, 11, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Glossary of Game Terms')
			libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
			libtcod.console_print_ex(game_menu_con, 42, 13, libtcod.BKGND_NONE,
				libtcod.CENTER, '(' + config['ArmCom2']['glossary'] + ')')
			
			if session.glossary is None:
				libtcod.console_set_default_foreground(game_menu_con, libtcod.light_red)
				libtcod.console_print_ex(game_menu_con, 42, 15, libtcod.BKGND_NONE,
					libtcod.CENTER, 'Error: Could not open glossary.json')
			else:
				
				libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
				
				# load the selected glossary from the file
				dictionary = session.glossary[config['ArmCom2']['glossary']]
				
				y = 14
				i = 0
				for k, v in dictionary.items():
					
					# haven't gotten to top of screen yet
					if i < session.glossary_entry - 7:
						i += 1
						continue
					
					if i == 0 and session.glossary_entry < 7:
						y += (7 - session.glossary_entry) * 2
					
					# end of screen
					if i >= session.glossary_entry+12:
						break
					
					# selected entry
					if i == session.glossary_entry:
						libtcod.console_set_default_background(game_menu_con, libtcod.dark_blue)
						libtcod.console_rect(game_menu_con, 1, y, 22, 1, True, libtcod.BKGND_SET)
						libtcod.console_set_default_background(game_menu_con, libtcod.black)
						lines = wrap(v, 30)
						y1 = 22
						for line in lines:
							PrintExtended(game_menu_con, 28, y1, line)
							y1 += 1
					
					PrintExtended(game_menu_con, 2, y, k)
					y += 2
					i += 1
				
				# display inputs
				libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL)
				if gamepad is not None:
					DisplayButton(game_menu_con, 38, 49, GAMEPADCHAR_DPAD_UD)
					DisplayButton(game_menu_con, 38, 51, GAMEPADCHAR_Y)
				else:
					libtcod.console_print(game_menu_con, 30, 48, 'A-Z')
					libtcod.console_print(game_menu_con, 30, 49, 'Up/Dn')
					libtcod.console_print(game_menu_con, 30, 50, 'PgUp/PgDn')
					libtcod.console_print(game_menu_con, 30, 51, 'Space')
				
				libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_grey)
				if not gamepad is None:
					libtcod.console_print(game_menu_con, 40, 48, 'Skip to Letter')
				libtcod.console_print(game_menu_con, 40, 49, 'Scroll Up/Down')
				libtcod.console_print(game_menu_con, 40, 50, 'Scroll 10 Up/Down')
				libtcod.console_print(game_menu_con, 40, 51, 'Cycle Language')
		
		# message log
		elif session.active_menu_tab == 2:
			
			libtcod.console_set_default_background(game_menu_con, libtcod.darker_yellow)
			libtcod.console_rect(game_menu_con, 1, 10, 82, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(game_menu_con, libtcod.black)
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print_ex(game_menu_con, 42, 11, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Message Log')
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
			if campaign_day is None:
				libtcod.console_print_ex(game_menu_con, 42, 15, libtcod.BKGND_NONE,
					libtcod.CENTER, '[Empty]')
			else:
				
				if len(campaign_day.message_log) == 0:
					libtcod.console_print(game_menu_con, 4, 47, '[No Messages to Display]')
				else:
					y = 45
					for text in reversed(campaign_day.message_log[0:current_message]):
						lines = wrap(text, 74, subsequent_indent='  ')
						for line in reversed(lines):
							PrintExtended(game_menu_con, 4, y, line)
							y -= 1
							if y < 14: break
						y -= 1
						if y < 14: break
				
				# display inputs
				if gamepad is not None:
					DisplayButton(game_menu_con, 38, 49, GAMEPADCHAR_DPAD_UD)
					DisplayButton(game_menu_con, 38, 51, GAMEPADCHAR_X)
				else:
					libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL)
					libtcod.console_print(game_menu_con, 30, 49, EnKey('w').upper() + '/' + EnKey('s').upper())
					libtcod.console_print(game_menu_con, 30, 50, 'PgUp/PgDn')
					libtcod.console_print(game_menu_con, 30, 51, 'End')
				
				libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_grey)
				libtcod.console_print(game_menu_con, 40, 49, 'Scroll Up/Down')
				libtcod.console_print(game_menu_con, 40, 50, 'Scroll 10 Up/Down')
				libtcod.console_print(game_menu_con, 40, 51, 'Scroll to Most Recent')
				
		
		# campaign info
		elif session.active_menu_tab == 3:
			
			libtcod.console_set_default_background(game_menu_con, libtcod.darker_blue)
			libtcod.console_rect(game_menu_con, 1, 10, 82, 3, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(game_menu_con, libtcod.black)
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			
			libtcod.console_print_ex(game_menu_con, 42, 11, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Current Campaign Info')
			
			# display basic campaign info here
			libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_blue)
			libtcod.console_print_ex(game_menu_con, 21, 15, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Current Campaign')
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print(game_menu_con, 2, 18, 'Name:')
			libtcod.console_print(game_menu_con, 2, 20, 'Start:')
			libtcod.console_print(game_menu_con, 2, 22, 'End:')         
			libtcod.console_print(game_menu_con, 2, 24, 'Player Nation:')
			libtcod.console_print(game_menu_con, 2, 26, 'Region:')
			libtcod.console_print(game_menu_con, 2, 28, 'Combat Day:')
			libtcod.console_print(game_menu_con, 2, 30, 'Difficulty:')
			libtcod.console_print(game_menu_con, 2, 32, 'Creator:')
			libtcod.console_print(game_menu_con, 2, 34, 'Enemy Nations:')
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.orange)
			libtcod.console_print(game_menu_con, 8, 18, campaign.stats['name'])
			libtcod.console_print(game_menu_con, 9, 20, GetDateText(campaign.stats['start_date']))
			libtcod.console_print(game_menu_con, 7, 22, GetDateText(campaign.stats['end_date']))
			libtcod.console_print(game_menu_con, 17, 24, campaign.stats['player_nation'])
			libtcod.console_print(game_menu_con, 10, 26, campaign.stats['region'])
			
			days = campaign.combat_calendar.index(campaign.today) + 1
			total_days = len(campaign.combat_calendar)
			libtcod.console_print(game_menu_con, 14, 28, str(days) + '/' + str(total_days))
			
			if 'difficulty' in campaign.stats:
				text = campaign.stats['difficulty'] + '/10'
			else:
				text = 'N/A'			
			libtcod.console_print(game_menu_con, 14, 30, text)
			
			if 'creator' in campaign.stats:
				text = campaign.stats['creator']
			else:
				text = 'N/A'
			libtcod.console_print(game_menu_con, 11, 32, text)
			
			text = ''
			for nation in campaign.stats['enemy_nations']:
				if text != '':
					text += ', '
				text += nation
			lines = wrap(text, 40)
			y = 36
			for line in lines:
				libtcod.console_print(game_menu_con, 3, y, line)
				y += 1
			
			# display active campaign options and AI difficult level, total VP modifier
			libtcod.console_set_default_foreground(game_menu_con, libtcod.lighter_blue)
			libtcod.console_print_ex(game_menu_con, 63, 15, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Active Campaign Options')
			
			y = 18
			for (name, k, desc, mod) in CAMPAIGN_OPTIONS:
				
				# skip inactive options
				if k != 'ai_difficulty' and not campaign.options[k]: continue
				
				libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
				libtcod.console_print(game_menu_con, 46, y, name)
				
				if k == 'ai_difficulty':
					if campaign.options[k] == -1:
						text = 'Easy'
						mod = -20
					elif campaign.options[k] == 0:
						text = 'Normal'
						mod = 0
					elif campaign.options[k] == 1:
						text = 'Hard'
						mod = 15
					else:
						text = 'Very Hard'
						mod = 20
					libtcod.console_print(game_menu_con, 67, y, text)
				
				if mod == 0:
					col = libtcod.grey
				elif mod < 0:
					col = libtcod.light_red
				else:
					col = libtcod.light_green
				libtcod.console_set_default_foreground(game_menu_con, col)
				if mod == 0:
					text = '-'
				else:
					text = ''
					if mod > 0: text += '+'
					text += str(mod) + '%' 
				libtcod.console_print(game_menu_con, 77, y, text)
				
				y += 3
			
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print(game_menu_con, 46, 40, 'Total VP Modifier:')
			
			text = ''
			if campaign.vp_modifier == 0:
				col = libtcod.grey
				text = '--'
			else:
				if campaign.vp_modifier < 0:
					col = libtcod.light_red
				else:
					col = libtcod.light_green
					text += '+'
				libtcod.console_set_default_foreground(game_menu_con, col)
				text += str(campaign.vp_modifier) + '%'
			libtcod.console_print(game_menu_con, 77, 40, text)
		
		# game settings
		elif session.active_menu_tab == 4:
			
			# display crew command hotkeys
			libtcod.console_set_default_foreground(game_menu_con, libtcod.light_green)
			libtcod.console_print(game_menu_con, 2, 20, 'Crew Command Hotkeys')
			y = 22
			libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
			for k, v in QUICK_COMMANDS.items():
				libtcod.console_print(game_menu_con, 2, y, k)
				libtcod.console_print(game_menu_con, 4, y, v)
				y += 1
			
			# section title
			libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
			libtcod.console_print_ex(game_menu_con, 42, 18, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Game Options')
			libtcod.console_set_default_background(game_menu_con, libtcod.darker_blue)
			libtcod.console_rect(game_menu_con, 32, 18, 21, 1, False, libtcod.BKGND_SET)
			libtcod.console_set_default_background(game_menu_con, libtcod.black)
			
			# display game options
			DisplayGameOptions(game_menu_con, WINDOW_XM-19, 22, skip_esc=True)
			
			# display inputs
			if gamepad is not None:
				DisplayButton(game_menu_con, 42, 44, GAMEPADCHAR_DPAD_UD)
				DisplayButton(game_menu_con, 42, 45, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(game_menu_con, ACTION_KEY_COL)
				libtcod.console_print(game_menu_con, 40, 44, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(game_menu_con, 40, 45, 'Enter')
		
			libtcod.console_set_default_foreground(game_menu_con, libtcod.light_grey)
			libtcod.console_print(game_menu_con, 47, 44, 'Select')
			libtcod.console_print(game_menu_con, 47, 45, 'Activate')
		
		libtcod.console_blit(game_menu_con, 0, 0, 0, 0, con, 3, 3)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		if session.active_menu_tab == 0:
			ShowTutorialSlide('game_menu_0')
		elif session.active_menu_tab == 1:
			ShowTutorialSlide('game_menu_1')
		elif session.active_menu_tab == 2:
			ShowTutorialSlide('game_menu_2')
		elif session.active_menu_tab == 3:
			ShowTutorialSlide('game_menu_3')
		elif session.active_menu_tab == 4:
			ShowTutorialSlide('game_menu_4')
	
	# create a local copy of the current screen to re-draw when we're done
	temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
	
	# darken screen background
	libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
	
	# index of last message currently displayed in log
	current_message = len(campaign_day.message_log)
	
	# generate menu console for the first time and blit to screen
	DrawMenuCon()
	
	# get input from player
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		
		# allow key repeating if we are scrolling through the glossary or message log
		if 0 < session.active_menu_tab < 3:
			if not GetInputEvent(allow_repeat=True): continue
		else:
			if not GetInputEvent(): continue
		
		# change active menu tab
		if key.vk == sdl2.SDLK_ESCAPE and session.active_menu_tab != 0:
			session.active_menu_tab = 0
			DrawMenuCon()
			continue
		elif key.vk == sdl2.SDLK_F1 and session.active_menu_tab != 1:
			session.active_menu_tab = 1
			DrawMenuCon()
			continue
		elif key.vk == sdl2.SDLK_F2 and session.active_menu_tab != 2:
			session.active_menu_tab = 2
			DrawMenuCon()
			continue
		elif key.vk == sdl2.SDLK_F3 and session.active_menu_tab != 3:
			session.active_menu_tab = 3
			DrawMenuCon()
			continue
		elif key.vk == sdl2.SDLK_F4 and session.active_menu_tab != 4:
			session.active_menu_tab = 4
			DrawMenuCon()
			continue
		
		# cycle active menu tab
		elif key.vk == sdl2.SDLK_TAB or session.gamepad_input in [9, 10]:
			if key.shift or session.gamepad_input == 9:
				session.active_menu_tab -= 1
				if session.active_menu_tab < 0:
					session.active_menu_tab = 4
			else:
				session.active_menu_tab += 1
				if session.active_menu_tab > 4:
					session.active_menu_tab = 0
			DrawMenuCon()
			continue
		
		# don't map keys if game tab active
		if session.active_menu_tab == 0:
			key_char = chr(key.c).lower()
		else:
			key_char = DeKey(chr(key.c).lower())
		
		# main menu tab
		if session.active_menu_tab == 0:
			
			# close menu and return to game
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 6:
				exit_menu = True
				continue
			
			# save and quit
			if key_char == 'q' or session.gamepad_input == 0:
				libtcod.console_clear(con)
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print_ex(con, WINDOW_XM, WINDOW_YM, libtcod.BKGND_NONE, libtcod.CENTER,
					'Saving Game...')
				libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
				libtcod.console_flush()
				
				SaveGame()
				session.exiting = True
				exit_menu = True
				continue
			
			# unit gallery
			elif key_char == 'g' or session.gamepad_input == 3:
				PlaySoundFor(None, 'menu_select')
				UnitGallery()
				continue
		
		# glossary tab
		elif session.active_menu_tab == 1 or session.gamepad_input == 6:
			
			if key.vk == sdl2.SDLK_F1:
				exit_menu = True
				continue
			
			if session.glossary is None: continue
			
			# cycle glossary language
			if key.vk == sdl2.SDLK_SPACE or session.gamepad_input == 3:
				keys = list(session.glossary.keys())
				
				# shout not happen, but just in case
				if config['ArmCom2']['glossary'] not in keys:
					config['ArmCom2']['glossary'] = 'English'
					SaveCFG()
					session.glossary_entry = 0
					DrawMenuCon()
					continue
				
				i = keys.index(config['ArmCom2']['glossary'])
				if i == len(keys) - 1:
					i = 0
				else:
					i += 1
				config['ArmCom2']['glossary'] = keys[i]
				SaveCFG()
				session.glossary_entry = 0
				DrawMenuCon()
				continue
			
			# scroll list
			if key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
				i = len(session.glossary[config['ArmCom2']['glossary']].keys())
				
				if key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
					step = 1
				else:
					step = 10
				if key.vk in [sdl2.SDLK_UP, sdl2.SDLK_PAGEUP] or session.gamepad_input == 11:
					session.glossary_entry -= step
					if session.glossary_entry < 0:
						session.glossary_entry = i-1
				else:
					session.glossary_entry += step
					if session.glossary_entry > i-1:
						session.glossary_entry = 0
				DrawMenuCon()
				continue
			
			# jump to letter
			if 97 <= ord(key_char) <= 122:
				i = 0
				target_code = ord(key_char) 
				for k, v in session.glossary[config['ArmCom2']['glossary']].items():
					if ord(k[0].lower()) >= target_code:
						session.glossary_entry = i
						break
					i += 1
				else:
					session.glossary_entry = i-1
				DrawMenuCon()
				continue
		
		# message log
		elif session.active_menu_tab == 2:
			
			if key.vk == sdl2.SDLK_F2 or session.gamepad_input == 6:
				exit_menu = True
				continue
		
			# scroll list
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN, sdl2.SDLK_END] or session.gamepad_input in [2, 11, 12]:
				
				if key.vk == sdl2.SDLK_END or session.gamepad_input == 2:
					current_message = len(campaign_day.message_log)
					DrawMenuCon()
					continue
				
				if key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or key_char in ['w', 's'] or session.gamepad_input in [11, 12]:
					step = 1
				else:
					step = 10
				if key.vk in [sdl2.SDLK_UP, sdl2.SDLK_PAGEUP] or key_char == 'w' or session.gamepad_input == 11:
					current_message -= step
					if current_message < 1:
						current_message = 1
				else:
					current_message += step
					if current_message > len(campaign_day.message_log):
						current_message = len(campaign_day.message_log)
				
				DrawMenuCon()
				continue
		
		# campaign info
		elif session.active_menu_tab == 3:
			
			if key.vk == sdl2.SDLK_F3 or session.gamepad_input == 6:
				exit_menu = True
				continue
		
		# game settings
		elif session.active_menu_tab == 4:
			
			if key.vk == sdl2.SDLK_F4 or session.gamepad_input == 6:
				exit_menu = True
				continue
			
			# change selected item
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					i = -1
				else:
					i = 1
				session.options_item += i
				if session.options_item < 0:
					session.options_item = len(GAME_OPTIONS) - 2	
				elif session.options_item > len(GAME_OPTIONS) - 2:
					session.options_item = 0
				DrawMenuCon()
				continue
			
			# activate selected item
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
				ChangeGameSettings()
				DrawMenuCon()
				continue
			
			# may have changed controllers, update the screen
			DrawMenuCon()
	
	# re-draw original screen
	libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)


# display a list of game options and current settings
def DisplayGameOptions(console, x, y, skip_esc=False):
	
	i = 0
	
	for option_text in GAME_OPTIONS:
		
		if option_text == 'Return to Main Menu' and skip_esc:
			i += 1
			continue
		
		# extra spacing
		if option_text == 'Return to Main Menu': y += 1
		
		# highlight if selected
		if i == session.options_item:
			libtcod.console_set_default_background(console, libtcod.dark_blue)
			libtcod.console_rect(console, x+1, y, 22, 1, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(console, libtcod.black)
		
		# option disabled
		if option_text == 'Music' and not config['ArmCom2'].getboolean('sounds_enabled'):
			libtcod.console_set_default_foreground(console, libtcod.darker_grey)
		else:
			libtcod.console_set_default_foreground(console, libtcod.lighter_grey)
		libtcod.console_print(console, x+2, y, option_text)
		
		# current option settings
		libtcod.console_set_default_foreground(console, libtcod.light_blue)
		
		if option_text == 'Font Size':
			i2 = config['ArmCom2'].getint('display_font')
			if i2 == 0:
				text = '8x8'
			elif i2 == 1:
				text = '12x12'
			else:
				text = '16x16'
		
		elif option_text == 'Fullscreen':
			if config['ArmCom2'].getboolean('fullscreen'):
				text = 'ON'
			else:
				text = 'OFF'
		
		elif option_text == 'Ultrawide Fullscreen':
			if config['ArmCom2'].getboolean('ultrawide'):
				text = 'ON'
			else:
				text = 'OFF'
		
		elif option_text == 'Sound Effects':
			if config['ArmCom2'].getboolean('sounds_enabled'):
				text = 'ON'
			else:
				text = 'OFF'
		
		elif option_text == 'Music':
			if config['ArmCom2'].getboolean('music'):
				text = 'ON'
			else:
				text = 'OFF'
		
		elif option_text == 'Master Volume':
			text = str(config['ArmCom2'].getint('master_volume'))
		
		elif option_text == 'Message Pause':
			text = ['Short', 'Normal', 'Long', 'Very Long', 'Extra Long'][config['ArmCom2'].getint('message_pause')]
		
		elif option_text == 'Must Dismiss Messages':
			if config['ArmCom2'].getboolean('message_prompt'):
				text = 'ON'
			else:
				text = 'OFF'
		
		elif option_text == 'Animation Speed':
			text = ['Fast', 'Normal', 'Slow'][config['ArmCom2'].getint('animation_speed')]
		
		elif option_text == 'Unit Stack Display':
			if config['ArmCom2'].getboolean('unit_stack_display'):
				text = 'ON'
			else:
				text = 'OFF'

		elif option_text ==  'New Inf/Cav Portraits':
			if config['ArmCom2'].getboolean('fancy_portraits'):
				text = 'ON'
			else:
				text = 'OFF'

		elif option_text == 'Ready Rack Refill':
			if config['ArmCom2'].getboolean('ready_rack_refill'):
				text = 'Default or Saved Loadout'
			else:
				text = 'OFF'

		elif option_text == 'Keyboard':
			text = KEYBOARDS[config['ArmCom2'].getint('keyboard')]
		
		elif option_text == 'Active Controller':
			if config['ArmCom2'].getint('active_controller') == 0 or gamepad is None:
				text = 'Keyboard'
			else:
				text = str(sdl2.SDL_GameControllerName(gamepad).decode())
		
		elif option_text == 'Return to Main Menu':
			text = ''
		
		libtcod.console_print(console, x+24, y, text)
		
		# special note for font size on SD
		if option_text == 'Font Size' and i2 != 0 and session.window_w <= 1280:
			libtcod.console_set_default_foreground(console, libtcod.light_grey)
			libtcod.console_print(console, x+30, y, '(8x8 best for Steam Deck)')
			libtcod.console_set_default_foreground(console, libtcod.light_blue)
		
		y += 1
		i += 1


# init the main console
def InitMainConsole():
	global window_x, window_y
	
	if config.getboolean('ArmCom2', 'fullscreen'):
		if config.getboolean('ArmCom2', 'ultrawide'):
			libtcod.console_init_root(UW_SCREEN_WIDTH, UW_SCREEN_HEIGHT, WINDOW_NAME,
			fullscreen=True, renderer=RENDERER, order='F', vsync=True)
			window_x, window_y = 34, 4
		else:
			libtcod.console_init_root(SCREEN_WIDTH, SCREEN_HEIGHT, WINDOW_NAME,
				fullscreen=True, renderer=RENDERER, order='F', vsync=True)
			window_x, window_y = 15, 4
	else:
		libtcod.console_init_root(WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_NAME,
			fullscreen=False, renderer=RENDERER, order='F', vsync=True)
		window_x, window_y = 0, 0
	if session is not None:
		session.UpdateDisplaySize()
	

# take a keyboard input and change game settings
def ChangeGameSettings(main_menu=False):
	
	global scenario, window_x, window_y

	# cycle font size
	selected_option = GAME_OPTIONS[session.options_item]
	
	if selected_option == 'Font Size':
		i = config['ArmCom2'].getint('display_font')
		i += 1
		if i > 2: i = 0
		config['ArmCom2']['display_font'] = str(i)
		
		if i == 0:
			fontname = 'c64_8x8_ext.png'
		elif i == 1:
			fontname = 'c64_12x12_ext.png'
		else:
			fontname = 'c64_16x16_ext.png'
		
		libtcod.console_set_custom_font(DATAPATH+fontname, libtcod.FONT_LAYOUT_ASCII_INROW, 16, 18)
		InitMainConsole()
		
		# disable window resizing now if not in fullscreen mode
		if config['ArmCom2']['fullscreen'] == 'false':
			sdl2.SDL_SetWindowResizable(sdl2.SDL_GetWindowFromID(session.window_id), sdl2.SDL_FALSE)
		
		FlushKeyboardEvents()
	
	# toggle fullscreen mode on/off
	elif selected_option == 'Fullscreen':
		if config.getboolean('ArmCom2', 'fullscreen'):
			config['ArmCom2']['fullscreen'] = 'false'
		else:
			
			# don't allow if not supported on renderer
			if libtcod.sys_get_renderer() not in [3, 4]:
				FlushKeyboardEvents()
				return
			config['ArmCom2']['fullscreen'] = 'true'
		
		InitMainConsole()
		
		# disable window resizing now if not in fullscreen mode
		if config['ArmCom2']['fullscreen'] == 'false':
			sdl2.SDL_SetWindowResizable(sdl2.SDL_GetWindowFromID(session.window_id), sdl2.SDL_FALSE)
		
		FlushKeyboardEvents()
	
	# toggle ultrawide fullscreen on/off
	elif selected_option == 'Ultrawide Fullscreen':
		if config['ArmCom2'].getboolean('ultrawide'):
			config['ArmCom2']['ultrawide'] = 'false'
		else:
			config['ArmCom2']['ultrawide'] = 'true'
		
		# reset screen if in fullscreen mode
		if config.getboolean('ArmCom2', 'fullscreen'):
			InitMainConsole()
			FlushKeyboardEvents()
			
			# disable window resizing
			sdl2.SDL_SetWindowResizable(sdl2.SDL_GetWindowFromID(session.window_id), sdl2.SDL_FALSE)
	
	# toggle sound effects on/off
	elif selected_option == 'Sound Effects':
		if config['ArmCom2'].getboolean('sounds_enabled'):
			config['ArmCom2']['sounds_enabled'] = 'false'
			# stop main theme if in main menu
			if main_menu:
				session.MusicHandler('main', False)
		else:
			if not session.InitMixer():
				print('Not able to init mixer, sounds remain disabled')
				return False
			config['ArmCom2']['sounds_enabled'] = 'true'
			# start main theme music if in main menu
			if main_menu:
				session.MusicHandler('main', True)
	
	# toggle music on/off
	elif selected_option == 'Music':
		if not config['ArmCom2'].getboolean('sounds_enabled'): return
		if config['ArmCom2'].getboolean('music'):
			config['ArmCom2']['music'] = 'false'
			# stop main theme if in main menu
			if main_menu:
				session.MusicHandler('main', False)
		else:
			config['ArmCom2']['music'] = 'true'
			# start main theme music if in main menu
			if main_menu:
				session.MusicHandler('main', True)
	
	# cycle master volume level
	elif selected_option == 'Master Volume':
		if config['ArmCom2'].getboolean('sounds_enabled'):
			i = config['ArmCom2'].getint('master_volume')
			if i == 10:
				i = 1
			else:
				i += 1
			config['ArmCom2']['master_volume'] = str(i)
			session.SetMasterVolume(i)
	
	# cycle message pause length
	elif selected_option == 'Message Pause':
		i = config['ArmCom2'].getint('message_pause')
		if i == 4:
			i = 0
		else:
			i += 1
		config['ArmCom2']['message_pause'] = str(i)
	
	# toggle messages must be dismissed
	elif selected_option == 'Must Dismiss Messages':
		if config['ArmCom2'].getboolean('message_prompt'):
			config['ArmCom2']['message_prompt'] = 'false'
		else:
			config['ArmCom2']['message_prompt'] = 'true'
	
	# cycle animation speed
	elif selected_option == 'Animation Speed':
		i = config['ArmCom2'].getint('animation_speed')
		if i == 2:
			i = 0
		else:
			i += 1
		config['ArmCom2']['animation_speed'] = str(i)
	
	# toggle unit stack display
	elif selected_option == 'Unit Stack Display':
		if config.getboolean('ArmCom2', 'unit_stack_display'):
			config['ArmCom2']['unit_stack_display'] = 'false'
		else:
			config['ArmCom2']['unit_stack_display'] = 'true'
		if scenario is not None:
			scenario.UpdateUnitCon()

	# toggle using new-style infantry/cavalry unit portraits
	elif selected_option ==  'New Inf/Cav Portraits':
		if config.getboolean('ArmCom2', 'fancy_portraits'):
			config['ArmCom2']['fancy_portraits'] = 'false'
		else:
			config['ArmCom2']['fancy_portraits'] = 'true'

	# ready-rack refill preference
	elif selected_option == 'Ready Rack Refill':
		if config.getboolean('ArmCom2', 'ready_rack_refill'):
			config['ArmCom2']['ready_rack_refill'] = 'false'
		else:
			config['ArmCom2']['ready_rack_refill'] = 'true'

	# switch keyboard layout
	elif selected_option == 'Keyboard':
		i = config['ArmCom2'].getint('keyboard')
		if i == len(KEYBOARDS) - 1:
			i = 0
		else:
			i += 1
		config['ArmCom2']['keyboard'] = str(i)
		session.GenerateKeyboards()
	
	# cycle between active input method and re-init game controllers
	elif selected_option == 'Active Controller':
		CycleActiveController()

	# exit sub-menu
	elif selected_option == 'Return to Main Menu' and main_menu:
		PlaySoundFor(None, 'menu_select')
		session.mm_options = False
		session.options_item = 0
		return

	else:
		return
	
	PlaySoundFor(None, 'menu_select')

	SaveCFG()


# display a pop-up window with a prompt and allow player to enter a text string
# can also generate randomly selected strings from a given list
# returns the final string
def ShowTextInputMenu(prompt, original_text, max_length, string_list):
	
	# dictionary to shift non-alpha chars
	SHIFT_CHARS = {
		'1' : '!',
		'2' : '@',
		'3' : '#',
		'4' : '$',
		'5' : '%',
		'6' : '^',
		'7' : '&',
		'8' : '*',
		'9' : '(',
		'0' : ')',
		'-' : '_',
		'=' : '+',
		'[' : '{',
		']' : '}',
		';' : ':',
		"'" : '"',
		'\\' : '|',  
		',' : '<',
		'.' : '>',
		'/' : '?'
	}
	
	# map extended characters
	code_to_char = dict((v, k) for k, v in CHAR_MAP.items())
	
	# (re)draw the input window (doesn't include current text or keyboard highlight)
	def CreateInputConsole():
		libtcod.console_clear(input_con)
		libtcod.console_set_default_foreground(input_con, libtcod.white)
		DrawFrame(input_con, 0, 0, 42, 44)
		
		# input prompt
		lines = wrap(prompt, 24)
		y = 2
		libtcod.console_set_default_foreground(input_con, libtcod.light_grey)
		for line in lines:
			libtcod.console_print_ex(input_con, 21, y, libtcod.BKGND_NONE,
				libtcod.CENTER, line.encode('IBM850'))
			y += 1
			if y == 5: break
		
		# text field
		libtcod.console_set_default_foreground(input_con, GAMEPAD_INPUT_COL)
		DrawFrame(input_con, 4, 5, 34, 5)
		
		libtcod.console_set_default_foreground(input_con, libtcod.light_grey)
		libtcod.console_print_ex(input_con, 21, 11, libtcod.BKGND_NONE, libtcod.CENTER,
			'Max Length: ' + str(max_length) + ' chars')
		
		# display inputs
		if gamepad is not None:
			DisplayButton(input_con, 15, 14, GAMEPADCHAR_B)
			DisplayButton(input_con, 15, 15, GAMEPADCHAR_X)
			DisplayButton(input_con, 15, 16, GAMEPADCHAR_START)
		else:
			libtcod.console_set_default_foreground(input_con, ACTION_KEY_COL)
			libtcod.console_print(input_con, 13, 14, 'Esc')
			libtcod.console_print(input_con, 13, 15, 'Del')
			libtcod.console_print(input_con, 13, 16, 'Tab')
		
		libtcod.console_set_default_foreground(input_con, libtcod.white)
		libtcod.console_print(input_con, 17, 14, 'Cancel')
		libtcod.console_print(input_con, 17, 15, 'Clear')
		libtcod.console_print(input_con, 17, 16, 'Confirm and Continue')
		
		if len(string_list) > 0:
			if gamepad is not None:
				DisplayButton(input_con, 15, 17, GAMEPADCHAR_Y)
			else:
				libtcod.console_set_default_foreground(input_con, ACTION_KEY_COL)
				libtcod.console_print(input_con, 13, 17, 'F1')
			libtcod.console_set_default_foreground(input_con, libtcod.white)
			libtcod.console_print(input_con, 17, 17, 'Generate Random')
		
		# on-screen keyboard inputs
		if gamepad is not None:
			DisplayButton(input_con, 14, 19, GAMEPADCHAR_DPAD_UD)
			DisplayButton(input_con, 15, 19, GAMEPADCHAR_DPAD_LR)
			DisplayButton(input_con, 15, 20, GAMEPADCHAR_A)
			DisplayButton(input_con, 15, 21, GAMEPADCHAR_LB)
		else:
			libtcod.console_put_char_ex(input_con, 11, 19, 24, ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(input_con, 12, 19, 25, ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(input_con, 13, 19, 26, ACTION_KEY_COL, libtcod.black)
			libtcod.console_put_char_ex(input_con, 14, 19, 27, ACTION_KEY_COL, libtcod.black)
			libtcod.console_set_default_foreground(input_con, ACTION_KEY_COL)
			libtcod.console_print(input_con, 11, 20, 'Enter')
			libtcod.console_print(input_con, 12, 21, 'Bksp')
		
		libtcod.console_set_default_foreground(input_con, libtcod.white)
		libtcod.console_print(input_con, 17, 19, 'Select Character')
		libtcod.console_print(input_con, 17, 20, 'Add Character')
		libtcod.console_print(input_con, 17, 21, 'Backspace')
			
		# display on-screen keyboard
		libtcod.console_set_default_foreground(input_con, libtcod.lighter_grey)
		x, y = 13, 24
		for c in range(274):
			libtcod.console_put_char(input_con, x, y, chr(c))
			x += 1
			if x >= 29:
				y += 1
				x = 13
		
	# update the input window with current info and display on screen
	def UpdateInputConsole(text, selected_char):
		
		# current text string
		libtcod.console_set_default_foreground(input_con, libtcod.white)
		libtcod.console_rect(input_con, 5, 7, 32, 1, True, libtcod.BKGND_SET)
		PrintExtended(input_con, 21, 7, text, center=True)
		
		# blit window to screen, and highlight selected character in on-screen keyboard
		libtcod.console_blit(input_con, 0, 0, 0, 0, con, 24, 8)
		(y, x) = divmod(selected_char, 16)
		libtcod.console_set_char_background(con, 37+x, 32+y, libtcod.green, libtcod.BKGND_SET)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	
	# play warning tone, update & display the displayed console with a flashing red bar around the text
	def ErrorFlash():
		PlaySoundFor(None, 'menu_select')
		x_coord = 45 - floor(len(text) / 2)
		for colour in [libtcod.dark_red, libtcod.darker_red]:
			libtcod.console_set_default_background(con, colour)
			libtcod.console_rect(con, x_coord, 15, len(text), 1, False, libtcod.BKGND_SET)
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			Wait(10, ignore_animations=True)
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_rect(con, x_coord, 15, len(text), 1, False, libtcod.BKGND_SET)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)	
	
	
	# create a new console for the pop-up
	input_con = libtcod.console_new(42, 44)
	libtcod.console_set_default_background(input_con, libtcod.black)
	libtcod.console_set_default_foreground(input_con, libtcod.white)
	
	# start with the original text string, can cancel input and keep this
	text = original_text
	
	# create a local copy of the current screen to re-draw when we're done, then darken the background
	temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
	libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
	
	# currently selected character for the on-screen keyboard
	selected_char = 0
	
	# draw window for first time, update it, and display it on screen
	CreateInputConsole()
	UpdateInputConsole(text, selected_char)
	
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		# ignore shift key being pressed
		if key.vk in [sdl2.SDLK_LSHIFT, sdl2.SDLK_RSHIFT]:
			session.key_down = False
		
		# cancel text input
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			# re-draw original screen and return original text string
			libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
			libtcod.console_flush()
			del temp_con
			del input_con
			return original_text
		
		# confirm and return
		elif key.vk == sdl2.SDLK_TAB or session.gamepad_input == 6:
			exit_menu = True
			continue
		
		# select random string from list if any
		elif key.vk == sdl2.SDLK_F1 or session.gamepad_input == 3:
			if len(string_list) == 0: continue
			for tries in range(300):
				new_text = choice(string_list)
				if len(new_text) <= max_length:
					text = new_text
					break
		
		# clear string
		elif key.vk == sdl2.SDLK_DELETE or session.gamepad_input == 2:
			text = ''
		
		# delete last character in string
		elif key.vk == sdl2.SDLK_BACKSPACE or session.gamepad_input == 9:
			if len(text) == 0: continue
			text = text[:-1]
		
		# select a different character from the on-screen keyboard
		elif key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_LEFT, sdl2.SDLK_RIGHT] or session.gamepad_input in [11, 12, 13, 14]:
			
			if key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
				selected_char -= 16
			elif key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12:
				selected_char += 16
			elif key.vk == sdl2.SDLK_LEFT or session.gamepad_input == 13:
				selected_char -= 1
			else:
				selected_char += 1
			
			if selected_char < 0:
				selected_char += 274
			elif selected_char > 273:
				selected_char -= 274
			
			PlaySoundFor(None, 'menu_select')
			UpdateInputConsole(text, selected_char)
		
		# input a character from the on-screen keyboard
		elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
			
			# can't get any longer
			if len(text) == max_length:
				ErrorFlash()
				continue
			
			if selected_char in code_to_char:
				text += code_to_char[selected_char]
			else:
				text += chr(selected_char)
			
			FlushKeyboardEvents()
			UpdateInputConsole(text, selected_char)
		
		# enter a new character
		else:
			
			# can't get any longer
			if len(text) == max_length:
				ErrorFlash()
				continue
			
			# accented or special character
			if key.vk == libtcod.KEY_TEXT:
				
				# Multi-character input, skip
				if len(key.text) > 1:
					FlushKeyboardEvents()
					continue
				
				# make sure this would be a valid character to display
				encoded_text = key.text.encode('IBM850', 'ignore')
				
				# character not supported
				if len(encoded_text) == 0:
					FlushKeyboardEvents()
					continue
				
				# character not supported
				if not (128 <= ord(encoded_text) <= 168):
					FlushKeyboardEvents()
					continue
				
				key_char = key.text
				
			else:
			
				# not a valid character
				if key.c == 0:
					FlushKeyboardEvents()
					continue
				
				# filter key input
				if not (32 <= key.c <= 122):
					FlushKeyboardEvents()
					continue
				
				if key.shift and chr(key.c) in SHIFT_CHARS:
					key_char = SHIFT_CHARS[chr(key.c)]
				else:
					key_char = chr(key.c)
					if key.shift and (97 <= key.c <= 122): key_char = key_char.upper()
			
			text += key_char
		
		FlushKeyboardEvents()
		UpdateInputConsole(text, selected_char)
		
	libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
	libtcod.console_flush()
	del temp_con
	del input_con
	
	return text


# allow the player to select one option from a list
def GetOption(option_list, menu_title=None):
	
	def DrawOptionMenu():
		
		libtcod.console_clear(menu_con)
		
		if menu_title is not None:
			lines = wrap(menu_title, 35)
			y = 18
			for line in lines[:6]:
				libtcod.console_print_ex(menu_con, WINDOW_XM, y, libtcod.BKGND_NONE,
					libtcod.CENTER, line)
				y += 1
		
		# show list of options
		c = 65
		x = 25
		y = 21
		for text in chunk_list[selected_chunk]:
			libtcod.console_set_default_foreground(menu_con, ACTION_KEY_COL)
			libtcod.console_put_char(menu_con, x, y, chr(c))
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			libtcod.console_print(menu_con, x+2, y, text)
			y += 1
			c += 1
		
		if len(chunk_list) < 1:
			y += 2
			libtcod.console_set_default_foreground(menu_con, ACTION_KEY_COL)
			libtcod.console_print(menu_con, x, y, 'Tab')
			libtcod.console_set_default_foreground(menu_con, libtcod.light_grey)
			libtcod.console_print(menu_con, x+4, y, 'Next Page')
		
		libtcod.console_blit(menu_con, 0, 0, 0, 0, 0, window_x, window_y)
	
	# divide the list of options into blocks of 26 options each
	chunk_list = []
	for i in range(0, len(option_list), 26):
		chunk_list.append(list(option_list[i:i+26]))
	
	selected_chunk = 0
	
	# create the menu console
	menu_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_set_default_background(menu_con, libtcod.black)
	libtcod.console_set_default_foreground(menu_con, libtcod.white)
	
	# draw menu console for first time
	DrawOptionMenu()
	
	option = None
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			exit_menu = True
			continue
		
		elif key.vk == sdl2.SDLK_TAB:
			selected_chunk += 1
			if selected_chunk > len(chunk_list) - 1:
				selected_chunk = 0
			DrawOptionMenu()
			continue
		
		option_code = key.c - 97
		if 0 <= option_code < len(chunk_list[selected_chunk]):
			option = chunk_list[selected_chunk][option_code]
			exit_menu = True
	
	# re-draw original screen console
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	return option
	

# display the debug menu, not enabled in distribution versions
def ShowDebugMenu():
	
	# draw the debug menu to screen
	def DrawDebugMenu():
		libtcod.console_clear(con)
		libtcod.console_set_default_foreground(con, libtcod.light_red)
		libtcod.console_print_ex(con, WINDOW_XM, 2, libtcod.BKGND_NONE, libtcod.CENTER, 'DEBUG MENU')
		
		libtcod.console_set_default_foreground(con, TITLE_COL)
		libtcod.console_print(con, 6, 6, 'Flags')
		
		y = 8
		n = 1
		for k, value in session.debug.items():
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 6, y, chr(n+64))
			if value:
				libtcod.console_set_default_foreground(con, libtcod.white)
			else:
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			libtcod.console_print(con, 8, y, k)
			y += 2
			n += 1
		
		# special commands
		libtcod.console_set_default_foreground(con, TITLE_COL)
		libtcod.console_print(con, 50, 6, 'Commands')
		x = 50
		y = 8
		libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
		for xm in range(len(DEBUG_OPTIONS)):
			libtcod.console_print(con, x, y+(xm*2), str(xm+1))
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		for text in DEBUG_OPTIONS:
			libtcod.console_print(con, x+3, y, text)
			y += 2
			
		libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
		libtcod.console_print(con, 33, 56, 'Esc')
		libtcod.console_print(con, 33, 57, 'Tab')
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_print(con, 39, 56, 'Return to Game')
		libtcod.console_print(con, 39, 57, 'Save Flags and Return')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
	# build a dictionary of ordered letter to key values
	letter_dict = {}
	n = 1
	for k, value in session.debug.items():
		letter_dict[chr(n+64)] = k
		n += 1
	
	# save the current root console
	temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_blit(0, 0, 0, 0, 0, temp_con, 0, 0)
	
	# draw the menu for the first time
	DrawDebugMenu()
	
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		if key.vk == sdl2.SDLK_ESCAPE:
			exit_menu = True
			continue
		
		elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB]:
			# save current debug settings
			with open(DATAPATH + 'debug.json', 'w', encoding='utf8') as data_file:
				json.dump(session.debug, data_file, indent=1)
			exit_menu = True
			continue
		
		key_char = chr(key.c).upper()
		
		if key_char in letter_dict:
			k = letter_dict[key_char]
			# flip the flag setting
			session.debug[k] = not session.debug[k]
			DrawDebugMenu()
			continue
		
		# debug menu option
		if key_char == '0':
			num = 9
		else:
			num = ord(key_char) - 49
		if num < 0 or num > len(DEBUG_OPTIONS)-1: continue
		
		text = DEBUG_OPTIONS[num]
		
		if text == 'Regenerate CD Map Roads & Rivers':
			if campaign_day is None: continue
			campaign_day.GenerateRoads()
			campaign_day.GenerateRivers()
			campaign_day.UpdateCDMapCon()
			campaign_day.UpdateCDDisplay()
			ShowMessage('Roads and rivers regenerated')
			exit_menu = True
		
		elif text == 'Stress Test':
			if scenario is None: continue
			for nation in campaign.current_week['enemy_nations']:
				for unit_id in campaign.stats['enemy_unit_list'][nation]:
					scenario.SpawnEnemyUnits(reinforcement=True, nation=nation, unit_id=unit_id)
					scenario.UpdateUnitCon()
					scenario.UpdateScenarioDisplay()
			exit_menu = True
		
		elif text == 'Spawn Enemy':
			if scenario is None: continue
			nation = GetOption(campaign.current_week['enemy_nations'], menu_title='Choose Nation')
			if nation is None: return
			unit_id = GetOption(campaign.stats['enemy_unit_list'][nation], menu_title='Choose Unit')
			if unit_id is None: return
			scenario.SpawnEnemyUnits(reinforcement=True, nation=nation, unit_id=unit_id, location=(-1,0))
			scenario.UpdateUnitCon()
			scenario.UpdateScenarioDisplay()
			ShowMessage('Spawned an enemy ' + unit_id)
			exit_menu = True
		
		elif text == 'Remove Enemy':
			if scenario is None: continue
			option_list = []
			for unit in scenario.units:
				if unit.owning_player != 1: continue
				if unit.unit_id in option_list: continue
				option_list.append(unit.unit_id)
			if len(option_list) == 0: continue
			unit_id = GetOption(option_list)
			if unit_id is None: return
			for unit in scenario.units:
				if unit.unit_id == unit_id and unit.owning_player == 1:
					ShowMessage('Destroyed an enemy ' + unit_id)
					unit.DestroyMe(no_vp=True)
					break
			exit_menu = True
		
		elif text == 'Attack Selected Crewman (Scenario)':
			if scenario is None: continue
			option_list = []
			for position in scenario.player_unit.positions_list:
				if position.crewman is None: continue
				option_list.append(position.name)
			position_name = GetOption(option_list)
			if position_name is None: return
			crewman = scenario.player_unit.GetPersonnelByPosition(position_name)
			if crewman.ResolveAttack({'firepower' : 10}) is not None:
				scenario.UpdateCrewInfoCon()
			exit_menu = True
		
		elif text == 'Set Crewman Injury':
			if scenario is None:
				unit = campaign.player_unit
			else:
				unit = scenario.player_unit
			option_list = []
			for position in unit.positions_list:
				option_list.append(position.name)
			position_name = GetOption(option_list)
			if position_name is None: continue
			
			crewman = unit.GetPersonnelByPosition(position_name)
			if crewman is None: continue
			
			option_list = []
			for text in crewman.injury.keys():
				option_list.append(text)
			option_list.append('KIA')
			location_name = GetOption(option_list)
			if location_name is None: continue
			
			if location_name == 'KIA':
				ShowMessage('Crewman is now dead.', good_news=False)
				crewman.KIA()
				exit_menu = True
				continue
			
			option_list = ['None', 'Light', 'Heavy', 'Serious', 'Critical']
			injury_name = GetOption(option_list)
			if injury_name is None: continue
			
			option_list = ['Good Order', 'Shaken', 'Stunned', 'Unconscious']
			status_name = GetOption(option_list)
			if status_name is None: continue
			
			# set the injury and show message
			crewman.injury[location_name] = ('Fresh', injury_name, False)
			crewman.condition = status_name
			ShowMessage('Crewman ' + location_name + ' injury now ' + injury_name + '; status is ' + crewman.condition)
			exit_menu = True
		
		elif text == 'Set Time to End of Day':
			if campaign_day is None: continue
			campaign_day.day_clock['hour'] = campaign_day.end_of_day['hour']
			campaign_day.day_clock['minute'] = campaign_day.end_of_day['minute']
			DisplayTimeInfo(time_con)
			if scenario is not None:
				DisplayTimeInfo(scen_time_con)
			text = 'Time is now ' + str(campaign_day.day_clock['hour']).zfill(2) + ':' + str(campaign_day.day_clock['minute']).zfill(2)
			ShowMessage(text)
			exit_menu = True
		
		elif text == 'End Current Scenario':
			if scenario is None: continue
			scenario.finished = True
			ShowMessage('Scenario finished flag set to True')
			exit_menu = True
		
		elif text == 'Regenerate Weather':
			if campaign_day is None: continue
			campaign_day.GenerateWeather()
			ShowMessage('New weather conditions generated')
			DisplayWeatherInfo(cd_weather_con)
			campaign_day.InitAnimations()
			exit_menu = True
		
		elif text == 'Promotion Check':
			for position in campaign.player_unit.positions_list:
				if position.crewman is None: continue
				position.crewman.PromotionCheck()
			ShowMessage('Promotion check complete.')
			exit_menu = True
		
		elif text == 'Set Steam Stat':
			steam_stat = GetOption(STEAM_STATS, menu_title='Choose Steam Stat')
			if steam_stat is None: continue
			session.ModifySteamStat(steam_stat, 1)
			ShowMessage('Increased ' + steam_stat + ' by one')
			exit_menu = True
	
	# re-draw original root console
	libtcod.console_blit(temp_con, 0, 0, 0, 0, 0, 0, 0)
	del temp_con


# display a list of crew positions and their crewmen to a console
def DisplayCrew(unit, console, x, y, highlight, darken_highlight=False, show_cmd=False, show_default=False, adv_highlight=False):
	
	for position in unit.positions_list:
		
		# highlight selected position and crewman
		if highlight is not None:
			if unit.positions_list.index(position) == highlight:
				if darken_highlight:
					libtcod.console_set_default_background(console, libtcod.darkest_blue)
				else:
					libtcod.console_set_default_background(console, libtcod.darker_blue)
				libtcod.console_rect(console, x, y, 24, 4, True, libtcod.BKGND_SET)
				libtcod.console_set_default_background(console, libtcod.black)
		
		# display position name and location in vehicle (eg. turret/hull)
		
		# if crewman is untrained in this position, highlight this
		libtcod.console_set_default_foreground(console, libtcod.light_blue)
		if position.crewman is not None:
			if position.crewman.UntrainedPosition():
				libtcod.console_set_default_foreground(console, libtcod.light_red)
		libtcod.console_print(console, x, y, position.name)
		
		if position.location is not None:
			libtcod.console_set_default_foreground(console, libtcod.white)
			libtcod.console_print_ex(console, x+23, y, libtcod.BKGND_NONE, 
				libtcod.RIGHT, position.location)
		
		# display last name of crewman and buttoned up / exposed status if any
		if position.crewman is None:
			libtcod.console_print(console, x, y+1, 'Empty')
		else:
			# display crewman nickname if any, otherwise name
			
			# if this is the player commander, use a different colour
			libtcod.console_set_default_foreground(console, libtcod.white)
			if position.crewman.is_player_commander:
				libtcod.console_set_default_foreground(console, PC_COL)
			if position.crewman.nickname != '':
				PrintExtended(console, x, y+1, position.crewman.nickname)
			else:
				PrintExtended(console, x, y+1, position.crewman.GetCrewmanName(first_initial=True), nation=position.crewman.nation)
			
			libtcod.console_set_default_foreground(console, libtcod.white)
			if not position.hatch:
				text = '--'
			elif position.crewman.ce:
				text = 'CE'
				if position.large_hatch: text += '(L)'
			else:
				text = 'BU'
			libtcod.console_print_ex(console, x+23, y+1, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
			libtcod.console_set_default_foreground(console, libtcod.white)
			
			# display current condition if not Good Order
			if position.crewman.condition != 'Good Order':
				libtcod.console_set_default_foreground(console, libtcod.red)
				libtcod.console_print(console, x, y+2,
					position.crewman.condition)
			
			# display fatigue if any
			if position.crewman.fatigue > 0:
				libtcod.console_set_default_foreground(console, libtcod.red)
				libtcod.console_print_ex(console, x+23, y+2, libtcod.BKGND_NONE, libtcod.RIGHT, 
					'-' + str(position.crewman.fatigue) + '%')
			
			# display current command if flag set
			if show_cmd:
				libtcod.console_set_default_foreground(console, libtcod.dark_yellow)
				libtcod.console_print(console, x, y+3, position.crewman.current_cmd)
			
			# otherwise, display default command if any and if flag set
			elif show_default and position.crewman.default_start is not None:
				libtcod.console_set_default_foreground(console, libtcod.light_grey)
				text = '[' + position.crewman.default_start[1] + '] - '
				if position.crewman.default_start[0]:
					text += 'CE'
				else:
					text += 'BU'
				libtcod.console_print(console, x, y+3, text)
			
			# otherwise display advance points if set
			elif adv_highlight and position.crewman.adv > 0:
				libtcod.console_set_default_foreground(console, libtcod.dark_orange)
				libtcod.console_print_ex(console, x+23, y+3, libtcod.BKGND_NONE, libtcod.RIGHT, 
					str(position.crewman.adv) + ' ADV')
			
		# horizontal line
		libtcod.console_set_default_foreground(console, libtcod.dark_grey)
		libtcod.console_hline(console, x, y+4, 24)
				
		libtcod.console_set_default_foreground(console, libtcod.white)
		y += 5


# turn an inputted key into a standard key input
def DeKey(key_char):
	if key_char in session.keyboard_decode: return session.keyboard_decode[key_char]
	return key_char


# turn a standard key into the one for the current keyboard layout
def EnKey(key_char):
	if key_char in session.keyboard_encode: return session.keyboard_encode[key_char]
	return key_char


# load campaign menu
def LoadCampaignMenu(continue_most_recent):
	
	def UpdateLoadCampaignScreen(selected_save):
		libtcod.console_clear(con)
		
		# menu title
		libtcod.console_set_default_foreground(con, libtcod.light_blue)
		DrawFrame(con, 33, 1, 25, 5)
		libtcod.console_set_default_foreground(con, libtcod.yellow)
		libtcod.console_print_ex(con, 45, 3, libtcod.BKGND_NONE, libtcod.CENTER,
			'Load Saved Campaign')
		
		# list of saved campaigns
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		
		s = saved_game_list.index(selected_save)
		y = 5
		
		for i in range(s-7, s+10):
			if i < 0:
				y += 3
				continue
			elif i > len(saved_game_list) - 1:
				break
			
			if saved_game_list[i] == selected_save:
				libtcod.console_rect(con, 2, y, 23, 2, True, libtcod.BKGND_SET)
			
			lines = wrap(saved_game_list[i]['campaign_name'], 23)
			y1 = 0
			for line in lines[:2]:
				libtcod.console_print(con, 2, y+y1, line)
				y1 += 1
			
			y += 3
		
		# display details about selected saved campaign
		libtcod.console_blit(session.flags[selected_save['nation']],
			0, 0, 0, 0, con, 31, 10)
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_set_default_background(con, libtcod.black)
		
		y = 30
		libtcod.console_print_ex(con, WINDOW_XM, y, libtcod.BKGND_NONE, libtcod.CENTER,
			'Saved Campaign')
		libtcod.console_print_ex(con, WINDOW_XM, y+3, libtcod.BKGND_NONE, libtcod.CENTER,
			'Current VP')
		libtcod.console_print_ex(con, WINDOW_XM, y+6, libtcod.BKGND_NONE, libtcod.CENTER,
			'Current Date')
		libtcod.console_print_ex(con, WINDOW_XM, y+11, libtcod.BKGND_NONE, libtcod.CENTER,
			'Game Version')
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		libtcod.console_print_ex(con, WINDOW_XM, y+1, libtcod.BKGND_NONE, libtcod.CENTER,
			selected_save['campaign_name'])
		libtcod.console_print_ex(con, WINDOW_XM, y+4, libtcod.BKGND_NONE, libtcod.CENTER,
			str(selected_save['total_vp']))
		libtcod.console_print_ex(con, WINDOW_XM, y+7, libtcod.BKGND_NONE, libtcod.CENTER,
			str(selected_save['date']))
		if CheckSavedGameVersion(selected_save['version']) != '':
			libtcod.console_set_default_foreground(con, libtcod.light_red)
		libtcod.console_print_ex(con, WINDOW_XM, y+12, libtcod.BKGND_NONE, libtcod.CENTER,
			str(selected_save['version']))
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 36, 51, GAMEPADCHAR_DPAD_UD)
			DisplayButton(con, 36, 52, GAMEPADCHAR_A)
			DisplayButton(con, 36, 53, GAMEPADCHAR_X)
			DisplayButton(con, 36, 54, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 32, 51, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(con, 32, 52, 'Tab')
			libtcod.console_print(con, 32, 53, 'D')
			libtcod.console_print(con, 32, 54, 'Esc')
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_print(con, 38, 51, 'Select Saved Campaign')
		libtcod.console_print(con, 38, 52, 'Load and Continue Campaign')
		libtcod.console_print(con, 38, 53, 'Delete Saved Campaign')
		libtcod.console_print(con, 38, 54, 'Return to Main Menu')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			
	
	# generate a list of all saved campaigns
	saved_game_list = []
	delete_list = []
	for directory in os.listdir(SAVEPATH):
		if not os.path.isdir(SAVEPATH + directory): continue
		
		game_info = {}
		
		# try to open file, prompt to try and restore backup if any
		finished_with_file = False
		path = SAVEPATH + directory + os.sep
		while not finished_with_file:
			try:
				with shelve.open(path + 'savegame') as save:
					game_info['directory'] = directory
					game_info['datetime'] = save['datetime']
					game_info['campaign_name'] = save['campaign'].stats['name']
					game_info['nation'] = save['campaign'].stats['player_nation']
					game_info['total_vp'] = save['campaign'].player_vp
					game_info['date'] = save['campaign'].today
					game_info['version'] = save['version']
				saved_game_list.append(game_info)
				finished_with_file = True
			except:
				
				# check for backup
				backup_path = BACKUP_PATH + directory + os.sep
				
				# no backup available
				if not os.path.isdir(backup_path):				
					if ShowNotification('Error in saved campaign: ' + directory + ', no backup available. Erase this corrupted save?', confirm=True):
						delete_list.append(directory)
						ShowNotification('Erased corrupted save: ' + directory)
					finished_with_file = True
				else:
					if not ShowNotification('Error in saved campaign: ' + directory + ', restore from backup copy?', confirm=True):
						finished_with_file = True
					else:
						copyfile(backup_path + 'savegame.dat', path + 'savegame.dat')
						copyfile(backup_path + 'savegame.dir', path + 'savegame.dir')
						copyfile(backup_path + 'savegame.bak', path + 'savegame.bak')
						os.remove(backup_path + 'savegame.dat')
						os.remove(backup_path + 'savegame.dir')
						os.remove(backup_path + 'savegame.bak')
						os.rmdir(backup_path)
						ShowNotification('Restored backup, will attempt to load.')
	
	# see if we need to delete any corrupted saves
	for directory in delete_list:
		EraseGame(directory)
	
	# make sure there's at least one saved game
	if len(saved_game_list) == 0:
		return False
	
	# sort by most recently saved
	saved_game_list = sorted(saved_game_list, key=lambda k: k['datetime'], reverse=True)
	
	# if we're continuing, try to load the most recently saved and return
	if continue_most_recent:
		if CheckSavedGameVersion(saved_game_list[0]['version']) != '':
			return False
		LoadGame(saved_game_list[0]['directory'])
		return True
	
	# otherwise, show menu and get player input
	
	# select first campaign by default
	selected_save = saved_game_list[0]
		
	# draw menu screen for first time
	UpdateLoadCampaignScreen(selected_save)
		
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		# return to main menu without loading a game
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			return False
		
		# try to proceed with loading selected campaign
		elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER, sdl2.SDLK_TAB] or session.gamepad_input == 0:
			saved_version = CheckSavedGameVersion(selected_save['version'])
			if saved_version != '':
				text = 'Saved campaign is not compatible with current game version.'
				if 'Preview' in saved_version:
					text += ' Preview builds must match exactly.'
				ShowNotification(text)
				continue
			exit_menu = True
		
		# delete selected saved campaign (not keymapped)
		elif chr(key.c).lower() == 'd' or session.gamepad_input == 2:
			if ShowNotification('Really delete this saved campaign?', confirm=True):
				EraseGame(selected_save['directory'])
				saved_game_list.remove(selected_save)
				if len(saved_game_list) == 0:
					return False
				selected_save = saved_game_list[0]
				UpdateLoadCampaignScreen(selected_save)
				continue
		
		key_char = DeKey(chr(key.c).lower())
		
		# change selected campaign
		if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
			
			i = saved_game_list.index(selected_save)
			
			if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
				if i == 0:
					selected_save = saved_game_list[-1]
				else:
					selected_save = saved_game_list[i-1]
			else:
				if i == len(saved_game_list) - 1:
					selected_save = saved_game_list[0]
				else:
					selected_save = saved_game_list[i+1]
			PlaySoundFor(None, 'menu_select')
			UpdateLoadCampaignScreen(selected_save)
			continue
	
	# load the game and return
	LoadGame(selected_save['directory'])
	return True


# display campaign records
def ShowRecordsMenu():
	
	def UpdateRecordsMenuScreen():
		libtcod.console_clear(con)
		
		libtcod.console_set_default_foreground(con, libtcod.grey)
		DrawFrame(con, 2, 2, 86, 56)
		DrawFrame(con, 2, 10, 86, 0)
		libtcod.console_blit(LoadXP('reports_sunset.xp'), 0, 0, 0, 0, con, 3, 3)
		
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_rect(con, 37, 5, 18, 3, True, libtcod.BKGND_SET)
		libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
		libtcod.console_print_ex(con, 46, 6, libtcod.BKGND_NONE,
			libtcod.CENTER, 'Campaign Records')
		
		libtcod.console_set_default_foreground(con, libtcod.darker_grey)
		libtcod.console_put_char(con, 9, 8, chr(197))
		libtcod.console_put_char(con, 14, 7, chr(197))
		libtcod.console_put_char(con, 21, 7, chr(42))
		libtcod.console_put_char(con, 66, 5, chr(197))
		
		# column headings
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_print(con, 4, 12, 'Name')
		libtcod.console_print(con, 29, 12, 'Level')
		libtcod.console_print(con, 37, 12, 'VP')
		libtcod.console_print(con, 42, 12, 'Fate')
		libtcod.console_print(con, 52, 12, 'Days')
		libtcod.console_print(con, 58, 12, 'Campaign')
		libtcod.console_print(con, 77, 12, 'Version')
		
		# no records yet
		if len(campaign_records) == 0:
			PrintExtended(con, 39, 30, 'No Records Yet')
		
		else:
		
			# list of top records on this page
			i = (current_page * 8)
			y = 15
			for data in campaign_records[i:i+8]:
				
				# highlight selected record
				if i == selected_record:
					libtcod.console_set_default_background(con, libtcod.darker_blue)
					libtcod.console_rect(con, 4, y, 81, 2, True, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
				
				libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
				
				PrintExtended(con, 4, y, data['commander_name'])
				
				libtcod.console_print_ex(con, 32, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, data['level'])
				libtcod.console_print_ex(con, 39, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(data['vp']))
				libtcod.console_print(con, 42, y, data['fate'])
				libtcod.console_print_ex(con, 54, y, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(data['records']['Combat Days']))
				
				y1 = y
				for line in wrap(data['campaign_name'], 18)[:3]:
					libtcod.console_print(con, 58, y1, line)
					y1 += 1
				
				y1 = y
				for line in wrap(data['game_version'], 8)[:2]:
					libtcod.console_print(con, 77, y1, line)
					y1 += 1
				
				libtcod.console_set_default_foreground(con, libtcod.darker_grey)
				for x in range(4, 85):
					libtcod.console_put_char(con, x, y+3, chr(45))
				
				i += 1
				y += 4
		
		# current/total pages
		text = 'Page ' + str(current_page + 1) + '/' + str(total_pages)
		libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
		libtcod.console_print_ex(con, 84, 48, libtcod.BKGND_NONE,
			libtcod.RIGHT, text)
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 40, 49, GAMEPADCHAR_DPAD_UD)
			DisplayButton(con, 40, 50, GAMEPADCHAR_DPAD_LR)
			DisplayButton(con, 40, 51, GAMEPADCHAR_A)
			DisplayButton(con, 40, 52, GAMEPADCHAR_X)
			DisplayButton(con, 40, 54, GAMEPADCHAR_Y)
			DisplayButton(con, 40, 55, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 32, 49, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(con, 32, 50, 'PgUp/PgDn')
			libtcod.console_print(con, 32, 51, 'Tab')
			libtcod.console_print(con, 32, 52, EnKey('d').upper())
			libtcod.console_print(con, 32, 54, EnKey('m').upper())
			libtcod.console_print(con, 32, 55, 'Esc')
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		libtcod.console_print(con, 42, 49, 'Select Record')
		libtcod.console_print(con, 42, 50, 'Previous/Next Page')
		libtcod.console_print(con, 42, 51, 'View Selected Record')
		libtcod.console_print(con, 42, 52, 'Delete Selected Record')
		libtcod.console_print(con, 42, 54, 'View Memorial')
		libtcod.console_print(con, 42, 55, 'Return to Main Menu')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	# load campaign records
	campaign_records = []
	try:
		with shelve.open(session.home_path + os.sep + 'campaign_records') as save:
			campaign_records = save['campaign_records']
	except:
		print('Error: Could not load campaign records file: ' + traceback.format_exc())
	
	# select first page, first record by default
	total_pages = ceil(len(campaign_records) / 8)
	current_page = 0
	selected_record = 0
	
	# draw menu screen for first time
	UpdateRecordsMenuScreen()
	
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		key_char = DeKey(chr(key.c).lower())
		
		# return to main menu
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			PlaySoundFor(None, 'menu_select')
			exit_menu = True
			continue
		
		# view selected record
		if key.vk == sdl2.SDLK_TAB or session.gamepad_input == 0:
			if len(campaign_records) == 0: continue
			PlaySoundFor(None, 'menu_select')
			DisplayCampaignRecord(campaign_records[selected_record])
			UpdateRecordsMenuScreen()
			continue
		
		# change selected record if possible
		if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
			if len(campaign_records) <= 1: continue
			PlaySoundFor(None, 'menu_select')
			
			if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
				if selected_record > 0:
					selected_record -= 1
				else:
					selected_record = len(campaign_records) - 1
			
			else:
				if selected_record < len(campaign_records) - 1:
					selected_record += 1
				else:
					selected_record = 0
			
			# switch display page if needed
			if selected_record // 8 != current_page:
				current_page = selected_record // 8
			
			UpdateRecordsMenuScreen()
			continue
		
		# switch to previous/next page of records
		elif key.vk in [sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [13, 14]:
			
			if total_pages == 1: continue
			
			PlaySoundFor(None, 'menu_select')
			if key.vk == sdl2.SDLK_PAGEUP or session.gamepad_input == 13:
				current_page -= 1
				if current_page < 0:
					current_page = total_pages - 1
			else:
				current_page += 1
				if current_page >= total_pages:
					current_page = 0
			
			selected_record = current_page * 8
			UpdateRecordsMenuScreen()
			continue
		
		# delete selected record
		elif key_char == 'd' or session.gamepad_input == 2:
			if len(campaign_records) == 0: continue
			PlaySoundFor(None, 'menu_select')
			if not ShowNotification('Delete this campaign record forever?', confirm=True): continue
			campaign_records.pop(selected_record)
			session.SaveCampaignRecords(campaign_records)
			
			# recalculate total record pages, selected previous record
			total_pages = ceil(len(campaign_records) / 8)
			selected_record -= 1
			if selected_record < 0:
				selected_record = 0
			
			# switch display page if needed
			if selected_record // 8 != current_page:
				current_page = selected_record // 8
			
			UpdateRecordsMenuScreen()
			continue
		
		# view memorial to fallen crewmen
		elif key_char == 'm' or session.gamepad_input == 3:
			PlaySoundFor(None, 'menu_select')
			ShowMemorial()
			UpdateRecordsMenuScreen()
			continue


# view one particular campaign record in detail
# also used for end of campaign final report
def DisplayCampaignRecord(data, final_report=False):
	
	def BlitAndWait():
		if DEBUG or not final_report: return
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		Wait(20, ignore_animations=True)
	
	def UpdateRecordScreen():
		
		# add a line of text to the screen, one character at a time unless not showing a final report
		def DisplayLine(x, y, text):
			if DEBUG or not final_report:
				libtcod.console_print(con, x, y, text)
				return
			x1 = x
			for char in text:
				libtcod.console_put_char(con, x1, y, char)
				x1 += 1
				libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
				Wait(2, ignore_animations=True)
		
		# draw background image
		libtcod.console_blit(bg_con, 0, 0, 0, 0, con, 0, 0)
		
		# page text
		libtcod.console_set_default_foreground(con, libtcod.black)
		DisplayLine(18, 3, 'Armoured Commander II')
		
		# campaign title
		lines = wrap(data['campaign_name'], 30)
		y = 4
		for line in lines[:2]:
			libtcod.console_print_ex(con, 28, y, libtcod.BKGND_NONE, libtcod.CENTER,
				line)
			y+=1
		BlitAndWait()
		
		DisplayLine(18, 7, 'Campaign Final Report')
		DisplayLine(9, 9, '. . . . . . . . . . . . . . . . . . . .')
		BlitAndWait()
		
		x = 48 - len(data['final_date'])
		DisplayLine(x, 11, data['final_date'])
		
		DisplayLine(9, 15, 'Name:')
		BlitAndWait()
		PrintExtended(con, 15, 15, data['commander_name'])
		BlitAndWait()
		
		DisplayLine(9, 17, 'Rank:')
		BlitAndWait()
		PrintExtended(con, 15, 17, data['rank'])
		BlitAndWait()
		
		DisplayLine(9, 19, 'VP Earned:')
		BlitAndWait()
		libtcod.console_print(con, 20, 19, str(data['vp']))
		BlitAndWait()
		
		DisplayLine(9, 21, 'VP Modifier:')
		BlitAndWait()
		libtcod.console_print(con, 22, 21, data['vp_modifier'])
		BlitAndWait()
		
		DisplayLine(9, 23, 'Level:')
		BlitAndWait()
		libtcod.console_print(con, 16, 23, data['level'])
		BlitAndWait()
		
		# campaign stats
		DisplayLine(9, 25, 'Statistics:')
		BlitAndWait()
		y = 27
		for (k, v) in data['records'].items():
			libtcod.console_print(con, 15, y, k + ':')
			libtcod.console_print_ex(con, 38, y, libtcod.BKGND_NONE, libtcod.RIGHT,
				str(v))
			BlitAndWait()
			y += 1
			if y == 46:
				break
		
		# set which nation to check for decorations
		decoration_nation = data['nation']
		if 'inherit' in session.nations[data['nation']]:
			for (k, v) in session.nations[data['nation']]['inherit'].items():
				if 'decorations' in v:
					decoration_nation = k
		
		# commander decorations
		# build a list of crewman decorations and number of times awarded, ordered by rank
		decoration_list = []
		if 'decorations' in session.nations[decoration_nation]:
			for (k, v) in session.nations[data['nation']]['decorations'].items():
				if v in data['decorations']:
					decoration_list.append((v, data['decorations'][v]))
		
		if len(decoration_list) == 0:
			libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
			libtcod.console_print(con, 59, 26, 'No Decorations Awarded')
			BlitAndWait()
		else:			
			y = 7
			for (name, number) in decoration_list:
				
				# decoration name, max two lines
				lines = wrap(name, 28)
				libtcod.console_set_default_foreground(con, libtcod.white)
				for line in lines[:2]:
					libtcod.console_print_ex(con, 70, y, libtcod.BKGND_NONE,
						libtcod.CENTER, line)
					y += 1
				
				# load and display decoration ribbon
				text = session.nations[decoration_nation]['short_code'] + '_' + name.replace(' ', '_') + '.xp'
				
				found_ribbon_xp = False
				filename = DATAPATH + 'ribbons' + os.sep + text
				if os.path.exists(filename):
					ribbon_con = LoadXP(filename)
					found_ribbon_xp = True
				else:
					# check for modded nation def
					if decoration_nation in session.modded_nations:
						filename = self.mod_path + self.modded_nations[decoration_nation] + os.sep + text
						if os.path.exists(filename):
							ribbon_con = LoadXP(filename)
							found_ribbon_xp = True
				
				if not found_ribbon_xp:
					y += 3
					continue
					
				libtcod.console_blit(ribbon_con, 0, 0, 0, 0, con, 64, y+1)
				
				# display bar(s) if crewman has been awarded 2-5, number if more than that
				if 1 < number < 6 :
					for i in range(number-1):
						for y1 in range(y+1, y+4):
							libtcod.console_put_char_ex(con, 77+i, y1, 221, libtcod.Color(222,222,222), libtcod.Color(0,64,0))
				elif number > 6:
					libtcod.console_set_default_foreground(con, libtcod.Color(222,222,222))
					libtcod.console_set_default_background(con, libtcod.Color(0,64,0))
					libtcod.console_print(con, 76, y+2, 'x ' + str(number))
					
				y += 7
				BlitAndWait()
		
		# game version
		libtcod.console_set_default_foreground(con, libtcod.dark_grey)
		libtcod.console_print_ex(con, 48, 55, libtcod.BKGND_NONE, libtcod.RIGHT,
			data['game_version'])
		
		# commander fate
		libtcod.console_set_default_foreground(con, libtcod.black)
		DisplayLine(10, 48, 'Fate:')
		BlitAndWait()
		libtcod.console_print_ex(con, 28, 48, libtcod.BKGND_NONE, libtcod.CENTER,
			data['fate'])
		libtcod.console_set_default_foreground(con, libtcod.light_red)
		DrawFrame(con, 19, 46, 18, 5)
		libtcod.console_set_default_foreground(con, libtcod.black)
		BlitAndWait()
		
		# display inputs
		libtcod.console_rect(con, 61, 54, 18, 5, True, libtcod.BKGND_SET)
		if gamepad is not None:
			if final_report:
				DisplayButton(con, 68, 56, GAMEPADCHAR_A)
			else:
				DisplayButton(con, 68, 56, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			if final_report:
				libtcod.console_print(con, 63, 56, 'Tab')
			else:
				libtcod.console_print(con, 63, 56, 'Esc')
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		if final_report:
			libtcod.console_print(con, 70, 56, 'Continue')
		else:
			libtcod.console_print(con, 70, 56, 'Return')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	
	# load background console
	bg_con = LoadXP('campaign_report.xp')
		
	# draw screen for first time
	UpdateRecordScreen()
	
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		# exit menu
		if (final_report and (key.vk == sdl2.SDLK_TAB or session.gamepad_input == 0)) or (not final_report and (key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1)):
			PlaySoundFor(None, 'menu_select')
			exit_menu = True
			continue
	
	libtcod.console_set_default_background(con, libtcod.black)



# display memorial for fallen crewmen
def ShowMemorial():
	
	def UpdateMemorialScreen():
		libtcod.console_clear(con)
		
		for y in range(0, 60, 6):
			libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, y)
			libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 87, y)
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_rect(con, 10, 1, 70, 3, True, libtcod.BKGND_SET)
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_print_ex(con, WINDOW_XM, 2, libtcod.BKGND_NONE,
			libtcod.CENTER, 'In Memorium')
		
		y = 6
		i = 0
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		if len(graveyard) == 0:
			libtcod.console_print_ex(con, WINDOW_XM, WINDOW_YM, libtcod.BKGND_NONE,
				libtcod.CENTER, 'No Entries Yet')
		
		for (text1, text2) in graveyard[scroll_line:]:
			PrintExtended(con, WINDOW_XM, y, chr(183) + ' ' + text1 + text2 + ' ' + chr(183), center=True)
			y += 2
			i += 1
			if i == 23: break
		
		if len(graveyard) > 0:
			libtcod.console_print_ex(con, WINDOW_XM, 59, libtcod.BKGND_NONE,
				libtcod.CENTER, str(len(graveyard)) + ' entries')
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 38, 55, GAMEPADCHAR_DPAD_UD)
			DisplayButton(con, 38, 56, GAMEPADCHAR_DPAD_LR)
			DisplayButton(con, 38, 57, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 29, 55, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(con, 29, 56, 'PgUp/PgDn')
			libtcod.console_print(con, 29, 57, 'Esc')
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		libtcod.console_print(con, 40, 55, 'Scroll Display')
		libtcod.console_print(con, 40, 56, 'Scroll Display (Skip 5)')
		libtcod.console_print(con, 40, 57, 'Return to Campaign Records')
		
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	
	# try to load the memorial info
	if not os.path.exists(session.home_path + os.sep + 'graveyard.dat'):
		graveyard = []
	else:
		try:
			with shelve.open(session.home_path + os.sep + 'graveyard') as save:
				graveyard = save['graveyard']
		except:
			print('Error: Found memorial file but could not load it')
	
	temp_con = LoadXP('memorial_border.xp')
	
	scroll_line = 0
	
	# draw screen for first time
	UpdateMemorialScreen()
	
	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		
		# return to campaign records menu
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			PlaySoundFor(None, 'menu_select')
			exit_menu = True
			continue
	
		key_char = DeKey(chr(key.c).lower())
		
		# view scrolling
		if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12, 13, 14]:
			
			if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
				i = -1
			elif key_char == 's' or key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12:
				i = 1
			elif key.vk == sdl2.SDLK_PAGEUP or session.gamepad_input == 13:
				i = -5
			else:
				i = 5
			
			PlaySoundFor(None, 'menu_select')
			if i < 0 and scroll_line + i < 0:
				scroll_line = 0
			elif i > 0 and (len(graveyard) - (scroll_line + i)) <= 25:
				scroll_line = len(graveyard) - 23
				if scroll_line < 0: scroll_line = 0
			else:
				scroll_line += i
			UpdateMemorialScreen()
			continue
	

# display mods menu
def ShowModsMenu():
	
	def UpdateModsMenuScreen():
		libtcod.console_clear(con)
		
		libtcod.console_set_default_foreground(con, libtcod.grey)
		DrawFrame(con, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT)
		
		# Main mods screen.
		if not gallery_mode:
			libtcod.console_set_default_background(con, libtcod.gold)
			libtcod.console_rect(con, 1, 1, WINDOW_WIDTH-2, 3, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			
			libtcod.console_set_default_foreground(con, libtcod.black)
			libtcod.console_print_ex(con, WINDOW_XM, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, 'Mods')
			
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print(con, 2, 5, 'Mods Folder: ' + str(session.mod_path))
			
			y = 8
			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_print(con, 2, y, 'Loaded Mods:')
			y += 2
			if len(session.active_mods) == 0:
				libtcod.console_print(con, 4, y, 'None')
			else:
				for modname in session.active_mods:
					libtcod.console_print(con, 4, y, modname)
					y += 1
					if y >= 51: break
					
			y += 2
			if len(session.failed_mods) > 0:
				libtcod.console_set_default_foreground(con, libtcod.light_red)
				libtcod.console_print(con, 2, y, 'Following files failed to load:')
				y += 2
				for modname in session.failed_mods:
					libtcod.console_print(con, 4, y, modname)
					y += 1
					if y >= 49: break
			
			# display menu items
			libtcod.console_set_default_foreground(con, libtcod.white)
			y = 50
			for text in MOD_MENU_ITEMS:
				
				# highlight if selected
				if MOD_MENU_ITEMS[selected_menu_item] == text:
					libtcod.console_set_default_background(con, libtcod.dark_blue)
					libtcod.console_rect(con, 34, y, 35, 1, True, libtcod.BKGND_SET)
					libtcod.console_set_default_background(con, libtcod.black)
				libtcod.console_print(con, 35, y, text)
				y += 1
			
			# display inputs
			if gamepad is not None:
				DisplayButton(con, 41, 57, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 41, 58, GAMEPADCHAR_A)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				libtcod.console_print(con, 37, 57, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 37, 58, 'Enter')
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			libtcod.console_print(con, 43, 57, 'Select')
			libtcod.console_print(con, 43, 58, 'Activate')

		# Gallery of various portraits/units/conflicts.
		else:
			libtcod.console_set_default_background(con, libtcod.dark_flame)
			libtcod.console_rect(con, 1, 1, WINDOW_WIDTH-2, 3, True, libtcod.BKGND_SET)
			libtcod.console_set_default_background(con, libtcod.black)
			
			libtcod.console_set_default_foreground(con, libtcod.orange)
			libtcod.console_print_ex(con, WINDOW_XM, 2, libtcod.BKGND_NONE,
				libtcod.CENTER, gallery_mode)

			# Simplified counting - would it count portrait keys? count variants as well? count duplicate portraits from multiple mods? easier to ignore the issue
			if gallery_mode != 'Modded Portraits':
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				libtcod.console_print_ex(con, 46, 5, libtcod.BKGND_NONE, libtcod.CENTER,
					str(len(gallery_list)) + ' ' + gallery_mode.lower().split(' ')[-1] + ' detected')

			libtcod.console_set_default_foreground(con, libtcod.white)
			libtcod.console_set_default_background(con, libtcod.dark_blue)

			selected_variant = available_variants[0]
			
			# left column: list of whatever we're displaying.
			if len(gallery_list) > 0:
			
				y = 5
				s = gallery_list.index(selected_entry)
				for i in range(s-20, s+30):
					if i < 0:
						y += 1
						continue
					elif i > len(gallery_list) - 1:
						break
					# this unit type is the currently highlighted one
					if i == s:
						libtcod.console_rect(con, 2, y, 25, 1, True, libtcod.BKGND_SET)
					libtcod.console_print(con, 2, y, gallery_list[i])
					y += 1
					
				# This mode is a trimmed version of the unit gallery.
				if gallery_mode == 'Unused Units':
					x_mod = 0
					unit_type = session.unit_types[selected_entry]

					# display info on selected unit
					DisplayUnitInfo(con, 33, 10, selected_entry, None, portrait_variant = selected_variant)

					# display historical notes if any
					if 'description' in unit_type:
						text = ''
						for t in unit_type['description']:
							text += t
						lines = wrap(text, 32)
						y = 26
						libtcod.console_set_default_foreground(con, libtcod.light_grey)
						for line in lines[:12]:
							PrintExtended(con, 30, y, line)
							y+=1
							
					# display origin nation if any
					if 'origin_nation' in unit_type:
						libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
						libtcod.console_print_ex(con, 46, 50, libtcod.BKGND_NONE, libtcod.CENTER,
							'Producer:')
						libtcod.console_print_ex(con, 46, 51, libtcod.BKGND_NONE, libtcod.CENTER,
							unit_type['origin_nation'])
					
					y = 8
					# display personnel positions if any
					if 'crew_positions' in unit_type:
						libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
						libtcod.console_print(con, 64, y, 'Personnel')
						libtcod.console_set_default_foreground(con, libtcod.white)
						text = ''
						for position in unit_type['crew_positions']:
							text += position['name']
							# add hatch/crew exposure info here if any
							if 'crew_always_exposed' in position:
								text += ' (CE)'
							elif 'open_top' in position:
								text += ' (OT)'
							elif 'hatch' in position:
								if 'large_hatch' in position:
									text += ' (LH)'
								else:
									text += ' (H)'
							text += ', '
						
						# strip out the last comma and space in the text
						text = text[:-2]
						
						y += 1
						for line in wrap(text, 23):
							libtcod.console_print(con, 65, y, line)
							y += 1
					
					# protected/wet ammo stowage
					if 'wet_stowage' in unit_type:
						y += 3
						libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
						libtcod.console_print(con, 64, y, 'Protected Ammo Stowage')
					
					# towing capacity if any
					if 'towing_capacity' in unit_type:
						y += 3
						libtcod.console_set_default_foreground(con, libtcod.white)
						libtcod.console_print(con, 64, y, 'Towing: ' + unit_type['towing_capacity'])
					
					# display details on weapons if any
					if 'weapon_list' in unit_type:
						y += 1
						libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
						libtcod.console_print(con, 64, y, 'Weapons')
						y += 2
						
						for weapon_type in unit_type['weapon_list']:
							libtcod.console_set_default_foreground(con, libtcod.white)
							if 'name' in weapon_type:
								text = weapon_type['name']
							elif weapon_type['type'] in ['Gun', 'Cannon']:
								text = weapon_type['calibre']
								if 'long_range' in weapon_type:
									text += weapon_type['long_range']
								if 'autocannon' in weapon_type:
									text += 'a'
							elif weapon_type['type'] == 'Bombs':
								text = weapon_type['calibre'] + 'mm Bombs' 
							elif weapon_type['type'] in MG_WEAPONS and 'calibre' in weapon_type:
								text = weapon_type['type'] + '+'
							else:
								text = weapon_type['type']
							libtcod.console_print(con, 64, y, text)
							y += 1
							
							libtcod.console_set_default_foreground(con, libtcod.light_grey)
							
							if 'rear_facing' in weapon_type: 
								libtcod.console_print(con, 65, y, 'Rear-Facing')
								y += 1
							if 'max_range' in weapon_type:
								text = 'Range: ' + weapon_type['max_range'] + ' hex'
								if int(weapon_type['max_range']) > 1:
									text += 'es'
								libtcod.console_print(con, 65, y, text)
								y += 1
							if 'rof' in weapon_type:
								libtcod.console_print(con, 65, y, 'RoF: ' + weapon_type['rof'] + '%')
								y += 1
							if 'autocannon' in weapon_type:
								libtcod.console_print(con, 65, y, 'Autocannon')
								y += 1
							if 'fp' in weapon_type:
								libtcod.console_print(con, 65, y, 'Firepower: ' + weapon_type['fp'])
								y += 1
							if 'fired_by' in weapon_type:
								libtcod.console_print(con, 65, y, 'Fired By:')
								y += 1
								for t in weapon_type['fired_by']:
									libtcod.console_print(con, 66, y, t)
									y += 1
							if 'reloaded_by' in weapon_type:
								libtcod.console_print(con, 65, y, 'Reloaded By:')
								y += 1
								for t in weapon_type['reloaded_by']:
									libtcod.console_print(con, 66, y, t)
									y += 1
							if 'ammo_type_list' in weapon_type:
								text = 'Ammo Types: '
								for t in weapon_type['ammo_type_list']:
									text += t + ' '
								for line in wrap(text, 24, subsequent_indent=' '):	
									libtcod.console_print(con, 65, y, line)
									y += 1
							if 'max_ammo' in weapon_type:
								libtcod.console_print(con, 65, y, 'Max Ammo: ' + weapon_type['max_ammo'])
								y += 1
							if 'rr_size' in weapon_type:
								libtcod.console_print(con, 65, y, 'Ready Rack: ' + weapon_type['rr_size'])
								y += 1
							if 'very_unreliable' in weapon_type:
								libtcod.console_print(con, 65, y, 'Very Unreliable')
								y += 1
							elif 'unreliable' in weapon_type:
								libtcod.console_print(con, 65, y, 'Unreliable')
								y += 1
							if 'front_only' in weapon_type:
								libtcod.console_print(con, 65, y, 'Front-Facing Only')
								y += 1
							if 'bu_ok' in weapon_type:
								libtcod.console_print(con, 65, y, 'Can fire while BU')
								y += 1
							if 'hd_ok' in weapon_type:
								libtcod.console_print(con, 65, y, 'Can fire while HD')
								y += 1
							
							y += 1

				else:
					x_mod = 15
					# filename
					libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
					if gallery_mode == 'Modded Portraits' and selected_variant != 'STD':
						portrait_name = selected_variant + os.sep + selected_entry
					else:
						portrait_name = selected_entry
					libtcod.console_print_ex(con, 45+x_mod, 7, libtcod.BKGND_NONE, libtcod.CENTER, portrait_name)
					
					# Individual portraits.
					if selected_entry in session.modded_portraits and selected_variant in session.modded_portraits[selected_entry]:
						portrait_source = session.modded_portraits[selected_entry][selected_variant][-1]
					else:
						portrait_source = 'Base Game'

					if gallery_mode == 'Unused Portraits':
						DisplayUnitPortrait(con, 33+x_mod, 10, selected_entry, portrait_variant = selected_variant)

					# Comparing modded and base-game portraits, possibly with multiple options.
					else:
						# Base game portrait for comparison.
						if selected_entry in session.base_game_portraits:
							sourcepath = session.base_game_portraits[selected_entry][selected_variant]
						else:
							sourcepath = PORTRAITPATH + 'unit_unknown.xp'
						libtcod.console_blit(LoadXP(sourcepath), 0, 0, 0, 0, con, 33+x_mod, 21)

						# Modded portrait.
						sourcepath = session.mod_path + portrait_source + os.sep + 'unit_portraits' + os.sep
						if selected_variant == 'STD':
							sourcepath += selected_entry
						else:
							sourcepath += selected_variant + os.sep + selected_entry
						if overlay_basic_portrait:
							y = 21
						else:
							y = 10
						libtcod.console_blit(LoadXP(sourcepath), 0, 0, 0, 0, con, 33+x_mod, y)

					# source of portrait(s)
					libtcod.console_set_default_foreground(con, libtcod.white)
					libtcod.console_print_ex(con, 45+x_mod, 18, libtcod.BKGND_NONE, libtcod.CENTER, portrait_source)
					if gallery_mode == 'Modded Portraits':
						libtcod.console_print_ex(con, 45+x_mod, 20, libtcod.BKGND_NONE, libtcod.CENTER, 'Base Game')
						libtcod.console_set_default_foreground(con, libtcod.grey)
						libtcod.console_print_ex(con, 45+x_mod, 19, libtcod.BKGND_NONE, libtcod.CENTER, 'overwriting')
						if overlay_basic_portrait:
							libtcod.console_set_default_foreground(con, libtcod.light_red)
							libtcod.console_print_ex(con, 45+x_mod, 13, libtcod.BKGND_NONE, libtcod.CENTER, '(Quick Compare Overlay)')

			# display labels for portrait variants
			y_offset = 0
			for variant in PORTRAIT_VARIANTS:
				if variant == selected_variant:
					libtcod.console_set_default_foreground(con, libtcod.white)
				elif variant in available_variants:
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
				else:
					libtcod.console_set_default_foreground(con, libtcod.dark_grey)
				libtcod.console_print(con, 58+x_mod, 10+y_offset, variant)

				# ditto for base-game portraits when comparing, to make it clearer if the portrait being replaced is the same variant or a different one that's being used as a default.
				if gallery_mode == 'Modded Portraits':
					if selected_entry in session.base_game_missing_variants and variant not in session.base_game_missing_variants[selected_entry]:
						libtcod.console_set_default_foreground(con, libtcod.light_grey)
					else:
						libtcod.console_set_default_foreground(con, libtcod.dark_grey)
					libtcod.console_print(con, 58+x_mod, 21+y_offset, variant)

				y_offset += 1

			# frame
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			if gallery_mode == 'Unused Units':
				frame_height = 45
			elif gallery_mode == 'Unused Portraits':
				frame_height = 13
			else:
				frame_height = 23
			DrawFrame(con, 29+x_mod, 8, 34, frame_height)
			libtcod.console_set_default_foreground(con, libtcod.white)

			# display inputs
			if gamepad is not None:
				DisplayButton(con, 36+x_mod, 54, GAMEPADCHAR_LB)
				DisplayButton(con, 37+x_mod, 54, GAMEPADCHAR_RB)
				DisplayButton(con, 37+x_mod, 55, GAMEPADCHAR_DPAD_UD)
				DisplayButton(con, 37+x_mod, 58, GAMEPADCHAR_B)
			else:
				libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
				if gallery_mode == 'Modded Portraits':
					if DEBUG:
						libtcod.console_set_default_foreground(con, libtcod.red)
						libtcod.console_print(con, 29+x_mod, 52, 'R')
						libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
					libtcod.console_print(con, 29+x_mod, 53, 'Space')

				libtcod.console_print(con, 29+x_mod, 54, 'Tab')
				libtcod.console_print(con, 29+x_mod, 55, EnKey('w').upper() + '/' + EnKey('s').upper())
				libtcod.console_print(con, 29+x_mod, 56, 'PgUp/PgDn')
				libtcod.console_print(con, 29+x_mod, 58, 'Esc')

			libtcod.console_set_default_foreground(con, libtcod.white)
			if gallery_mode == 'Modded Portraits':
				if DEBUG:
					libtcod.console_set_default_foreground(con, libtcod.light_red)
					libtcod.console_print(con, 39+x_mod, 52, 'DEBUG: Overwrite Portrait')
					libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 39+x_mod, 53, 'Overlay Portraits (While Held)')
			
			libtcod.console_print(con, 39+x_mod, 54, 'Cycle Portrait Variant')
			libtcod.console_print(con, 39+x_mod, 55, 'Scroll Up/Down')
			libtcod.console_print(con, 39+x_mod, 56, 'Scroll 10 Up/Down')
			libtcod.console_print(con, 39+x_mod, 58, 'Exit Gallery')
			
			libtcod.console_set_default_background(con, libtcod.black)

		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)

	def GenerateAvailableVariants():
		nonlocal available_variants
		if gallery_mode == 'Unused Portraits':
			available_variants = [var for var in PORTRAIT_VARIANTS if var not in session.missing_variants[selected_entry]]
		elif gallery_mode == 'Modded Portraits':
			available_variants = [var for var in PORTRAIT_VARIANTS if var in session.modded_portraits[selected_entry]]
		elif gallery_mode == 'Unused Units' and 'portrait' in session.unit_types[selected_entry] and session.unit_types[selected_entry]['portrait'] in session.portrait_library:
			available_variants = [var for var in PORTRAIT_VARIANTS if var not in session.missing_variants[session.unit_types[selected_entry]['portrait'].lower()]]
		else:
			available_variants = ['STD'] # needs one or it will crash

	# menu and gallery info
	MOD_MENU_ITEMS = [
		'Check Modded Campaigns', 'Check Unit Definitions', 'Display Unused Units', 'Display Unused Portraits',
		'Contrast Modded/Default Portraits', 'Return to Main Menu'
	]
	
	selected_menu_item = 0
	
	
	gallery_mode = False
	selected_entry = None
	available_variants = ['STD'] # selected variant = first in list. Must be one or it will crash.
	overlay_basic_portrait = False # when comparing portraits, whether to put the base-game portrait over the top to make subtle changes clearer

	# draw menu screen for first time
	UpdateModsMenuScreen()

	exit_menu = False
	while not exit_menu:
		libtcod.console_flush()
		if not GetInputEvent(allow_repeat=True): continue
		key_char = DeKey(chr(key.c).lower())

		# return to main menu / mod menu
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			if gallery_mode:
				gallery_mode = False
				GenerateAvailableVariants()
				UpdateModsMenuScreen()
			else:
				exit_menu = True
			continue

		elif gallery_mode:
			# cycle portrait variant (if any)
			if key.vk == sdl2.SDLK_TAB or session.gamepad_input in [9, 10]:
				if session.gamepad_input == 9:
					available_variants.insert(0, available_variants.pop())
				else:
					available_variants.append(available_variants.pop(0))
				UpdateModsMenuScreen()
				continue


			# DEBUG: overwrite a portrait in the base game with one from a mod.
			elif chr(key.c).lower() == 'r':# or session.gamepad_input == 2: ???
				if gallery_mode == 'Modded Portraits':
					if not DEBUG: continue
					selected_variant = available_variants[0]
					mod_folder = session.modded_portraits[selected_entry][selected_variant][-1]

					# Prompt to overwrite.
					if selected_variant == 'STD':
						prompt_prefix = ''
					else:
						prompt_prefix = selected_variant + os.sep
					if selected_entry in session.base_game_portraits:
						text = 'Overwrite "' + prompt_prefix + selected_entry + '" with the version from mod "' + mod_folder + '"?'
					else:
						text = 'Add "' + prompt_prefix + selected_entry + '" from mod "' + mod_folder + '" to the game files?'
					
					if not ShowNotification(text, confirm=True): continue

					sourcepath = session.mod_path + mod_folder + os.sep + 'unit_portraits' + os.sep
					destination = PORTRAITPATH
					if selected_variant != 'STD':
						sourcepath += selected_variant + os.sep
						destination += selected_variant + os.sep
					if not os.path.exists(sourcepath + selected_entry):
						ShowNotification('Attempted to copy modded portrait "' + selected_entry + '" from folder "' + sourcepath + '", but the file does not seem to exist. This should not have happened.')
					elif not os.path.exists(destination):
						ShowNotification('Attempted to copy modded portrait "' + selected_entry + '" to game folder "' + destination + '", but the folder does not seem to exist. This should not have happened.')
					else:
						copyfile(sourcepath + selected_entry, destination + selected_entry)
						PlaySound('add_skill')

						# Add the new portrait to base_game_portraits and base_game_missing_variants for future comparisons. missing_variants and portrait_library already include modded files by default.
						if selected_entry in session.base_game_portraits:
							session.base_game_portraits[selected_entry][selected_variant] = destination + selected_entry
							if selected_variant in session.base_game_missing_variants[selected_entry]:
								session.base_game_missing_variants[selected_entry].remove(selected_variant)
						else:
							session.base_game_portraits[selected_entry] = {variant : destination + selected_entry for variant in PORTRAIT_VARIANTS}
							session.base_game_missing_variants[selected_entry] = [variant for variant in PORTRAIT_VARIANTS if variant != selected_variant]

						# Remove it from modded_portraits.
						session.modded_portraits[selected_entry].pop(selected_variant, None)
						if len(session.modded_portraits[selected_entry]) > 0: # Go to the next variant if there is one.
							available_variants.pop(0)
						else: # otherwise remove the entire entry
							session.modded_portraits.pop(selected_entry, None)
							if len(gallery_list) > 1: # if there's any mod portraits beyond the current one, remove this entry and go to the next one
								selection = gallery_list.index(selected_entry)
								gallery_list.remove(selected_entry)
								if selection > len(gallery_list) - 1:
									selected_entry = gallery_list[0]
								else:
									selected_entry = gallery_list[selection]
								available_variants = [var for var in PORTRAIT_VARIANTS if var in session.modded_portraits[selected_entry]]
							else: # otherwise, return to the mod menu.
								gallery_mode = False
								GenerateAvailableVariants()
								ShowNotification('No modded portraits remaining to compare.')

						UpdateModsMenuScreen()
				continue

			# cycle list up/down
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
				
				# no unit types visible
				if len(gallery_list) == 0:
					continue

				i = gallery_list.index(selected_entry)
				if key_char == 'w' or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_PAGEUP] or session.gamepad_input == 11:
					if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
						i -= 1
					else:
						i -= 10
					if i < 0:
						i = len(gallery_list) - 1
				else:
					if key_char == 's' or key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12:
						i += 1
					else:
						i += 10
					if i > len(gallery_list) - 1:
						i = 0
					
				selected_entry = gallery_list[i]
				GenerateAvailableVariants()
				PlaySound('menu_select')
				UpdateModsMenuScreen()
				continue


			# Hold down space to overlap the portraits.
			if key.vk == sdl2.SDLK_SPACE and gallery_mode == 'Modded Portraits':
				overlay_basic_portrait = True
				UpdateModsMenuScreen()
				while session.key_down:
					libtcod.console_flush()
					GetInputEvent(allow_repeat=True)
				overlay_basic_portrait = False
				UpdateModsMenuScreen()
				continue


		else:
			
			# cycle selected option up/down
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					selected_menu_item -= 1
				else:
					selected_menu_item += 1
				if selected_menu_item < 0:
					selected_menu_item = len(MOD_MENU_ITEMS) - 1
				elif selected_menu_item >= len(MOD_MENU_ITEMS):
					selected_menu_item = 0
				UpdateModsMenuScreen()
				continue
			
			# activate selected option
			elif key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
				
				text = MOD_MENU_ITEMS[selected_menu_item]
				
				# exit the mod menu
				if text == 'Return to Main Menu':
					exit_menu = True
					continue
				
				# check modded campaigns for common issues
				elif text == 'Check Modded Campaigns':
			
			
					if chr(key.c).lower() == 'c' or session.gamepad_input == 2:
						
						# no modded campaigns loaded
						if len(session.modded_campaign_list) == 0:
							ShowNotification('No modded campaigns loaded.')
							continue
		
						error_count = 0
						
						for filename in session.modded_campaign_list:
							try:
								with open(filename, encoding='utf8') as data_file:
									campaign_data = json.load(data_file)
							except Exception as e:
								ShowNotification('Error: Unable to parse campaign file ' + filename + ': ' + str(e))
								error_count += 1
								continue
							
							if CheckCampaign(campaign_data):
								ShowNotification('One or more issues found in ' + filename + ', check the console.')
								error_count += 1
						
						if not error_count:
							ShowNotification('No issues found.')
						continue

				# check over all unit definitions for common problems
				elif text == 'Check Unit Definitions':
					for k, v in session.unit_types.items():
						if 'portrait' in v:
							if v['portrait'].lower() not in session.portrait_library:
								print(' Warning: No portraits found for: ' + k)
						if len(k) > 25:
							print(' Warning: Unit ID too long (max 25 chars): ' + k)
						if 'description' in v:
							text = ''
							for t in v['description']:
								text += t
							lines = wrap(text, 32)
							if len(lines) > 13:
								print(' Warning: Unit description too long (max 13 lines of 32 chars): ' + k)
						if 'weapon_list' in v:
							for weapon_data in v['weapon_list']:
								if 'ammo_type_list' in weapon_data and 'special_ammo' in weapon_data:
									for special_ammo in list(weapon_data['special_ammo'].keys()):
										if special_ammo in weapon_data['ammo_type_list']: continue
										print('Warning: Special ammo defined but not included in ammo list for a weapon in ' + k)
					
					ShowNotification('Any issues have been printed to the console.')
					continue
				
				# display units that aren't in any campaigns or used as tractors
				elif text == 'Display Unused Units':
					
					unused_units = list(session.unit_types)
					for filename in session.campaign_list:
						try:
							with open(filename, encoding='utf8') as data_file:
								campaign_data = json.load(data_file)
						except Exception as e:
							continue
	
						if 'player_unit_list' in campaign_data:
							for selected_unit in campaign_data['player_unit_list']:
								if selected_unit in unused_units:
									unused_units.remove(selected_unit)
						if 'player_arty_support' in campaign_data:
							for selected_unit in campaign_data['player_arty_support']:
								if selected_unit in unused_units:
									unused_units.remove(selected_unit)
	
						if 'player_unit_support' in campaign_data:
							for k, v in campaign_data['player_unit_support'].items():
								for selected_unit in v:
									if selected_unit in unused_units:
										unused_units.remove(selected_unit)
	
						if 'friendly_transported_units' in campaign_data:
							for k, v in campaign_data['friendly_transported_units'].items():
								if k in unused_units:
									unused_units.remove(k)
								for selected_unit in v:
									if selected_unit in unused_units:
										unused_units.remove(selected_unit)
	
						if 'enemy_arty_support' in campaign_data:
							for k, v in campaign_data['enemy_arty_support'].items():
								for selected_unit in v:
									if selected_unit in unused_units:
										unused_units.remove(selected_unit)
	
						if 'enemy_air_support' in campaign_data:
							for k, v in campaign_data['enemy_air_support'].items():
								for selected_unit in v:
									if selected_unit in unused_units:
										unused_units.remove(selected_unit)
	
						if 'enemy_unit_list' in campaign_data:
							for k, v in campaign_data['enemy_unit_list'].items():
								for selected_unit in v:
									if selected_unit in unused_units:
										unused_units.remove(selected_unit)
	
						if 'enemy_transported_units' in campaign_data:
							for k1, v1 in campaign_data['enemy_transported_units'].items():
								for k2, v2 in v1.items():
									if k2 in unused_units:
										unused_units.remove(k2)
									for selected_unit in v2:
										if selected_unit in unused_units:
											unused_units.remove(selected_unit)
	
					for nation in session.nations:
						if 'gun_tractors' in session.nations[nation]:
							for unit_id in session.nations[nation]['gun_tractors']:
								if unit_id in unused_units:
									unused_units.remove(unit_id)
	
					# remove game-engine units that aren't explicitly used in campaigns.
					for basic_unit in ['Locomotive', 'Horse Limber', 'Large Horse Limber']:
						if basic_unit in unused_units:
							unused_units.remove(basic_unit)
	
					if len(unused_units):
						gallery_mode = 'Unused Units'
						gallery_list = unused_units
						selected_entry = unused_units[0]
						GenerateAvailableVariants()
						UpdateModsMenuScreen()
					else:
						ShowNotification('No unused units found.')
					continue
				
				# display portraits that aren't used in-game
				elif text == 'Display Unused Portraits':
			
					unused_portraits = list(session.portrait_library)
	
					# Remove the portraits of normal units.
					for unit, stats in session.unit_types.items():
						if 'portrait' in stats:
							unit_portrait = stats['portrait'].lower()
							if unit_portrait in unused_portraits:
								unused_portraits.remove(unit_portrait)
	
					# Remove the national variants of infantry/cavalry units.
					for portrait in session.infantry_portrait_library:
						for variant in session.infantry_portrait_library[portrait]:
							for nation_code, filepath in session.infantry_portrait_library[portrait][variant].items():
								national_variant = filepath.split(os.sep)[-1].lower() # split off the file path and just get the portrait filename, then lowercase it for library case reasons.
								if national_variant in unused_portraits:
									unused_portraits.remove(national_variant)
	
					# Remove the portraits of sniper teams, which don't have specific unit entry to keep them from being used in campaigns as on-map units.
					if 'unit_sniper_team.xp' in unused_portraits:
						unused_portraits.remove('unit_sniper_team.xp')
					for nation_suffix in [session.nations[i]['short_code'].lower() for i in session.nations] + ['basic']:
						sniper_portrait_variant = nation_suffix.join(['unit_sniper_team_', '.xp'])
						if sniper_portrait_variant in unused_portraits:
							unused_portraits.remove(sniper_portrait_variant)
					
					# Remove the unspotted target portrait.
					if 'unit_unknown.xp' in unused_portraits:
						unused_portraits.remove('unit_unknown.xp')
	
					if len(unused_portraits):
						gallery_mode = 'Unused Portraits'
						gallery_list = unused_portraits
						selected_entry = unused_portraits[0]
						GenerateAvailableVariants()
						UpdateModsMenuScreen()
					else:
						ShowNotification('No unused portraits found.')
					continue

				# Go through modded portraits and compare their hashes to the corresponding base-game portrait, removing any that have already been ported to the base game. 	
				elif text == 'Contrast Modded/Default Portraits':
			
					if len(session.modded_portraits):		
						import hashlib
						for unit_key in list(session.modded_portraits):
							if unit_key not in session.base_game_portraits:
								continue
							for variant in list(session.modded_portraits[unit_key]):
								sourcepath = session.mod_path + session.modded_portraits[unit_key][variant][-1] + os.sep + 'unit_portraits' + os.sep
								if variant != 'STD':
									sourcepath += variant + os.sep
								with open(sourcepath + unit_key, 'rb') as mod_file:
									modded_hash = hashlib.md5(mod_file.read()).hexdigest()
								with open(session.base_game_portraits[unit_key][variant], 'rb') as base_file:
									base_hash = hashlib.md5(base_file.read()).hexdigest()
								if base_hash == modded_hash:
									session.modded_portraits[unit_key].pop(variant, None)
							if len(session.modded_portraits[unit_key]) == 0:
								session.modded_portraits.pop(unit_key, None)
	
						# If there's no modded portraits that aren't already copied to the base game, continue.
						if len(session.modded_portraits):
							gallery_mode = 'Modded Portraits'
							gallery_list = list(session.modded_portraits)
							selected_entry = gallery_list[0]
							GenerateAvailableVariants()
							UpdateModsMenuScreen()
							continue

					ShowNotification('No modded portraits found.')
					continue



# output a crash log before closing
def OutputCrashLog(text):
	filename = str(Path.home()) + os.sep + 'ArmCom2' + os.sep + 'logs'
	filename += os.sep + 'crashlog_' + datetime.now().strftime("%Y-%m-%d_%H_%M_%S") + '.txt'
	with open(filename, 'w', encoding='utf-8') as f:
		f.write('ArmCom2 Crashlog, (' + VERSION + '):\n')
		
		if campaign is not None:
			f.write('Campaign: ' + campaign.filename + '\n')
			if campaign.today is not None:
				f.write('Date: ' + GetDateText(campaign.today) + '\n\n')
		
		if scenario is not None:
			f.write('Player Unit: ' + scenario.player_unit.unit_id + '\n')
			f.write('Scenario Phase: ' + SCEN_PHASE_NAMES[scenario.phase] + '\n')
			
		if session is not None:
			if len(session.active_mods) > 0:
				text = 'Active Mods: '
				for filename in session.active_mods:
					text += filename + ' '
				f.write(text + '\n\n')
		f.write(text + '\n\n')


# handle continuing into a new campaign after one is completed
def ContinueCampaign():
	
	COMPATIBLE_NATIONS = {
		"France" : ["Free France", "Vichy France"],
		"Vichy France" : ["Free France"]
	}
	
	global campaign, campaign_day, scenario
	
	# If Player Commander ended the previous campaign in the Field Hospital, CommanderInAComa would have already released him temporarily
	
	# don't allow if Player Commander is dead
	for position in campaign.player_unit.positions_list:
		if position.crewman is None: continue
		if position.crewman.is_player_commander and not position.crewman.alive:
			return False
	
	# don't allow this for the tutorial campaign
	if 'tutorial_campaign' in campaign.stats: return False
	
	# check to see if any crew are left!
	all_dead = True
	for position in campaign.player_unit.positions_list:
		if position.crewman is None: continue
		if not position.crewman.alive: continue
		all_dead = False
		break
	
	# check field hospital too
	if len(campaign.hospital) > 0:
		all_dead = False
	
	if all_dead:
		return False
	
	# scan campaigns and build a list of possible ones to continue into
	campaign_list = []
	
	for filename in session.campaign_list:
		try:
			with open(filename, encoding='utf8') as data_file:
				campaign_data = json.load(data_file)
		except Exception as e:
			continue
		
		nations_ok = True
		if campaign_data['player_nation'] != campaign.stats['player_nation']:
			nations_ok = False
			if campaign.stats['player_nation'] in COMPATIBLE_NATIONS:
				if campaign_data['player_nation'] in COMPATIBLE_NATIONS[campaign.stats['player_nation']]:
					nations_ok = True
		if not nations_ok: continue
		
		# not possible to join a campaign if end date is also before or on the previous campaign's end date
		if campaign_data['end_date'] <= campaign.stats['end_date']:
			continue
			
		campaign_list.append(filename)
	
	# no possible ones to continue into
	if len(campaign_list) == 0:
		return False
	
	# confirm with player
	if not ShowNotification('Continue on a new campaign with surviving crewmen?', confirm=True, add_pause=True):
		return None
	
	# create a new campaign object, copy over the old player unit and its crew to the
	# new campaign, and make the campaign object the new campaign
	new_campaign = Campaign()
	new_campaign.player_unit = campaign.player_unit
	(year1, month1, day1) = campaign.stats['end_date'].split('.')
	old_campaign = campaign
	campaign = new_campaign
	
	# also copy over the field hospital and campaign options
	campaign.hospital = old_campaign.hospital.copy()
	campaign.options = old_campaign.options.copy()
	campaign.vp_modifier = old_campaign.vp_modifier
	
	# save the stats of the old campaign
	old_campaign_stats = old_campaign.stats.copy()
	
	# show a restricted campaign selection menu
	if not campaign.CampaignSelectionMenu(campaign_list=campaign_list, old_campaign=old_campaign):
		return False
	
	# apply advance bonuses to crewmen, re-calculate their age, and resolve all outstanding injuries
	(year2, month2, day2) = campaign.stats['start_date'].split('.')
	a = datetime(int(year2), int(month2), int(day2), 0, 0, 0) - datetime(int(year1), int(month1), int(day1), 0, 0, 0)
	days_past = a.days
	advances = int(ceil(days_past / CONTINUE_CAMPAIGN_LEVEL_UP_DAYS))
	ShowNotification('Your crewmen receive ' + str(advances) + ' advance points from training.')
	for position in campaign.player_unit.positions_list:
		if position.crewman is None: continue
		position.crewman.adv += advances
		position.crewman.CalculateAge()
		position.crewman.ResolveOutstandingInjuries()
	
	# see if any crewmen are released from the field hospital
	returning_crewmen = []
	for crewman in reversed(campaign.hospital):
		
		# update age and remove any current campaign skills
		crewman.CalculateAge()
		crewman.RemoveCampaignSkills()
		
		(min_days, max_days) = crewman.field_hospital
		if min_days > 0:
			min_days -= days_past
			if min_days < 0:
				min_days = 0
		
		if max_days > 0:
			max_days -= days_past
			if max_days < 0:
				max_days = 0
		
		# crewman with 0 max days left are automatically returned to action
		if max_days == 0:
			crewman.field_hospital = None
			returning_crewmen.append(crewman)
			campaign.hospital.remove(crewman)
			crewman.ResolveOutstandingInjuries()
			continue
		
		# roll for return to action based on how many days elapsed
		if min_days <= 0 or 'Fighting Spirit' in crewman.skills:
			if GetPercentileRoll() <= float(days_past) * FIELD_HOSPITAL_RELEASE_CHANCE:
				crewman.field_hospital = None
				returning_crewmen.append(crewman)
				campaign.hospital.remove(crewman)
				crewman.ResolveOutstandingInjuries()
				continue
		
		# crewman remains in hospital, update days remaining
		crewman.field_hospital = (min_days, max_days)
	
	# allow player to choose a new tank, and give player option to assign returning crew if any
	if len(returning_crewmen) > 0:
		if len(returning_crewmen) == 1:
			text = 'One crewman has'
		else:
			text = 'Crewmen have'
		text += ' returned from their stay in the field hospital and may be assigned to your tank.'
		ShowNotification(text)
		campaign.ReplacePlayerTank(returning_crewmen=returning_crewmen, old_campaign_stats=old_campaign_stats)
	else:
		campaign.ReplacePlayerTank(old_campaign_stats=old_campaign_stats)
	
	# remove old campaign skills and add new campaign skills to crewmen 
	for position in campaign.player_unit.positions_list:
		if position.crewman is None: continue
		position.crewman.RemoveCampaignSkills()
		position.crewman.AddCampaignSkills()
	
	# finish setting up the campaign
	campaign.DoPostInitChecks()
	
	# create a new campaign day and a placeholder for the current scenario
	campaign_day = CampaignDay()
	for (hx, hy) in CAMPAIGN_DAY_HEXES:
		campaign_day.map_hexes[(hx,hy)].CalcCaptureVP()
	campaign_day.GenerateRoads()
	campaign_day.GenerateRivers()
	
	# check for updated portrait variants for the new campaign
	campaign.UpdatePortraitVariant()
	
	campaign.ShowStartOfDay()
	campaign.AddJournal('Start of day')
	
	# set currently displayed journal entry to the new day
	campaign.active_journal_day = campaign.today
	
	SaveGame()
	BackupGame()
	
	# clear the old vars
	scenario = None
	
	return True


# display a loading message on the double buffer console
def DisplayLoadingMsg():
	libtcod.console_set_default_background(con, libtcod.black)
	libtcod.console_rect(con, WINDOW_XM-6, WINDOW_YM-1, 12, 3, True, libtcod.BKGND_SET)
	libtcod.console_print_ex(con, WINDOW_XM, WINDOW_YM, libtcod.BKGND_NONE, libtcod.CENTER,
		'Loading...')
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()


# show a gallery of all the unit types in the game
def UnitGallery():
	
	# display a list of campaigns where this unit type appears
	def DisplayUnitCampaignRoster():
		
		# get list of campaigns first
		lines = []
		for filename in session.campaign_list:
			try:
				with open(filename, encoding='utf8') as data_file:
					campaign_data = json.load(data_file)
			except Exception as e:
				continue
			
			if 'player_unit_list' in campaign_data:
				if selected_unit in campaign_data['player_unit_list']:
					lines.append(campaign_data['name'])
					continue
			if 'player_arty_support' in campaign_data:
				if selected_unit in campaign_data['player_arty_support']:
					lines.append(campaign_data['name'])
					continue
			
			found_unit = False
			if 'player_unit_support' in campaign_data:
				for k, v in campaign_data['player_unit_support'].items():
					if selected_unit in v:
						lines.append(campaign_data['name'])
						found_unit = True
						break
			if found_unit: continue
			
			if 'friendly_transported_units' in campaign_data:
				for k, v in campaign_data['friendly_transported_units'].items():
					if k == selected_unit:
						lines.append(campaign_data['name'])
						found_unit = True
						break
					if selected_unit in v:
						lines.append(campaign_data['name'])
						found_unit = True
						break
			if found_unit: continue
			
			if 'enemy_arty_support' in campaign_data:
				for k, v in campaign_data['enemy_arty_support'].items():
					if selected_unit in v:
						lines.append(campaign_data['name'])
						found_unit = True
						break
			if found_unit: continue
			
			if 'enemy_air_support' in campaign_data:
				for k, v in campaign_data['enemy_air_support'].items():
					if selected_unit in v:
						lines.append(campaign_data['name'])
						found_unit = True
						break
			if found_unit: continue
			
			if 'enemy_unit_list' in campaign_data:
				for k, v in campaign_data['enemy_unit_list'].items():
					if selected_unit in v:
						lines.append(campaign_data['name'])
						found_unit = True
						break
			if found_unit: continue
			
			if 'enemy_transported_units' in campaign_data:
				for k1, v1 in campaign_data['enemy_transported_units'].items():
					for k2, v2 in v1.items():
						if k2 == selected_unit:
							lines.append(campaign_data['name'])
							found_unit = True
							break
						if selected_unit in v2:
							lines.append(campaign_data['name'])
							found_unit = True
							break
					if found_unit: break
			if found_unit: continue
		
		# no appearances
		if len(lines) == 0:
			ShowSimpleMessage('No results for this combination.')
			return
		
		temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
		libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
		
		# darken background 
		libtcod.console_blit(darken_con, 0, 0, 0, 0, con, 0, 0, 0.0, 0.7)
		
		# create display console
		roster_con = NewConsole(53, 55, libtcod.black, libtcod.white)
		libtcod.console_clear(roster_con)
		libtcod.console_set_default_foreground(roster_con, libtcod.grey)
		DrawFrame(roster_con, 0, 0, 53, 55)
		
		libtcod.console_set_default_foreground(roster_con, libtcod.white)
		libtcod.console_print_ex(roster_con, 27, 3, libtcod.BKGND_NONE, libtcod.CENTER,
			selected_unit)
		libtcod.console_print_ex(roster_con, 27, 4, libtcod.BKGND_NONE, libtcod.CENTER,
			'appears in the following campaigns:')
		
		y = 6
		libtcod.console_set_default_foreground(roster_con, libtcod.light_grey)
		for line in lines:
			libtcod.console_print(roster_con, 4, y, line)
			y += 1
			if y >= 50: break
		
		# display inputs
		if gamepad is not None:
			DisplayButton(roster_con, 22, 52, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(roster_con, ACTION_KEY_COL)
			libtcod.console_print(roster_con, 18, 52, 'Esc')
		libtcod.console_set_default_foreground(roster_con, libtcod.light_grey)
		libtcod.console_print(roster_con, 24, 52, 'Close Window')
		
		libtcod.console_blit(roster_con, 0, 0, 0, 0, con, 18, 3)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
		exit_menu = False
		while not exit_menu:
			libtcod.console_flush()
			if not GetInputEvent(): continue
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				exit_menu = True
				continue
	
	def UpdateUnitFilterScreen():
		libtcod.console_clear(con)
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		DrawFrame(con, 2, 2, 86, 56)
		
		libtcod.console_set_default_background(con, libtcod.darkest_purple)
		libtcod.console_rect(con, 34, 3, 25, 3, False, libtcod.BKGND_SET)
		libtcod.console_set_default_background(con, libtcod.black)
		
		libtcod.console_set_default_foreground(con, libtcod.light_purple)
		libtcod.console_print_ex(con, 46, 4, libtcod.BKGND_NONE, libtcod.CENTER,
			'Set Unit Type Filters')
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_print(con, 6, 8, 'Nation of Origin')
		if selected_filter_column == 0:
			libtcod.console_rect(con, 6, 8, 24, 1, False, libtcod.BKGND_SET)
		libtcod.console_print(con, 31, 8, 'Category')
		if selected_filter_column == 1:
			libtcod.console_rect(con, 31, 8, 24, 1, False, libtcod.BKGND_SET)
		libtcod.console_print(con, 56, 8, 'Class')
		if selected_filter_column == 2:
			libtcod.console_rect(con, 56, 8, 24, 1, False, libtcod.BKGND_SET)
		
		libtcod.console_set_default_background(con, libtcod.black)
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		x = 6
		for text in FILTER_TAGS:
			libtcod.console_print(con, x, 10, '[Any]')
			
			if active_filters[text] is None:
				libtcod.console_set_default_background(con, libtcod.darker_blue)
				libtcod.console_rect(con, x, 10, 24, 1, False, libtcod.BKGND_SET)
				libtcod.console_set_default_background(con, libtcod.black)
			
			y = 11
			for v in session.unit_filter_tags[text]:
				libtcod.console_print(con, x, y, v)
				
				# highlight this filter if active
				if active_filters[text] is not None:
					if active_filters[text] == v:
						libtcod.console_set_default_background(con, libtcod.darker_blue)
						libtcod.console_rect(con, x, y, 24, 1, False, libtcod.BKGND_SET)
						libtcod.console_set_default_background(con, libtcod.black)
				
				y += 1
			x += 25
		
		# display inputs
		if gamepad is not None:
			DisplayButton(con, 36, 52, GAMEPADCHAR_LB)
			DisplayButton(con, 37, 52, GAMEPADCHAR_RB)
			DisplayButton(con, 37, 53, GAMEPADCHAR_DPAD_UD)
			DisplayButton(con, 37, 55, GAMEPADCHAR_B)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 32, 52, 'Tab')
			libtcod.console_print(con, 32, 53, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(con, 32, 54, 'PgUp/PgDn')
			libtcod.console_print(con, 32, 55, 'Enter')
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_print(con, 42, 52, 'Cycle Column')
		libtcod.console_print(con, 42, 53, 'Select Filter')
		libtcod.console_print(con, 42, 54, 'Select Filter (Skip 5)')
		libtcod.console_print(con, 42, 55, 'Set Filters and Return')
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		
	def UpdateUnitGalleryScreen():
		libtcod.console_clear(con)
		
		libtcod.console_set_default_background(con, libtcod.darker_blue)
		libtcod.console_rect(con, 29, 1, 34, 3, False, libtcod.BKGND_SET)
		libtcod.console_set_default_background(con, libtcod.black)
		
		libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
		libtcod.console_print_ex(con, 46, 2, libtcod.BKGND_NONE, libtcod.CENTER,
			'Unit Gallery')
		
		libtcod.console_set_default_foreground(con, libtcod.light_grey)
		libtcod.console_print_ex(con, 46, 5, libtcod.BKGND_NONE, libtcod.CENTER,
			str(len(unit_type_list)) + ' total unit types')
		if len(filtered_list) == 0:
			libtcod.console_set_default_foreground(con, libtcod.light_red)
		libtcod.console_print_ex(con, 46, 6, libtcod.BKGND_NONE, libtcod.CENTER,
			str(len(filtered_list)) + ' match current filters')
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_set_default_background(con, libtcod.dark_blue)
		
		# left column: list of unit types if any
		if len(filtered_list) > 0:
		
			y = 5
			s = filtered_list.index(selected_unit)
			for i in range(s-20, s+30):
				if i < 0:
					y += 1
					continue
				elif i > len(filtered_list) - 1:
					break
				
				# this unit type is the currently highlighted one
				if i == s:
					libtcod.console_rect(con, 2, y, 25, 1, True, libtcod.BKGND_SET)
				
				libtcod.console_print(con, 2, y, filtered_list[i])
				
				y += 1
			
			libtcod.console_set_default_foreground(con, libtcod.light_grey)
			DrawFrame(con, 29, 8, 34, 45)
			libtcod.console_set_default_foreground(con, libtcod.white)
			
			# display basic info on selected unit type
			unit_type = session.unit_types[selected_unit]
			
			# display portrait. Get a nation argument, as infantry/cavalry are often generic units shared
			# between multiple nations but have nation-specific portrait variants, using either the current
			# active nation filter or the unit's origin nation, for those that have one.
			# units often have origin nations that aren't in the nation defines so that needs checking as well.
			if 'origin_nation' in active_filters and active_filters['origin_nation'] in session.nations:
				display_nation = session.nations[active_filters['origin_nation']]['short_code']
			elif 'origin_nation' in unit_type and unit_type['origin_nation'] in session.nations:
				display_nation = session.nations[unit_type['origin_nation']]['short_code']
			else:
				display_nation = None
			DisplayUnitInfo(con, 33, 10, selected_unit, None, portrait_variant = PORTRAIT_VARIANTS[portrait_variant], portrait_nation = display_nation)

			# get an ID for the unit portrait, to grey out unavailable portrait variant keys
			if 'portrait' not in unit_type or unit_type['portrait'].lower() not in session.portrait_library:
				unit_portrait = None
			else:
				unit_portrait = unit_type['portrait'].lower()
				if unit_type['category'] in ['Infantry', 'Cavalry']:
					if not config['ArmCom2'].getboolean('fancy_portraits'):
						display_nation = 'BASIC'
					unit_portrait = session.infantry_portrait_library[unit_portrait][PORTRAIT_VARIANTS[portrait_variant]][display_nation].split(os.sep)[-1].lower()

			# display labels for portrait variants
			y = 12
			for variant in PORTRAIT_VARIANTS:
				if variant == PORTRAIT_VARIANTS[portrait_variant]:
					libtcod.console_set_default_foreground(con, libtcod.white)
				elif unit_portrait is not None and variant not in session.missing_variants[unit_portrait]:
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
				else:
					libtcod.console_set_default_foreground(con, libtcod.dark_grey)
				libtcod.console_print(con, 58, y, variant)
				y += 1
			
			# display historical notes if any
			if 'description' in unit_type:
				text = ''
				for t in unit_type['description']:
					text += t
				lines = wrap(text, 32)
				y = 26
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				for line in lines[:13]:
					PrintExtended(con, 30, y, line)
					y+=1
			
			# display historical rarity info if any
			if 'rarity' in unit_type:
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 31, 41, 'Historical Rarity:')
				libtcod.console_set_default_foreground(con, libtcod.light_grey)
				y = 42
				
				# apply offset if any
				i = 0
				
				# display arrow indicating more entries above
				if rarity_offset > 0:
					libtcod.console_put_char_ex(con, 57, y, 24, libtcod.white, libtcod.black)
				
				for date, chance in unit_type['rarity'].items():
					
					# cut off list if too long to display
					if y >= 49:
						
						# display arrow indicating more entries below
						libtcod.console_put_char_ex(con, 57, y-1, 25, libtcod.white, libtcod.black)
						break
					
					if rarity_offset <= i:
						libtcod.console_print(con, 33, y, GetDateText(date) + ':')
						libtcod.console_print(con, 53, y, str(chance) + '%')
						y += 1
					i += 1
					
			# display origin nation if any
			if 'origin_nation' in unit_type:
				libtcod.console_set_default_foreground(con, libtcod.lighter_grey)
				libtcod.console_print_ex(con, 46, 51, libtcod.BKGND_NONE, libtcod.CENTER,
					'Origin: ' + unit_type['origin_nation'])
			
			y = 1
			# display personnel positions if any
			if 'crew_positions' in unit_type:
				libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
				libtcod.console_print(con, 64, y, 'Personnel')
				libtcod.console_set_default_foreground(con, libtcod.white)
				text = ''
				for position in unit_type['crew_positions']:
					text += position['name']
					# add hatch/crew exposure info here if any
					if 'crew_always_exposed' in position:
						text += ' (CE)'
					elif 'open_top' in position:
						text += ' (OT)'
					elif 'hatch' in position:
						if 'large_hatch' in position:
							text += ' (LH)'
						else:
							text += ' (H)'
					text += ', '
				
				# strip out the last comma and space in the text
				text = text[:-2]
				
				y += 1
				for line in wrap(text, 23):
					libtcod.console_print(con, 65, y, line)
					y += 1
			
			# protected/wet ammo stowage
			if 'wet_stowage' in unit_type:
				y += 2
				libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
				libtcod.console_print(con, 64, y, 'Protected Ammo Stowage')
			
			# towing capacity if any
			if 'towing_capacity' in unit_type:
				y += 2
				libtcod.console_set_default_foreground(con, libtcod.white)
				libtcod.console_print(con, 64, y, 'Towing: ' + unit_type['towing_capacity'])
			
			# display details on weapons if any
			if 'weapon_list' in unit_type:
				y += 2
				libtcod.console_set_default_foreground(con, libtcod.lighter_blue)
				libtcod.console_print(con, 64, y, 'Weapons')
				y += 2
				
				for weapon_type in unit_type['weapon_list']:
					libtcod.console_set_default_foreground(con, libtcod.white)
					if 'name' in weapon_type:
						text = weapon_type['name']
					elif weapon_type['type'] in ['Gun', 'Cannon']:
						text = weapon_type['calibre']
						if 'long_range' in weapon_type:
							text += weapon_type['long_range']
						if 'autocannon' in weapon_type:
							text += 'a'
					elif weapon_type['type'] == 'Bombs':
						text = weapon_type['calibre'] + 'mm Bombs' 
					elif weapon_type['type'] in MG_WEAPONS and 'calibre' in weapon_type:
						text = weapon_type['type'] + '+'
					else:
						text = weapon_type['type']
					libtcod.console_print(con, 64, y, text)
					y += 1
					
					libtcod.console_set_default_foreground(con, libtcod.light_grey)
					
					if 'rear_facing' in weapon_type or weapon_type['type'] == 'RMG':
						libtcod.console_print(con, 65, y, 'Rear-Facing')
						y += 1
					if 'max_range' in weapon_type:
						text = 'Range: ' + weapon_type['max_range'] + ' hex'
						if int(weapon_type['max_range']) > 1:
							text += 'es'
						libtcod.console_print(con, 65, y, text)
						y += 1
					if 'rof' in weapon_type:
						libtcod.console_print(con, 65, y, 'RoF: ' + weapon_type['rof'] + '%')
						y += 1
					if 'autocannon' in weapon_type:
						libtcod.console_print(con, 65, y, 'Autocannon')
						y += 1
					if 'fp' in weapon_type:
						libtcod.console_print(con, 65, y, 'Firepower: ' + weapon_type['fp'])
						y += 1
					if 'fired_by' in weapon_type:
						libtcod.console_print(con, 65, y, 'Fired By:')
						y += 1
						for t in weapon_type['fired_by']:
							libtcod.console_print(con, 66, y, t)
							y += 1
					if 'reloaded_by' in weapon_type:
						libtcod.console_print(con, 65, y, 'Reloaded By:')
						y += 1
						for t in weapon_type['reloaded_by']:
							libtcod.console_print(con, 66, y, t)
							y += 1
					if 'ammo_type_list' in weapon_type:
						text = 'Ammo Types: '
						for t in weapon_type['ammo_type_list']:
							text += t + ' '
						for line in wrap(text, 24, subsequent_indent=' '):	
							libtcod.console_print(con, 65, y, line)
							y += 1
					if 'max_ammo' in weapon_type:
						libtcod.console_print(con, 65, y, 'Max Ammo: ' + weapon_type['max_ammo'])
						y += 1
					if 'rr_size' in weapon_type:
						libtcod.console_print(con, 65, y, 'Ready Rack: ' + weapon_type['rr_size'])
						y += 1
					if 'very_unreliable' in weapon_type:
						libtcod.console_print(con, 65, y, 'Very Unreliable')
						y += 1
					elif 'unreliable' in weapon_type:
						libtcod.console_print(con, 65, y, 'Unreliable')
						y += 1
					if 'front_only' in weapon_type:
						libtcod.console_print(con, 65, y, 'Front-Facing Only')
						y += 1
					if 'bu_ok' in weapon_type:
						libtcod.console_print(con, 65, y, 'Can fire while BU')
						y += 1
					if 'hd_ok' in weapon_type:
						libtcod.console_print(con, 65, y, 'Can fire while HD')
						y += 1
					
					y += 1

		# display inputs
		if gamepad is not None:
			DisplayButton(con, 36, 54, GAMEPADCHAR_LB)
			DisplayButton(con, 37, 54, GAMEPADCHAR_RB)
			DisplayButton(con, 37, 55, GAMEPADCHAR_DPAD_UD)
			DisplayButton(con, 37, 57, GAMEPADCHAR_Y)
			DisplayButton(con, 37, 58, GAMEPADCHAR_B)
			DisplayButton(con, 66, 57, GAMEPADCHAR_DPAD_LR)
			DisplayButton(con, 66, 58, GAMEPADCHAR_X)
		else:
			libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
			libtcod.console_print(con, 29, 54, 'Tab')
			libtcod.console_print(con, 29, 55, EnKey('w').upper() + '/' + EnKey('s').upper())
			libtcod.console_print(con, 29, 56, 'PgUp/PgDn')
			libtcod.console_print(con, 29, 57, 'F')
			libtcod.console_print(con, 29, 58, 'Esc')			
			libtcod.console_print(con, 64, 57, EnKey('q').upper() + '/' + EnKey('a').upper())
			libtcod.console_print(con, 64, 58, 'R')
		
		libtcod.console_set_default_foreground(con, libtcod.white)
		libtcod.console_print(con, 39, 54, 'Cycle Portrait Variant')
		libtcod.console_print(con, 39, 55, 'Scroll Up/Down')
		libtcod.console_print(con, 39, 56, 'Scroll 10 Up/Down')
		libtcod.console_print(con, 39, 57, 'Set Filters')
		libtcod.console_print(con, 39, 58, 'Exit Gallery')
		
		libtcod.console_print(con, 68, 57, 'Scroll Rarity')
		libtcod.console_print(con, 68, 58, 'Campaign Roster')
		
		libtcod.console_set_default_background(con, libtcod.black)
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	# create a local copy of the current screen to re-draw when we're done
	temp_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_blit(con, 0, 0, 0, 0, temp_con, 0, 0)
	
	# build a list of all the current unit types
	unit_type_list = []
	for k, v in session.unit_types.items():
		unit_type_list.append(k)
	
	# set up the initial filtered list
	filtered_list = unit_type_list.copy()
	
	# select the first unit type to start
	if len(filtered_list) == 0:
		selected_unit = None
	else:
		selected_unit = filtered_list[0]
	
	# selected portrait variant (if any)
	portrait_variant = 0
	
	# current scroll offset for displaying rarity factors
	rarity_offset = 0
	
	# set up filters
	active_filters = {}
	for text in FILTER_TAGS:
		active_filters[text] = None
	filter_window_active = False
	selected_filter_column = 0
	
	# draw screen for first time
	UpdateUnitGalleryScreen()
	
	exit_loop = False
	while not exit_loop:
		libtcod.console_flush()
		if not GetInputEvent(allow_repeat=True): continue
		
		# filter sub-menu active
		if filter_window_active:
			
			# exit sub-menu
			if key.vk in [sdl2.SDLK_ESCAPE, sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 1:
				filter_window_active = False
				
				# rebuild filtered_list and reset selected_unit based on current active_filters
				filtered_list = []
				for k in unit_type_list:
					add_unit = True
					for text in FILTER_TAGS:
						if active_filters[text] is None: continue
						if text in session.unit_types[k]:
							if session.unit_types[k][text] != active_filters[text]:
								add_unit = False
								break
					if add_unit: filtered_list.append(k)
				
				if len(filtered_list) == 0:
					selected_unit = None
				else:
					if selected_unit not in filtered_list:
						selected_unit = filtered_list[0]
						rarity_offset = 0
				
				UpdateUnitGalleryScreen()
				continue
			
			# cycle active filter column
			if key.vk == sdl2.SDLK_TAB or session.gamepad_input in [9, 10]:
				if session.gamepad_input == 9:
					selected_filter_column -= 1
				else:
					selected_filter_column += 1
				if selected_filter_column > 2:
					selected_filter_column = 0
				elif selected_filter_column < 0:
					selected_filter_column = 2
				UpdateUnitFilterScreen()
				continue
			
			key_char = DeKey(chr(key.c).lower())
			
			# cycle active filter within column
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
				
				column = session.unit_filter_tags[FILTER_TAGS[selected_filter_column]]
				
				if key_char == 's' or key.vk in [sdl2.SDLK_DOWN, sdl2.SDLK_PAGEDOWN] or session.gamepad_input == 12:
					
					# no filter selected yet for this column
					if active_filters[FILTER_TAGS[selected_filter_column]] is None:
						if key.vk == sdl2.SDLK_PAGEDOWN:
							if len(column) >= 5:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[4]
							else:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[-1]
						else:
							active_filters[FILTER_TAGS[selected_filter_column]] = column[0]
					else:
						i = column.index(active_filters[FILTER_TAGS[selected_filter_column]])
						if key.vk == sdl2.SDLK_PAGEDOWN:
							if i+5 <= len(column) - 1:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[i+5]
							else:
								active_filters[FILTER_TAGS[selected_filter_column]] = None
						else:
							if i == len(column) - 1:
								active_filters[FILTER_TAGS[selected_filter_column]] = None
							else:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[i+1]
				
				else:
					
					# no filter selected yet for this column
					if active_filters[FILTER_TAGS[selected_filter_column]] is None:
						if key.vk == sdl2.SDLK_PAGEUP:
							if len(column) <= 5:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[0]
							else:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[-1]
						else:
							active_filters[FILTER_TAGS[selected_filter_column]] = column[-1]
					else:
						i = column.index(active_filters[FILTER_TAGS[selected_filter_column]])
						if key.vk == sdl2.SDLK_PAGEUP:
							if i >= 5:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[i-5]
							else:
								active_filters[FILTER_TAGS[selected_filter_column]] = None
						else:
							if i == 0:
								active_filters[FILTER_TAGS[selected_filter_column]] = None
							else:
								active_filters[FILTER_TAGS[selected_filter_column]] = column[i-1]
				
				UpdateUnitFilterScreen()
				continue
	
		# exit menu
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			exit_loop = True
			continue
		
		# cycle portrait variant (if any)
		elif key.vk == sdl2.SDLK_TAB or session.gamepad_input in [9, 10]:
			if session.gamepad_input == 9:
				portrait_variant -= 1
				if portrait_variant < 0:
					portrait_variant = len(PORTRAIT_VARIANTS) - 1
			else:
				portrait_variant += 1
				if portrait_variant == len(PORTRAIT_VARIANTS):
					portrait_variant = 0
			UpdateUnitGalleryScreen()
			continue
		
		# open filter sub-menu (not mapped)
		if chr(key.c).lower() == 'f' or session.gamepad_input == 3:
			filter_window_active = True
			UpdateUnitFilterScreen()
			continue
		
		# display campaign roster
		elif chr(key.c).lower() == 'r' or session.gamepad_input == 2:
			
			# no unit types in filtered list
			if selected_unit is None: continue
			
			DisplayUnitCampaignRoster()
			UpdateUnitGalleryScreen()
			continue
		
		key_char = DeKey(chr(key.c).lower())
		
		# cycle list up/down
		if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN, sdl2.SDLK_PAGEUP, sdl2.SDLK_PAGEDOWN] or session.gamepad_input in [11, 12]:
			
			# no unit types visible
			if len(filtered_list) == 0: continue
			
			i = filtered_list.index(selected_unit)
			if key_char == 'w' or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_PAGEUP] or session.gamepad_input == 11:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					i -= 1
				else:
					i -= 10
				if i < 0:
					i = len(filtered_list) - 1
			else:
				if key_char == 's' or key.vk == sdl2.SDLK_DOWN or session.gamepad_input == 12:
					i += 1
				else:
					i += 10
				if i > len(filtered_list) - 1:
					i = 0
				
			selected_unit = filtered_list[i]
			rarity_offset = 0
			PlaySoundFor(None, 'menu_select')
			UpdateUnitGalleryScreen()
			continue
		
		# cycle rarity factor display
		elif key_char in ['q', 'a'] or session.gamepad_input in [13, 14]:
			
			# no unit types visible
			if len(filtered_list) == 0: continue
			if selected_unit is None: continue
			
			unit_type = session.unit_types[selected_unit]
			if 'rarity' not in unit_type: continue
			if key_char == 'q' or session.gamepad_input == 13:
				if rarity_offset == 0: continue
				rarity_offset -= 1
			else:
				if rarity_offset + 7 >= len(unit_type['rarity'].keys()): continue
				rarity_offset += 1
			PlaySoundFor(None, 'menu_select')
			UpdateUnitGalleryScreen()
			continue
			
	
	# re-draw original screen
	libtcod.console_blit(temp_con, 0, 0, 0, 0, con, 0, 0)
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	del temp_con


# display info on a unit type or a particular spawned unit object
# portrait_nation arg only matters to unit info panel and is overridden by the unit_obj's nation var if there is one.
# weapon_highlight takes a weapon object and marks that specific weapon on the unit card, and has priority over position_highlight.
# position_highlight takes an integer index and marks weapons fired or loaded by that position, more brightly for weapons the crewman is on the command to operate.
def DisplayUnitInfo(console, x, y, unit_id, unit_obj, portrait_variant=None, status=True, portrait_nation=None, weapon_highlight=None, position_highlight=None):
	
	# determine if a portrait variant needs to be used
	if portrait_variant is None:
		if campaign is not None:
			portrait_variant = campaign.portrait_variant
	if portrait_variant is None:
		portrait_variant = 'STD'
	
	unit_type = session.unit_types[unit_id]
	
	libtcod.console_set_default_background(console, libtcod.black)
	libtcod.console_set_default_foreground(console, libtcod.lighter_blue)
	
	# unit id
	libtcod.console_print(console, x, y, unit_id)
	
	# unit class
	libtcod.console_set_default_foreground(console, libtcod.light_grey)
	libtcod.console_print(console, x, y+1, unit_type['class'])
	
	# draw empty portrait background
	libtcod.console_set_default_background(console, PORTRAIT_BG_COL)
	libtcod.console_rect(console, x, y+2, 25, 8, True, libtcod.BKGND_SET)
	
	# portrait if any. Uses the instantiated unit_obj if there is one, otherwise the generic unit stats.
	DisplayUnitPortrait(console, x, y+2, (unit_obj or unit_type), portrait_variant, portrait_nation)
	
	# display type nickname if any
	if 'nick_name' in unit_type:
		libtcod.console_set_default_foreground(console, libtcod.black)
		libtcod.console_print_ex(console, x+24, y+2, libtcod.BKGND_NONE,
			libtcod.RIGHT, unit_type['nick_name'])
	
	# display if AFV and no radio
	if 'armour' in unit_type and unit_type['category'] == 'Vehicle':
		if 'no_radio' in unit_type:
			libtcod.console_set_default_foreground(console, libtcod.black)
			text = 'NR'
			if 'radio_after' in unit_type:
				text += unit_type['radio_after'][2:4]
			libtcod.console_print_ex(console, x+24, y+9, libtcod.BKGND_NONE,
				libtcod.RIGHT, text)
	
	# info for spawned units
	if unit_obj is not None:
	
		# display unit name if any overtop portrait
		if unit_obj.unit_name != '':
			libtcod.console_set_default_foreground(console, libtcod.white)
			PrintExtended(console, x, y+2, unit_obj.unit_name)
		
		# display remaining fate points if player and in campaign day
		if campaign_day is not None and unit_obj.is_player:
			if campaign_day.fate_points > 0:
				libtcod.console_set_default_foreground(console, libtcod.darker_purple)
				if 'nick_name' in unit_type:
					y1 = y+3
				else:
					y1 = y+2
				libtcod.console_print_ex(console, x+24, y1, libtcod.BKGND_NONE,
					libtcod.RIGHT, str(campaign_day.fate_points))
		
		# display if has damaged/broken radio
		if unit_obj.has_radio:
			if unit_obj.radio_destroyed:
				libtcod.console_set_default_foreground(console, libtcod.black)
				libtcod.console_print_ex(console, x+24, y+9, libtcod.BKGND_NONE,
					libtcod.RIGHT, 'Rx')
			elif unit_obj.radio_damaged:
				libtcod.console_set_default_foreground(console, libtcod.dark_grey)
				libtcod.console_print_ex(console, x+24, y+9, libtcod.BKGND_NONE,
					libtcod.RIGHT, 'Rd')
		
		# display if unit has taken a penetrating hit
		if unit_obj.ko_hit:
			libtcod.console_set_default_foreground(console, libtcod.red)
			libtcod.console_print(console, x, y+9, 'PH')
	
	# display default weapons; will not display any weapons added to a unit after spawn
	# display turret mounts on line 1, all others on line 2
	# keep track of x location and display in red if jammed, dark grey if broken
	libtcod.console_set_default_background(console, libtcod.darkest_red)
	libtcod.console_rect(console, x, y+10, 25, 2, True, libtcod.BKGND_SET)
	
	if 'weapon_list' in unit_type:
		x1 = x
		x2 = x
		i = 0
		for weapon_type in unit_type['weapon_list']:
			
			# set display colour
			libtcod.console_set_default_foreground(console, libtcod.white)
			
			if 'very_unreliable' in weapon_type:
				libtcod.console_set_default_foreground(console, libtcod.grey)
			elif 'unreliable' in weapon_type:
				libtcod.console_set_default_foreground(console, libtcod.light_grey)
			
			# highlight if on a spawned unit and broken/jammed, or is an AAMG that can be operated without being CE
			# background-highlight if we're marking either this specific weapon or weapons operated by a certain crew position
			highlight_colour = libtcod.darkest_red
			if unit_obj is not None:
				if len(unit_obj.weapon_list) > i:
					weapon = unit_obj.weapon_list[i]
					if weapon.broken:
						libtcod.console_set_default_foreground(console, libtcod.darker_grey)
					elif weapon.jammed:
						libtcod.console_set_default_foreground(console, libtcod.light_red)
					elif 'bu_ok' in weapon_type:
						libtcod.console_set_default_foreground(console, libtcod.lightest_purple)
		
					# Highlight colours are brighter than the crew bars because they're obscured by the text
					# and need to be distinct from the dark-red background instead of the usual black
					if unit_obj.is_player: 
						if weapon_highlight is not None:
							if weapon == weapon_highlight:
								highlight_colour = (0,0,150)
						elif position_highlight is not None:
							position = unit_obj.positions_list[position_highlight]
							if weapon.GetStat('mount') is None or position.location == weapon.GetStat('mount'):
								if weapon.GetStat('fired_by') is not None and position.name in weapon.GetStat('fired_by'):
									if scenario and position.crewman and position.crewman == weapon.GetOperatingCrewman():
										highlight_colour = libtcod.blue
									else:
										highlight_colour = (0,0,150)
								elif weapon.GetStat('reloaded_by') is not None and position.name in weapon.GetStat('reloaded_by'):
									if scenario and position.crewman and position.crewman.current_cmd == 'Reload':
										highlight_colour = libtcod.dark_orange
									else:
										highlight_colour = libtcod.darker_orange

			# generate weapon name text
			if weapon_type['type'] == 'Flame Thrower':
				text = 'FTR'
			elif 'name' in weapon_type:
				text = weapon_type['name']
			elif weapon_type['type'] == 'Gun':
				text = weapon_type['calibre']
				if 'long_range' in weapon_type:
					text += weapon_type['long_range']
				if 'autocannon' in weapon_type:
					text += 'a'
			elif weapon_type['type'] == 'Cannon':
				text = weapon_type['calibre'] + 'mm Cannon'
			elif weapon_type['type'] in MG_WEAPONS and 'calibre' in weapon_type:
				text = weapon_type['type'] + '+'
			else:
				text = weapon_type['type']
			
			upper_line = True
			if 'mount' in weapon_type:
				if weapon_type['mount'] != 'Turret':
					upper_line = False
			
			# switch to lower line - no more room!
			if upper_line:
				if x1 + 2 + len(text) >= x + 25:
					upper_line = False
			
			if upper_line:
				if x1 != x:
					# change background of previous weapon's spacer
					libtcod.console_set_char_background(console, x1, y+10, highlight_colour)
					x1 += 1
				# highlight weapon background if necessary
				libtcod.console_set_default_background(console, highlight_colour)
				libtcod.console_rect(console, x1, y+10, len(text), 1, True, libtcod.BKGND_SET)
				libtcod.console_print(console, x1, y+10, text)
				x1 += len(text)
				# add between-weapon spacer if there's room
				if x1 < x + 25:
					libtcod.console_put_char_ex(console, x1, y+10, 221, highlight_colour, libtcod.darkest_red)
			else:
				if x2 != x:
					libtcod.console_set_char_background(console, x2, y+11, highlight_colour)
					x2 += 1
				libtcod.console_set_default_background(console, highlight_colour)
				libtcod.console_rect(console, x2, y+11, len(text), 1, True, libtcod.BKGND_SET)
				libtcod.console_print(console, x2, y+11, text)
				x2 += len(text)
				if x2 < x + 25:
					libtcod.console_put_char_ex(console, x2, y+11, 221, highlight_colour, libtcod.darkest_red)
			
			i += 1
	
	# armour if any
	libtcod.console_set_default_foreground(console, libtcod.white)
	armoured = False
	turret_line_width = 0
	hull_line_width = 0
	if 'armour' not in unit_type:
		if unit_type['category'] == 'Vehicle':
			libtcod.console_print(console, x, y+12, 'Unarmoured')
	else:
		armoured = True
		libtcod.console_print(console, x, y+12, 'Armoured')
		
		if 'open_rear_turret' in unit_type:
			libtcod.console_print(console, x+9, y+12, 'OTR')
		elif 'open_topped' in unit_type:
			libtcod.console_print(console, x+9, y+12, 'OT')
		
		libtcod.console_set_default_foreground(console, libtcod.light_grey)
		
		# turret armour
		if 'turret' in unit_type:
			text = 'U'
			if unit_type['turret'] not in ['FIXED', 'FXT']:
				text = 'T'
			text += ' ' + unit_type['armour']['turret_front'] + '/' + unit_type['armour']['turret_side']
			libtcod.console_print(console, x, y+13, text)
			turret_line_width = len(text)
		else:
			turret_line_width = 0
		
		# hull armour
		text = 'H ' + unit_type['armour']['hull_front'] + '/' + unit_type['armour']['hull_side']
		hull_line_width = len(text)
		libtcod.console_print(console, x, y+14, text)
	
	# turret traverse and gyro info
	if 'turret' in unit_type:
		text = unit_type['turret']
		if 'gyro' in unit_type:
			text += ' G'
		libtcod.console_print(console, x+1+turret_line_width, y+13, text)
	
	# movement class, ground pressure
	text = unit_type['movement_class']
	
	# shorten display if required
	if text == 'Half-Tracked':
		text = 'Half-Track'
	
	if 'powerful_engine' in unit_type:
		text += '+'
	if 'very_unreliable' in unit_type:
		text += '(vu)'
	elif 'unreliable' in unit_type:
		text += '(u)'
	libtcod.console_set_default_foreground(console, libtcod.green)
	if 'ground_pressure' in unit_type:
		if unit_type['ground_pressure'] == 'Light':
			libtcod.console_set_default_foreground(console, libtcod.lighter_green)
		elif unit_type['ground_pressure'] == 'Heavy':
			libtcod.console_set_default_foreground(console, libtcod.darker_green)
	
	# status for spawned unit objects
	if unit_obj is not None:
		if unit_obj.immobilized:
			libtcod.console_set_default_foreground(console, libtcod.light_red)
			text = 'Immobilized'
		elif unit_obj.broken_down:
			libtcod.console_set_default_foreground(console, libtcod.light_red)
			text = 'Broken Down'
		elif unit_obj.bogged:
			libtcod.console_set_default_foreground(console, libtcod.light_red)
			text = 'Bogged Down'
	
	libtcod.console_print_ex(console, x+24, y+12, libtcod.BKGND_NONE, libtcod.RIGHT,
		text)
	
	# HVSS, recce, and/or off road
	libtcod.console_set_default_foreground(console, libtcod.dark_green)
	text = ''
	if 'HVSS' in unit_type:
		text += 'HVSS'
	if 'recce' in unit_type:
		if text != '':
			text += ' '
		text += 'Recce'
	if 'off_road' in unit_type:
		if text != '':
			text += ' '
		text += 'ATV'
	libtcod.console_print_ex(console, x+24, y+13, libtcod.BKGND_NONE, libtcod.RIGHT,
		text)
	
	# size class if any
	if 'size_class' in unit_type:
		if unit_type['size_class'] != 'Normal':
			libtcod.console_set_default_foreground(console, libtcod.white)
			libtcod.console_print_ex(console, x+24, y+14, libtcod.BKGND_NONE,
				libtcod.RIGHT, unit_type['size_class'])
	
	# return now if no spawned object or not displaying status
	if unit_obj is None or not status:
		libtcod.console_set_default_background(console, libtcod.black)
		return
	
	# Hull Down status if any
	if len(unit_obj.hull_down) > 0:
		libtcod.console_set_default_foreground(console, libtcod.sepia)
		libtcod.console_print(console, x+hull_line_width+1, y+14, 'HD')
		
		# emplacements have HD all around
		if len(unit_obj.hull_down) == 6:
			libtcod.console_put_char_ex(console, x+hull_line_width+3, y+14,
				250, libtcod.sepia, libtcod.black)
		else:
			libtcod.console_put_char_ex(console, x+hull_line_width+3, y+14,
				GetDirectionalArrow(unit_obj.hull_down[0]), libtcod.sepia, libtcod.black)
	
	# reduction if any
	elif unit_obj.reduced:
		libtcod.console_set_default_foreground(console, libtcod.light_red)
		libtcod.console_print(console, x, y+14, 'Reduced')
	
	# rest of unit status
	libtcod.console_set_default_foreground(console, libtcod.light_grey)
	libtcod.console_set_default_background(console, libtcod.darkest_blue)
	libtcod.console_rect(console, x, y+15, 25, 2, True, libtcod.BKGND_SET)
	
	text = ''
	if unit_obj.routed:
		text += 'Routed '
	elif unit_obj.pinned:
		text += 'Pinned '
	if unit_obj.moving:
		text += 'Moving '
	if unit_obj.fired:
		text += 'Fired '
	libtcod.console_print(console, x, y+16, text)
	
	# terrain and smoke/dust status
	libtcod.console_set_default_background(console, libtcod.darker_sepia)
	libtcod.console_rect(console, x, y+17, 25, 2, True, libtcod.BKGND_SET)
	
	if unit_obj.terrain is not None:
		libtcod.console_set_default_foreground(console, libtcod.green)
		libtcod.console_print(console, x, y+17, unit_obj.terrain)
	
	text = ''
	if unit_obj.smoke > 0:
		text += 'Sm:' + str(unit_obj.smoke)
	if unit_obj.dust > 0:
		if unit_obj.smoke > 0:
			text += ' '
		text += 'Ds:' + str(unit_obj.dust)
	
	if text != '':
		libtcod.console_set_default_foreground(console, libtcod.grey)
		libtcod.console_print_ex(console, x+24, y+17, libtcod.BKGND_NONE,
			libtcod.RIGHT, text)
	
	libtcod.console_set_default_background(console, libtcod.black)

# Get a unit portrait and return it as a console (if 'console' = None) or display it to a console (if one is given)
# 'portrait_variant' is the variant to use, if it's available. If 'unit' is an instantiated unit its nation var is used instead.
# 'portrait_nation' is the nation variant to use if the unit is infantry/cavalry.
# 'unit' can be a specific portrait, a unit stat folder, or an instantiated unit.
# Note that portrait names are converted to lowercase as the portrait libraries are case-sensitive.
def DisplayUnitPortrait(console = None, x = 0, y = 0 , unit = None, portrait_variant = 'STD', portrait_nation = None):
	# a specific portrait
	if isinstance(unit, str):
		portrait_name = unit.lower()
	else:
		# an instantiated unit uses its specific nation rather than a directly-set argument. This is also a framework for future unit portrait variations.
		if isinstance(unit, Unit):
			unit_stats = unit.stats
			portrait_nation = session.nations[unit.nation]['short_code']
		else:
			unit_stats = unit
		if 'portrait' not in unit_stats:
			return
		portrait_name = unit_stats['portrait'].lower()
		if unit_stats['category'] in ['Infantry', 'Cavalry']:
			# if pref is off, use the old stick-figure portrait
			if not config['ArmCom2'].getboolean('fancy_portraits'):
				portrait_nation = 'BASIC'
			if portrait_name in session.infantry_portrait_library:
				portrait_name = session.infantry_portrait_library[portrait_name][portrait_variant][portrait_nation]

	if portrait_name in session.portrait_library:
		portrait_name = session.portrait_library[portrait_name][portrait_variant]

	if console is not None:
		libtcod.console_blit(LoadXP(portrait_name), 0, 0, 0, 0, console, x, y)
	else:
		return LoadXP(portrait_name)


# display acknowledgements screen
def DisplayAcknowledgments():
	
	ACKNOWLEDGEMENTS_TEXT = [
		"First my thanks to Bruce Shelley who designed the 1987 Patton's Best board game, " +
		'the original inspiration for the Armoured Commander games.',
		'Thanks to everyone who played the original ArmCom and gave me constructive feedback',
		'My sincere thanks to all the Early Access players who submitted suggestions and ' +
		'bug reports via Steam discussion boards or the Discord.',
		'Particular thanks goes out to:',
		'Kyzrati/Josh for his encouragement and advice to a naive side-hustle game developer, ' +
		'and for creating REXPaint which made designing the consoles so much more enjoyable;',
		'Flori2412 for his early enthusiasm for the game, creating new units and campaigns, ' +
		'and helping to test and polish the game;',
		'Cjprince for all the amazing portraits and unit designs;',
		'Czarek422 for the great aircraft portraits;',
		'EngineerZero for the much-improved background consoles, and the decoration ribbons;',
		'Allie for all the much improved flag consoles;',
		'chri for portraits;',
		'YARD for crewmen names and suggestions;',
		'Vanagandr for careful review of the source code, excellent suggestions and contributions to the code;',
		'And anyone else that I might have forgotten!'
	]
	
	# classic C64 colours!
	libtcod.console_set_default_foreground(con, libtcod.Color(107,94,180))
	libtcod.console_set_default_background(con, libtcod.Color(52,40,121))
	
	libtcod.console_clear(con)
	
	# display game name and version number
	libtcod.console_print_ex(con, WINDOW_XM, 2, libtcod.BKGND_NONE,
		libtcod.CENTER, NAME)
	libtcod.console_print_ex(con, WINDOW_XM, 3, libtcod.BKGND_NONE,
		libtcod.CENTER, VERSION)
	libtcod.console_set_default_foreground(con, libtcod.gold)
	libtcod.console_print_ex(con, WINDOW_XM, 5, libtcod.BKGND_NONE,
		libtcod.CENTER, 'Acknowledgements')
	
	libtcod.console_set_default_foreground(con, libtcod.white)
	x = 8
	y = 10
	for text in ACKNOWLEDGEMENTS_TEXT:
		lines = wrap(text, 34)
		for line in lines:
			libtcod.console_print(con, x, y, line)
			y += 1
			if y >= 50:
				x = 47
				y = 10
		if y > 10:
			y += 2
		if y >= 50:
			x = 47
			y = 10
	
	# display inputs
	if gamepad is not None:
		DisplayButton(con, 40, 57, GAMEPADCHAR_B)
	else:
		libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
		libtcod.console_print(con, 36, 57, 'Esc')
	libtcod.console_set_default_foreground(con, libtcod.white)
	libtcod.console_set_default_background(con, libtcod.black)
	libtcod.console_print(con, 42, 57, 'Return to Main Menu')
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	exit_loop = False
	while not exit_loop:
		libtcod.console_flush()
		if not GetInputEvent(): continue
		if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
			return
	

# check a modded campaign file for potential issues, displays warning messages, and returns True if there's a serious issue
def CheckCampaign(campaign_data):
	
	issues = False
	
	# essential data
	if campaign_data['player_nation'] not in session.nations:
		print(campaign_data['name'] + ': Player nation not part of loaded nation definitions.')
		issues = True
	if 'combat_days' not in campaign_data:
		print(campaign_data['name'] + ' is missing an entry for the number of combat days')
		issues = True
	
	# potential issues
	for v in campaign_data['player_unit_list']:
		if v not in session.unit_types:
			print(campaign_data['name'] + ': Player unit ' + v + ' is not part of loaded unit type definitions.')
			issues = True
	if 'player_unit_dates' in campaign_data:
		for v in campaign_data['player_unit_dates']:
			if v not in campaign_data['player_unit_list']:
				print(campaign_data['name'] + ': Player unit ' + v + ' has an entry in player_unit_dates but is not part of player_unit_list.')
				issues = True
	if 'tank_vp_modifiers' in campaign_data:
		for v in campaign_data['tank_vp_modifiers']:
			if v not in campaign_data['player_unit_list']:
				print(campaign_data['name'] + ': Player unit ' + v + ' has an entry in tank_vp_modifiers but is not part of player_unit_list.')
				issues = True
	for k, v in campaign_data['enemy_unit_list'].items():
		for text in v:
			if text not in session.unit_types:
				print(campaign_data['name'] + ': Enemy unit for ' + k + ', ' + text + ', is not part of loaded unit type definitions.')
				issues = True
	if 'enemy_captured_units' in campaign_data:
		print(campaign_data['name'] + ' has an obsolete entry for enemy_captured_units')
		issues = True
	if 'decorations_list' in campaign_data:
		print(campaign_data['name'] + ' has an obsolete entry for decorations_list')
		issues = True
	
	return issues


# returns true if a gun tractor of the given unit_id could tow a gun unit of the given size
def TractorCanTow(unit_id, size_class):
	SIZE_CLASSES = ['Very Small', 'Small', 'Normal', 'Large', 'Very Large']
	if SIZE_CLASSES.index(size_class) <= SIZE_CLASSES.index(session.unit_types[unit_id]['towing_capacity']):
		return True
	return False


# Converts a list of individual strings to a grammatical text string list. Uses Oxford Comma. Doesn't actually care what language the strings are.
def GenerateEnglishList(target_list):
	list_length = len(target_list)
	if list_length == 0:
		print('ERROR: Empty list passed to GenerateEnglishList.')
		return ''
	elif list_length == 1:
		return target_list[0]
	elif list_length == 2:
		return ' and '.join(target_list)
	else:
		final_entry = target_list.pop()
		return ', '.join(target_list) + ', and ' + final_entry


# Used repeatedly to assemble odds graphs. The bar takes up 3 cells of vertical space and the edges are partial-cell characters.
# Text can be drawn in the spaces at least 1 cell in from each edge. x,y are top-left coord. width is the total width in cells.
# odds is the odds number in the usual '75% = 75.0' format. crit_miss_band means to not draw the right end cap and leave a fraction of underlying bar behind.
# if small_bar is true, the bar is drawn only one cell high at y+1
def DrawOddsBar(target_console, x, y, width, odds, colour, crit_miss_band, skip_left_cap=False):
	
	proportion = int(ceil(width * odds / 100.0))
	if proportion == 0:
		return
	
	old_fg = libtcod.console_get_default_foreground(target_console)
	old_bg = libtcod.console_get_default_background(target_console)
	libtcod.console_set_default_foreground(target_console, colour)
	libtcod.console_set_default_background(target_console, colour)
	
	# left end cap if any
	if not skip_left_cap:
		for y_mod in range(4):
			libtcod.console_print_ex(target_console, x, y + y_mod, libtcod.BKGND_NONE, libtcod.LEFT, chr([11, 222, 222, 225][y_mod])) 
	
	# right end cap, optional as there's usually at least some chance of a miss/failure.
	end_cap = False
	if not crit_miss_band and proportion == width:
		end_cap = True
		for y_mod in range(4):
			libtcod.console_print_ex(target_console, width, y + y_mod, libtcod.BKGND_NONE, libtcod.LEFT, chr([12, 221, 221, 224][y_mod]))

	# central full-cell bar, width calculation is a bit complex but it makes things line up - 50% of 10-cell bar = 5 characters
	libtcod.console_rect(target_console, x + 1, y + 1, min(proportion - 1, width - 2), 2, False, libtcod.BKGND_SET)
	
	# top/bottom narrow bars, blocked from extending into the end cap
	x_end = x+proportion
	if x_end > width:
		x_end = width
	for x_pos in range(x+1, x_end):
		libtcod.console_print_ex(target_console, x_pos, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(95))
		libtcod.console_print_ex(target_console, x_pos, y + 3,libtcod.BKGND_NONE, libtcod.LEFT, chr(223))
	
	libtcod.console_set_default_foreground(target_console, old_fg)
	libtcod.console_set_default_background(target_console, old_bg)


##########################################################################################
#                                     Sound Effects                                      #
##########################################################################################


# randomly choose an appropriate sample for this sound and play it
# if sounds are not enabled, returns without doing anything
# if sound effect is not found, display one warning per session (to avoid console spam) 
def PlaySound(sound_name):
	if not config['ArmCom2'].getboolean('sounds_enabled'): return
	if sound_name not in session.sound_effects:
		if not session.missing_sound_displayed:
			session.missing_sound_displayed = True
			print('WARNING: Sound effect file(s) missing for: ' + sound_name + '; this warning will only be displayed once per session')
		return
	filename = choice(session.sound_effects[sound_name])
	sample = mixer.Mix_LoadWAV((filename).encode('ascii'))
	mixer.Mix_PlayChannel(-1, sample, 0)


# select and play a sound effect for a given situation
def PlaySoundFor(obj, action):
	
	# sounds disabled
	if not config['ArmCom2'].getboolean('sounds_enabled'):
		return
	
	# basic sound effect, not modified by the object involved in the sound
	if obj is None:
		PlaySound(action)
		return

	# opening or closing a hatch
	elif action == 'hatch':
		if obj.hatch_open:
			PlaySound('hatch_open')
		else:
			PlaySound('hatch_close')
		return

	elif action == 'movement':
		
		# no sound effect if concealed enemy unit
		if obj.owning_player == 1 and not obj.spotted:
			return
		if obj.GetStat('class') == 'Motorcycle Team':
			PlaySound('mc_moving')
		elif 'Wheeled' in obj.GetStat('movement_class'):
			PlaySound('wheeled_moving')
		elif obj.GetStat('movement_class') in ['Infantry', 'Cavalry']:
			PlaySound('infantry_moving')	
		elif obj.GetStat('movement_class') == 'Half-Tracked':
			PlaySound('ht_moving')
		elif obj.GetStat('class') == 'Tractor':
			PlaySound('tractor_moving')
		elif obj.GetStat('class') == 'Heavy Tank':
			PlaySound('heavy_tank_moving')
		elif obj.GetStat('class') in ['Medium Tank', 'Tank Destroyer', 'Assault Gun', 'Heavy Tank']:
			PlaySound('medium_tank_moving')
		elif obj.GetStat('class') in ['Tankette', 'Light Tank']:
			PlaySound('light_tank_moving')
		elif obj.GetStat('movement_class') == 'Gun' and obj.towed_by is None:
			PlaySound('infantry_moving')
		# no other movement sounds for now
		return
	
	elif action == 'fire':
		
		weapon_name = obj.GetStat('name')
		
		if obj.stats['type'] in MG_WEAPONS:
			if obj.GetStat('name') == 'HMG' or obj.GetStat('calibre') is not None:
				PlaySound('hmg_firing')
			else:
				lmg_rof = 'low'
				if obj.unit is not None:
					if 'origin_nation' in obj.unit.stats:
						source_nation = obj.unit.stats['origin_nation']
					else:
						source_nation = obj.unit.nation
					if source_nation == 'Germany':
						lmg_rof = 'high'
					elif source_nation in ['Soviet Union', 'United States of America']:
						lmg_rof = 'med'
				PlaySound('lmg_firing_' + lmg_rof)
			return
		
		if obj.GetStat('type') == 'Rockets':
			PlaySound('rockets_firing')
			return
		
		if obj.GetStat('rocket_mortar') is not None:
			PlaySound('rocket_mortar')
			return
		
		if obj.GetStat('type') in ['Gun', 'Cannon']:
			if weapon_name == 'AT Rifle':
				PlaySound('at_rifle_firing')
				return
			elif 'Mortar' in weapon_name:
				PlaySound('mortar_firing')
				return
			
			calibre_text = obj.GetStat('calibre')
			
			# should not happen, but just in case
			if calibre_text is None:
				PlaySound('light_gun_firing')
				return
			
			calibre = int(calibre_text)
			if calibre < 40:
				PlaySound('light_gun_firing')
			elif calibre < 80:
				PlaySound('medium_gun_firing')
			else:
				PlaySound('heavy_gun_firing')
			
			return
			
		
		if obj.GetStat('name') == 'Rifles':
			PlaySound('rifle_fire')
			return
			
		if obj.GetStat('name') == 'Submachine Guns':
			PlaySound('smg_firing')
			return
			
		if obj.GetStat('name') == 'Grenades':
			PlaySound('grenades')
			return
			
		if obj.GetStat('name') == 'Flame Thrower':
			PlaySound('flamethrower')
			return
			
		if obj.GetStat('name') == 'PIAT':
			PlaySound('piat_firing')
			return
			
		if obj.GetStat('name') == 'Bazooka':
			PlaySound('bazooka')
			return
			
		if obj.GetStat('name') in ['Panzerschreck', 'Panzerfaust', 'Panzerfaust Klein']:
			PlaySound('small_rocket')
			return
		
	elif action == 'unit_ko':
		if obj.GetStat('category') in ['Infantry', 'Cavalry']:
			PlaySound('ko_infantry')
			if libtcod.random_get_int(0, 0, 1000) == 0: PlaySound('wilhelm')
		elif obj.GetStat('category') == 'Gun':
			PlaySound('ko_gun')
		elif obj.GetStat('category') == 'Vehicle' and obj.GetStat('armour') is None:
			PlaySound('ko_veh')
		return
	
	elif action == 'he_explosion':
		# used for all gun/cannon calibres for now
		PlaySound('37mm_he_explosion')
		return

	elif action == 'vehicle_explosion':
		PlaySound('vehicle_explosion')
		return
	
	elif action == 'plane_incoming':
		if obj.unit_id in ['Me 262', 'Me 262 A-2a']:
			PlaySound('jet')
			return
		PlaySound('plane_incoming')
		return
	
	elif action == 'stuka_divebomb':
		PlaySound('stuka_divebomb')
		return

	print ('ERROR: Could not determine which sound to play for action: ' + action)


# cycle the active controller
def CycleActiveController():
	
	# no controllers active
	if session.num_controllers == 0: return
	
	config['ArmCom2']['active_controller'] = str(config['ArmCom2'].getint('active_controller') + 1)
	if config['ArmCom2'].getint('active_controller') > session.num_controllers:
		config['ArmCom2']['active_controller'] = '0'
	InitControllers()
	

# try and initialize game controllers, and activate the one currently selected in the game options
def InitControllers(first_time=False):
	
	global gamepad
	
	gamepad = None
	active_controller = config['ArmCom2'].getint('active_controller')
	session.num_controllers = 0
	sdl2.SDL_Init(sdl2.SDL_INIT_JOYSTICK)
	num_joysticks = sdl2.joystick.SDL_NumJoysticks()
	if num_joysticks < 0:
		print('ERROR: ' + sdl2.SDL_GetError())
	elif num_joysticks == 0:
		return
	
	for i in range(num_joysticks):
		if sdl2.SDL_IsGameController(i):
			joystick = sdl2.SDL_GameControllerOpen(i)
			if joystick is not None:
				session.num_controllers += 1
				
				# keyboard controls active
				if active_controller == 0: continue
				
				if session.num_controllers == active_controller:
					gamepad = joystick
	
	if not first_time: return
	if session.num_controllers == 0: return
	
	# if we're doing this at boot-up, activate the last controller found instead
	# this ensures that the Steam Deck's controller will be enabled from install, for example
	config['ArmCom2']['active_controller'] = str(session.num_controllers)
	gamepad = sdl2.SDL_GameControllerOpen(session.num_controllers-1)
	SaveCFG()
	print('Controller activated: ' + str(sdl2.SDL_GameControllerName(gamepad).decode()))


# display a special character to indicate a gamepad input button
def DisplayButton(console, x, y, button):
	fg_col = libtcod.black
	bg_col = GAMEPAD_INPUT_COL
	if button == GAMEPADCHAR_A:
		bg_col = libtcod.light_green
	elif button == GAMEPADCHAR_B:
		bg_col = libtcod.light_red
	elif button == GAMEPADCHAR_X:
		bg_col = libtcod.light_blue
	elif button == GAMEPADCHAR_Y:
		bg_col = libtcod.light_yellow
	elif button in [GAMEPADCHAR_DPAD_UD, GAMEPADCHAR_DPAD_LR, 24, 25, 26, 27]:
		fg_col = GAMEPAD_INPUT_COL
		bg_col = libtcod.black
	elif button in [GAMEPADCHAR_LSB, GAMEPADCHAR_RSB]:
		fg_col = libtcod.light_grey
		bg_col = libtcod.black
	libtcod.console_put_char_ex(console, x, y, button, fg_col, bg_col)
	
	

##########################################################################################
#                                   Main Menu Stuff                                      #
##########################################################################################

# start a new campaign
def StartNewCampaign():
	
	global campaign, campaign_day, scenario, session
	
	# create a new campaign object and allow player to select a campaign
	campaign = Campaign()
	if not campaign.CampaignSelectionMenu():
		return False
	
	# show campaign options menu
	if not campaign.CampaignOptionsMenu():
		return False
	
	# set the initial portrait variant to be used
	campaign.UpdatePortraitVariant()
	
	# allow player to select their tank and set their tank name
	(unit_id, tank_name) = campaign.TankSelectionMenu(starting_campaign=True)
	
	# cancel campaign start
	if unit_id is None:
		return False
	
	# create the player unit
	campaign.player_unit = Unit(unit_id, is_player=True)
	campaign.player_unit.unit_name = tank_name
	campaign.player_unit.nation = campaign.stats['player_nation']
	campaign.player_unit.GenerateNewPersonnel()
	campaign.player_unit.ClearGunAmmo()
	
	# finish setting up the campaign
	campaign.DoPostInitChecks()
	
	# create a new campaign day
	campaign_day = CampaignDay()
	for (hx, hy) in CAMPAIGN_DAY_HEXES:
		campaign_day.map_hexes[(hx,hy)].CalcCaptureVP()
	campaign_day.GenerateRoads()
	campaign_day.GenerateRivers()
	campaign.AddJournal('Start of day')
	
	campaign.ShowStartOfDay()
	
	# placeholder for the currently active scenario
	scenario = None
	
	return True
	

# start a special tutorial campaign
def DoTutorial():
	
	global campaign, campaign_day, scenario, session
	
	libtcod.console_blit(LoadXP('training_1.xp'), 0, 0, 0, 0, 0, window_x+12, window_y+3)
	libtcod.console_flush()
	Wait(300, ignore_animations=False)
	campaign = Campaign()
	campaign.CampaignSelectionMenu(auto_start=CAMPAIGNPATH + 'introduction.json')
	libtcod.console_clear(0)
	libtcod.console_flush()
	ShowTutorialSlide('intro')
	if gamepad is not None:
		libtcod.console_clear(0)
		libtcod.console_flush()
		ShowTutorialSlide('controller')
	campaign.CampaignOptionsMenu()
	campaign.UpdatePortraitVariant()
	(unit_id, tank_name) = campaign.TankSelectionMenu(starting_campaign=True)
	if unit_id is None:
		return False
	campaign.player_unit = Unit(unit_id, is_player=True)
	campaign.player_unit.unit_name = tank_name
	campaign.player_unit.nation = campaign.stats['player_nation']
	campaign.player_unit.GenerateNewPersonnel()
	campaign.player_unit.ClearGunAmmo()
	campaign.DoPostInitChecks()
	campaign_day = CampaignDay()
	for (hx, hy) in CAMPAIGN_DAY_HEXES:
		campaign_day.map_hexes[(hx,hy)].CalcCaptureVP()
	campaign_day.GenerateRoads()
	campaign_day.GenerateRivers()
	campaign.AddJournal('Start of day')
	campaign.ShowStartOfDay()
	scenario = None
	return True
	

# update the animation effect
def AnimateMainMenu():
	
	global gradient_x
	
	for x in range(0, 10):
		if x + gradient_x > WINDOW_WIDTH: continue
		for y in range(19, 34):
			char = libtcod.console_get_char(con, x + gradient_x, y)
			fg = libtcod.console_get_char_foreground(con, x + gradient_x, y)
			if char != 0 and fg != GRADIENT[x]:
				libtcod.console_set_char_foreground(con, x + gradient_x,
					y, GRADIENT[x])
	gradient_x -= 2
	if gradient_x <= 0: gradient_x = WINDOW_WIDTH + 10


MAIN_MENU_COMMANDS = [
	'Continue', 'Load Campaign', 'New Campaign', 'Tutorial', 'Options', 'Mods',
	'Campaign Records', 'Unit Gallery', 'Acknowledgments', 'Quit'
]

# draw the main title to the screen and display menu options
# if options_menu_active, draw the options menu instead
def UpdateMainTitleCon(transition=False):
	
	# check to see if there is 1+ saved campaign, and whether that one is compatible
	one_compatible_game = False
	no_saved_games = True
	try:
		for directory in os.listdir(SAVEPATH):
			if not os.path.isdir(SAVEPATH + directory): continue
			with shelve.open(SAVEPATH + directory + os.sep + 'savegame') as save:
				if 'version' not in save: continue
				no_saved_games = False
				if CheckSavedGameVersion(save['version']) != '': continue
				one_compatible_game = True
				break
	except:
		print('ERROR: Corrupted saved campaign file: ' + directory)
	
	libtcod.console_blit(main_title, 0, 0, 0, 0, con, 0, 0)
	
	y = 37
	if session.mm_options:
		
		# display game options commands
		DisplayGameOptions(con, WINDOW_XM-20, 36)
		
	else:
		
		i = 0
		 
		for text in MAIN_MENU_COMMANDS:
			
			# grey-out option if not possible
			disabled = False
			
			if text == 'Continue' and not one_compatible_game:
				disabled = True
			
			elif text == 'Load Campaign' and no_saved_games:
				disabled = True
			
			# add spaces in the menu
			if text in ['Tutorial', 'Options']: y += 1
			
			# highlight if selected
			if i == session.mm_item:
				libtcod.console_set_default_background(con, libtcod.dark_blue)
				libtcod.console_rect(con, WINDOW_XM-10, y, 20, 1, True, libtcod.BKGND_SET)
				libtcod.console_set_default_background(con, libtcod.black)
			
			if disabled:
				libtcod.console_set_default_foreground(con, libtcod.dark_grey)
			else:
				libtcod.console_set_default_foreground(con, libtcod.lightest_grey)
			
			libtcod.console_print_ex(con, WINDOW_XM, y, libtcod.BKGND_NONE, libtcod.CENTER,
				text)	
			
			y += 1
			i += 1
	
	# display inputs
	if gamepad is not None:
		DisplayButton(con, 43, 54, GAMEPADCHAR_DPAD_UD)
		DisplayButton(con, 43, 55, GAMEPADCHAR_A)
	else:
		libtcod.console_set_default_foreground(con, ACTION_KEY_COL)
		libtcod.console_print(con, 39, 54, EnKey('w').upper() + '/' + EnKey('s').upper())
		libtcod.console_print(con, 39, 55, 'Enter')
	libtcod.console_set_default_foreground(con, libtcod.light_grey)
	libtcod.console_print(con, 46, 54, 'Select')
	libtcod.console_print(con, 46, 55, 'Activate')
	
	if not transition or DEBUG:
		libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
		return
	
	for y in range(WINDOW_YM, 0, -2):
		libtcod.console_clear(0)
		libtcod.console_blit(con, 0, y, 0, ((WINDOW_YM-y)*2)+1, 0, window_x, window_y+y)
		Wait(2, ignore_animations=True)
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)


##########################################################################################
#                                      Main Script                                       #
##########################################################################################

global window_x, window_y
global main_title
global campaign, campaign_day, scenario, session
global steam_active, gamepad

campaign = None
campaign_day = None
scenario = None
session = None
gamepad = None

print(NAME + ' ' + VERSION + ' - Console Window\n')

# make sure debug settings file is present if DEBUG flag is active
if DEBUG:
	if not os.path.exists(DATAPATH + 'debug.json'):
		DEBUG = False

# make sure game has write permissions in its own directory
if not os.access(os.getcwd(), os.W_OK):
	print('ERROR: Cannot write to install directory!')
	print('Make sure game is installed in a directory with write access (eg. Program Files for Windows).')
	os.system('pause')
else:
	print('Diagnostic and error messages may appear here, otherwise you can safely ignore this window while playing.\n\n')


# main exception-catching branch
try:
	
	# create home folders if they don't exist yet
	if not os.path.isdir(HOMEPATH): os.mkdir(HOMEPATH)
	if not os.path.isdir(MODPATH): os.mkdir(MODPATH)
	if not os.path.isdir(LOGPATH): os.mkdir(LOGPATH)

	# try to load game settings from config file, will create a new file if none present
	LoadCFG()
	
	# determine font to use based on settings file; set up custom font and create the root console
	i = config['ArmCom2'].getint('display_font')
	if i == 0:
		fontname = 'c64_8x8_ext.png'
	elif i == 1:
		fontname = 'c64_12x12_ext.png'
	else:
		fontname = 'c64_16x16_ext.png'
	libtcod.console_set_custom_font(DATAPATH+fontname, libtcod.FONT_LAYOUT_ASCII_INROW, 16, 18)
	
	WINDOW_NAME = NAME + ' - ' + VERSION
	
	# set up root console
	InitMainConsole()
	
	libtcod.sys_set_fps(LIMIT_FPS)
	libtcod.console_set_default_background(0, libtcod.black)
	libtcod.console_set_default_foreground(0, libtcod.white)
	libtcod.console_clear(0)
	libtcod.console_flush()
	
	# create double buffer console
	con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_set_default_background(con, libtcod.black)
	libtcod.console_set_default_foreground(con, libtcod.white)
	libtcod.console_clear(con)
	
	# display loading screen
	libtcod.console_print_ex(con, WINDOW_XM, WINDOW_YM, libtcod.BKGND_NONE, libtcod.CENTER,
		'Loading...')
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	
	# create mouse and key event holders
	mouse = libtcod.Mouse()
	key = libtcod.Key()
	
	# create new session object
	session = Session()
	
	# try to init sound mixer and load sounds if successful
	if config['ArmCom2'].getboolean('sounds_enabled'):
		if not session.InitMixer():
			config['ArmCom2']['sounds_enabled'] = 'false'
			print('Unable to init SDL mixer, sounds disabled')
	
	# generate keyboard mapping dictionaries
	session.GenerateKeyboards()
	
	# create darken screen console
	darken_con = libtcod.console_new(WINDOW_WIDTH, WINDOW_HEIGHT)
	libtcod.console_set_default_background(darken_con, libtcod.black)
	libtcod.console_set_default_foreground(darken_con, libtcod.black)
	libtcod.console_clear(darken_con)
	
	# create game menu console: 84x54
	game_menu_con = libtcod.console_new(84, 54)
	libtcod.console_set_default_background(game_menu_con, libtcod.black)
	libtcod.console_set_default_foreground(game_menu_con, libtcod.white)
	libtcod.console_clear(game_menu_con)
	
	# try to start up steamworks
	global steam_active
	steam_active = False
	try:
		steamworks = STEAMWORKS()
		steamworks.initialize()
		steam_active = True
	except:
		print('Unable to initialize Steamworks, stats and achievements will not be recorded!')
	
	# check for gamepad controller(s) and try to initialize
	# if the game finds 1+ controllers at this point, it will enable the last one found
	InitControllers(first_time=True)
	
	# for some reason, the main console has to be re-initialized in order for the game controller to be read
	if gamepad is not None:
		InitMainConsole()
	
	
	
	##########################################################################################
	#                                        Main Menu                                       #
	##########################################################################################
	
	# display studio logo and disclaimer
	libtcod.console_clear(con)
	libtcod.console_blit(LoadXP('cats.xp'), 0, 0, 0, 0, con, WINDOW_XM-15, WINDOW_YM-25)
	libtcod.console_set_default_foreground(con, libtcod.white)
		
	libtcod.console_set_default_foreground(con, libtcod.light_grey)
	y = WINDOW_YM + 18
	lines = wrap(DISCLAIMER, 40)
	for line in lines:
		libtcod.console_print_ex(con, WINDOW_XM, y, libtcod.BKGND_NONE, libtcod.CENTER, line)
		y += 1
	libtcod.console_set_default_foreground(con, libtcod.white)
	if not DEBUG: libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	
	start_time = time.time()
	
	# try to sync stats with Steam
	if steam_active:
		steamworks.RequestCurrentStats()
		steamworks.run_callbacks()
	
	while time.time() - start_time < 2:
		libtcod.console_flush()
		FlushKeyboardEvents()
		if DEBUG: break
	
	# load and generate main title background
	main_title = LoadXP('main_title.xp')
	if session.tank_portrait is not None:
		libtcod.console_blit(session.tank_portrait, 0, 0, 0, 0, main_title, 7, 6)
	if session.tank_portrait_id is not None:
		libtcod.console_set_default_foreground(main_title, libtcod.dark_grey)
		libtcod.console_print_ex(main_title, 20, 15, libtcod.BKGND_NONE, libtcod.CENTER, session.tank_portrait_id)
	
	# version number and program info
	libtcod.console_set_default_foreground(main_title, libtcod.lighter_blue)
	libtcod.console_print_ex(main_title, WINDOW_XM, WINDOW_HEIGHT-3, libtcod.BKGND_NONE,
		libtcod.CENTER, 'Version ' + VERSION)
	libtcod.console_set_default_foreground(main_title, libtcod.light_blue)
	libtcod.console_print_ex(main_title, WINDOW_XM, WINDOW_HEIGHT-2, libtcod.BKGND_NONE,
		libtcod.CENTER, 'Copyright 2021 Gregory Adam Scott')
	if DEBUG:
		libtcod.console_set_default_foreground(main_title, libtcod.black)
		libtcod.console_print_ex(main_title, WINDOW_XM+1, 1, libtcod.BKGND_NONE,
			libtcod.CENTER, 'DEBUG MODE')
	today = datetime.today()
	if today.month == 11 and 1 <= today.day <= 11:
		libtcod.console_blit(LoadXP('poppy2.xp'), 0, 0, 0, 0, main_title, 1, WINDOW_HEIGHT-11)
	else:
		libtcod.console_blit(LoadXP('poppy.xp'), 0, 0, 0, 0, main_title, 1, WINDOW_HEIGHT-11)
	
	# gradient animated effect for main menu
	GRADIENT = [
		libtcod.Color(51, 51, 51), libtcod.Color(100, 100, 140), libtcod.Color(100, 100, 178),
		libtcod.Color(100, 100, 217), libtcod.Color(150, 170, 255), libtcod.Color(100, 100, 217),
		libtcod.Color(100, 100, 178), libtcod.Color(100, 100, 140), libtcod.Color(51, 51, 51),
		libtcod.Color(51, 51, 51)
	]
	
	# set up gradient animation timing
	time_click = time.time()
	gradient_x = WINDOW_WIDTH + 5
	
	# start playing main theme if enabled
	session.MusicHandler('main', True)
	
	# draw the main title console to the screen for the first time
	UpdateMainTitleCon(transition=True)
	
	# disable window resizing now if not in fullscreen mode
	if config['ArmCom2']['fullscreen'] == 'false':
		sdl2.SDL_SetWindowResizable(sdl2.SDL_GetWindowFromID(session.window_id), sdl2.SDL_FALSE)

	# Main Menu loop
	exit_game = False
	while not exit_game:
		
		if DEBUG:
			if libtcod.console_is_window_closed(): sys.exit()
		
		# trigger animation and update screen
		if time.time() - time_click >= 0.06:
			AnimateMainMenu()
			libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
			time_click = time.time()
		
		libtcod.console_flush()
		if not GetInputEvent(): continue
		key_char = DeKey(chr(key.c).lower())
		
		# options sub-menu active
		if session.mm_options:
			
			# exit sub-menu
			if key.vk == sdl2.SDLK_ESCAPE or session.gamepad_input == 1:
				PlaySoundFor(None, 'menu_select')
				session.mm_options = False
				session.options_item = 0
				UpdateMainTitleCon()
				continue
			
			# change selected item
			if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
				if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
					i = -1
				else:
					i = 1
				session.options_item += i
				if session.options_item < 0:
					session.options_item = len(GAME_OPTIONS) - 1
				elif session.options_item > len(GAME_OPTIONS) - 1:
					session.options_item = 0
					
				UpdateMainTitleCon()
				continue
			
			# activate selected item
			if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
				ChangeGameSettings(main_menu=True)
				UpdateMainTitleCon()
				continue
			
			# may have changed controllers, update the screen
			UpdateMainTitleCon()
			continue
		
		# main menu
		
		# quit - but ignore if mapped
		if key_char == 'q' and DeKey('q') == 'q':
			exit_game = True
			PlaySoundFor(None, 'menu_select')
			continue
		
		# change selected item
		if key_char in ['w', 's'] or key.vk in [sdl2.SDLK_UP, sdl2.SDLK_DOWN] or session.gamepad_input in [11, 12]:
			if key_char == 'w' or key.vk == sdl2.SDLK_UP or session.gamepad_input == 11:
				i = -1
			else:
				i = 1
			session.mm_item += i
			if session.mm_item < 0:
				session.mm_item = 9	
			elif session.mm_item > 9:
				session.mm_item = 0
			UpdateMainTitleCon()
			continue
		
		# activate a command
		if key.vk in [sdl2.SDLK_RETURN, sdl2.SDLK_KP_ENTER] or session.gamepad_input == 0:
			
			text = MAIN_MENU_COMMANDS[session.mm_item]
			
			if text == 'Quit':
				exit_game = True
				PlaySoundFor(None, 'menu_select')
				continue
			
			elif text == 'Options':
				session.mm_options = True
				UpdateMainTitleCon()
				PlaySoundFor(None, 'menu_select')
				continue
			
			elif text == 'Mods':
				session.MusicHandler('main', False)
				PlaySoundFor(None, 'menu_select')
				ShowModsMenu()
				session.MusicHandler('main', True)
				UpdateMainTitleCon()
				continue
			
			elif text == 'Campaign Records':
				PlaySoundFor(None, 'menu_select')
				ShowRecordsMenu()
				UpdateMainTitleCon()
				continue
			
			elif text == 'Unit Gallery':
				session.MusicHandler('main', False)
				PlaySoundFor(None, 'menu_select')
				UnitGallery()
				session.MusicHandler('main', True)
				UpdateMainTitleCon()
				continue
			
			elif text == 'Acknowledgments':
				PlaySoundFor(None, 'menu_select')
				DisplayAcknowledgments()
				UpdateMainTitleCon()
				continue
		
			# start a new campaign, or load a saved campaign
			else:
		
				session.MusicHandler('main', False)
				PlaySoundFor(None, 'menu_select')
				
				# tutorial - start an easy campaign with pre-set settings and tutorial tips enabled
				if text == 'Tutorial':
					if not DoTutorial():
						campaign = None
						UpdateMainTitleCon()
						session.MusicHandler('main', True)
						continue
				
				# continue most recently saved campaign, or load a saved campaign
				elif text in ['Continue', 'Load Campaign']:
					if not LoadCampaignMenu(text == 'Continue'):
						campaign = None
						UpdateMainTitleCon()
						session.MusicHandler('main', True)
						continue
					
				# start a new campaign
				else:
					if not StartNewCampaign():
						campaign = None
						UpdateMainTitleCon()
						session.MusicHandler('main', False)
						continue
				
				exit_campaign_loop = False
				while not exit_campaign_loop:
				
					campaign.DoCampaignCalendarLoop()
				
					# campaign has ended 
					if campaign.ended:
						old_filename = campaign.filename
						result = ContinueCampaign()
						
						# player could have continued into a new campaign but chose not to; keep old save
						if result is None:
							SaveGame()
							exit_campaign_loop = True
							continue
						
						EraseGame(old_filename)
						
						# continuing into a new campaign
						if result is True:	
							continue
					
					exit_campaign_loop = True
				
				# reset exiting flag
				session.exiting = False
				
				UpdateMainTitleCon()
				libtcod.console_flush()
				
				# restart main theme if enabled
				session.MusicHandler('main', True)
				
				UpdateMainTitleCon()			


except Exception:
	traceback.print_exc()
	if DEBUG: sys.exit()
	OutputCrashLog(traceback.format_exc())
	if con is None: sys.exit()
	libtcod.console_clear(con)
	libtcod.console_set_default_foreground(con, libtcod.light_red)
	libtcod.console_print_ex(con, WINDOW_XM, 2, libtcod.BKGND_NONE, libtcod.CENTER,
		'Armoured Commander II Has Crashed')
	libtcod.console_set_default_foreground(con, libtcod.white)
	libtcod.console_print_ex(con, WINDOW_XM, 3, libtcod.BKGND_NONE, libtcod.CENTER,
		'Version ' + VERSION)
	
	# display active campaign and any active unit mods
	if campaign is not None:
		libtcod.console_print_ex(con, WINDOW_XM, 6, libtcod.BKGND_NONE, libtcod.CENTER,
			'Campaign: ' + campaign.filename)
	if session is not None:
		if len(session.active_mods) > 0:
			y = 8
			text = 'Active Mods: '
			for filename in session.active_mods:
				text += filename + ' '
			lines = wrap(text, 40)
			for line in lines:
				libtcod.console_print_ex(con, WINDOW_XM, y, libtcod.BKGND_NONE,
					libtcod.CENTER, line)
				y += 1
				if y == 15: break
	
	libtcod.console_print_ex(con, WINDOW_XM, 16, libtcod.BKGND_NONE, libtcod.CENTER,
		'A crashlog has been saved to: ' + str(Path.home()) + os.sep + 'ArmCom2' + os.sep + 'logs')
	libtcod.console_print_ex(con, WINDOW_XM, 17, libtcod.BKGND_NONE, libtcod.CENTER,
		'Please report this on the Steam Discussion board or Discord')
	libtcod.console_print_ex(con, WINDOW_XM, 18, libtcod.BKGND_NONE, libtcod.CENTER,
		'Crashlog printed below:')
	
	y = 20
	lines = wrap(traceback.format_exc(), 40)
	for line in lines:
		libtcod.console_print(con, 25, y, line)
		y += 1
		if y == WINDOW_HEIGHT-6: break
	
	libtcod.console_print_ex(con, WINDOW_XM, WINDOW_HEIGHT-4, libtcod.BKGND_NONE,
		libtcod.CENTER, 'Press Enter to Quit')
	
	libtcod.console_blit(con, 0, 0, 0, 0, 0, window_x, window_y)
	libtcod.console_flush()
	WaitForContinue(ignore_animations=True)
	sys.exit()

if steam_active:
	steamworks.unload()

# END #
